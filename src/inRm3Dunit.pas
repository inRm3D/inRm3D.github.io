unit inRm3Dunit; //v2.869  2019.08.23
interface
uses
  Windows, Messages, SysUtils, Variants, Classes, ImgList, Forms, Graphics,
  Dialogs, ExtCtrls, ComCtrls, Controls, Buttons, ToolWin, Menus, ShellApi,
  CgTypes, StdCtrls, Clipbrd,  GL, GLu,  Tabs, Math, // // OpenGL, Glut,
  Express, Pars, Parsglb, cgGeometry, DragImage, Splash, BMP, JPEG, PNGImage,
  Grids, CheckLst, ShellCtrls, Outline;//, RzTabs;
const
  Version= 'inRm3D v2.869 '; //v字不可缺！
  maxObj=1000;    //最大对象数
  FPStime=1000;
  UndoTime=127;   // Undo次数
  PageTime= 23;   // 页数
  LayerTime=23;   // 层数
  LinkTime= 48;   // 关联数
  LocaTime=2048;  // 轨迹点数
  TraceTime=512;  // 踪迹数
  towPi= 2*Pi;  halfPi=Pi/2;  quadPi=Pi/4; oneArc=57.29578;
  varBlockPos=12; // varBlockPos 参数滑块左边界
  PaintListCount= 127; //手绘曲线最大笔数
  PaintPointCount=1023;//手绘曲线最大点数
  objColor:Array[0..16]of TColor=( //颜色菜单
    $000000,$0000FF,$0088FF,$00FFFF, $00FF00,$FFFF00,$FF0000,$FF00FF,
    $E08080,$800080,$008000,$800000, $000080,$6080C0,$C0C0C0,$808080, $FFFFFF);
type
  TsImage=Record sFormat, sData :AnsiString; end;//图片文本(字符串)
  TLayer=Array[0..LayerTime]of boolean;
  TPaintData=Record //手绘数据
    cX,cY, tX,tY,bX,bY, mainList,wireList :integer;//原始坐标  cx,dy偏移量
    dx,dy:single; Dot:TcgVector;
    Hot,Del,Moved,Break :boolean;
    end;
  TObjList=Record //对象列表
    ID:integer; Text:string; State:string[5]; //ID对象ID Text列表字串
    end;
  TmyObject=Record //对象数据结构
    Name,parent, ShowID :integer;  //Name:创建时自动生成的唯一序列号 parent父对象 ShowID:对象列表中的顺序号
    Kind,Mode :integer; //类型、样式
    Tag,TagN :string; TagS,TagC:integer; //标签串 字体 字号 颜色
    TagT:string[4];     //标签字体模式
    TagPos, TagSize :TPoint; //标签参数 TagPos位置 TagSize长宽
    TagP,TagScr :TcgVector;  //TagScr标签左下角的三维坐标 TagSel选择框  与窗框有关,不保存
    p0,p1,p2,p3,p4,p5,Vec,pTR,pBL :TcgVector;  //向量  pTR为平移变换的偏移量 p4为函数曲面的参数
    //Obj[0]的Para[0]用于记录变换值 Para[0].x,y,z平移值，Para[0].w缩放值 Para[0].r旋转角度
    Para  :Array[0..LinkTime]of TcgVector;//用于记录参数控制数据
    Link, LinkName :Array[0..LinkTime]of integer;//关联构件索引 orde约束点的路径
    info  :Array[0..3]of AnsiString;         //纹理文件 方程的表达式
    Cutter:Array[0..6,0..2]of integer;//剪切面
    Value :Array[0..LinkTime]of single;
    Color,ColorB :TcgColorF;  //构件颜色(透明度)
    ColorMode :integer;       //着色模式
    ColorV0, ColorV1 :single; //着色值域
    L,W,H,R,Thick,Angle :single;   //长、宽 高 转角 旋转变换角 Thick圆和平面的厚度
    S, nTrace,maxTrace :integer;//S线形、剪裁、实体边数。作为平面的填充模式，<10为外框线形，>=10为填充模式
    D,F,U,Q,Deg,noSel,Rand :boolean;   //Q可被截   noSel不被左键选中
    kW,kH,kWtag,kHtag :single;      //纹理尺寸 大于图片尺寸的2的整数幂
    mainList,maskList,wireList,seleList,tracList,stipList, texID,texTag :Cardinal; //图片纹理 标签纹理
    ObjShow,TagShow, bEnd :TLayer; //构件及标签的显示顺序
    Hide, Lock, Mask, Way, Trace :boolean;  //选中状态, 无条件隐藏, 锁定状态
    Edited, Seled, Hot, Dad,Son :boolean; //正被编辑，与之有关的构件将被重画
    DelID,iL,iR,iT :integer; //DelID:关联构件被删除
    sImage:TsImage;     //图像文本格式
    butID :TPanel;      //控制按钮控件
    runID :TSpeedButton;//控制按钮控件左上角的暂停按纽
    imgID :TImage;      //控制按钮控件右下角的移动图象
    timID :TTimer;      //动画、移动时钟
    end;
  gl4f = Array[0..3]of single;
  gl3f = Array[0..2]of single;  //
  TObjType = Array of TmyObject;   //构件记录数组. 下标为1的记录为环境数据
  TDropFile = Array[0..255]of Char;
  Tpara= Array[1..18]of single; //计算式中的常量参数

  TmyUndoData=Record
    undoCode, undoNum :integer; //undoCode: 0_编辑 1_添加 2_删除 3_合并 4_分离 undoNum:涉及对象个数
    undoObjID :Array[0..LinkTime]of integer; //序号0为undo数组指针 后续序号为Obj数组指针
    end;
  TBackObj=record
    undoID, undoMax, maxName :integer; //undoID当前undo指针 undoMax最大undo指针 maxName最大对象名
    undoData :Array[0..undoTime]of TmyUndoData;
    undoObj  :Array[0..undoTime]of TmyObject;
    end;

  TPosType  = Array of TcgVector;
  TLocaType = Array of TPosType;
  TFaceType = Array of TLocaType;// array of array of TcgVector;

  TPosColor = Array of TcgColorF;
  TLocaColor= Array of TPosColor;
  TFaceColor= Array of TLocaColor;

  TLinkType = Array of Array of Boolean;
  TIterate= Record p0:TcgVector;  L:single; end;
  TIterateRule= Array[0..7,0..21]of integer; //迭代规则

  TfrmMain = Class(TForm)
    OpenBox: TOpenDialog;
    SaveBox: TSaveDialog;
    ColorBox:TColorDialog;
    butZoom: TPanel;
    timAuto: TTimer;
    timSpin: TTimer;
    timFlash: TTimer;
    labHint: TStaticText;
    imgSys: TImageList;   //按钮图集
    imgRun: TImage;
    imgSize: TImage;
    imgFillMode: TImage;  //平面模式图片
    pnlShow: TPanel;      //对象层容器
    edtTemp: TEdit;
    popObj: TPopupMenu;   //分隔线
    popCode: TPopupMenu;  //函数
      menFunc1: TMenuItem;
      menFunc2: TMenuItem;
      menFunc3: TMenuItem;
      menFunc4: TMenuItem;
      menFunc5: TMenuItem;
      menBar31: TMenuItem;
      menBar38: TMenuItem;
      menBar42: TMenuItem;
      menBar39: TMenuItem;
      calcPi: TMenuItem;
      calcEi: TMenuItem;
      calcAbs: TMenuItem;
      calcInt: TMenuItem;
      calcFr: TMenuItem;
      calcSqr: TMenuItem;
      calcSqrt: TMenuItem;
      calcExp: TMenuItem;
      calcLn: TMenuItem;
      calcSgn: TMenuItem;
      calcRound: TMenuItem;
      calcRandom: TMenuItem;
      calcSin: TMenuItem;
      calcCos: TMenuItem;
      calcTan: TMenuItem;
      calcSinh: TMenuItem;
      calcCosh: TMenuItem;
      calcTanh: TMenuItem;
      calcArcsin: TMenuItem;
      calcArccos: TMenuItem;
      calcArctan: TMenuItem;
      calcMax: TMenuItem;
      calcMin: TMenuItem;
      calcEqual: TMenuItem;
      calcLess: TMenuItem;
      calcLesse: TMenuItem;
      calcNote: TMenuItem;
      calcHeav: TMenuItem;
      calcRad: TMenuItem;
      calcLog: TMenuItem;
      calcParity: TMenuItem;
      calcArcsinh: TMenuItem;
      calcArccosh: TMenuItem;
      calcArctanh: TMenuItem;
      calcMod: TMenuItem;
      calcFact: TMenuItem; //
    pnlProp: TPanel;        //属性框
      butNail: TSpeedButton;
      pnlFPS: TPanel;
      posEdit: TEdit;
      tabProp: TPageControl;
        Tab0: TTabSheet; //对象属性
          pnl0: TPanel;
          pnl1: TPanel;
            labTag: TLabel;
            varTag: TLabel;
            varColor: TLabel;
          pnl2: TPanel;
            labColor: TLabel;
            varC: TLabel;
            varC1: TLabel;
          pnl3: TPanel;
            labX: TLabel;
            posX: TLabel;
          pnl4: TPanel;
            labY: TLabel;
            posY: TLabel;
          pnl5: TPanel;
            labZ: TLabel;
            posZ: TLabel;
          pnl6: TPanel;
            labW: TLabel;
            varW: TLabel;
          pnl7: TPanel;
            labL: TLabel;
            varL: TLabel;
          pnl8: TPanel;
            labS: TLabel;
            varS: TLabel;
          pnl9: TPanel;
            varH: TLabel;
            labH: TLabel;
          pnl10: TPanel;
            labA: TLabel;
            varA: TLabel;
          pnl11: TPanel;
            labT: TLabel;
            varT: TLabel;
          pnl12: TPanel;
            cheColor: TCheckBox;
          pnl13: TPanel;
            cheSolid: TCheckBox;
          pnl14: TPanel;
            cheMask: TCheckBox;
            butTex: TButton;
          pnl15: TPanel;
            cheWay: TCheckBox;
          pnl16: TPanel;
            labFill: TLabel;
            cmbFill: TComboBox;
          pnl18: TPanel;   //可关联构件菜单
            ToolBar1: TToolBar;
            butSon: TToolButton;
            butDad: TToolButton;
          pnl19: TPanel;   //定比 定距
            selWay0: TRadioButton;
            selWay1: TRadioButton;
          pnl20: TPanel;
            varR: TLabel;
            labR: TLabel;
          pnl21: TPanel;
            labShape: TLabel;
            cmbStyle: TComboBox;
          pnl22: TPanel;//箭头
            labArrow: TLabel;
            pnlLeft: TPanel;
            imgLeft: TImage;
            pnlRight: TPanel;
            imgRight: TImage;
          pnl23: TPanel;//剪裁
            cheSec: TCheckBox;
            cheCutter: TCheckListBox;
            butCutter: TButton;
          pnl24: TPanel;//炫彩
            labColorFull: TLabel;
            pnlColorH: TPanel;
            imgColorH: TImage;
            pnlColorV: TPanel;
            imgColorV: TImage;
          pnl25: TPanel;//锁定
            cheLock: TCheckBox;
          pnl26: TPanel;//遮挡
            cheBlock: TCheckBox;
          pnl27: TPanel;//痕迹
            cheTrace: TCheckBox;
          pnl28: TPanel;//痕长
            varTrace: TLabel;
            labTrace: TLabel;
          pnl29: TPanel;//精度
            labAccuracy: TLabel;
            cmbAccuracy: TComboBox;
          pnl00: TPanel;//可选择
            cheSel: TCheckBox;
          pnl47: TPanel;//显示
            cheShow: TCheckBox;
          pnl48: TPanel;//底边式
            cheBottom: TCheckBox;
        Tab1: TTabSheet;//场景属性
          pnl30: TPanel;//景深
            labDeep: TLabel;
            varDeep: TLabel;
          pnl31: TPanel;//透视
            labPers: TLabel;
          pnl32: TPanel;//Z轴
            varPers: TLabel;
          pnl33: TPanel;//轴线
            cheAxis: TCheckBox;
            cheAxisZ: TCheckBox;
          pnl34: TPanel;//网格
            cheGrid: TCheckBox;
          pnl35: TPanel;//原点
            cheOrigin: TCheckBox;
          pnl36: TPanel;//雾效
            cheFog: TCheckBox;
          pnl37: TPanel;//反锯齿
            cheSmooth: TCheckBox;
          pnl38: TPanel;//刷新率
            cheFlash: TCheckBox;
          pnl39: TPanel;//工具提示
            cheHint: TCheckBox;
          pnl40: TPanel;//景色
            varScreen: TLabel;
            labScene: TLabel;
          pnl41: TPanel;//标签
            cheTag: TCheckBox;
            varObjColor: TLabel;
          pnl44: TPanel;//平面
            chePlane: TCheckBox;
          pnl45: TPanel;//刻度
            cheMark: TCheckBox;
          pnl46: TPanel;//X弧度
            cheAngle: TCheckBox;
          labProp: TLabel; //系统参数
          pnl42: TPanel;
            labObj: TLabel;
            cmbObjKind: TComboBox;
          pnl43: TPanel;         //
            labObjSize: TLabel;
            varObjSize: TLabel;
          butGetDefault: TButton; //保存
          butSaveDefault: TButton;

    tlbMenu: TToolBar; //工具条
    menMain: TMainMenu;   //文件
      menFile: TMenuItem;
      menNew: TMenuItem;
      menOpen: TMenuItem;
      menSave: TMenuItem;
      menSaveAs: TMenuItem;
      menSaveImage: TMenuItem;
      menBar10: TMenuItem;
      menPage: TMenuItem;
        menPageNew: TMenuItem;
        menPageClone: TMenuItem;
        menPageOpen: TMenuItem;
        menBar6: TMenuItem;
        menBar11: TMenuItem;
        menPageDelete: TMenuItem;
        menBar12: TMenuItem;
        menBar13: TMenuItem;
        menPageRename: TMenuItem;
      menBar51: TMenuItem;
      menExit: TMenuItem;
      menBar1: TMenuItem;
    menEdit: TMenuItem;   //编辑
      menUndo: TMenuItem;
      menRedo: TMenuItem;
      menBar48: TMenuItem;
    menCopyObj: TMenuItem;
    menPasteObj: TMenuItem;
      menObjDel: TMenuItem;
      menPaintDel: TMenuItem;
      menBar29: TMenuItem;
      menControl: TMenuItem; //按钮
        menHide: TMenuItem;
        menAnimation: TMenuItem;
        menMove: TMenuItem;
        menSeries: TMenuItem;
        menLinkNet: TMenuItem;
      menObjAll: TMenuItem;
      menSelDad: TMenuItem;
      menSelSon: TMenuItem;
      menBar69: TMenuItem;//----------
      menJoin: TMenuItem; //线段反向
      menCutting: TMenuItem; //分割
      menImage: TMenuItem;
      menMoveID: TMenuItem;
      menProp: TMenuItem;
    menView: TMenuItem;   //显示
      menDotStyle: TMenuItem;
        menDotSize1: TMenuItem;
        menDotSize2: TMenuItem;
        menDotSize3: TMenuItem;
        menDotSize4: TMenuItem;
        menDotSize5: TMenuItem;
          menBar19: TMenuItem;
        menDotSize6: TMenuItem;
        menDotSize7: TMenuItem;
        menDotSize8: TMenuItem;
        menDotSize9: TMenuItem;
      menLineStyle: TMenuItem;
        menWidth1: TMenuItem;
        menWidth2: TMenuItem;
        menWidth3: TMenuItem;
        menWidth4: TMenuItem;
        menWidth5: TMenuItem;
          menBar21: TMenuItem;
        menWidth7: TMenuItem;
        menWidth8: TMenuItem;
        menWidth9: TMenuItem;
      menColor: TMenuItem;
      menObjHide: TMenuItem;
      menAll: TMenuItem;
      menTagHide: TMenuItem;
      menLabel: TMenuItem;
      menTrace: TMenuItem;
      menTraceDel: TMenuItem;
        menBar55: TMenuItem;//----------
      menSpin: TMenuItem;
      menSport: TMenuItem;
      menStart: TMenuItem;
      menMax: TMenuItem;
      menPers: TMenuItem; //视角
        menXYZ: TMenuItem;
        menViewer: TMenuItem;
        menX: TMenuItem;
        menY: TMenuItem;
        menZ: TMenuItem;
        menLock: TMenuItem;
        men2D: TMenuItem;
      menBar2: TMenuItem;//----------
      menFont: TMenuItem;
      menList: TMenuItem; //对象列表
      menTools: TMenuItem;
      menStatus: TMenuItem;
      menPages: TMenuItem;
      menMenuOnBottom: TMenuItem; //菜单置于底部


    menTrans: TMenuItem;  //变换
      menMark3: TMenuItem;
      menMark4: TMenuItem;
      menMark5: TMenuItem;
      menMark6: TMenuItem;
      menMark7: TMenuItem;
      menBar9: TMenuItem;//----------
      men125: TMenuItem;
      men121: TMenuItem;
      men122: TMenuItem;
      men124: TMenuItem;
      men123: TMenuItem;
      men126: TMenuItem;
      men128: TMenuItem;
      men129: TMenuItem;
      men130: TMenuItem;//仿射变换
      menBar67: TMenuItem;//----------
      men131: TMenuItem;
      menMark8: TMenuItem;
      menBar5: TMenuItem;//----------
    menSize: TMenuItem;    //数据
      men111: TMenuItem;
      men112: TMenuItem;
      menBar97: TMenuItem;//----------
      menSize03: TMenuItem;
      menSize04: TMenuItem;
      menSize05: TMenuItem;
      menSize06: TMenuItem;
      menSize07: TMenuItem;
      menSize08: TMenuItem;
      menSize09: TMenuItem;
      menSize13: TMenuItem;
      menSize14: TMenuItem;
      menSize15: TMenuItem;
      menSize16: TMenuItem;
      menSize17: TMenuItem;
      menSize19: TMenuItem;
    menAnother: TMenuItem; //帮助
      menHelp: TMenuItem;
      menNet: TMenuItem;
      menBar57: TMenuItem; //----------
      menLanguage: TMenuItem;
      menAbout: TMenuItem;
      qw1: TMenuItem;
    menConst: TMenuItem;  //构造
      menDot: TMenuItem;  //点
        men11: TMenuItem;
        men12: TMenuItem;
        men13: TMenuItem;
        men14: TMenuItem;
        men15: TMenuItem;
    men16: TMenuItem;
      menLine: TMenuItem; //直线
        men21: TMenuItem;
        men23: TMenuItem;
        men24: TMenuItem;
        men25: TMenuItem;
        men26_2: TMenuItem;
        men27: TMenuItem;
        men28: TMenuItem;
        men29: TMenuItem;
      menVector: TMenuItem; //向量
        menVector0: TMenuItem;
        menVector1: TMenuItem;
        menVector2: TMenuItem;
        menVector3: TMenuItem;
        menVector4: TMenuItem;
      menCircle: TMenuItem; //圆
        men31: TMenuItem;
        men32: TMenuItem;
        men33: TMenuItem;
        men34: TMenuItem;
      menCurve: TMenuItem;  //曲线
        men26: TMenuItem;   //相惯线
        men51: TMenuItem;   //轨迹线
        men171: TMenuItem;  //路径
        men191: TMenuItem;  //圆锥曲线1
        men192: TMenuItem;  //圆锥曲线2
    men172: TMenuItem;
        menBar4: TMenuItem;
        menFuncCurve: TMenuItem;//函数曲线
      menBar166: TMenuItem;
      menPlane: TMenuItem;  //平面
        men42: TMenuItem;
        men43: TMenuItem;
        men44: TMenuItem;
        men45: TMenuItem;
      menPolygon: TMenuItem;
    menPoly03: TMenuItem;
    menPoly04: TMenuItem;
    menPoly05: TMenuItem;
    menPoly06: TMenuItem;
    menPoly08: TMenuItem;
    menPoly10: TMenuItem;
    menPoly12: TMenuItem;
        menBar3: TMenuItem;
    menPolyN: TMenuItem;
    menPoly0: TMenuItem;
    menPoly99: TMenuItem;
      menFace: TMenuItem;   //曲面
        men71: TMenuItem;
        men72: TMenuItem;
        men74: TMenuItem;
      menFuncFace: TMenuItem; //函数曲面
      menBar147: TMenuItem;//----------
      menSphere: TMenuItem;
      menSphere3D: TMenuItem;
      menCone: TMenuItem;
      menTable: TMenuItem;    //棱台
        menTable3: TMenuItem;
        menTable4: TMenuItem;
        menTable5: TMenuItem;
        menTable6: TMenuItem;
        menTable8: TMenuItem;
        menTable10: TMenuItem;
        menTable12: TMenuItem;
        menBar7: TMenuItem; //----------
        menTable0: TMenuItem;
        menTableN: TMenuItem;
      menSolid: TMenuItem;   //多面体
        menSolid1: TMenuItem;
        menSolid2: TMenuItem;
        menSolid3: TMenuItem;
        menSolid4: TMenuItem;
        menSolid5: TMenuItem;
    menSolidBar: TMenuItem;
        menSolid6: TMenuItem;
        menSolid65: TMenuItem;

    tlbMain: TToolBar;
      butMax: TToolButton;
      butSpin: TToolButton;
      butLock: TToolButton;
      butAll: TToolButton;
      butProp: TToolButton;
    UpDwPage: TUpDown;
      barPage: TTrackBar;//----------
    tlbTools: TToolBar;   //作图工具条
      butArrow: TToolButton;
      butPoint: TToolButton;
      butLine: TToolButton;
      butCircle: TToolButton;
      butPlane: TToolButton;
      butTxt: TToolButton;
      butPen: TToolButton;
    tlbShort: TToolBar;   //动态工具条
      butPaintRect: TToolButton;
      butPaintCircle: TToolButton;
      butPaintDel: TToolButton;
      butJoin: TToolButton;
      butSize: TToolButton;
      but12: TToolButton;
      but14: TToolButton;
      but15: TToolButton;
      but21: TToolButton;
      but22: TToolButton;
      but23: TToolButton;
      but24: TToolButton;
      but25: TToolButton;
      but26: TToolButton;
      but27: TToolButton;
      but28: TToolButton;
      but29: TToolButton;
      but31: TToolButton;
      but32: TToolButton;
      but33: TToolButton;
      but34: TToolButton;
      but41: TToolButton;
      but42: TToolButton;
      but43: TToolButton;
      but44: TToolButton;
      but45: TToolButton;
      but46: TToolButton;
      but51: TToolButton;
      but64: TToolButton;
      but60: TToolButton;
      but61: TToolButton;
      but62: TToolButton;
      but63: TToolButton;
      but72: TToolButton;
      but71: TToolButton;
      but74: TToolButton;
      but171: TToolButton;
      popVector: TPopupMenu;
        butVector0: TMenuItem;
        butVector1: TMenuItem;
        butVector2: TMenuItem;
        butVector3: TMenuItem;
        butVector4: TMenuItem;
      popTable: TPopupMenu;
        butTable03: TMenuItem;
        butTable04: TMenuItem;
        butTable05: TMenuItem;
        butTable06: TMenuItem;
        butTable08: TMenuItem;
        butTable10: TMenuItem;
        butTable12: TMenuItem;
        butTableBar: TMenuItem; //-----------
        butTableN: TMenuItem;
      popSolid: TPopupMenu;
        butSolid1: TMenuItem;
        butSolid2: TMenuItem;
        butSolid3: TMenuItem;
        butSolid4: TMenuItem;
        butSolid5: TMenuItem;
        butSolidBar: TMenuItem;
        butSolid6: TMenuItem;
        butSolid0: TMenuItem;
      popPolygon: TPopupMenu;
        butPoly03: TMenuItem;
        butPoly04: TMenuItem;
        butPoly05: TMenuItem;
        butPoly06: TMenuItem;
        butPoly08: TMenuItem;
        butPoly10: TMenuItem;
        butPoly12: TMenuItem;
        butPolyN: TMenuItem;
        butPolyBar: TMenuItem;
        butPoly99: TMenuItem;
        butPoly: TMenuItem;
      popSize: TPopupMenu;
        butSize03: TMenuItem;
        butSize04: TMenuItem;
        butSize05: TMenuItem;
        butSize06: TMenuItem;
        butSize07: TMenuItem;
        butSize08: TMenuItem;
        butSize09: TMenuItem;
        butSize13: TMenuItem;
        butSize14: TMenuItem;
        butSize15: TMenuItem;
        butSize16: TMenuItem;
        butSize17: TMenuItem;
    stbBar: TPanel;   //状态条
      tabPage: TTabSet;
      edtPage: TEdit;
      popPage: TPopupMenu;
        popPageNew: TMenuItem;
        popPageClone: TMenuItem;
        popPageDelete: TMenuItem;
        popPageRename: TMenuItem;
        popPageOpen: TMenuItem;
    popMultObj: TPopupMenu;
    imgZoom: TImage;
    imgDrag: TImage;

    pnlControl: TPanel;//控制框
      butOK: TButton;
      butCtrlExit: TButton;
      butRand: TButton; //随机 仅用于迭代
      pagControl: TPageControl;
    pnlCalcPad: TPanel; //软键盘
      butCalc7: TSpeedButton;
      butCalc8: TSpeedButton;
      butCalc9: TSpeedButton;
      butCalc4: TSpeedButton;
      butCalc5: TSpeedButton;
      butCalc6: TSpeedButton;
      butCalc1: TSpeedButton;
      butCalc2: TSpeedButton;
      butCalc3: TSpeedButton;
      butCalc0: TSpeedButton;
      butCalc10: TSpeedButton;
      butCalc11: TSpeedButton;
      butCalc12: TSpeedButton;
      butCalc13: TSpeedButton;
      butCalc14: TSpeedButton;
      butCalc15: TSpeedButton;
      butCalc16: TSpeedButton;
      butCalc17: TSpeedButton;
      butCalc18: TSpeedButton;
    tabPath: TTabSheet;//路径框
      lstPath: TListBox;
      butPathDel: TButton;
      butPathResume: TButton;
    tabText: TTabSheet;//文本框
      memText: TMemo;
    tabCalc: TTabSheet;//计算框
      pnlResult: TPanel;
      memExpr: TMemo;
      labResult: TLabel;
    tabPara: TTabSheet;//参数框
      grdPara: TStringGrid;
      labParaValue: TLabel;
      labParaObj: TLabel;
      labParaCtrl: TLabel;
      butParaAdd: TButton;
      butParaDel: TButton;
      cmbPara: TComboBox;
      edtValu: TEdit;
    tabMove: TTabSheet;
      labMove: TLabel;
      cmbMove: TComboBox;
    tabIterate: TTabSheet;
    pnlIterate: TPanel;
        labSour: TLabel;
        labDest: TLabel;
      butDieDaiAdd: TButton;
      butDieDaiSub: TButton;
      txtDepth: TEdit;
      labDepth: TLabel;
      labLayer: TLabel;
      edtLayer: TEdit;
      cheLast: TCheckBox;
      cheDot: TCheckBox;
      cheRand: TCheckBox;
    tabFunc: TTabSheet; //函数曲面
      selAxis: TComboBox;
      selFunc0: TRadioButton;
      selFunc1: TRadioButton;
      selFunc2: TRadioButton;
      edtX: TLabeledEdit;
      edtY: TLabeledEdit;
      edtZ: TLabeledEdit;
      edtXmin: TLabeledEdit;
      edtXmax: TLabeledEdit;
      edtXinc: TLabeledEdit;
      edtParA: TLabeledEdit;
      edtParB: TLabeledEdit;
      edtParC: TLabeledEdit;
      edtParD: TLabeledEdit;
      edtParE: TLabeledEdit;
      edtParF: TLabeledEdit;
      edtYmin: TLabeledEdit;
      edtYmax: TLabeledEdit;
      edtYinc: TLabeledEdit;
      edtZmin: TLabeledEdit;
      edtZmax: TLabeledEdit;
      edtZinc: TLabeledEdit;
      cheRound: TCheckBox;
      cheHide: TCheckBox;
    tabLabel: TTabSheet; //批量标签框
      edtLabel: TEdit;
      labLabel: TLabel;
      imgLabel: TPaintBox;
    tabColor: TTabSheet; //参数着色
      grpPara: TGroupBox;
        cmbColor1: TComboBox;
        cmbColor2: TComboBox;
        cmbColor3: TComboBox;
        radColor: TRadioButton;
        radGray: TRadioButton;
        radLight: TRadioButton;
      grpWare: TGroupBox;
        edtColorV0: TEdit;
        edtColorV1: TEdit;
        labParaBar: TLabel;
      grpRepeat: TGroupBox;
        radNoWay: TRadioButton;
        radOneWay: TRadioButton;
        radTwoWay: TRadioButton;
        imgColor: TImage;
        imgColorR: TImage;
        imgColorG: TImage;
        imgColorB: TImage;
    tlbCalc: TToolBar; //计算规则
      butCalcCode: TToolButton;
    tabAffine: TTabSheet; //仿射变换规则
      Label1: TLabel;
      Label2: TLabel;
      Label3: TLabel;
    tabLink: TTabSheet; //链接框
      radPage: TRadioButton;
      radLink: TRadioButton;
      edtLink: TEdit;
      labButton: TLabel;
      cmbPage: TComboBox;
      cmbButton: TComboBox;
      butLinkFile: TSpeedButton;
    pnlList: TPanel;  //对象列表
      pnlListTitle: TPanel;
      pnlListBox: TPanel;
      butListClose: TSpeedButton;
    butListAnchor: TSpeedButton;
      butList: TToolButton;
      imgList: TImage;
    pnlFont: TPanel;  //字体编辑框
      tlbFont: TToolBar;
      cmbFontN: TComboBox;
      cmbFontS: TComboBox;
      cmbFontC: TComboBox;
      butFontB: TToolButton;
      butFontI: TToolButton;
      butFontU: TToolButton;
      imgFont: TImage;
      scrList: TScrollBar;
    butCalc99: TSpeedButton;
      butCalcPad: TSpeedButton;
      butPathD: TSpeedButton;
      butPathU: TSpeedButton;
    but13: TToolButton;
    but16: TToolButton;
    butSize19: TMenuItem;
    toolSpace2: TToolButton;
    pnlColorPad: TPanel;
    N2: TMenuItem;
    Lst: TListBox;
    imgListMode: TImage;
    menInterface: TMenuItem;
    menRecover: TMenuItem;
    calcIif: TMenuItem;
    N4: TMenuItem;
    calctrunc: TMenuItem; //调试专用
    procedure WhenHint(Sender: TObject);
    procedure FormCreate( Sender: TObject);
    procedure FormCloseQuery( Sender: TObject; var CanClose: Boolean);
    procedure FormKeyDown( Sender: TObject; var Key: Word;Shift: TShiftState);
    procedure FormKeyPress( Sender: TObject; var Key: Char);
    procedure FormKeyUp( Sender: TObject; var Key: Word; Shift: TShiftState);
    procedure FormMouseMove( Sender: TObject; Shift: TShiftState; X,Y: Integer);
    procedure FormMouseDown(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure FormMouseUp( Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure FormDblClick( Sender: TObject);
    procedure FormMouseWheel( Sender: TObject; Shift: TShiftState; WheelDelta: Integer; MousePos: TPoint; var Handled: Boolean);
    procedure FormClose( Sender: TObject; var Action: TCloseAction);
    procedure FormResize( Sender: TObject);
    procedure FormPaint( Sender: TObject);
    procedure setWindowStyle; //全屏切换
    procedure timAutoTimer( Sender: TObject);   //动态轨迹线
    procedure timFlashTimer( Sender: TObject);  //标签闪烁
    procedure timAnimateTimer( Sender: TObject);//动画控制
    procedure timMoveTimer( Sender: TObject);   //移动控制
    procedure timSeriesTimer( Sender: Tobject); //系列按钮控制
    procedure timVarTimer( Sender: TObject);    //參數動畫
    procedure ObjShowClick( Sender: TObject);
    procedure TagShowClick( Sender: TObject);
    procedure butOpenClick( Sender: TObject);
    procedure butDrawClick( Sender: TObject);
    procedure butCancClick( Sender: TObject);
    procedure butOKClick( Sender: TObject);
    procedure but10Click( Sender: TObject);
    procedure butDadMouseDown( Sender: TObject; Button: TMouseButton;Shift: TShiftState; X, Y: Integer);
    procedure butDieDaiAddClick( Sender: TObject);
    procedure barPageChange( Sender: TObject);
    procedure cheSolidMouseUp( Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure cheRandMouseUp( Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure cmbStyleChange( Sender: TObject);
    procedure cmbFillDrawItem( Control: TWinControl; Index: Integer; Rect: TRect; State: TOwnerDrawState);
    procedure cmbFillClick( Sender: TObject);
    procedure edtZEnter( Sender: TObject);
    procedure edtParAKeyPress( Sender: TObject; var Key: Char);
    procedure edtXKeyDown( Sender: TObject; var Key: Word; Shift: TShiftState);
    procedure itmOpenClick( Sender: TObject);
    procedure popObjClick( Sender: TObject);
    procedure imgSingleMouseDown( Sender: TObject; Button: TMouseButton;Shift: TShiftState; X, Y: Integer);
    procedure imgForeMouseDown( Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure butIDMouseDown( Sender: TObject; Button: TMouseButton;Shift: TShiftState; X, Y: Integer);
    procedure butIDMouseUp(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure imgIDMouseDown( Sender: TObject; Button: TMouseButton;Shift: TShiftState; X, Y: Integer);
    procedure imgIDMouseMove( Sender: TObject; Shift: TShiftState; X,Y: Integer);
    procedure imgIDMouseUp( Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure imgIDDblClick( Sender: TObject);
    procedure runIDClick( Sender: TObject);
    procedure memExprChange( Sender: TObject);
    procedure menSolidClick( Sender: TObject);
    procedure butSolidClick( Sender: TObject);
    procedure menTableClick( Sender: TObject);
    procedure butTableClick( Sender: TObject);
    procedure menPolygonClick( Sender: TObject);
    procedure butPolygonClick( Sender: TObject);
    procedure menSizeClick( Sender: TObject);
    procedure butSizeClick( Sender: TObject);
    procedure posEdit1KeyDown( Sender: TObject; var Key: Word; Shift: TShiftState);
    procedure posEdit1KeyPress( Sender: TObject; var Key: Char);
    procedure pnlColorClick( Sender: TObject);
    procedure pnlFuncShow; //函数曲面属性
    procedure pnlIterateShow( Add:boolean); //迭代属性
    procedure pnlPathShow( ID:integer; Add:boolean);//路径属性
    procedure pnlCtrlShow( ID:integer); //控制按纽属性
    procedure pnlCalcMouseDown( Sender: TObject; Button: TMouseButton;Shift: TShiftState; X, Y: Integer);
    procedure selAxisChange( Sender: TObject);
    procedure tabPropChange( Sender: TObject);
    procedure txtDepthEnter(Sender: TObject);
    procedure txtDepth0MouseDown( Sender: TObject; Button: TMouseButton;Shift: TShiftState; X, Y: Integer);
    procedure varAMouseDown( Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure varAMouseMove( Sender: TObject; Shift: TShiftState; X,Y: Integer);
    procedure varTMouseUp( Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
//    procedure butMoveClick( Sender: TObject);
    procedure cmbMoveSelect( Sender: TObject);
    procedure memExprKeyDown( Sender: TObject; var Key: Word;Shift: TShiftState);
    procedure imgColorHMouseDown(Sender: TObject; Button: TMouseButton;Shift: TShiftState; X, Y: Integer);
    procedure butSaveDefaultClick( Sender: TObject);
    procedure cmbObjKindChange( Sender: TObject);
    procedure N27Click( Sender: TObject);
    procedure selFuncChange( Sender: TObject);
    procedure timSpinTimer( Sender: TObject);
    procedure radMoveClick( Sender: TObject);
    procedure lstCtrlMouseDown( Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure cmbAccuracyChange( Sender: TObject);
    procedure UpDwPageClick( Sender: TObject; Button: TUDBtnType);
    procedure posEditExit( Sender: TObject);
    procedure menOpenClick( Sender: TObject);
    procedure menSize8Click( Sender: TObject);
    procedure menMoveIDClick( Sender: TObject);
    procedure vi( Sender: TObject);
    procedure menSpinClick( Sender: TObject);
    procedure but12Click( Sender: TObject);
    procedure menMarkClick( Sender: TObject);
    procedure menTransClick( Sender: TObject);
    procedure popPageClick( Sender: TObject);
    procedure tabPageMouseDown( Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure tabPageMouseMove( Sender: TObject; Shift: TShiftState; X,Y: Integer);
    procedure edtPageChange( Sender: TObject);
    procedure edtPageExit( Sender: TObject);
    procedure edtPageKeyDown( Sender: TObject; var Key: Word; Shift: TShiftState);
    procedure menCopyObjClick( Sender: TObject);
    procedure menPasteObjClick( Sender: TObject);
    procedure FormDestroy( Sender: TObject);
    procedure menEditClick( Sender: TObject);
    procedure setPaintList( setHot:boolean);
    procedure butPaintColorEDrawItem(Sender: TObject; ACanvas: TCanvas; ARect: TRect; Selected: Boolean);
    procedure butPaintColorEMeasureItem( Sender: TObject; ACanvas: TCanvas; var Width, Height: Integer);
    procedure butPaintColorFClick( Sender: TObject);
    procedure butPaintCircleClick( Sender: TObject);
    procedure menObjHideClick( Sender: TObject);
    procedure menWidth9Click( Sender: TObject);
    procedure menDotSize9Click( Sender: TObject);
    procedure butPaintDelClick( Sender: TObject);
    procedure butNailClick( Sender: TObject);
    procedure pnlControlMouseDown( Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure pnlControlMouseMove( Sender: TObject; Shift: TShiftState; X,Y: Integer);
    procedure imgDragMouseDown( Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure imgDragMouseMove( Sender: TObject; Shift: TShiftState; X,Y: Integer);
    //参数轴
    procedure imgParaMouseDown( Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure imgParaMouseMove( Sender: TObject; Shift: TShiftState; X,Y: Integer);
    procedure imgParaMouseUp( Sender :TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure imgParaDblClick( Sender :TObject);
    procedure cmbParaSelect( Sender: TObject);
    procedure butParaAddClick( Sender: TObject);
    procedure grdParaSelectCell( Sender: TObject; ACol, ARow: Integer; var CanSelect: Boolean);
    procedure edtValuExit( Sender: TObject);
    procedure grdParaOK( ID: integer);
    procedure menLabelClick(Sender: TObject);
    procedure menViewClick(Sender: TObject);
    procedure edtLabelChange(Sender: TObject);
    procedure radGrayClick(Sender: TObject);
    procedure cmbColor3Change(Sender: TObject);
    procedure menXYZClick(Sender: TObject);
    procedure edtZExit(Sender: TObject);
    procedure txtDepthExit(Sender: TObject);
    procedure txtDepthKeyPress(Sender: TObject; var Key: Char);
    procedure butCalc7Click(Sender: TObject);
    procedure butPathResumeClick(Sender: TObject);
    procedure lstPathExit(Sender: TObject);
    procedure edtLabelKeyDown(Sender: TObject; var Key: Word; Shift: TShiftState);
    procedure cmbPageChange(Sender: TObject);
    procedure butLinkFileClick(Sender: TObject);
    procedure menTraceClick(Sender: TObject);
    procedure selWay1MouseUp(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure cheCutterClickCheck(Sender: TObject);
    procedure cheCutterMouseDown(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure menVectorClick(Sender: TObject);
    procedure butVector1Click(Sender: TObject);
    procedure men172Click(Sender: TObject);
    procedure butFontDClick(Sender: TObject);
    procedure cmbFontCDrawItem(Control: TWinControl; Index: Integer; Rect: TRect; State: TOwnerDrawState);
    procedure pnlFontMouseDown(Sender: TObject; Button: TMouseButton;  Shift: TShiftState; X, Y: Integer);
    procedure pnlFontMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure imgFontClick(Sender: TObject);
    procedure menCuttingClick(Sender: TObject);
    procedure menPasteTextureClick(Sender: TObject);
    procedure pnlListMouseDown(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure pnlListMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure imgListMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure imgListMouseDown(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure imgListDblClick(Sender: TObject);
    procedure scrListChange(Sender: TObject);
  private
    rc : HGLRC;   // Rendering Context
    dc : HDC;
    procedure MenuItemAdvancedDrawItem(Sender: TObject; ACanvas: TCanvas;
      ARect: TRect; State: TOwnerDrawState); //设置菜单项的热键下划线
  public
    BackColor, AxisColor, gridColor :TcgColorF;
    {--- view ---}
    Axis, Deep, Pers, FogL : single;//坐标轴长度、场景深度、透视度、雾距
    {--- work variables ---}
    SelectBuf :Array[0..63]of integer;//选择模式使用的缓存数组
    aryFile :Array[0..9]of string;      //文件菜单选项
    itmOpen :Array[0..9]of TMenuItem;   //Open菜单项目
    pnlColor:Array[0..18]of Tpanel;     //调色板
    selFunc: Array[0..2]of TRadioButton;//
    FuncCtrl:Array[0..2]of TlabeledEdit;
    pnlArray:Array[0..32]of TPanel;     //属性控件数组
    txtArray:Array[0..8,0..21]of TEdit; //迭代规则窗里的控件 txtArray[8]用于仿射变换规则
    objArray:TIterateRule; //迭代规则
    parID :Array[1..18]of integer; //计算表达式中的构件序号

    pStiple :TPlaneStiple;     //平面填充模式
    HotText :TEdit; //当前编辑框
    hotEdit :TLabeledEdit;
    hotBut  :TPanel; //当前控制按纽
    hotLabel:TLabel;
    HotTool :TToolButton; HotMenu:TMenuItem; hotToolK:integer;//当前工具按钮和参数
    aObjShow, aTagShow :Array[0..LayerTime] of TPanel;   //对象显示状态控件数组、标签显示状态控件数组
    ObjCount, OldCount, FileCount,MenuCount, maxPage: integer; //总构件数、备份构件数、Kind需求、Mode需求
    MarkObj, Hit,Hits,lastHit,leftHit, selNum,lastSel :integer;
    nK,nM,nS :integer; //创建中的构建类型
    x0,y0, dx,dy, MoveX,MoveY, DownX,DownY :integer;    //选中的构件索引 selNum:选择构件时的计数器
    titleHeight :integer; //窗口标题栏的高度。与机器的显示模式有关
    SportObj, SportTime : integer; //运动构件、运动路径、标签位置
    Origin :TcgVector; // 坐标原点位置
//    Quadric : PGLUquadric;  // cylinder
    viewP :TviewPortArray;
    modeM,projM :T16DArray;
    k1,k2,k3,k4,k5,k6,k7,k8,k9,k10,k11,k12,k13,k14,k15,k16,k17,k18,k19,k20 :boolean; //选中的构件类型
    m1,m2,m3,m4,m5,m6,m7,m8,m9,m10,m11,m12,m13,m14,m15,m16,m17,m18,m19 :boolean; //选中的构件模式
    bA,bC,bS, bEnter,keyDown, bAll, bDown, bMove, bL,bR,bM,bDouble, bFlash, willAdd, KeyX,KeyY :boolean; //[Ctrl]、[Shift]键按下状态，鼠标状态
    bEdit, bAdd,bAdded, bSel, bSport,bPause,bFrameSel,bMultiSel, bSelLink, bOpenFile, lastHot :boolean;
    bNail,bAxis,bGrid,bHint,b2D, bDotJoin,bMerge,bSplit :boolean; //编辑状态、添加状态、选择状态、运动状态、暂停状态
//    myTimer: TTimer;  //用于不定期弹出注册窗口
    CancelNum, ToolID,CtrlNum: integer;//备份数组指针 当前按钮 属性控件数
    FPS:single; {All used for FPS Counter.}
    OldTime,frames:integer;
    MarkTrans :Array[0..9,0..2]of integer; //标记变换
    par :Tpara; //作为参数的六个构件的序号
    expr:string; //计算框中的表达式
    stArray :Array of string; //批量设置标签

    procedure WMDropFiles(var Msg:TWMDropFiles);message WM_DROPFILES; //拖入文件
    procedure setMem( n :integer; bb :boolean); //动态数组内存分配
    procedure SetFont( ID:integer; bEnable, FontToObj:boolean);
    function TransCustom( ID:integer):integer; //自定义变换
    function TransVec( ID:integer; Dot:TcgVector):TcgVector;
    procedure SetDCPixelFormat;
    procedure SetProjection(Draw,isFlash:boolean; func:integer );
    procedure set2Dstyle;
    function DoSelect( x,y:integer) :integer; //选择构件
    function ObjSelected( ID:integer; bS,bC,bL,bR:boolean):integer; //选择了一个构件
    function GetTag( ID :integer):string; // 计算新添构件的标签字符
    function DotInCircle( pc:TcgVector; Nor:integer; Fi,rR,Ht,Rt:single) :TcgVector; //计算圆周上的约束点的坐标
    function DotInPlane( ID:integer; var xL,xH:single; x,y:single; bTag:boolean) :TcgVector;
    procedure setLine( ID:integer; pc,pn:TcgVector );
    procedure setPlane( ID:integer; pc:TcgVector; Nor:integer; Rr:single);
    function getDotAngle(Dot,Cen:TcgVector; Nor:integer; vR:single; bb:boolean):single; //点 圆构件
    function getSonNum(ID, ObjCount :integer):integer; //统计子对象数目
    procedure CountObjNum(isFromObjList, isRight:boolean); //设置按钮的可用性
    function SetHint( kind,mode,selNum :integer) :string; //设置控件标签
    function GetDotPos( pp:TcgVector; calc:boolean) :TcgVector;    //获得点的屏幕坐标
    function GetWinPos( ID,k :integer) :TcgVector;    //获得构件的屏幕坐标
    function GetObjPos( ID:integer; p:TcgVector; x,y,z :single) :TcgVector;   //获得构件的空间坐标
    function getScrColor( c:TcgColorF):TcgColorF;   //从背景色计算轴线色
    procedure InitLights;   //灯光初始化
    procedure setFog;       //设置雾效
    procedure initDefault;  //系统默认参数
    procedure setDefault(NewPos :boolean);   //根据环境参数设置界面
    procedure Start( New :boolean);          //开始
    procedure GetTextList( ID :integer); //字符串的显示列表
    function TagToBMP( ID:integer; isTag:boolean):Cardinal;
    function TextToBMP( ID:integer; st:AnsiString; isNewText:boolean):Cardinal;
    function AddingEdges( ID,ObjNum:integer):integer; //添加实体时附加的棱边
    function getObjName( n:integer):integer; //新建对象名
    function AddingCross( ID,ObjNum:integer):integer; //添加交点
    procedure TextAndImage( ID:integer; bIterate,isPosition,isImage,isNewText:boolean); //文本 图片 按钮选择框
    procedure AppendObj( t, kk:integer); //添加构件
    procedure AddingObj( t, kk:integer); //添加构件
    procedure ToolResponse(t:integer); //响应菜单或工具
    procedure BreckAdding; //中断添加过程
    procedure DeleteObj(ID :integer; bb:boolean);    //删除构件
    procedure PosDraw(ID :integer);      //坐标指示线
    procedure GridList; //坐标网格
    procedure AxisList; //坐标轴的显示列表
    procedure AxisDraw(bName,bMask:boolean); //坐标轴
    procedure MainDraw( ModOrRender :GLEnum; isFlash:boolean; func:char); //主绘图过程
    function getLinkVar( Link:integer; Dot:TcgVector):single; //计算链接值
    function CrossTowPlane( a,b:integer; var paa,pbb:TcgVector):boolean;
    function CrossPlaneFace( ID:integer):integer; //平面与曲面的交惯线
    function CrossTowFace( ID:integer):integer; //俩曲面的交惯线
    function CrossLine( ID:integer; bDraw,bList,bOnlyDraw:boolean):integer;//相贯线
    procedure Marker( ID:integer; bDraw,bList,bOnlyDraw:boolean);//标注
    function PointJoin( ID,New:integer):integer; // 合并 分离
    procedure DrawProjecteLines( ID:integer); //投影变换的投影线
    procedure Pointe( ID:integer; bDraw,bList,bOnlyDraw:boolean);                     // 点
    procedure Lineer( ID:integer; bDraw,bList,bOnlyDraw:boolean);  // 直线
    function Plane( ID:integer; bDraw,bList:boolean):integer; // 平面
    function Circle( ID,Nor:integer; var PosVct:TPosType):integer; //pc 圆心, ID 法线, L 半径
    function Arc( ID,M:integer; var posVct:TPosType; isLoca:boolean):integer; //圆弧
    function CircleDraw( ID:integer; bDraw,bList,bLoca,bOnlyDraw:boolean):integer;// 圆
    function calcLocaLength(ID:integer):integer; //轨迹点之间的距离
    function Locus( ID:integer; bDraw,bList,bOnlyDraw,bFace :boolean):integer; // 轨迹
    function Conic( ID:integer; bDraw,bList,bOnlyDraw:boolean):integer; //圆锥曲线
    function Path( ID:integer; bDraw,bList,bOnlyDraw:boolean):integer;  // 路径
    procedure ThreeView( ID: integer); //三视图
    procedure PicDraw( ID:integer); //图片
    procedure SolidDraw( ID:integer; isSeled,isWire,isMask :boolean);
    procedure FaceDraw( ID:integer; isSeled,isCircle,isBall,isSolid,isMask,isLine:boolean);
    procedure Face( ID:integer; bDraw,bList,bOnlyDraw:boolean);
    procedure Sphere( ID:integer; bDraw,bList:boolean);//球体,半径R,精度N,是否填充F
    procedure Cubes( ID:integer; bDraw,bList,bLine:boolean);//多面体
    procedure Cone( ID:integer; bDraw,bList:boolean); //圆台
    procedure Table( ID:integer; bDraw,bList,bLine:boolean);//棱台
    procedure CustomTable( ID:integer; bDraw,bList,bLine:boolean);  //凸棱台
    procedure Polyhedron( ID:integer; bDraw,bList,bLine:boolean);//凸壳
    procedure SolidMask( ID:integer; pc:TcgVector);//实体的遮罩
    procedure Solid( ID:integer; bDraw,bList,bMask,bLine:boolean);//实体
    procedure RollFace( ID :integer; bList,bOnlyDraw:boolean);    //旋转曲面
    procedure RureFace( ID: integer; bList,bOnlyDraw:boolean);    //直纹曲面
    procedure NormalFace( ID :integer; bList,bOnlyDraw:boolean);  //轨迹面
//    procedure BinaryFace( ID: integer; bList,bOnlyDraw:boolean);  //复合曲面
    function checkFunc( ID:integer):boolean; //表达式检查
    procedure getExpressData(ID:integer; expr :string; k, xStep,yStep :integer);
    procedure funcFace( ID: integer; bDraw,bList,bOnlyDraw:boolean); // 方程式
    procedure CurveFromFace(ID:integer); //用曲面边缘构造曲线
    procedure ImplicitFace( ID: integer; bDraw,bList,bOnlyDraw:boolean); //隐函数曲面
    function DrawCurve( ID,listID,a, M,Ss,sTime:integer; ver:Cardinal; bList,bSport:boolean):integer;//画曲线
    function funcCurve( ID: integer; bDraw,bList,bOnlyDraw:boolean):integer;     //函数曲线
    function ImplicitCurve( ID: integer; bDraw,bList,bOnlyDraw:boolean):integer; //隐函数曲线
    procedure Iterate( ID: integer; bDraw,bList:boolean);  //迭代
//    procedure Block( ID:integer; BlockFile:string);                // 自由块
    procedure MoveObj( ID, x,y,dx,dy :integer );// 移动对象
    function MovePoint( ID:integer; isOnly,isLocus:boolean):boolean; //移动约束点 ID动点
    procedure Print( p:TcgVector; ID :integer);// 字符打印
    procedure Save( workCode, ID,Num:integer; bSave,bAlone:boolean);    //备份
    procedure UnDo( isUndo:boolean);                //恢复
    function updateTexture(NewPos:boolean):string; //更新文本 纹理 按钮
    function OpenFile( FileName :string; isFile,addPage :boolean):integer;//打开文件,返回构件数
    procedure SaveFile( FileName :string);  //保存文件
    procedure OpenPicture( ID:integer; isPicture, bDraw:boolean);
    procedure ReRelate( first,last :integer; bBlock,bOnlyDraw,bTextDraw :boolean);      //重建关联构件
    procedure ShowProp( ID :integer; isMove:boolean);        //显示构件属性值
    procedure ShowObjProp(ID,x,y :integer; bL,bR :boolean); //属性控件显示状态 返回属性框高度
    procedure setPopMenu( bOpen :boolean; name :string);//更新文件菜单
    procedure AddItem( ID,t:integer;  bFist,bEnable,bBreak:boolean);
//    procedure cmbTagUpdate( IDx:integer; isNew:boolean); //更新构件列表
    procedure ObjListUpdate( IDx:integer; isNew:boolean); //更新构件列表
    procedure scrListSet; //设置对象列表滚动条
    procedure setSportMenu( bSport,bPause :boolean); //设置运动菜单项
    procedure setTimer( t :integer; Draw:boolean);
    procedure HideAllPanel;
    function getDotAngleByAxis( p:TcgVector; b:integer; var rR:single):TcgVector; //计算[点]相对于轴线的转角
    function getMidLineVec(pa,np, na,nb:TcgVector; Ratio:single; Angle:single):TcgVector;//中线的向量
    procedure ClearSelRec(ID:integer); //清除选择队列
    procedure UpdateFPS( time:integer);
    procedure pnlCalcShow( ID:integer);
    function insExpr( Des,Sur:string; insPos:integer; var Pos:integer):string; //st 插入的字符 bbb 新的光标位置
    function checkExpr( ID:integer;var par:Tpara):string;
    function ReplaceCode( ID:integer; expr:string):string;
    function calcFunc( ID:integer; var res:double; check,show:boolean):boolean; //需要检测表达式
    function calcSize( ID:integer):double; //度量
    procedure appendExpr( ID:integer);//添加表达式控件
    procedure createCtrl( ID:integer; New:boolean);   //创建控制按纽
    procedure createParaBar( ID:integer; New:boolean);//创建参数轴
    procedure createTimer( ID:integer; New:boolean);  //创建时钟
    procedure DrawParaBar( ID, p:integer; isDrag,isLocus:boolean);
    function checkSaved :boolean; //是否保存已编辑的模型
    procedure DieDaiResize;
    function ObjIsParent( ID,Son :integer):boolean;//ID是否Son的父构件
    procedure setObjLink( ID,i :integer; st:string);
    procedure MoveObjID(old,new :integer);
    procedure ChangeObjID(var ID,New :integer); //移动对象顺序
    procedure upDateLink( ID:integer; isFile:boolean); //刷新链接
    procedure setBackColor( color :TColor; t,k:integer);
    procedure posEditValueChange( Sender:TObject; Key:Word);
    procedure ShowTabEdit;
    procedure SaveThisPage( Page,Num:integer; isSave,isDelList:boolean);
    procedure ReadThisPage( Page:integer);
    procedure setBarTrack( ID:integer);//参数滑竿
    procedure SelObjFromMultMenu( Sender:TObject);//右键重叠构件时，从右键菜单里选择构件
    function BreackAdd:boolean; //终止添加
    procedure PaintDel; //删除手绘线
    procedure ShowControlBox( ID,butTag:integer; tabSheet :TTabSheet);
    procedure ChangePage(OldPage,NowPage:integer);
    function BoolToStr(ID,n:integer; isTag:boolean):string; //二进制字符串转换为整数
    procedure StrToBool(ID,n:integer; st:string; isTag:boolean); //字符串转换为逻辑串
    procedure SelMultyObj(var MarkObj, hit, Hits, x,y:integer); //选择重叠对象
    procedure imgListDrawItem(ID,Index:integer; text:string;  isAppend,isUpdate:boolean);
    procedure imgListUpdate( ID,index: Integer; isFromOther,isLeft,isRight:boolean); //刷新对象列表
    procedure setListPosision;
    procedure SelLinkObj(hit:integer);  //选择关联构件
  protected //
  end;
type
  TCube =Array [0..7] of ^TcgVector; // Points to 8 grid points (cube)
type
  TMenuItemAccess = class(TMenuItem);
var
  frmMain: TfrmMain;
  DCh:HDC;
  HRC: HGLRC;
  WindowHandle:Thandle;
//  Quadric :PGLUquadric;  // cylinder
  Palette :HPALETTE;
  fontBase:Cardinal;
  bPW:boolean;    //注册与否
  bAnimat :boolean; //bCopy:连续复制
  res :double;  CopyID,hotID, iLanguage :integer;  //res 计算结果 CopyID复制变换
  sgfName,sgfFile,sgfPath, initFile,exePath,tmpPath : String; //程序名和路径、模型文件名和路径
  Obj     :TObjType;    //作图用主数据
  Objs    :array[0..PageTime]of TObjType;   //页面数据
  CopyObj :array of TMyObject; //构件复制数组
  BackObj :TBackObj;    // Undo数据 UndoTime: Undo次数
  BackObjs:array[0..PageTime]of TBackObj;   //页面Undo数据
  ObjNameStack: array[0..maxObj]of boolean; //对象名是否被占用

  LocaVct   :TLocaType; //轨迹点的坐标
  LocaColor :TLocaColor;
  FaceVct   :TFaceType; //曲面顶点坐标
  FaceColor :TFaceColor;
  aLink   :TLinkType;   //相贯线相邻线段的链接状态
  winPos  :Array[0..LayerTime]of TcgVector;   //构件顶点的屏幕坐标

  PaintList:Array[0..PaintPointCount] of TPaintData;//手绘点位置
  PaintData:Array[0..PaintListCount] of TPaintData;//手绘原始位置 偏移量
  PaintListNum, PaintHot, PaintNum, PaintMax :integer; //手绘比划数 当前比划 当前手绘点数
  PaintStyle, PaintWidth, PaintColorIndex :integer; //手绘线型 线宽
  PaintColor :TcgColorF;             //手绘颜色

  stMode:TstMode; stAxis:TstAxis;
  mNum :TmNum; //鼠标图案 TmNum在CgGeometry单元中定义
  SelRec  :Array[0..maxObj] of integer; //已选择的构件 0总数 1点数 2直线数 3圆数... 21开始被选择的构件ID
  JoinLink:Array[0..maxObj, 0..1]of integer;//两点合并时，统计子对象数目
  ObjListID:Array[0..maxObj]of TObjList; //构件列表项的对象ID
  FlashSize: integer; //用于面对指定场景、合并
  rX,rY,rZ, rX0,rY0,rZ0, rX1,rY1,rZ1, rX2,rY2,rZ2, r0,rView :single; //水平视角、垂直视角、圆周上的约束点被拖动时的初始角度
  OldPage,NewPage,Layer :integer;
  ClipBoard :TClipBoard;
  isWin7or8, bAxisTagSeled :boolean; //Win7以上操做系统 是否选择了坐标轴标签
  hotKey :word;
  defaultProp:Array[0..7]of single; //默认属性 1点型 2线长 4线型 5角度6比例
  defaultVec :TcgVector;//默认平移向量
  isUseToControler :boolean = false; //是否用于控件
  isReadOnly:boolean = false; //是否只读（不允许保存，用于控件）
  is2D:boolean = false; //2D状态（锁定z视点）
  type TAppObjProc = Procedure(Sender: TObject) of object ;
    var AppObjProc : TAppObjProc; //添加对象时的过程变量
  tagFont:TFont; //用于设置字体
  EPS:Double=0.00001;

implementation

{$R *.DFM}

procedure TfrmMain.MenuItemAdvancedDrawItem(Sender: TObject; ACanvas: TCanvas; ARect: TRect; State: TOwnerDrawState);
  var vWin32Platform: Integer;
begin //设置菜单项的热键下划线
  vWin32Platform := PInteger(@Win32Platform)^;
  PInteger(@Win32Platform)^ := -1;
  TMenuItemAccess(Sender).OnAdvancedDrawItem := nil;
  try
    TMenuItemAccess(Sender).AdvancedDrawItem(ACanvas, ARect, State,
      TMenuItemAccess(Sender).GetParentComponent is TMainMenu);
  finally
    TMenuItemAccess(Sender).OnAdvancedDrawItem := MenuItemAdvancedDrawItem;
    PInteger(@Win32Platform)^ := vWin32Platform;
  end;
end;

//================== 基本常用函数 ===================
function EP( a:single):boolean;
  begin result:=abs(a)<EPS; end;
function SGN(a,b:single):boolean; //俩数正负为真
  begin result:=(a>=0)and(b<0) or (a<0)and(b>=0); end;
procedure SwapI(var a,b:integer);
  var c:integer; begin c:=a; a:=b; b:=c; end;
procedure SwapF(var a,b:single);
  var c:single; begin c:=a; a:=b; b:=c; end;
procedure SwapV(var a,b:TcgVector);
  var c:TcgVector; begin c:=a; a:=b; b:=c; end;
function IIFi( a:boolean; b,c :integer):integer;    //返回integer
  begin if a then result:=b else result:=c; end;
function IIFf( a:boolean; b,c :single):single;  //返回float
  begin if a then result:=b else result:=c; end;
function IIFs( a:boolean; b,c :string) :string;   //返回string
  begin if a then result:=b else result:=c; end;
function IIFc( a:boolean; b,c :cardinal):cardinal;//返回cadinal
  begin if a then result:=b else result:=c; end;
function IIFb( a,b,c :boolean) :boolean;                //返回boolean
  begin if a then result:=b else result:=c; end;
function IIFv( a:boolean; b,c:TcgVector):TcgVector;
  begin if a then result:=b else result:=c; end;
function ItoS( v :integer):string;
  begin result:=IntToStr(v); end;
function FtoS( v :single; len :integer) :string;   //将浮点数转换为格式文本
  begin if abs(v)<0.0000001 then v:=0; str( v:0:len, result);
  if Length(result)>9 then result:=copy(result,1,12);  end;
function FtS( v:single):string;
  begin if abs(v)<0.0000001 then v:=0; str( v:5:2, result); end;
function GetPos( x,y,z :single) :gl3f;
  begin result[0]:=x;  result[1]:=y;  result[2]:=z; end;
function SwitchI( i, a,b,c :integer):integer;
  begin result:=0; case i of 1:result:=a; 2:result:=b; 3:result:=c; end;  end;
function SwitchF( i:integer; a,b,c :single):single;
  begin result:=0; case i of 1:result:=a; 2:result:=b; 3:result:=c; end;  end;
function SwitchS( i:integer; a,b,c,d :string):string;
  begin case i of 0:result:=a; 1:result:=b; 2:result:=c; 3:result:=d;end;  end;
procedure Limit( var a:single; less,lesser, bigg,bigger:single);
  begin if a<less then a:=lesser; if a>bigg then a:=bigger; end;
procedure setEnable( b:boolean; c:cardinal); //设置OpenGL状态值
  begin if b then glEnable( c) else glDisable( c); end;
function LeftStr(const AText: AnsiString; const ACount: Integer): AnsiString; overload;
  begin Result := Copy(WideString(AText), 1, ACount); end;
function RightStr(const AText: AnsiString; const ACount: Integer): AnsiString; overload;
  begin Result := Copy(WideString(AText), Length(WideString(AText)) + 1 - ACount, ACount);
  end;
procedure CleanLink(ID,a:integer);
  var i:integer;
begin
  for i:= a to LinkTime do begin Obj[ID].Link[i]:=0; Obj[ID].LinkName[i]:=0; end;
end;
function fTrim( v:single):string; //去掉小数尾部的0
  var i,Len :integer;
begin
  if EP(trunc(v)-v) then //视为整数
    result:= IntToStr(trunc(v))
  else begin
    str( v:12:4, result);  if Length(result)>12 then result:=copy(result,1,12);
    i:=Length(result);     while result[i]='0' do Dec(i);
    result:= copy(result,1,i);
    end;
  result:=trim(result);
end;
//获得对象的标签
function IDtoS(ID:integer):string; 
begin
  result:=Obj[ID].Tag;
  if(result='')then result:='{#}'+IntToStr(Obj[ID].ShowID); //{#} 就是字符#
end;

{function sts( st:string):string;//返回两个字符
  begin if(Length(st)=1)then result:=st+' ' else result:=copy(st,1,2);
  end; }
function getVarNum(st:string):integer; //统计字串内被空格分隔的子串数目
  var i,n,Len :integer;  Blank:boolean;
  begin
    Blank:=false;  Len:=Length(st);  result:=0;
    for i:=1 to Len do begin
      if(st[i]=' ')then Blank:=true;
      if Blank and(st[i]<>' ')then begin
        inc(result); Blank:=false;
        end;
      end;
  end;
function sts( st:string):string;//返回两个字符
  begin if(Length(st)=1)then result:=' '+st else result:=' '+copy(st,1,2);
  end;
function getStr(st:string; k:integer):string;//从字串中提取字串
  var i,j,d,n,Len :integer; //bTrans 是否转换成浮点数
  begin
    i:=6; n:=0; Len:=Length(st);  result:='';  
    repeat
      inc(i); d:=0;  //d:小数点位置
      if(st[i]>' ')then begin
        j:=i; inc(n);
        repeat inc(i);  if(st[i]='.')then d:=i;
         until(st[i]=' ') or (d>0)and(i-d>=5) or (i>Len);
        if(n=k)then result:=copy(st,j,i-j);
        end;
     until(n=k)or(i>=Len);
  end;
function getFlo(st:string; k:integer):single;//从字串中提取浮点数
  var s:string;
  begin
    s:=getStr(st, k);  if(s='')then result:=0 else result:=StrToFloat( s);
    end;
function getInt(st:string; k:integer):integer; //从字串中提取整数
  var s:string;
  begin
    s:=getStr(st, k);  if(s='')then result:=0 else result:=StrToInt( s);
  end;

function ArcTan2(const Y, X: Extended): Extended;
  asm
        FLD     Y
        FLD     X
        FPATAN
        FWAIT
  end;
function ArcCos(const X: Extended): Extended;
  begin Result := ArcTan2(Sqrt(1 - X * X), X); end;
function ArcSin(const X: Extended): Extended;
  begin Result := ArcTan2(X, Sqrt(1 - X * X))  end;
function IntPower(const Base: Extended; const Exponent: Integer): Extended;
asm
        mov     ecx, eax
        cdq
        fld1                      { Result := 1 }
        xor     eax, edx
        sub     eax, edx          { eax := Abs(Exponent) }
        jz      @@3
        fld     Base
        jmp     @@2
@@1:    fmul    ST, ST            { X := Base * Base }
@@2:    shr     eax,1
        jnc     @@1
        fmul    ST(1),ST          { Result := Result * X }
        jnz     @@1
        fstp    st                { pop X from FPU stack }
        cmp     ecx, 0
        jge     @@3
        fld1
        fdivrp                    { Result := 1 / Result }
@@3:
        fwait
end;
function Power(const Base, Exponent: Extended): Extended;
begin
  if Exponent = 0.0 then
    Result := 1.0               { n**0 = 1 }
  else if (Base = 0.0) and (Exponent > 0.0) then
    Result := 0.0               { 0**n = 0, n > 0 }
  else if (Frac(Exponent) = 0.0) and (Abs(Exponent) <= MaxInt) then
    Result := IntPower(Base, Integer(Trunc(Exponent)))
  else
    Result := Exp(Exponent * Ln(Base))
end;

function TfrmMain.BoolToStr(ID,n:integer; isTag:boolean):string; //逻辑串转换字符串
  var i,j,m, Len,code :integer;
begin
  result:='';
  Len:=n div 6;// 每6位逻辑串转换为一个字符
  for j:=0 to Len do begin
    code:=0;
    for i:=1 to 6 do begin
      m:=j*6+i; if(m>n)then continue;
      if(isTag and Obj[ID+m].TagShow[Layer]) or(not isTag and Obj[ID+m].ObjShow[Layer])
          then code:=code+(1 shl(6-i));
      end;
    result:=result+ chr(code+48);
    end;
end;

procedure TfrmMain.StrToBool(ID,n:integer; st:string; isTag:boolean); //字符串转换为逻辑串
  var i,j,k,m,Len,code :integer;  ch:char;  boo:boolean;
begin
  Len:=Length(st);
  for j:=1 to Len do begin
    ch:=st[j];
    code:=ord(ch)-48;
    for i:=1 to 6 do begin
      k:=code;
      code:=code shr 1; //右移1位
      boo:= k<>(code shl 1);
      m:=j*6-i+1; if(m>n)then continue;
      if isTag then for k:=0 to LayerTime do Obj[ID+m].TagShow[k]:=boo
               else for k:=0 to LayerTime do Obj[ID+m].ObjShow[k]:=boo;
      end;
    end;
end;

function EdgeToRadius(W:single; S:integer):single;//由正多边形棱长换算外接球半径
begin
    case S of
      1,11:result:=sqrt(6)/4; //正四面体
      2,12:result:=sqrt(3)/2; //正六面体
      3,13:result:=sqrt(2)/2; //正八面体
      4,14:result:=sqrt(6)*Sqrt(3+sqrt(5))/4; //正十面体
      5,15:result:=sqrt(10+2*sqrt(5))/4;       //正十二面体
      end;
    result:=result*W;
end;

procedure setPanelBeval(pnl :TPanel; press :boolean);
begin
  with pnl do begin
  if press then begin BevelInner:=bvLowered; BevelOuter:=bvLowered; end
           else begin BevelInner:=bvRaised;  BevelOuter:=bvRaised; end;
  if press then color:=clMedGray else color:=clBtnFace;
  end; //with pnl
end;

procedure MyMessage(st:string);
  var pt:array[0..79] of Char;
begin
  StrPCopy(pt,st);
  Application.MessageBox(pt, 'inRm3D', MB_OK+MB_ICONINFORMATION);
end;
//================= 刷新标题栏 ==================
procedure updateTitle;
begin  //exit;
  frmMain.caption:=Version + '[ '+IIFs( SgfName>'', SgfName,'New File')+ ' ]' ;
end;

function getCrossNum(ka,kb:integer):integer;
begin result:=0; //预设的交点数目
       if(Ka=2)and(Kb=2)then result:=0//直线/直线, 只1个
  else if(Ka=2)and(Kb in[3,4,6])or(Ka=3)and(Kb=4)then result:=1 //直线与圆/平面/实体, 最多2个
  else if(Ka=2)and(Kb=19)then result:=3 //直线与圆锥曲线 最多4个
  else if(Ka in[3,19])and(Kb in[3,19])then result:=3 //圆锥曲线之间 最多4个
  else if(Ka=3)and(Kb=6)then result:=19  //圆/平面/实体，最多20个
  else if(Ka in[5,15,16,17])or(Kb in[5,7,9,15,16,17])then result:=31;//曲线/曲面, 最多32个
end;
{  if(Ka=2)and(Kb in[2,4])then result:=0;//直线与直线平面的交点只1个
  if(Ka in[3,19])or(Kb in[3,19])then result:=3; //与圆锥曲线有关的交点最多4个
  if(Ka=2)and(Kb in[3,6])or(Ka=3)and(Kb=4)then result:=1; //圆与直线或平面的交点最多2个
  if(Ka=3)and(Kb=6)then result:=19;//圆与实体有关的交点最多20个
  if(Ka in[5,15,16,17])or(Kb in[5,7,9,15,16,17])then result:=31;//与曲线或曲面有关的交点最多32个
}
procedure getEdges(ID:integer; var kEdge,kVct:integer); //添加实体时附加的棱边
  var SS:integer;
begin
  kEdge:=0; kVct:=0;
  with Obj[ID] do begin
  if(Kind=4)and(Mode=6)then begin   //多边形
    kEdge:=IIFi( W<3,-1,trunc(W));
    if Rand then kVct:=trunc(W);    //正多边形
    if(kEdge=99)then kEdge:=4;  //长方形
    if(kVct=99)then kVct:=4;    //长方形
    end;
  if(Kind=6)then begin
    SS:=S mod 100;
    if(Mode=3)and(SS=12)then SS:=2; if(Mode=3)and(SS=11)then SS:=1;//以底边定义的正四/六面体
    case Mode of
      3:kEdge:=SolidEdge[SS]; //多面体
      4:begin //棱台
        if(Link[0]>1)and(Obj[Obj[Link[0]].parent].Kind=4)and(Obj[Obj[Link[0]].parent].Mode<6)
          then kEdge:=12 //底面为平面
          else kEdge:=IIFi( SS=0, trunc(Obj[Link[0]].W)*3, SS*3); //S=0凸棱台 else 正棱台
        end;
      5:kEdge:=(trunc(W)-2)*3; // 凸壳
      end;
    case Mode of
      3:kVct:=SolidVct[SS];
      4:begin
        if(Link[0]>1)and(Obj[Obj[Link[0]].parent].Kind=4)and(Obj[Obj[Link[0]].parent].Mode<6)
          then kVct:=4
          else kVct:=IIFi( SS=0, trunc(Obj[Link[0]].W), SS*2); //S=0凸棱台 else 正棱台
        end; //
      5:kVct:=0;
      end;
    end;
  end;
end;

function setMultiColor(ID, y,yInc, a :single):TcgColorF; //设置眩彩
  var yd,ye :single;  cc:TcgColorF;
begin
  y:=abs(y);  yd:= y*6/yInc;  ye:=yInc/6;
  if(y<=ye)then cc:=cgColorF(1, yd, 0, a);                //0-1
  if(y>ye)  and(y<=ye*2)then cc:=cgColorF( 2-yd, 1, 0, a);//1-2
  if(y>ye*2)and(y<=ye*3)then cc:=cgColorF( 0, 1, yd-2, a);//2-3
  if(y>ye*3)and(y<=ye*4)then cc:=cgColorF( 0, 4-yd, 1, a);//3-4
  if(y>ye*4)and(y<=ye*5)then cc:=cgColorF( yd-4, 0, 1, a);//4-5
  if(y>ye*5)then cc:=cgColorF( 1, 0, 6-yd, a);//5-6
  glColor4fv( @cc);
  result:=cc;
end;
function getColor(ID:integer):TcgColorF;
  var aa,bb,cc, t,t1,k :single;  isEven :boolean;
begin
  with Obj[ID]do begin
    if(Link[6]>10)then aa:=abs(Obj[Link[6]].L);   if(aa>1)then aa:=aa-trunc(aa);
    if(Link[7]>10)then bb:=abs(Obj[Link[7]].L);   if(bb>1)then bb:=bb-trunc(bb);
    if(Link[8]<11)then Link[8]:=Link[7];
    if(Link[8]>10)then cc:=abs(Obj[Link[8]].L);   if(cc>1)then cc:=cc-trunc(cc);
    if(ColorMode<3)then begin //炫彩
      if(Link[7]>10)then result:=cgColorF(aa,bb,cc, Color.A)
      else result:=setMultiColor(ID, trunc( (aa-trunc(aa))*255),255,Color.A);
      end
    else begin //灰度
      t1:=abs(aa-ColorV0)/(ColorV1-ColorV0);
      k:=trunc(t1); t:=k/2;
      isEven:=(t=trunc(t));  if(aa<ColorV0)then isEven:=not isEven;
      t:=t1-k;
      case ColorMode of
        3:begin if(aa<ColorV0)then t:=0; if(aa>ColorV1)then t:=1; end; //不循环
        4:if(aa<ColorV0)then t:=1-t;
        5:begin if isEven then t:=1-t; if(aa<ColorV0)then t:=1-t;  end;
        end;
      result:=cgColorF( t,t,t, Color.A);
      end;
    glColor4fv( @result);
  end;//with
end;
procedure setObj(ID,K,M:integer; Dot,V:TcgVector);
begin
  with Obj[ID]do begin Kind:=K; Mode:=M; p0:=Dot; Vec:=V; end;
end;
//=====================  点p的垂足  =============================
function Footer(  p :TcgVector; b:integer; bDistance:bool):TcgVector;
  var t :single;  //bCalc: 是否计算垂线长度
begin
  with Obj[b] do
  case Kind of
    1:result:=p0; // 投影到点
    2:result:=cgDotLineFooter(p, p0,Vec, false);
    3,4,19:begin // 投影到圆或平面
      t:=-cgDotProduct(Vec, p)- Vec.w;
      result:=cgVecAddMult(p, Vec, t); end;
    end; //case Obj[b].Kind
  if bDistance then result.w:= cgDistance( p, result); //垂线长度
end;

procedure getListID(var ListID:Cardinal; n:integer);
begin
  if ListID=0 then ListID:=glGenLists(n);
end;

//================ 跟踪 =====================
function getTraceListID(ID:integer; bAdd:boolean):integer;
begin
  with Obj[ID] do begin
    getListID(mainList,1);
    if not bAdd and Trace then begin //
      getListID(tracList,200);
      inc(nTrace); if nTrace>maxTrace then nTrace:=1;
      result:=tracList+nTrace;
      end
    else
      result:=mainList;
  end;
end;
procedure setTraceList(ID:integer); //跟踪
  var i :integer;
begin //listID:=ID*200+30000;
  with Obj[ID] do begin
  glNewList( mainList, GL_COMPILE);  //建立显示列表
    glCallList(tracList+nTrace);
  glEndList;
  glNewList( tracList, GL_COMPILE);  //建立显示列表
    for i:= nTrace to maxTrace do glCallList(tracList+i);
    for i:= 1 to nTrace-1 do glCallList(tracList+i);
  glEndList;
  end;
end;

procedure TfrmMain.ClearSelRec(ID:integer); //清除选择队列
  var i:integer;
begin
  for i:=0 to 63 do SelRec[i]:=0;
  for i:=0 to ObjCount do
    begin Obj[i].Hot:=false;  Obj[i].Seled:=false; end;
  menObjDel.Enabled:=false;
  bDotJoin:=false;   bAdd:=false; bSel:=false; bMerge:=false; bSplit:=false;
  selNum:=0;   nK:=0; nM:=0;  lastHit:=0;  lastSel:=0;
  CountObjNum(false, true);
end;
{=========================== 打印标签 ==========================}
procedure TfrmMain.Print( p:TcgVector; ID :integer);
  var pa,pb,pc,pd, pp,pt :TcgVector;
      cL, dx,dy :single;
begin
  if(ID in[2..4])and not cheAxis.Checked then exit;
  if(ID=4)and not cheAxisZ.Checked then exit;
  with Obj[ID]do begin
  if(Kind in[10,11])then exit;
  if not bAll and(Mode=13)and not(Kind=9)//棱边或顶点
    and((Kind=2)and not Obj[Link[0]].D  //父对象的“棱边”属性
     or (Kind=1)and not Obj[Link[0]].U  //父对象的“顶点”属性
     or not Obj[Link[0]].ObjShow[Layer] ) //父对象的显示状态
    then exit;
  glDisable( GL_LIGHTING);
  if(ID in[2..4])then begin
    TagP.x:=0; cL:=L-R;// if F then cL:=cL/2;
    p:=cgVector(0,0,0); case ID of 2:p.x:=cL; 3:p.y:=cL; 4:p.z:=cL; end;
    if(ID=2)then begin //'x',x轴
      if(rx>90)and(rx<270)then TagP.x:=-TagSize.x;
      TagP.y:=-TagSize.y div 4;
      end;
    if(ID=3)then begin //'y',y轴
      if(rx<180)then TagP.x:=-TagSize.x;
      TagP.y:=-TagSize.y div 4;
      end;
    if(ID=4)then begin //'z',z轴
      if(rx<90)or(rx>270)then TagP.x:=-TagSize.x;
      TagP.y:=-TagSize.y div 5; if(ry<180)then TagP.y:=-trunc(TagSize.y*4/5);
      end;
    end;
  pp:=getDotPos(p,true);   pt:=pp;
  pp.x:=pp.x+TagP.x;  TagPos.X:=trunc(pp.x);
  pp.y:=pp.y+TagP.y;  TagPos.Y:=trunc(pp.y);

  pa:=getObjPos(0,pp, pp.x, pp.y, pp.z);
  pb:=getObjPos(0,pp, pp.x, pp.y+TagSize.y, pp.z);
  pc:=getObjPos(0,pp, pp.x+TagSize.x, pp.y+TagSize.y, pp.z);
  pd:=getObjPos(0,pp, pp.x+TagSize.x, pp.y, pp.z);

  if(texTag>0)then begin  //绑定纹理
    glEnable(GL_ALPHA_TEST);    glAlphaFunc(GL_GREATER, 0);
    glEnable(GL_TEXTURE_2D);    glBindTexture(GL_TEXTURE_2D, texTag);
    end;
  glColor4f(1,1,1,1);
  glBegin( GL_POLYGON);//
    glTexCoord2d(    0,    0);   glVertex3fv( @pa);
    glTexCoord2d(    0,kHtag);   glVertex3fv( @pb);
    glTexCoord2d(kWtag,kHtag);   glVertex3fv( @pc);
    glTexCoord2d(kWtag,    0);   glVertex3fv( @pd);
  glEnd;
  glDisable(GL_TEXTURE_2D);
  if bR and Hot and not(ID in[2..4])then begin //拖动时的边框
    glLineWidth(1);     glColor4fv(@Obj[1].ColorB);
    glBegin( GL_LINE_LOOP);
      glVertex3fv(@pa); glVertex3fv(@pb);
      glVertex3fv(@pc); glVertex3fv(@pd);
    glEnd;
    dx:=TagPos.x+TagSize.x/2-pt.x;  dy:=TagPos.y+TagSize.y/2-pt.y;
    if(dx>0)and(dy>0)then pp:=pa;   if(dx>0)and(dy<0)then pp:=pb;
    if(dx<0)and(dy<0)then pp:=pc;   if(dx<0)and(dy>0)then pp:=pd;

    glBegin( GL_LINE_STRIP);
      glVertex3fv(@p);  glVertex3fv(@pp);
    glEnd;
    end;
  end;//with Obj[ID]
end;
//================= 设置文本 ====================
procedure TfrmMain.GetTextList( ID :integer);
begin
  if not(Obj[ID].Kind in[10,11,14])then
      Obj[ID].texTag:= TagToBMP(ID,true);
end;

procedure setBMPformat(ID:integer; BMP:TBitmap; subRatio:single; isAnti:boolean);//isSub上下标字号减半
  var lf :LogFont;
begin
  with BMP do begin
//    PixelFormat := pf24bit;         Color:=512; //
    with Canvas.Font do begin
      Name:=Obj[ID].TagN;
      Size:=trunc(Obj[ID].TagS*subRatio);
      Color:=Obj[ID].TagC;  if(Color=frmMain.Color)then Color:=Color xor $FFFF;
      if Obj[ID].TagT[1]='1'then Style:=Style+[fsBold];
      if Obj[ID].TagT[2]='1'then Style:=Style+[fsItalic];
      if Obj[ID].TagT[3]='1'then Style:=Style+[fsUnderline];
      if Obj[ID].TagT[4]='1'then Style:=Style+[fsStrikeOut];
      end; //with Canvas.Font
    if isAnti then begin
      GetObject( Canvas.Font.Handle, SizeOf(LogFont), @lf);
      lf.lfQuality := ANTIALIASED_QUALITY; //NonANTIALIASED_QUALITY;//
      Canvas.Font.Handle := CreateFontIndirect(lf);
      end;
//    Canvas.Brush.Style:= bsClear;
    Canvas.Pen.Color  :=Obj[1].LinkName[0];
    Canvas.Brush.Color:=Obj[1].LinkName[0];// clRed; //
    Canvas.Rectangle(0,0, Width,Height);
    end;//with BMP
end;
//=========== 将标签字符串转换成BMP图像 ===================
function TfrmMain.TagToBMP(ID:integer; isTag:boolean):Cardinal;//isTag 仅处理标签
  var i,j,n, w0,h0,h1, LenTag:integer;  t,tEPS:single;  bb,isInfo :boolean;
      st, sTag,sExp,sSub, aStr:AnsiString;
      BMP,subBMP:Tbitmap;
begin //
  with Obj[ID]do begin
  w0:=0; h1:=0;  bb:=false;  isInfo:=false;
  LenTag:=0; sExp:='';
  sTag:=Tag;
  setLength(aStr,1);  aStr:=Tag;

  if(Kind=18)and(Mode=2)and Trace then begin //Trace“标注”属性
    t:=L; if Deg then t:=L*oneArc;  sTag:=FtoS(t,S);
    end
  else if(Kind=11)and(Mode=1)and Q then begin //Q 显示计算式 Mask显示标签
    if Mask then sTag:=Tag+' = '+info[0]
            else sTag:=info[0]+'=';
    isInfo:=true;
    end
  else begin //标签 是否有上标符 是为兼容
    LenTag:=Length(sTag);  i:=0; n:=0;
    if(LenTag>1)then repeat inc(i); if(sTag[i]='^')then n:=i;  until(i>=LenTag);
    if(n>0)then sTag:=sTag+']';
    end;

  if not isTag and not Mask and not Q then
    sTag:=''  //not isTag:计算式 Mask:缩写
  else if(trim(sTag)='')then begin
    if(ID>10) then sTag:='{#}'+itos(ID) else sTag:=' '; //{#} 就是字符#
    end
  else if(Kind=11)and(Mode=2)and not Mask then //缩写参数
    sTag:=''; 
  if not isTag and(Kind=11)then begin
    i:=trunc(R);  t:=L; if(Mode in[1,6])and Deg then t:=t*oneArc;//Mode=1计算式 6度量角度
    sExp:=FtoS(t,S);    sSub:=''; //S 精度
    if(Mode=15)and(i=0)then // 坐标
      sExp:='('+FtoS(Obj[Link[0]].p0.x,S)+', '+FtoS(Obj[Link[0]].p0.y,S)+', '+FtoS(Obj[Link[0]].p0.z,S)+')';
    if(Mode=15)and(i=4)then // 坐标
      sExp:='('+FtoS(Obj[Link[0]].p0.x,S)+', '+FtoS(Obj[Link[0]].p0.y,S)+')';
    if(Mode=16)and(i=0)or(Mode=17)and(i<>3)then // 向量
      sExp:='('+FtoS(Vec.x,S)+', '+FtoS(Vec.y,S)+', '+FtoS(Vec.z,S)+')';
    if(Mode=16)and(i=4)then
      sExp:='('+FtoS(Vec.x,S)+', '+FtoS(Vec.y,S)+')';
    if(Mode in[1,7])then begin //计算值不存在，或无穷大
      if F then begin sExp:=''; sSub:='∞'; end;
      if U then begin sExp:=''; sSub:=SwitchS( iLanguage,'未定义','未定義','Undifined','');end;
      end;
    if(Mode=19)and not hide then begin  // 方程式
      tEPS:=EPS;  EPS:=intPower(0.1,S);
      sExp:='';
      if(Obj[Link[0]].Kind=2)then begin // 直线方程
        sExp:='x='+ FtoS(p5.x,S);
        if not EP(Vec.x)then sExp:=sExp+ IIFs(Vec.x>0,'+','')+ FtoS(Vec.x,S)+'t';
        sExp:=sExp+', y='+ FtoS(p5.y,S);
        if not EP(Vec.y)then sExp:=sExp+ IIFs(Vec.y>0,'+','')+ FtoS(Vec.y,S)+'t';
        sExp:=sExp+', z='+ FtoS(p5.z,S);
        if not EP(Vec.z)then sExp:=sExp+ IIFs(Vec.z>0,'+','')+ FtoS(Vec.z,S)+'t';
        end;
      if(Obj[Link[0]].Kind=3)then begin // 圆方程
        sExp:=  'x='+ FtoS(p5.x,S);
        if not EP(p4.x)then sExp:=sExp+ IIFs(p4.x>0,'+','')+ FtoS(p4.x,S)+'cos(t)';
        if not EP(p4.y)then sExp:=sExp+ IIFs(p4.y>0,'+','')+ FtoS(p4.y,S)+'sin(t)';
        sExp:=sExp+', y='+ FtoS(p5.y,S);
        if not EP(p4.z)then sExp:=sExp+ IIFs(p4.z>0,'+','')+ FtoS(p4.z,S)+'cos(t)';
        if not EP(p4.w)then sExp:=sExp+ IIFs(p4.w>0,'+','')+ FtoS(p4.w,S)+'sin(t)';
        sExp:=sExp+', z='+ FtoS(p5.z,S);
        if not EP(p4.r)then sExp:=sExp+ IIFs(p4.r>0,'+','')+ FtoS(p4.r,S)+'sin(t)';
        end;
      if(Obj[Link[0]].Kind=4)then begin // 平面方程
        if not EP(Vec.x)then sExp:= FtoS(Vec.x,S)+'x';
        if not EP(Vec.y)then sExp:=sExp +IIFs(Vec.y>0,'+','')+FtoS(Vec.y,S)+'y';
        if not EP(Vec.z)then sExp:=sExp +IIFs(Vec.z>0,'+','')+FtoS(Vec.z,S)+'z';
        if not EP(Vec.w)then sExp:=sExp +IIFs(Vec.w>0,'+','')+FtoS(Vec.w,S);
        sExp:=sExp +'=0';
        end;
      EPS:=tEPS;
      end;
    if Mask then begin //标签
      if(Mode in[15,16])and(i in[0,4]) or(Mode=19) or (Mode=17)and(i<>3) //15坐标 16向量 17向量运算
        then sExp:=': '+sExp
        else sExp:=' = '+sExp;
      end;
    end;
  st:=sTag+sExp+sSub;
  BMP:=TBitmap.Create;
  setBMPformat(ID, BMP, 1, false);
  LenTag:=Length(st);
  with BMP do begin
    Canvas.Font.Size:=trunc( Obj[ID].TagS*0.7); // 上下标字号
    h1:=Canvas.TextHeight( st);                 // 上下标字高
    Canvas.Font.Size:=trunc( Obj[ID].TagS);
    Width:= Canvas.TextWidth( st+sSub+'。');    if( Width>2048)then  Width:=2048; //总宽度
    Height:= trunc( Canvas.TextHeight(st)*1.1); if(Height>1024)then Height:=1024; //总高度
    w0:=0; h0:=Height-h1; //h0下标位置
    j:=1;  h1:=0;
    if(LenTag>0)then
    repeat
      if(st[j]in['[','_','{','^'])then begin //
        if(st[j]='{')or(st[j]='^')and(not isInfo)then Canvas.Font.Size:=trunc( Obj[ID].TagS*0.6); //上标
        if(st[j]in['[','_'])then Canvas.Font.Size:=trunc( Obj[ID].TagS*0.7); //下彪
        if(st[j]in['[','_'])then h1:=h0; //遇下标则增加高度
        inc(j);
        end;
      if(st[j]in[']','}'])then begin
        inc(j);   Canvas.Font.Size:=Obj[ID].TagS;   h1:=0;
        end;
      i:=j; n:=0;
      repeat
        bb:=(st[i]in['_','[','{',']','}'])or(st[i]='^')and(not isInfo)or(i>LenTag); //
        inc(i);  if not bb then inc(n);
        until bb or(i>LenTag);
      aStr:= copy( st,j,n);
      Canvas.TextOut( w0, h1, aStr);
      if(j<=LenTag)then w0:=w0+ Canvas.TextWidth( aStr);
      j:=j+n;
      until(j>LenTag);
    if((Kind=11)and(Mode=1)or(Mode=6)or(Kind=18)and(Mode=2))and Deg then begin //角度度量 角度标注
      Canvas.TextOut( w0, -trunc(0.4*Height), '。'); //角度符号
      w0:=w0+ Canvas.TextWidth( '。')div 2;
      end;
    Width:= w0;
    end;//with BMP
  if(Kind=11)then
    result:= myLoadTexture(ID,texID, '', BMP, TagSize.x, TagSize.y, kWtag, kHtag, true)
  else
    result:= myLoadTexture(ID,texTag,'', BMP, TagSize.x, TagSize.y, kWtag, kHtag, true);
  BMP.Free;
  end; //with Obj[ID]
end;
//=========== 将文本字符串转换成图像纹理 ===================
function TfrmMain.TextToBMP(ID:integer; st:AnsiString; isNewText:boolean):Cardinal;
  var i,N, len, w0,h0, wi,he :integer;  isPlus,bEnd :boolean;
      aStr:array of AnsiString;   ss:AnsiString;
      BMP:Tbitmap;
  function getValue(ID:integer; ss:AnsiString; isPlus,isNewText:boolean):AnsiString;
    var i, LinkNum:integer;
    begin result:='';  LinkNum:=11;
      i:=10; repeat inc(i); until(ss=Obj[i].Tag)or(i>=ID);
      if(i<ID)then begin
        result:=ftos(Obj[i].L, Obj[i].S);
        if isPlus and(Obj[i].L>=0) then result:='+'+result;
        if isNewText then begin Obj[ID].Link[LinkNum]:=i; inc(LinkNum); end;
        end;
    end;
begin
  if st='' then st:=' '; Len:=length(st);
  setLength(aStr,1);
  aStr[0]:=st;  N:=0;
  if(Obj[ID].Kind=10)then begin //文本 寻找换行符
    if isNewText then
      for i:=13 to LinkTime do Obj[ID].Link[i]:=0;
    i:=0; aStr[0]:='';
    repeat
      inc(i); isPlus:=false;
      if(ord(st[i])=92)then begin //92="\"两个反斜杠之间为欲插入的数值标签
        inc(i);
        isPlus:=(ord(st[i])=43); if isPlus then inc(i); //43="+"号
        ss:=''; bEnd:=false;
        repeat
          if(ord(st[i])=92)then begin //92="\"
            if(ss>'')then aStr[N]:=aStr[N]+getValue(ID,ss,isPlus,isNewText);
            bEnd:=true;
            end
          else begin
            if(st[i]>'')then ss:=ss+st[i];
            end;
          inc(i);
          until bEnd or(i>Len)or(ord(st[i])=13); //
        end;
      if(i<Len)and(ord(st[i])=13) //换行符
        then begin inc(N); setLength(aStr,N+1); aStr[N]:=''; inc(i); end
        else if(i<=Len)then aStr[N]:=aStr[N]+st[i]
      until i>Len;
    end;
  BMP:=TBitmap.Create;
  setBMPformat(ID, BMP, 1, true);
  with BMP do begin
    w0:=0;
    for i:=0 to N do begin
      wi:=Canvas.TextWidth( aStr[i]); if wi>w0 then w0:=wi;
      end;
    h0:=Canvas.TextHeight(st[1]);
    he:=h0*(n+1)+Obj[ID].S*n;  
    if(w0>2048)then w0:=2048;    Width:=w0;
    if(he> 512)then he:= 512;   Height:=he;
    for i:=0 to N do Canvas.TextOut(0,i*h0+Obj[ID].S*i, aStr[i]);
    end;
  with Obj[ID] do
    result:= myLoadTexture(ID,texID, '', BMP, TagSize.x,TagSize.y, kW,kH, true );
  if Assigned(BMP)then BMP.Free;
  setLength(aStr,0);
end;
//==================== 文本 图片 按钮选择框 ===================
procedure TfrmMain.TextAndImage(ID:integer; bIterate,isPosition,isImage,isNewText:boolean); //
  var pc,pp,pt :TcgVector;
      t, x0,y0,x1,y1,x2,y2,x3,y3, kx,ky,tx,ty, fSin,fCos :single;
  label notImage;
begin
  with Obj[ID]do begin
  if(Kind=11)and(isImage)then begin
    if(Mode=1)then hide:=not calcFunc( ID, res, false,false); //计算式
    if(Mode>2)then res:=calcSize( ID);   //度量
    if(Mode=2)then begin //参数
      if(Link[2]>10)then L:=Obj[Link[2]].L;
      if(Link[3]>10)then begin p2.x:=Obj[Link[3]].L; if(L<p2.x)then L:=p2.x; end; //起值
      if(Link[4]>10)then begin p2.z:=Obj[Link[4]].L; if(L>p2.z)then L:=p2.z; end; //终植
      if Trace then DrawParaBar(ID, 0, false,false);//参数滑块
      res:=L;
      end
    else
      L:=res;  //度量值、计算值
    if(ID=MarkObj)and tab0.Visible then begin
      t:=res; if(Kind=11)and(Mode in[1,6])and Deg then t:=t*oneArc;
      if(Mode=2)and(Link[2]>0)then varL.Caption:=IDtoS(Link[2]) else varL.Caption:=FtoS(t,4);
      end;
    if(S<0)or(S>8)then S:=4;
    texID:=TagToBMP(ID, false);// TextToBMP(ID, info[2]);//
    end;
  if bIterate then exit;
  if(Kind=10)then begin
    if(Mode=1)then TextToBMP(ID, info[2], isNewText);
    if(p0.x<0)then p0.x:=0; if(p0.y<50)then p0.y:=50;
    end;
  if(Kind=11)then begin
    if(p0.x<20)then p0.x:=20;  if(p0.x>Width-40)then p0.x:=Width-40;
    if(p0.y<50)then p0.y:=50;  if(p0.y>ClientHeight)then p0.y:=ClientHeight;
    end;
  pc:=p0;
  if(Kind=14)then begin //按钮
    pc.x:=p0.x-1; TagSize.x:=trunc(W)+2; TagSize.y:=trunc(H)+2;
    end;
  glPushMatrix;// glPushAttrib( GL_ALL_ATTRIB_BITS );//
  glLoadIdentity;
  glDisable(GL_LIGHTING);
  glTranslatef( 0, 0, -0.1);
  pt:=getObjPos(0,pt, -Width/2+pc.x, 1.5*Height-pc.y, 0); //对象的场景坐标  +k
  pp:=getObjPos(0,pp, 0,0,0); //三维原点的场景坐标
    TagScr.x:=pt.x-pp.x;  TagScr.y:=pt.y+pp.y; //左下角场景坐标 在MainDraw中绘出
  if not isImage then goto notImage;
  if(Kind=10)and(Mode=2)then t:=L else t:=1; //t=L 图片比例
  pt:=getObjPos(0,pc, TagSize.x*t, Height-TagSize.y*t, 0);
    x0:=pt.x-pp.x;    y0:=-pt.y-pp.y;  //右上角场景坐标
  pt:=getObjPos(0,pc, TagSize.x*t, TagSize.y*t, 0);
    kx:=pt.x-pp.x;    ky:=pt.y-pp.y;   //选择框右上角
  getListID(mainList,1);
  getListID(seleList,1);
  glNewList(seleList, GL_COMPILE); //选择框
    glLineWidth(2);   glColor4fv(@Obj[1].ColorB);
    glPolygonMode( GL_FRONT_AND_BACK, GL_LINE);
    glRectf(0, 0, kx, ky);
    glPolygonMode( GL_FRONT_AND_BACK, GL_FILL);
  glEndList;
  if(Kind=10)and(Mode<3)or(Kind=11)then begin //文本 图片
    glNewList(mainList, GL_COMPILE);
    if(texID>0)then begin  //绑定纹理
      glEnable(GL_ALPHA_TEST);    glAlphaFunc(GL_GREATER, 0);
      glEnable(GL_TEXTURE_2D);    glBindTexture(GL_TEXTURE_2D, texID);
      end;
    glColor4f(1,1,1,1);
    if(Kind=10)then begin
      if(Link[12]=0)then glColor4f(1,1,1,Color.A) else glColor4f(1,1,1,Obj[Link[12]].L);
      end;
    if(Kind=11)then begin tx:=kWtag;  ty:=kHtag;  end
               else begin tx:=kW;     ty:=kH;     end;
    glBegin( GL_POLYGON);//
      glTexCoord2d( 0, 0);   glVertex2f( 0, 0);
      glTexCoord2d( 0,ty);   glVertex2f( 0,y0);
      glTexCoord2d(tx,ty);   glVertex2f(x0,y0);
      glTexCoord2d(tx, 0);   glVertex2f(x0, 0);
    glEnd;
    glDisable(GL_TEXTURE_2D);
    glEndList;
    end;
  end;//with Obj[ID]
notImage:
  glPopMatrix;// glPopAttrib;//
  glEnable(gl_depth_test); //打开深度缓存
end;
//==================== 重建关联 ===================
procedure TfrmMain.ReRelate( first,last :integer; bBlock,bOnlyDraw,bTextDraw:boolean);
  var i,j :integer;  bLink:boolean;
begin
  if first<11 then first:=11;
  Obj[first].edited:=true;
  for i:= first+1 to last do with Obj[i] do begin
    bLink:=false;  if(Kind=13)then bLink:=true; //13迭代
    j:=-1;
    if(Kind=4)and(Mode=6)and not Rand and(trunc(Obj[i].Angle)=first)then  //平面凸壳厚度
      bLink:=true
    else
    repeat inc(j); if(Link[j]>0)and Obj[Link[j]].edited then bLink:=true;
      until(bLink)or(j=LinkTime);//bLink关联构件是否变化
    if bLink then edited:=true;
    end;
  for i:= first to last do with Obj[i] do
    if edited and(DelID=0) then begin // and not Hide
    if(Kind in[1..7,9,15,16,17,19])then parent:=i;
    if(Mode in[7..12,14,16])or(Kind<>9)and(Mode=13)then parent:=Obj[Link[0]].parent;
    if(Mode=15)then parent:=i;
    glEnable(GL_COLOR_MATERIAL);
    case Kind of
      1:Pointe( i,true,true,bOnlyDraw);    // 点
      2:Lineer( i,true,true,bOnlyDraw);     //直线
      3:CircleDraw( i,true,true,true,bOnlyDraw);// 圆
      4:Plane( i,true,true);                //平面
      5:Locus( i,true,true,bOnlyDraw,false);//轨迹
      6:Solid( i,true,true,true,Mode<7);    //实体
      7:Face( i,true,true,bOnlyDraw);       //曲面
      8:if(Mode in[4,5,7])then L:=calcSize( i);   //标记角度 标记比 标记距离
      9:if(Mode=13)or(Obj[parent].Mode=13)
        then ImplicitFace( i, true,true,bOnlyDraw)//隐函数曲面
        else funcFace( i, true,true,bOnlyDraw);   //显函数曲面
     10,11,14:TextAndImage(i, false,true,true,false);   //图像 参数 计算 度量 按钮
     13:if ObjShow[Layer] then Iterate( i, true,true); //迭代
     15:CrossLine( i, true,true,bOnlyDraw); //相贯线
     16:funcCurve( i, true,true,bOnlyDraw); //函数曲线
     17:if(Mode=2)then ThreeView(i)         //三视图
        else Path( i,true,true,bOnlyDraw);  //路径
     18:Marker( i,true,true,bOnlyDraw);     //标注
     19:Conic( i,true,true,bOnlyDraw);      //圆锥曲线
      end; //case Kind
    end; //with Obj[i] do case Kind
  for i:= 11 to last do Obj[i].edited:=false;
end;
//======================= 视图变换 ========================
procedure ChangeAngle(  ID:integer; Invert:boolean);
  var Rr,t,k, vA,vB,vC :single; pc,pn :TcgVector;
      bA,bB :boolean;   iID:integer;
begin
  with Obj[ID] do begin
    if(Kind=2)or(Kind=3)then pc:=p0
    else pc:=Obj[Link[0]].p0;
    glTranslatef( pc.x, pc.y, pc.z); //位移
    t:=IIFf(Link[3]>0, Obj[Link[3]].L, R); //弧度值
    t:=t*oneArc; //角度值
    iID:=Link[1]; if(Kind=2)or(Kind=3)then iID:=ID;
    end; //with Obj[b]
  with Obj[iID] do begin //Obj[ID].
    if Kind=1 then pn:=cgNormalVec(p0,pc) else pn:=Vec;
    if not Invert then cgInvertVec(pn);
    vA:=pn.x; vB:=pn.y; vC:=pn.z;
    bA:= abs(vA)=0; bB:=abs(vB)=0;
    if(bA)and(bB)then begin  //平行于Z轴
      if(vC>0)then glRotatef( 180, 1,0,0);
      end
    else
      if(bA)then begin    //平行于YOZ平面
        glRotatef(-90, 1,0,0);  //先绕X轴旋转
        Rr:= ArcTan(vC/vB)* oneArc;
        glRotatef( Rr, 1,0,0);  //再绕X轴旋转
        if vB>0 then glRotatef( 180, 1,0,0);
        end
      else begin
        glRotatef( -90, 0,1,0 ); //绕Y轴旋转90度后平行于X轴
        Rr:= ArcTan(vB/vA)* oneArc; if vA<0 then Rr:=180+Rr;
        glRotatef(  Rr, 1,0,0 ); //绕X轴旋转
        k:= cgModelLength( vA, vB, 0);
        Rr:= ArcTan(vC/k)* oneArc;
        glRotatef( -Rr, 0,1,0 ); //绕Y轴旋转
        end;
    if abs(t)>0 then glRotatef( t, 0,0,1 ); //绕Z轴旋转
    end; //with Obj[c]
end;
//============ 坐标变换 ===================
procedure MoveDotPos(  var p:TcgVector; New,Nor:TcgVector);
  var vA,vB,vC,fR :single;  //p_欲移位的点 New_新坐标 Nor_新向量
      bA,bB,bC :boolean;
begin
  vA:=Nor.x;  vB:=Nor.y;  vC:=Nor.z;
  bA:= EP(vA); bB:=EP(vB); bC:=EP(vC);
  fR:= IIFf((bC)and(bB), -halfPi, IIFi(vB>=0,-1,1)*arcTan(sqrt(sqr(vA)+sqr(vB))/vC));
  if(vC<0)then fR:=fR+Pi;
  cgRotateX( p, fR);
  fR:= IIFf((bA)and(bB),-halfPi, IIFf((bB)and(bC),-halfPi, -arcTan(vA/vB)));
  cgRotateZ( p, fR);
  p:=cgVecAdd(p,New);// cgVector(p.x+v.x, p.y+v.y, p.z+v.z);
end;
//刷新链接
procedure upDateLinkName(ID:integer);
  var i,j,k :integer;
begin
  for i:=11 to ID do with Obj[i] do if(delID=0)then begin//刷新链接
    for j:=0 to LinkTime do if(LinkName[j]>0)then begin
      k:=0; repeat inc(k); until not(k in[8..10])and(LinkName[j]=Obj[k].Name)or(k=ID);//允许跟后续构件关联
      if(LinkName[j]=Obj[k].Name)then Link[j]:=k;
      end;
    end;
end;

procedure TfrmMain.upDateLink(ID:integer; isFile:boolean);
  var i,j,k :integer;
begin
  for i:=11 to ID do with Obj[i] do if(delID=0)then begin//刷新链接
    updateLinkName(ID);
    if Assigned(butID)then butID.Tag:=i;
    if Assigned(imgID)then imgID.Tag:=i;
    if Assigned(timID)then timID.Tag:=i;
    for j:=0 to 5 do if(Cutter[j,0]>0)then begin //允许被后续截面剪裁
      k:=4; repeat inc(k); until not(k in[8..10])and(Cutter[j,0]=Obj[k].Name)or(k=ID);
      if(Cutter[j,0]=Obj[k].Name)then Cutter[j,1]:=k;
      end;
    end;
  if not isFile then exit; //若打开块文件则不用创建下列控件
  for i:= 11 to ObjCount do with Obj[i] do if(delID=0)then begin
    if(Kind=14)then begin //控制按纽控件
      if(Assigned(butID))then with butID do begin
        left:=trunc( Obj[i].p0.x);  width :=trunc( Obj[i].W);
        height:=trunc( Obj[i].H);   top :=trunc( Obj[i].p0.y)-height-TitleHeight;
        font.Name:=Obj[i].TagN;     font.Size:=Obj[i].TagS; //font.Style:=fsBold; //
        font.Color:= cgColorFtoTColor(Obj[i].Color);
        caption:= Obj[i].Tag;       Obj[i].F:=false;   Tag:=i;
        Visible:=ObjShow[Layer]or bAll;
        end
      else createCtrl( i, true);
      end
    else if(Kind=11)and(Mode=2)then begin //参数轴
      if(Assigned(butID))then with butID do begin
        Left:=trunc( Obj[i].p0.x) +TagPos.X;
        Top :=trunc( Obj[i].p0.y) -TagPos.Y -height-TitleHeight+12;
        Width :=maxTrace+8;
        Height:=8;
        Visible:= (ObjShow[Layer]and Trace);           Tag:=i;
        end
      else createParaBar( i, true);
      end
    else
      if(Assigned(butID))then butID.Visible:=false;
    end;
end;

procedure setTowFaceColor(ID:integer; OneFace:boolean);
  var{环境色}mAmbient0, mAmbient1, {散射色}mDiffuse0, mDiffuse1 :TcgColorF;
      isTex :boolean;
begin
  with Obj[ID]do begin
    if not((Kind=6)and(Mode=5))and(Link[12]>10)then Color.A:=Obj[Link[12]].L;
    if(OneFace)then begin  //U颜色随点
      glEnable(GL_COLOR_MATERIAL);
      glLightModeli( GL_LIGHT_MODEL_TWO_SIDE, GL_FALSE); //单面着色
      if(Link[6]>0)and(Kind<>17)then mDiffuse0:=getColor(ID) // setColor(ID, trunc((Obj[Link[6]].L-trunc(Obj[Link[6]].L))*200),200,Color.A)
              else mDiffuse0:=cgColorF( 1, 1, 1, color.A ); //材料环境色
      glMaterialfv(GL_FRONT, GL_DIFFUSE,  @mDiffuse0);
      end
    else begin
      glDisable(GL_COLOR_MATERIAL);
      glLightModeli( GL_LIGHT_MODEL_TWO_SIDE, GL_TRUE); //双面着色
      isTex:=(Kind=6)and(Obj[parent].Mode in[1,2,6]) //是否允许贴图
              or(Kind=4)and((Obj[parent].Mode<>6)or(Obj[parent].Mode=6)and Obj[parent].Rand )
              or(Kind=3)and(Obj[parent].Mode<3)
              or(Kind=7)
              or(Kind=9)and(Mode<13)
              or(Kind=10)and(Mode=2);
      if isTex and D  // D贴图
        then mAmbient0:=cgColorF( 1, 1, 1, color.A )
        else mAmbient0:=color; // //材料环境色
      mDiffuse0:=cgColorF( 1, 1, 1, color.A );
      glMaterialfv(GL_FRONT, GL_AMBIENT,  @mAmbient0);
      glMaterialfv(GL_FRONT, GL_DIFFUSE,  @mDiffuse0);//透明度必须此句
      if isTex and D
        then mAmbient1:=cgColorF( 1, 1, 1, colorB.A )
        else mAmbient1:=colorB;
      if(ID<8)then mAmbient1:=color;
      mDiffuse1:=cgColorF( 1, 1, 1, color.A );
      glMaterialfv(GL_BACK,  GL_AMBIENT,  @mAmbient1);
      glMaterialfv(GL_BACK,  GL_DIFFUSE,  @mDiffuse1);//透明度必须此句
      end;
    end;
end;
//===========  实体点 ============
procedure SolidPoint(pP:TcgVector; pM, pS:integer; pW:single; bSelList:boolean);
  var i,j :integer;  k,t:single;
      Ball:array[0..12,0..12]of TcgVector;
  const a=0.7071; rZ=0.5236; //rZ=towPi/12
    Diam:array[0..6]of gl3f=((1,0,0),(0,1,0),(-1,0,0),(0,-1,0),(1,0,0),(0,0,-1),(0,0,1));
    Cube:array[0..2,0..4]of gl3f=
     ((( a, a,-a),(-a, a,-a),(-a,-a,-a),( a,-a,-a),( a, a,-a)), //下底
      (( a, a, a),(-a, a, a),(-a,-a, a),( a,-a, a),( a, a, a)), //上底
      (( 0, a, 0),(-a, 0, 0),( 0,-a, 0),( a, 0, 0),( 0, 0, 0)));//旁面法线
  procedure DrawPoint(pP:TcgVector; pS:integer);
    var i,j:integer;
  begin
    case pS of
    1:for j:=6 downto 1 do begin //球形
        glBegin(GL_QUAD_STRIP);
        for i:=0 to 12 do begin
          glNormal3fv(@Ball[i  ,j]);  glVertex3fv(@Ball[i,  j]);
          glNormal3fv(@Ball[i,j-1]);  glVertex3fv(@Ball[i,j-1]);
          end;
        glEnd;
        end;
    2:for j:=0 to 1 do begin //钻形
        glBegin(GL_TRIANGLES);
        for i:=0 to 3 do begin
          glNormal3f(IIFi(i in[0,3],1,-1), IIFi(i<2,1,-1), 1);
          glVertex3fv(@Diam[6]);  glVertex3fv(@Diam[i]);  glVertex3fv(@Diam[i+1]);
          glNormal3f(IIFi(i in[0,3],1,-1), IIFi(i<2,1,-1),-1);
          glVertex3fv(@Diam[5]);  glVertex3fv(@Diam[i+1]);  glVertex3fv(@Diam[i]);
          end;
        glEnd;
        end;
    3:begin
      for i:=0 to 3 do begin //立方形
        glBegin(GL_QUAD_STRIP);
          glNormal3fv(@Cube[2,i]);
          glVertex3fv(@Cube[0,i+1]);  glVertex3fv(@Cube[1,i+1]);
          glVertex3fv(@Cube[0,i  ]);  glVertex3fv(@Cube[1,i  ]);
        glEnd;
        end;
      glBegin(GL_QUADS);
      glNormal3f( 0, 0,-a); for i:=3 downto 0 do glVertex3fv(@Cube[0,i]);//下底
      glNormal3f( 0, 0, a); for i:=0 to 3 do glVertex3fv(@Cube[1,i]);    //上底
      glEnd;
      end;
    end;//case
  end;
begin
//  with Obj[ID]do begin
  if(pS>3)then pS:=1; //
  if(pS=1)or bSelList then
  for j := 0 to 6 do begin //从底向上一圈一圈计算圆周
    k:= j*rZ + halfPi;
    for i := 0 to 12 do
      Ball[i,j]:=cgVector( cos(k)*cos(i*rZ), cos(k)*sin(i*rZ), sin(k) );
    end;//for j
  glEnable(GL_LIGHTING);
  glEnable(GL_COLOR_MATERIAL);
  glPushMatrix;
  glPolygonMode( GL_BACK, IIFc(pS=1,GL_FILL,GL_LINE));
  glPolygonMode( GL_FRONT, GL_FILL );
  if not(bSelList)or(pM=6)then glTranslatef( pP.x, pP.y, pP.z); //移动原点
  t:=pW/50; if bSelList then t:=t*1.4;
  glScalef(t,t,t);   glLineWidth(2); //if bSelList then glLineWidth(2);
  if bSelList then begin  //选择状态下
    glBegin(GL_LINE_STRIP); for i:=0 to 12 do glVertex3fv(@Ball[i,3]); glEnd;
    end
  else
    DrawPoint(pP,pS);
  glPopMatrix;
  glPolygonMode( GL_FRONT_AND_BACK, GL_FILL);
//  end;//with
end;
//=========== 管状线段 ===========
procedure SolidLine(ID,j,listID :integer; bList:boolean);
 type TVec=array[0..8]of gl3f;
const a=0.7071;
      Vec:TVec=(( 1, 0,0),(a, a,0),(0, 1,0),(-a,a,0),(-1,0,0),
                (-a,-a,0),(0,-1,0),(a,-a,0),( 1,0,0));
  var i,k,iH,SS:integer; t,t0,t1, vL, kx :single;
  procedure Cylinder(ID:integer; R,L:single; isTwoColor:boolean);//圆柱 R半径 L长度
    var i:integer;  v0,v1:gl3f;  R0,R1:single;
  begin
    glBegin(GL_QUAD_STRIP);
    if not isTwoColor then glColor4fv(@Obj[ID].Color);
    for i:=0 to 8 do begin
      if not isTwoColor then begin
        v0:=Vec[i]; v0[0]:=v0[0]*R; v0[1]:=v0[1]*R;
        v1:=v0; v1[2]:=v0[2]+L;
        end
      else begin
        R0:=Obj[Obj[ID].Link[0]].W/50;
        R1:=Obj[Obj[ID].Link[1]].W/50;
        v0:=Vec[i]; v0[0]:=v0[0]*R0; v0[1]:=v0[1]*R0;
        v1:=Vec[i]; v1[0]:=v1[0]*R1; v1[1]:=v1[1]*R1; v1[2]:=v1[2]+L;
        end;
      glNormal3fv( @Vec[i]);
      if isTwoColor then glColor4fv(@Obj[Obj[ID].Link[0]].Color);
      glVertex3fv( @v0);
      if isTwoColor then glColor4fv(@Obj[Obj[ID].Link[1]].Color);
      glVertex3fv( @v1);
      end;
    glEnd;
    end;
  procedure CylinderOutLine(R,L:single);//选择状态 R半径 L长度
    var i :integer;  v0,v1 :gl3f;
  begin
    glColor4fv(@Obj[1].ColorB);
    for i:=0 to 3 do begin
      glBegin(GL_LINES);
        v0:=Vec[i*2]; v0[0]:=v0[0]*R; v0[1]:=v0[1]*R;  v1:=v0; v1[2]:=v0[2]+L;
        glVertex3fv( @v0); glVertex3fv( @v1);
      glEnd;
      end;
    end;
  procedure Arrow(ka,kx,kz,kL:single; isBack:boolean); //箭头
    var i:integer;
        V:array[0..10]of TcgVector;  pn:TcgVector;
  begin
    V[0]:=cgVector(0,0,kL);     V[10]:=cgVector(0,0,kz);
    V[1]:=cgVector( kx, 0,kz);  V[2]:=cgVector( ka, ka,kz); V[3]:=cgVector(0,kx,kz);
    V[4]:=cgVector(-ka,ka,kz);  V[5]:=cgVector(-kx,  0,kz); V[6]:=cgVector(-ka,-ka,kz);
    V[7]:=cgVector( 0,-kx,kz);  V[8]:=cgVector( ka,-ka,kz); V[9]:=V[1];
    if(isBack)then begin
      glPolygonMode( GL_FRONT, GL_FILL); glPolygonMode( GL_BACK,  GL_LINE);
      end
    else begin
      glPolygonMode( GL_FRONT, GL_LINE); glPolygonMode( GL_BACK, GL_FILL);
      end;
    glBegin(GL_QUAD_STRIP);
      for i:=1 to 9 do begin
        pn:=cgVecSub(V[i],V[10]);  if(kL=0)then cgInvertVec(pn);
        glNormal3fv(@pn);
        glVertex3fv(@V[0]); glVertex3fv(@V[i]);
        end;
    glEnd;
    glBegin(GL_TRIANGLE_FAN);
      pn:=cgVecSub(V[0],V[10]);   glNormal3fv(@pn);
      glVertex3fv(@V[10]);   for i:=9 DownTo 1 do glVertex3fv(@V[i]);
    glEnd;
    end;
begin
  with Obj[ID] do begin
  if bList then glNewList(IIfi(j=0, listID, stipList), GL_COMPILE);  //建立显示列表
  glPushMatrix;
  glEnable(GL_LIGHTING);
  glLineWidth(1);
  ChangeAngle(ID, false);
  t:=W/50;  vL:=L; iH:=trunc(H); t0:=0; t1:=0;
  if(iH=1)or(iH=3)then begin //始端箭头
    t0:=t;  if(Mode=1)and U then t0:=Obj[Link[0]].W/50; 
    end;
  if(iH=2)or(iH=3)then begin //终端箭头
    t1:=t;  if(Mode=1)and U then t1:=Obj[Link[1]].W/50; 
    end;
  glColor3fv(@Color);
  if Link[6]>10 then Color:=getColor(ID); // ColorB:=Color;
  setTowFaceColor(ID, false);
  glEnable(GL_COLOR_MATERIAL);
  if(iH>0)then begin //有箭头
    if(Mode=1)and U then glColor3fv(@Obj[Link[0]].Color);
    if(iH=1)or(iH=3)then Arrow(t0*1.4, t0*2, t0*10, 0, false); //始端箭头
    if(Mode=1)and U then glColor3fv(@Obj[Link[1]].Color);
    if(iH>1)then Arrow(t1*1.4, t1*2, vL-t1*10, vL, true);     //终端箭头

    if(iH=1)or(iH=3)then glTranslatef(0,0, t0*10);
    vL:=L-(t0+t1)*10; //一端箭头
    end;
  glPolygonMode( GL_BACK, GL_FILL);  glPolygonMode( GL_FRONT,GL_LINE );
  glLightModeli( GL_LIGHT_MODEL_TWO_SIDE, GL_FALSE); //双面着色
  SS:=S; if(j=1)then SS:=5; //j=1 遮挡状态则画虚线
  case SS of
    4:Cylinder(ID, t,vL, (Mode=1)and U); //实线
    5:begin //虚划线
      k:=trunc(vL/t)div 8; kx:=vL/(k*8+5); //单位线长
      for i:=0 to k do begin Cylinder(ID, t,kx*5, false); glTranslatef(0,0, kx*8); end;
      end;
    6:begin //虚点线
      k:=trunc(vL/t)div 4; kx:=vL/(k*4+1); //单位线长
      for i:=0 to k do begin Cylinder(ID, t,kx, false);  glTranslatef(0,0, kx*4);  end;
      end;
    7:begin //点划线
      k:=trunc(vL/t)div 12; kx:=vL/(k*12+5);//单位线长
      for i:=0 to k do begin
        Cylinder(ID, t,kx*5, false);   glTranslatef(0,0, kx*8);  if(i=k)then break;
        Cylinder(ID, t,kx, false);     glTranslatef(0,0, kx*4);
        end;
      end;
    end;//case M
  glPolygonMode( GL_FRONT_AND_BACK,GL_FILL );
  glPopMatrix;
  if bList then glEndList;

  if(j=1)and bList then begin
    glNewList( seleList, GL_COMPILE);  //选择状态
    glPushMatrix;
    glDisable(GL_LIGHTING);
    ChangeAngle(ID, false);
    glLineWidth(1); glColor4fv(@Obj[1].ColorB);
    CylinderOutLine(t*1.1, L);//选择状态 R半径 L长度
    glPopMatrix;
    glEndList;
    end;
  end;//with Obj[ID]
end;
//=========== 管状圆 ===========
procedure SolidCircle(ID,listID,jj,ss :integer; bList,bMask :boolean);//ss线形
 type TVec=array[0..8]of TcgVector;
  var i,j,N,gg :integer;   a,t:single;  pt,pp,pn:TcgVector;   isTow:boolean;//偶数点
      Vct:array of TVec;   tmpC:TcgColorF;
      Nor:array[0..8]of TcgVector; //法线
begin
  N:=high(LocaVct[ID]);   setLength(Vct, N+1);
  with Obj[ID]do begin
  a:=W/50;  t:=0.7071*a; gg:=Link[6];
  for i:=0 to N do begin
    pp:=LocaVct[ID,i];
    pn:=cgNormalVec(pp,p0);
    Vct[i,0]:=cgVecSubMult(pp,pn, a);   Vct[i,2]:=cgVecSubMult(pp,Vec, a);
    Vct[i,4]:=cgVecAddMult(pp,pn, a);   Vct[i,6]:=cgVecAddMult(pp,Vec, a);
      pt:=cgVecSubMult(pp,pn, t);
    Vct[i,1]:=cgVecSubMult(pt,Vec, t);  Vct[i,7]:=cgVecAddMult(pt,Vec, t);
      pt:=cgVecAddMult(pp,pn, t);
    Vct[i,3]:=cgVecSubMult(pt,Vec, t);  Vct[i,5]:=cgVecAddMult(pt,Vec, t);
    Vct[i,8]:=Vct[i,0];
    end;
  if bList and(jj=0)then begin //选择状态
    glNewList( seleList, GL_COMPILE);//  ID+9000
    glLineWidth(1); glColor4fv(@Obj[1].ColorB);
    for j:=0 to 3 do begin
      glBegin(GL_LINE_STRIP); for i:=0 to N do glVertex3fv(@Vct[i,j*2]); glEnd;
      end;
    glEndList;
    end;
  for j:=0 to 8 do Nor[j]:=cgNormalVec(Vct[0,j], LocaVct[ID,0]);
  i:=0;  isTow:=false;
  if bList then glNewList( listID, GL_COMPILE);//遮挡虚线
  glEnable(GL_LIGHTING);  glLineWidth(1);
  glPolygonMode( GL_BACK, GL_LINE);
  glPolygonMode( GL_FRONT,GL_FILL);
  if gg>10 then begin Color:=getColor(ID); end;
  tmpC:=ColorB;   ColorB:=Color;
  setTowFaceColor(ID, false);
  ColorB:=tmpC;
  if(jj=0)and bMask then ss:=5;
  case ss of
    4:repeat //实线
        glBegin(GL_QUAD_STRIP);
        for j:=0 to 8 do begin
          glNormal3fv(@Nor[j]);    glVertex3fv(@Vct[i,j]);
          Nor[j]:=cgNormalVec( Vct[i+1,j], LocaVct[ID,i+1]);
          glNormal3fv(@Nor[j]);    glVertex3fv(@Vct[i+1,j]);
          end;
        glEnd;
        inc(i);
       until(i>=N);
    5:repeat //虚线
        glBegin(GL_QUAD_STRIP);
        for j:=0 to 8 do begin
          pn:=cgNormalVec(Vct[i,j],LocaVct[ID,i]);  glNormal3fv(@pn);
          glVertex3fv(@Vct[i,j]);  glVertex3fv(@Vct[i+1,j]);
          end;
        glEnd;
        inc(i,2);
       until(i>=N);
    6:repeat //虚点
        glBegin(GL_QUAD_STRIP);
        pt:=cgNormalVec(LocaVct[ID,i+1],LocaVct[ID,i]);
        for j:=0 to 8 do begin
          pn:=cgNormalVec(Vct[i,j],LocaVct[ID,i]);  glNormal3fv(@pn);
          glVertex3fv(@Vct[i,j]);
          pp:=cgVecAddMult(Vct[i,j],pt,0.1);
          glVertex3fv(@pp);
          end;
        glEnd;
        inc(i);
       until(i>=N);
    7:repeat //点划
        glBegin(GL_QUAD_STRIP);
        pt:=cgNormalVec(LocaVct[ID,i+1],LocaVct[ID,i]);
        for j:=0 to 8 do begin
          pn:=cgNormalVec(Vct[i,j],LocaVct[ID,i]);  glNormal3fv(@pn);
          glVertex3fv(@Vct[i,j]);
          if isTow then pp:=cgVecAddMult(Vct[i  ,j],pt,0.1)
                   else pp:=cgVecAddMult(Vct[i+1,j],pt,0.1);
          glVertex3fv(@pp);
          end;
        glEnd;
        inc(i);   isTow:=not isTow; if isTow then inc(i);
       until(i>=N);
    end; //case
  glDisable(GL_LIGHTING);
  glPolygonMode( GL_FRONT_AND_BACK,GL_FILL);
  if bList then glEndList;
  setLength(Vct,0);
  end;//with
end;
//=========== 管状曲线 ===========
procedure SolidCurve(ID,listID,a,Ss,sTime :integer; bSport,bList:boolean);//pc,pn圆心及法线 S线形 W线径
 type TVec=array[0..8]of TcgVector;
  var i,j,k,N :integer;   rR,t :single;  isTow,isParaColor :boolean;
      pa,pb,pc, Ve,pt,pp,pn :TcgVector;
      Vct:array of TVec;  Tmp:array of TcgVector;  Lnk:array of boolean;
begin
  N:=high(LocaVct[ID]);
  setLength(Vct, N+1);
  setLength(Tmp, N+1);
  setLength(Lnk, N+1);
  for i:=0 to N do begin Tmp[i]:=LocaVct[ID,i]; Lnk[i]:=aLink[ID,i]; end;
  for i:=1 to N do Tmp[i].w:=cgDistance(Tmp[i],Tmp[i-1]); //顶点间距

  isParaColor:=( high(LocaColor[ID])>=high(LocaVct[ID]) ); //参数颜色 色随顶点
  with Obj[ID]do begin
  if U and(Kind in[5,15,17])then rR:=Tmp[0].r else rR:=W;  //U 随顶点 函数曲线则限制在坐标系范围内
  rR:=rR/50; //U 色随点
  for i:=0 to N do begin
    if(i<N)then pb:=cgNormalVec(Tmp[i],Tmp[i+1]);
    if(i=0)or(not Lnk[i])and(i<N)then begin
      pn:=Vec; Vec:=pb; //pn 暂存曲线所在平面的法线 圆锥曲线的切线所需
      for j:=0 to 8 do
        Vct[i,j]:=frmMain.DotInCircle( Tmp[i], ID,j*quadPi, rR,0,0);
      Vec:=pn; //恢复法线
      end
    else
      if(i=N)or(not Lnk[i+1])then pn:=pa
    else
      pn:=cgVecAdd(pa,pb);
    pn.w:=-cgDotProduct(pn,Tmp[i] );//圆所在平面方程的常数项
    if(i>0)and(Lnk[i])then begin
      t:=Tmp[i].r/Tmp[i-1].r;
      for j:=0 to 8 do begin
        cgLinePlaneCross(Vct[i-1,j],pa, Tmp[i],pn, pp);//pp 直线与平面之交点
        Vct[i,j]:=pp;
        if U and(Kind in[5,15,17]) then Vct[i,j]:=cgVecAddMult(Tmp[i], cgVecSub(pp,Tmp[i]), t);//随顶点
        end;
      end;
    pa:=pb;  //cgNormalVec(Tmp[i-1],Tmp[i]);
    end;
  if bList then glNewList( IIFi(a=0, listID, stipList), GL_COMPILE);
  if bList and(a=4000)then Ss:=5;
  glEnable(GL_LIGHTING);
  setTowFaceColor(ID, true);
  glPolygonMode( GL_FRONT,GL_FILL);  glPolygonMode( GL_BACK, GL_LINE);
  glLineWidth(1);
  if(Link[6]=0)or(Kind=17)then glColor4fv( @Color)
    else setMultiColor(ID, trunc((Obj[Link[6]].L-trunc(Obj[Link[6]].L))*200),200,Color.A);
  i:=0;  isTow:=false;
  case Ss of
    4:begin //实线
      repeat
      while(Lnk[i+1])and(i<N)and(not bSport or(i<=sTime))do begin
        glBegin(GL_QUAD_STRIP);
        for j:=0 to 8 do begin
          if isParaColor then glColor4fv( @LocaColor[ID,i]);
          pn:=cgNormalVec( Vct[i,j], Tmp[i]);
          glNormal3fv(@pn);    glVertex3fv(@Vct[i,j]);
          if isParaColor and(i<N)then glColor4fv( @LocaColor[ID,i+1]);
          pn:=cgNormalVec( Vct[i+1,j], Tmp[i+1]);
          glNormal3fv(@pn);    glVertex3fv(@Vct[i+1,j]);
          end; //for j
        glEnd;
        if not Lnk[i+1]then break else inc(i);
        end; //while...
        inc(i);
       until(i>=N) or (bSport)and(i>sTime);
      glBegin(GL_POLYGON); for j:=0 to 7 do glVertex3fv(@Vct[0,j]); glEnd;//封头
      glBegin(GL_POLYGON); for j:=7 DownTo 0 do glVertex3fv(@Vct[N,j]); glEnd;//封头
      end;
    5:repeat //虚线
      while(Lnk[i+1])and(i<N)and(not bSport or(i<=sTime))do begin
        if isParaColor then glColor4fv( @LocaColor[ID,i]);
        glBegin(GL_QUAD_STRIP);
        for j:=0 to 8 do begin
          pn:=cgNormalVec(Vct[i,j],Tmp[i]);  glNormal3fv(@pn);
          glVertex3fv(@Vct[i,j]);  glVertex3fv(@Vct[i+1,j]);
          end;
        glEnd;
        if not Lnk[i+1]then break else inc(i,2);
        end;
        inc(i,2);
       until(i>=N);
    6:repeat //虚点
      while(Lnk[i+1])and(i<N)and(not bSport or(i<=sTime))do begin
        if isParaColor then glColor4fv( @LocaColor[ID,i]);
        glBegin(GL_QUAD_STRIP);
        pt:=cgNormalVec(Tmp[i+1],Tmp[i]);
        for j:=0 to 8 do begin
          pn:=cgNormalVec(Vct[i,j],Tmp[i]);  glNormal3fv(@pn);
          glVertex3fv(@Vct[i,j]);
          pp:=cgVecAddMult(Vct[i,j],pt,0.1);
          glVertex3fv(@pp);
          end;
        glEnd;
        if not Lnk[i+1]then break else inc(i,1);
        end;
        inc(i);
       until(i>=N);
    7:repeat //点划
      while(Lnk[i+1])and(i<N)and(not bSport or(i<=sTime))do begin
        if isParaColor then glColor4fv( @LocaColor[ID,i]);
        glBegin(GL_QUAD_STRIP);
        pt:=cgNormalVec(Tmp[i+1],Tmp[i]);
        for j:=0 to 8 do begin
          pn:=cgNormalVec(Vct[i,j],Tmp[i]);  glNormal3fv(@pn);
          glVertex3fv(@Vct[i,j]);
          if isTow then pp:=cgVecAddMult(Vct[i  ,j],pt,0.1)
                   else pp:=cgVecAddMult(Vct[i+1,j],pt,0.1);
          glVertex3fv(@pp);
          end;
        glEnd;
        if not Lnk[i+1]then break else begin
          inc(i,1); isTow:=not isTow; if isTow then inc(i);
          end;
        end;
        inc(i);   isTow:=not isTow; if isTow then inc(i);
       until(i>=N);
    end;
  if(Kind in[15,17])and F then begin //填充相贯线或路径
    glPolygonMode( GL_FRONT_AND_BACK, GL_FILL);
    glDisable(GL_COLOR_MATERIAL);
    glColor4fv( @Color);
    if(Kind=15)then begin   //相贯线
      glBegin(GL_POLYGON);
        pn:=cgGetNormal(LocaVct[ID,0],LocaVct[ID,i],LocaVct[ID,i+1]);
        glNormal3fv( @pn);  //法线
      for i:=0 to N do glVertex3fv(@LocaVct[ID,i]);
      glEnd;
      end;
    if(Kind=17)then begin   //路径
      setTowFaceColor(ID, false);
      pc:=cgVector(0,0,0);
      for i:=0 to N do pc:=cgVecAdd(pc,LocaVct[ID,i]);  //计算平均中点
      pc:=cgVecScale(pc,1/(N+1));
      glBegin(GL_TRIANGLES);
      for i:=0 to N-1 do begin
        pn:=cgGetNormal(pc, LocaVct[ID,i], LocaVct[ID,i+1]);
        glNormal3fv( @pn);  //法线
        glVertex3fv( @pc);  glVertex3fv(@LocaVct[ID,i]); glVertex3fv(@LocaVct[ID,i+1]);
        end;
      glEnd;
      end;
    end;
  if bList then glEndList;
  if bList and(a<>4000)then begin //选择状态
    glNewList( seleList, GL_COMPILE); // ID+9000
    glLineWidth(1);  glColor4fv(@Obj[1].ColorB);
    for j:=0 to 3 do begin
      glBegin(GL_LINE_STRIP);
      for i:=0 to N do begin
        if(not Lnk[i])then begin glEnd; glBegin(GL_LINE_STRIP); end; //中断
        glVertex3fv(@Vct[i,j*2]);
        end;
      glEnd;
      end;
    glEndList;
    end;
  end;//with

  glPolygonMode( GL_FRONT_AND_BACK,GL_FILL);
  glDisable(GL_LIGHTING);
  setLength(Vct,0);  setLength(Tmp,0);  setLength(Lnk,0);
end;
//========================  圆周上的点  =============================
function TfrmMain.DotInCircle(  pc:TcgVector; Nor:integer; Fi,Rr,Ht,Rt:single):TcgVector;
//pc:圆心, Nor:法线, Fi:圆周角, Rr:半径, Ht:椭圆度, Rt椭圆长轴转角
  var vA,vB,vC, i,j,k, px,py,pz :single;
      sinA,cosA, sinS,cosS :single;
      pp :TcgVector;  bA,bB :bool;
begin  //
  with Obj[Nor] do begin vA:=-Vec.x; vB:=-Vec.y; vC:=-Vec.z; end;
  bA:=EP(vA); bB:=EP(vB);
  if Ht>0 then begin //椭圆
    i:=Rr*Cos(Fi);  j:=(1-Ht)*Rr*Sin(Fi);
    Rr:=cgModelLength(i,j,0);
    if i<>0 then Fi:=arcTan(j/i); if(i<0)then Fi:=Pi+Fi;
    end;
  Fi:=Fi+Rt; //+EPS
  if(bA)and(bB)then begin //法线平行于Z轴
    i:=Rr*Cos(Fi);  j:=Rr*Sin(Fi);  if(vC>0)then j:=-j;
    pp:= cgVector( i, j, 0);  //
    end
  else begin
    if vC<0 then Fi:=IIFi(Fi<Pi,1,3)*Pi-Fi;
    i:=Rr*Cos(Fi);  j:=Rr*Sin(Fi);
    k:=cgModelLength(vA,vB,0);
    if(vB=0)then sinA:=1 else sinA:=abs(vA/k); //sinA:=IIFf(vB=0, 1, abs(vA/k));
    if(vB=0)then cosA:=0 else cosA:=abs(vB/k); //cosA:=IIFf(vB=0, 0, abs(vB/k));
    if(vA>=0)and(vB<0)or(vA<0)and(vB>=0)then sinA:=-sinA;
    if(vC>=0)then sinS:=k else sinS:=-k; // sinS:=IIFf(vC>=0,k,-k);
    cosS:=abs(vC);
     k:= j*CosS;
    px:= i*CosA- k*SinA;
    py:=-i*SinA- k*CosA;
    pz:= j*SinS;
    if vB<0 then pp:= cgVector(-px,-py, pz) else pp:= cgVector( px, py, pz);
    if vC<0 then cgInvertVec(pp);
  end;
  result:=cgVecAdd(pp,pc);
end;

procedure TfrmMain.setLine( ID:integer; pc,pn:TcgVector );
begin //虚拟一条直线
  with Obj[ID]do begin Kind:=2; Mode:=1; p0:=pc; Vec:=pn; p1:=cgVecAdd(p0,Vec); end;
end;

procedure TfrmMain.setPlane(ID:integer; pc:TcgVector; Nor:integer; Rr:single);
begin                               // 圆心          法线         半径
  setLength(LocaVct[ID],4);
  with Obj[ID]do begin //虚拟一个平面
    Kind:=4; Mode:=3;
    p0:=pc;
    p1:=DotInCircle( pc, Nor,      0, Rr,0,0);
    p2:=DotInCircle( pc, Nor, halfPi, Rr,0,0);
    Vec:=Obj[Nor].Vec;
    LocaVct[ID,0]:=p0; LocaVct[ID,1]:=p1; LocaVct[ID,2]:=p2;
    end;   //DotInCircle参数表: 圆心,法线,圆周角, 半径
end;
//=========== 计算圆周上的点的圆周角 ============================
function TfrmMain.getDotAngle( Dot,Cen:TcgVector; Nor:integer; vR:single; bb:boolean):single; //点 圆构件
  var zita, r,y :single;  zz:bool;        //点Dot、圆心Cen、法线Nor、半径vR
      v :TcgVector;
begin
  v:=Obj[Nor].Vec;  //  vL:=cgVectorLength(v);//法线的模, 恒等于1
  if vR<EPS then begin result:=0; exit; end; // 退出
  zz:= EP(v.x)and EP(v.y); //法线平行于Z轴
  zita:=arcCos(v.z); //法线的仰角
  if zz then begin y:=(Dot.y-Cen.y); if v.z<0 then y:=-y; end
    else y:=(Dot.z-Cen.z)/sin(zita);
  if EP(vR)then r:=0 else r:=y/vR;
  if abs(r)>1 then r:=IIFf(r>=0, 1,-1);
  r:= arcSin(r); //第一象限的圆周角 r:=arcSin(r/vL) vL是法线的模,等于1
  if zz then if Dot.x<Cen.x then r:=Pi-r;
  if not zz then if cgDistance(Obj[10].p1, Dot)>(vR*1.414)then r:=Pi-r;
  if r<0 then r:=towPi+r;
  result:=r;  //
end;

function TfrmMain.DotInPlane(  ID:integer; var xL,xH:single; x,y:single; bTag:boolean) :TcgVector;
  var k1,k2,kx1,ky1,kx2,ky2, x1,x2 :single; //ID点构件 xL圆周角 x,y坐标 bTag是否计算点坐标
      pa,pb,pc, pp,pn :TcgVector;   b:integer;
begin
  if(Obj[ID].Kind=18)then b:=ID else  b:=Obj[ID].Link[1];
  pa:= WinPos[0]; pb:= WinPos[1]; pc:=WinPos[2]; //端点的屏幕坐标，在frmMouseDown里赋值
  kx1:=pa.x-pb.x; ky1:=pa.y-pb.y;  kx2:=pc.x-pb.x; ky2:=pc.y-pb.y;
  with Obj[ID] do
  if(Kind=1)and(Mode=2)and(Obj[b].Kind=2) //直线上的点
    or(Kind=2)or(Kind=18)then begin
    if abs(ky1)<abs(kx1)//斜率<1
      then xL:= (pa.x-x)/kx1 else xL:= (pa.y-y)/ky1;
    exit;
    end; // with Obj[ID] do if
  k1:=ky1; if kx1<>0 then k1:=k1/kx1; //第一、二点连线的斜率
  k2:=ky2; if kx2<>0 then k2:=k2/kx2; //第二、三点连线的斜率
  //鼠标所在的点与上述三点形成一个平行四边形，鼠标点与第二点是相对的两点，另外两点是
  x1:=(k1*pb.x- k2*x- pb.y+y)/(k1-k2);
  x2:=(k2*pb.x- k1*x- pb.y+y)/(k2-k1);
  k1:=(x1-pb.X); if(kx1<>0)then k1:=k1/kx1; //x1至第二点之距离与第一、二点连线长度之比
  k2:=(x2-pb.X); if(kx2<>0)then k2:=k2/kx2; //x2至第二点之距离与第二、三点连线长度之比
  with Obj[ID] do begin
  if(Kind=1)and(Obj[b].Kind=4)or(Kind=4)and bTag then  //平面上的点 或平面的标签
    begin xL:=k1;  xH:=k2; exit; end;//跳出
  with Obj[10]do begin
    pa:=cgVecSub(p0,p1); pa:=cgVecAddMult(p1,pa,k1); //pa:=cgVector(p1.x+k1*(p0.x-p1.x), p1.y+k1*(p0.y-p1.y),  p1.z+k1*(p0.z-p1.z));
    pb:=cgVecSub(p2,p1); pb:=cgVecAddMult(p1,pb,k2); //pb:=cgVector(p1.x+k2*(p2.x-p1.x), p1.y+k2*(p2.y-p1.y),  p1.z+k2*(p2.z-p1.z));
    pp:=cgVecAdd(pa,pb); pp:=cgVecSub(pp,p1);        //pp:=cgVector(pb.x-p1.x+pa.x,  pb.y-p1.y+pa.y, pb.z-p1.z+pa.z); //鼠标位置所指平面上的点
    end;
  case Kind of
    1:case Mode of
      2:begin //圆周上的约束点
        pc:=Obj[b].p0; //圆心
        pn:=cgNormalVec(pp,pc);  //半径线的向量  //向量单位化
        xL:=Obj[b].L;  //半径
        pp:=cgVecAddMult(pc,pn,xL);//
        xL:=getDotAngle( pp, pc, b, xL,false); //圆周角
        end;
      9:begin  //旋转复制点
        pc:=p1;  //圆心
        pn:=cgNormalVec(pp,pc);  //半径线的向量
        xL:=L; //半径
        pp:=cgVecAddMult(pc,pn,xL);
        xL:=getDotAngle( pp, pc, b, xL,false); //圆周角
        end;
      end;
    3:if bTag or(Mode=3) then begin //点法圆的半径或圆周上的标签
        pc:=p0; //圆心
        pn:=cgNormalVec(pp,pc); //半径线的向量
        pp:=cgVecAddMult(pc,pn,L);
        xL:=getDotAngle( pp, pc, ID, L,false); //标签的圆周角
        end              //点、圆心、法线、半径
      else begin //点法圆的半径
        xL:=cgDistance(pp,p0);  //点法圆的半径
        p4:=pp;
        end;
    end; //kind
  end; //with Obj[ID]
end;
//================= [点]绕指定法线的圆周角
function TfrmMain.getDotAngleByAxis(  p:TcgVector; b:integer; var rR:single):TcgVector;
  var pa:TcgVector;
begin
    pa:= Footer(  p, b, true); //垂点(圆心)
    setPlane(10, pa, b, pa.w);  //虚拟一个平面
    rR:=getDotAngle( p, pa, b, pa.w,false); //旋转角度
    result:=pa;
end;
  //中线的向量
function TfrmMain.getMidLineVec(pa,np, na,nb:TcgVector; Ratio:single; Angle:single):TcgVector;
  var pc,pd,pp:TcgVector; aR,bR,dR:single;
begin
  setLine( 9,pa,np);
  pc:=cgVecAdd(pa,na);  getDotAngleByAxis( pc, 9, aR); //pc:圆心 aR:圆周角
  pd:=cgVecAdd(pa,nb);  getDotAngleByAxis( pd, 9, bR);
  dR:=bR-aR;  if(aR<bR) then dR:=-towPi+dR;
  pp:=DotInCircle(  pa, 9, aR+dR*Ratio, 1, 0,0);
  result:=cgVecSub(pp,pa);
end;
//========================= 计算链接值 ==========================
function TfrmMain.getLinkVar( Link:integer; Dot:TcgVector):single;
begin
  with Obj[Link]do begin
  if(Kind=1)and(Mode in[1,3..8,11..19])then //另外一个点的距离 约束点/旋转/缩放变换除外
    result:=cgDistance( p0, Dot)
  else if(Mode in[9,10,12])then //旋转、缩放、向量值
    result:=R
  else
    result:=L;
  end; //with
end;
//============== 备份数据 / 恢复数据 ==============
procedure SysBackup(ID:integer; var BackObje:TObjType; var BackLoca:TLocaType;
                                var BackFace:TFaceType;var BackLink:TLinkType;
                                var BackLocaC:TLocaColor; var BackFaceC:TFaceColor;
                                isBackUp:Boolean);
  var i,j,M:integer;
begin
  if isBackUp then begin //备份数据
    setLength( BackObje, ID);   setLength( BackLoca, ID);
    setLength( BackFace, ID);   setLength( BackLink, ID);
    setLength( BackLocaC,ID);   setLength( BackFaceC,ID);
    for i:= 0 to ID-1 do begin
      BackObje[i]:= Obj[i];  //备份全部构件
      M:=high(LocaVct[i]);
      if(M>0)then begin //备份构件顶点
        setLength(BackLoca[i], M+1);  for j:=0 to M do BackLoca[i,j]:=LocaVct[i,j];
        end;
      M:=high(FaceVct[i]);
      if M>=0 then begin //备份曲面顶点
        setLength(BackFace[i], M+1);  for j:=0 to M do BackFace[i,j]:=FaceVct[i,j];
        end;
      M:=high(aLink[i]);
      if M>0 then begin //备份顶点状态
        setLength(BackLink[i], M+1);  for j:=0 to M do BackLink[i,j]:=aLink[i,j];
        end;
      M:=high(LocaColor[i]);
      if(M>0)then begin //备份曲线顶点颜色
        setLength(BackLocaC[i], M+1);  for j:=0 to M do BackLocaC[i,j]:=LocaColor[i,j];
        end;
      M:=high(FaceColor[i]);
      if M>0 then begin //备份曲面顶点颜色
        setLength(BackFaceC[i], M+1);  for j:=0 to M do BackFaceC[i,j]:=FaceColor[i,j];
        end;
      end;
    end
  else begin             //恢复数据
    for i:= 0 to ID-1 do begin
      Obj[i]:=BackObje[i]; //恢复全部构件
      M:=high(BackLoca[i]);
      if M>0 then begin //恢复构件顶点
        setLength(LocaVct[i], M+1); for j:=0 to M do LocaVct[i,j]:=BackLoca[i,j];
        end;
      M:=high(BackFace[i]);
      if M>=0 then begin //恢复曲面顶点
        setLength(FaceVct[i], M+1); for j:=0 to M do FaceVct[i,j]:=BackFace[i,j];
        end;
      M:=high(BackLink[i]);
      if M>0 then begin //恢复顶点状态
        setLength(aLink[i], M+1);   for j:=0 to M do aLink[i,j]:=BackLink[i,j];
        end;
      M:=high(BackLocaC[i]);
      if M>0 then begin //恢复曲线顶点颜色
        setLength(LocaColor[i], M+1); for j:=0 to M do LocaColor[i,j]:=BackLocaC[i,j];
        end;
      M:=high(BackFaceC[i]);
      if M>0 then begin //恢复曲面顶点颜色
        setLength(FaceColor[i], M+1); for j:=0 to M do FaceColor[i,j]:=BackFaceC[i,j];
        end;
      end;
    setLength( BackObje, 0);  setLength( BackLoca, 0);
    setLength( BackFace, 0);  setLength( BackLink, 0);
    setLength( BackLocaC,0);  setLength( BackFaceC,0);
    end;
end;
//=========== 平面形心 ==============
function Centroid(ID :integer):TcgVector;
  var i,M,N :integer;  pc:TcgVector;
begin 
  if(Obj[ID].Kind=3)then begin result:=Obj[ID].p0; exit; end; //直接返回圆心
  N:=high(LocaVct[ID])-1;
  M:=N;
  with Obj[ID]do begin
    if(Obj[parent].Mode<3)and EP(Obj[parent].L)then M:=N-1;
    end;
  pc:=cgOrigin;
  for i:=0 to M do pc:=cgVecAdd(pc,LocaVct[ID,i]); //各顶点坐标的平均值
  result:=cgVecScale(pc,1/(M+1));
end;
//================= 自定义变换 ===========================
function TfrmMain.TransCustom(ID:integer):integer; //自定义变换
  var i,j,a,b,c, M,N :integer;  ka,kb, fL,fW :single;
      pa,pb,pc, nL,nW :TcgVector;
      BackObje :TObjType;   BackLoca :TLocaType;
      BackFace :TFaceType;  BackLink :TLinkType;
      BackLocaC:TLocaColor; BackFaceC:TFaceColor;
  label drawCopy, OnlyDraw, isExit;
  function VecTransCustom(Dot:TcgVector; b,c:integer):TcgVector;
    var i:integer;
  begin
    Obj[b].p0:=Dot; Obj[b].L:=Dot.w;
    for i:=b+1 to c do with Obj[i] do
      case Kind of
      1:Pointe(i, false,false,false);
      2:Lineer( i, false,false,false);      //直线
      3:CircleDraw( i, false,false,true,false);//圆
      4:Plane( i, false,false);             //平面
      5:Locus( i, false,false,false,false); //轨迹线
      6:Solid( i, false,false,false,false); //多面体
      7:Face( i, false,false,false);        //曲面
     11:begin
        if(Mode=1)then calcFunc( i, res, false,false); //计算式
        if(Mode>2)then res:=calcSize( i);   //度量
        if(Mode=2)then res:=L else L:=res;
        end;
     15:CrossLine( i, false,false,false);   //相贯线
     16:FuncCurve( i, false,false,false);   //函数曲线
     17:Path( i, false,false,false);        //路径
     19:Conic(i, false,false,false);        //圆锥曲线
      end;
    result:=Obj[c].p0;
  end;
begin  //caption :='-';
  result:=0;
  SysBackup(ID, BackObje,BackLoca,BackFace,BackLink,BackLocaC,BackFaceC, true);//数据备份
  with Obj[ID]do begin
    a:=Link[0]; b:=Link[1]; c:=Link[2]; M:=0;
    if(Kind=1)then p0:=VecTransCustom(Obj[a].p0, b,c);
    if(Kind=5)and(Obj[a].Kind=2)then begin //由直线变换成的轨迹线
      if R<3 then R:=3; //密度
      M:=trunc(Obj[a].L*R); if M<3 then M:=3;
      setLength(LocaVct[a], M+1);
      setLength(LocaColor[ID], IIFi(U,M+1,0)); //U 颜色线宽随动点
      ka:=Obj[a].L/M;
      for i:=0 to M do begin
        LocaVct[a,i]:=cgVecAddMult(Obj[a].p0,Obj[a].Vec,ka*i);
        LocaVct[a,i].w:=i*ka;   LocaVct[a,i].r:=Obj[c].W;
        if U then LocaColor[ID,i]:=Obj[c].Color;//颜色线宽随动点
        end;
      setLength( aLink[a], M+1); for i:=0 to M do aLink[a,i]:=true;
      end;
    if(Kind=7)and(Obj[a].Kind=4)then begin //由平面变换成的曲面
      pa:=LocaVct[a,0];   pb:=LocaVct[a,1];   pc:=LocaVct[a,2];
      nL:=cgNormalVec(pb,pa);  fL:=nL.w;  M:=trunc(fL*R);  ka:=fL/M;
      nW:=cgNormalVec(pc,pb);  fW:=nW.w;  N:=trunc(fW*R);  kb:=fW/N;
      setLength(FaceVct[a],M+1);  for i:=0 to M do setLength(FaceVct[a,i],N+1);
      for i:=0 to M do begin
        FaceVct[a,i,0]:=cgVecAddMult(pa,nL,ka*i);
        for j:=0 to N do
          FaceVct[a,i,j]:=cgVecAddMult(FaceVct[a,i,0],nW,kb*j);
        end;
      Caption:=Caption; //很奇怪 若没有这行则有时会不显示曲面
      end;
    if(Kind in[5,15,16,17,19])then begin
      M:=High(LocaVct[a]);
      setLength(LocaVct[ID],M+1); setLength(aLink[ID],M+1);
      for i:=0 to M do begin
        LocaVct[ID,i]:=VecTransCustom(LocaVct[a,i], b,c);
        aLink[ID,i]:=aLink[a,i];
        if U then LocaVct[ID,i].r:=LocaVct[a,i].r; //颜色线宽随动点
        end;
      if(Kind=5)and(Obj[a].Kind=2)then setLength(LocaVct[a],0);
      end;
    if(Kind in[6,7,9])then begin
      M:=High(FaceVct[a]);  N:=High(FaceVct[a,0]);
      setLength(FaceVct[ID],M+1);  for i:=0 to M do setLength(FaceVct[ID,i],N+1);
      for i:=0 to M do for j:=0 to N do
        FaceVct[ID,i,j]:=VecTransCustom(FaceVct[a,i,j], b,c);
      if(Kind=7)and(Obj[a].Kind=4)then setLength(FaceVct[a],0);
      end;
    end;//with
  result:=M;
  SysBackup(ID, BackObje,BackLoca,BackFace,BackLink,BackLocaC,BackFaceC, false);//数据恢复
end;
//================= 变换 ===========================
function TfrmMain.transVec(ID:integer; Dot:TcgVector):TcgVector;
  var pa,pb,pc,pd, pp,np:TcgVector;  t,aR,rR:single;
      i, b,c,dd,ee,ff, Ka,Kb,Kc,Kd,Ke,Kf :integer;
begin
  with Obj[ID] do begin
  b:=Link[1]; c:=Link[2]; dd:=Link[3]; ee:=Link[4]; ff:=Link[5];
  Kb:=Obj[ b].Kind;  Kc:=Obj[ c].Kind;
  Kd:=Obj[dd].Kind;  Ke:=Obj[ee].Kind;  Kf:=Obj[ff].Kind;
  case Mode of
    7:begin //投影
      if(b<1)then b:=7; //默认z平面
      if(c=0)then
        pc:=Footer( dot, b, false) //垂点
      else begin //有光线构件    with Obj[c] do
        if U and(Obj[c].Kind=2)or(Obj[c].Kind=1) //U 点光
          then np:=cgNormalVec(Obj[c].p0, dot)
          else np:=Obj[c].Vec;
        if EP(cgDotProduct(np,Obj[b].Vec))then begin
          hide:=true; if hide then exit;
          end;
        if(Obj[b].Kind=2)and(Obj[c].Kind=2)//投影到直线 且光线也是直线
          then pc:=cgTowLineCross2(dot, Obj[b].p0, Obj[c].Vec, Obj[b].Vec )
          else cgLinePlaneCross(dot, np, Obj[b].p0, Obj[b].Vec, pc); //投影到平面
        end;
      if(dd>0)and(Obj[dd].DelID=0)then begin
        if(ee=0)and(ff=0)then
          R:=Obj[dd].L  //缩放值
        else //标记两条直线之比
          if(Obj[dd].Kind=2)and
            (ee>0)and(Obj[ee].DelID=0)and(Obj[ee].Kind=2)then begin
            hide:=EP(Obj[ee].L); //分母为0
            if not hide then R:=Obj[dd].L/Obj[ee].L;
            end
        else //标记三点之比
          if(Obj[dd].Kind=1)and
            (ee>0)and(Obj[ee].DelID=0)and(Obj[ee].Kind=1)and
            (ff>0)and(Obj[ff].DelID=0)and(Obj[ff].Kind=1)then begin
            aR:=cgDistance(Obj[dd].p0,Obj[ee].p0);
            hide:=EP(aR); //分母为0
            if not hide then R:=cgDistance(Obj[dd].p0,Obj[ff].p0)/aR;
            end;
        end;
      if R<>0 then begin
        np:=cgVecSub(Dot, pc);  pc:=cgVecAddMult( pc,np, R);
        end;
      end;
    8:begin //对称
      if(b<1)then b:=1; //默认原点
      pc:=Footer( dot, b, false);   //垂点
      pc:=cgVector( pc.x*2-Dot.x, pc.y*2-Dot.y, pc.z*2-Dot.z); //对称点
      end;
    9:begin //旋转
      if(b<1)then b:=4; //默认z轴
      if(dd>0)and(Obj[dd].DelID=0)then begin  //
        if(Obj[dd].Kind=18)and(Obj[dd].Mode=2)then //角度标注
          R:=Obj[dd].L
        else if(Obj[dd].Kind<>11)and(Obj[dd].Mode=9)then //旋转变换的角度
          R:=Obj[dd].R
        else if(Obj[dd].Kind=1)and(ee=0)and(ff=0) or (Obj[dd].Kind=11)then
          R:=IIFf((Obj[dd].Kind=3)and(Obj[dd].Mode in[3,4]),Obj[dd].H, Obj[dd].L)  //转角
        else begin
          pp:=np;
          if(Kd=2)and(Ke=2) //标记两条直线之夹角
            and(ee>0)and(Obj[ee].DelID=0)then begin
            pp:=Obj[dd].Vec; np:=Obj[ee].Vec;
            end
          else if(Kd*Ke*Kf=2)//标记两点一线之夹角(两平面之夹角)
            and(ee>0)and(Obj[ee].DelID=0)
            and(ff>0)and(Obj[ff].DelID=0)then begin
            pa:=Obj[dd].p0; pb:=Obj[ee].p0; pc:=Obj[ff].p0;  pd:=Obj[ff].p1;
            if(Kd=2)then begin pa:=Obj[ee].p0; pb:=Obj[ff].p0; pc:=Obj[dd].p0; pd:=Obj[dd].p1; end;
            if(Ke=2)then begin pa:=Obj[dd].p0; pb:=Obj[ff].p0; pc:=Obj[ee].p0; pd:=Obj[ee].p1; end;
            pp:=cgGetNormal(pa,pc,pd);  np:=cgGetNormal(pb,pc,pd);
            end
          else if(Kd*Ke*Kf=1)//标记三点之夹角
            and(ee>0)and(Obj[ee].DelID=0)
            and(ff>0)and(Obj[ff].DelID=0)then begin
            pp:=cgNormalVec(Obj[ee].p0, Obj[dd].p0);
            np:=cgNormalVec(Obj[ee].p0, Obj[ff].p0);
            end;
          t:=cgDotProduct(pp,np);
          R:=arcCos(t);
          end;
        end;
      rR:=R;  if Deg then rR:=rR/oneArc;    //D 角度制 转换为弧度
      if(b>0)and(Obj[b].Kind=1)then begin //以点为旋转轴
        pp:=Obj[b].p0;  b:=9; if(c=0)then c:=4;
        setLine( 9, pp, Obj[c].Vec); //虚拟轴线
        end;
      if(Obj[b].Kind in[3,4])then begin //圆轴线或平面中轴线
        if(Obj[b].Kind=3)then pp:=Obj[b].p0 else pp:=Centroid(b); //中点
        setLine( 9, pp, Obj[b].Vec); //虚拟轴线
        b:=9;
        end;
      pc:=getDotAngleByAxis( dot, b, aR); //pc:圆心 aR:圆周角
      pc:=DotInCircle(  pc, b, aR+IIFf(U,-rR,rR), pc.w, 0,0);
      if(Kind=1)then L:=R;
      end;
    10:begin //缩放
      if(b<1)then b:=1;  //默认原点
      if(dd>0)and(Obj[dd].DelID=0)then begin
        if(ee=0)and(ff=0)or(Obj[ee].Kind=11)then //
          R:=Obj[dd].L  //缩放值
        else //标记两条直线之比
          if(Obj[dd].Kind=2)and
            (ee>0)and(Obj[ee].DelID=0)and(Obj[ee].Kind=2)then begin
            hide:=EP(Obj[ee].L); //分母为0
            if not hide then R:=Obj[dd].L/Obj[ee].L;
            end
        else //标记三点之比
          if(Obj[dd].Kind=1)and
            (ee>0)and(Obj[ee].DelID=0)and(Obj[ee].Kind=1)and
            (ff>0)and(Obj[ff].DelID=0)and(Obj[ff].Kind=1)then begin
            aR:=cgDistance(Obj[dd].p0, Obj[ee].p0);
            hide:=EP(aR); //分母为0
            if not hide then begin
              np:=cgNormalVec(Obj[ee].p0, Obj[dd].p0);
              pp:=cgDotLineFooter(Obj[ff].p0, Obj[dd].p0, np, true);  //约束点在准线上的垂足
              R:=cgDistance(Obj[dd].p0, pp)/aR;
              if not cgVecSgn(cgVecSub(pp, Obj[dd].p0),np)then R:=-R;
              end;
            end;
        end;
      if(Kind=1)then L:=R;
      pc:=cgVecSub(dot, Obj[b].p0);
      pc:=cgVecAddMult( Obj[b].p0, pc, R);
      end;
    11:begin //平移
      if  b>0 then if(Obj[b].Mode=11)then pTR.x:=Obj[b].pTR.x else pTR.x:=getLinkVar( b, dot);
      if  c>0 then if(Obj[b].Mode=11)then pTR.y:=Obj[b].pTR.y else pTR.y:=getLinkVar( c, dot);
      if dd>0 then if(Obj[b].Mode=11)then pTR.z:=Obj[b].pTR.z else pTR.z:=getLinkVar(dd, dot);
      pc:=cgVecAdd( Dot, pTR); //pTR 平移量
      end;
    12:begin //向量变换
      if(b<1)then Link[1]:=2;//默认X轴
      if(dd>0)then R:=getLinkVar(dd, dot);
      if(Obj[b].Kind=1)then begin pc:=Obj[c].p0; pp:=Obj[b].p0; end  //两点向量
                       else begin pc:=Obj[b].p5; pp:=Obj[b].p4; end; //直线向量
      np:=cgNormalVec(pc,pp);
      if Deg then t:=R else t:=R*np.w;  //沿直线的约束点 D:定长
      pc:=cgVecAddMult(Dot, np, t);
      end;
    15:begin //反演
      if(b=0)and not bAdd then begin b:=1; Link[1]:=1; LinkName[1]:=1; end;//默认坐标原点
      if(c>0)then R:=Obj[c].L;
      pc:=cgInversion(Obj[b].p0, Dot, R, Lock);
      end;
    16:begin //仿射
      for i:=0 to 11 do if(Link[i+16]>0)then Value[i]:= getLinkVar( Link[i+16], dot);
      pc:=Dot;
      pc.x:=Value[0]*Dot.x+ Value[1]*Dot.y+ Value[ 2]*Dot.z+ Value[ 3];
      pc.y:=Value[4]*Dot.x+ Value[5]*Dot.y+ Value[ 6]*Dot.z+ Value[ 7];
      pc.z:=Value[8]*Dot.x+ Value[9]*Dot.y+ Value[10]*Dot.z+ Value[11];
      end;
    20:begin //三视图
      pc:=Dot;  case b of 5:pc.x:=0;  6:pc.y:=0;  7:pc.z:=0; end;
      if(R>0)then pc:=cgVecAddMult( pc, cgVecSub( Dot,pc), R);
      if(R<0)and(b<>6)then begin //投影在y平面上则不做旋转
        t:=-R*halfPi;     aR:=pc.y*sin(t); //旋转角度
        if(b=5)then pc.x:=aR* IIFi(Dot.x<0,-1,1)* IIFi(Dot.y<0,1,-1); //绕z轴旋转
        if(b=7)then pc.z:=aR* IIFi(Dot.z<0,1,-1)* IIFi(Dot.y<0,-1,1); //绕x轴旋转
        pc.y:=pc.y*cos(t);
        end;
      end;
    end;
    result:=pc;
  end;//with Obj[ID]
end;
//============== 判断父构件 ===================
function ObjIsDad(Dad,Son :integer):boolean; //如果Dad是Son的父构件则返回true
  var i,j :integer;
begin
  result:=false; if(Dad=1)or(Son=1)then exit;
  if(Dad=0)or(Son=0)or(Dad=Son)then exit;
  if(Son<Dad)then SwapI(Dad,Son);
  for i:=Dad to Son do Obj[i].Edited:=(i=Son);
  for i:=Son DownTo Dad do with Obj[i]do if(Edited)then
    for j:=0 to LinkTime do if(Link[j]>0)then Obj[Link[j]].Edited:=true;
  result:=Obj[Dad].Edited;
end;
//========== 统计子对象数目 ================
function TfrmMain.getSonNum(ID, ObjCount :integer):integer;
  var i,j :integer;  //仅统计子对象
begin
  result:=0; if(ID=1)then result:=1;
  i:=ID;     if(ID=1)then i:=10;

  while(i<ObjCount)do begin //标记子对象
    inc(i); if(Obj[i].DelID<>0)then continue;
    j:=-1;
    repeat inc(j); until(j>=LinkTime)or(Obj[i].Link[j]=ID);
    if(Obj[i].Link[j]=ID)then begin
      JoinLink[result,0]:=i;  JoinLink[result,1]:=j;
      inc(result);
      end;
    end;
end;
//=============== 移动对象顺序 ==================
procedure TfrmMain.ChangeObjID(var ID,New :integer); //把New移动到ID之前
  var i,j,n,iNew :integer;  tmpObj:TmyObject;
  function MarkFather(ID,New:integer):integer; //标记父对象
    var i,j,k,iID,iNew :integer;  
    begin
      iNew:=New;
      for i:=ID+1 to New do Obj[i].Edited:=(i=New);
      for i:=New DownTo ID+1 do with Obj[i]do
        if Edited then begin
        for j:=0 to LinkTime do if(Link[j]>ID)then Obj[Link[j]].Edited:=true;
        if(Mode=13)then begin //棱边
          iID:=Link[0]; //父对象
          for k:=iID to ObjCount do with Obj[k]do
            if(Mode=13)and(Link[0]=iID)then begin
              Edited:=true; if(k>New)then iNew:=k;
              end;
          end;
        if(Kind=1)and(Mode=4)then begin //交点
          iID:=Link[2]; //父对象
          for k:=iID to ObjCount do with Obj[k]do
            if(Mode=4)and(Link[2]=iID)then begin
              Edited:=true; if(k>New)then iNew:=k;
              end;
          end;
        end;
      result:=iNew;
    end;
begin
  if(ID>New)then exit;
  iNew:=MarkFather(ID,New);//标记父对象
  n:=ID;
  for i:=ID+1 to iNew do with Obj[i]do if Edited then begin
    tmpObj:=Obj[i];
    for j:=i DownTo n+1 do Obj[j]:=Obj[j-1];
    Obj[n]:=tmpObj;
    inc(n);
    end;
  upDateLink(ObjCount, true); //刷新链接
  ObjListUpdate(11,true);
  for i:= 11 to ObjCount do Obj[i].edited:=true; //重建显示列表
  ID:=n; if(New<iNew)then New:=ID-1-iNew+New else New:=ID-1;
end;
//=============== 合并/分离 ==================
function TfrmMain.PointJoin( ID,New:integer):integer;
  var i,j,k,n :integer;  pc :TcgVector;
      t :single;   tmpObj:TmyObject;
begin //
  if(ID<New)then ChangeObjID( ID,New); //合并到后续对象
  result:=ID;
  with Obj[ID]do begin
  if(Mode=1)and(New>1)and(Obj[New].Kind>1)then begin//自由点合并到线
    save(0,ID,1,false,true);
    for i:=0 to 3 do begin Link[i]:=0; LinkName[i]:=0; end;
    Mode:=2; L:=0.7; D:=false;  p2.x:=0; p2.z:=1;
    if(Obj[New].Kind=2)then begin //合并到直线
      pc:=Footer( p0, New, false); //垂点
      if EP(Obj[New].L)then L:=0
        else L:=cgDistance(pc,Obj[New].p0)/Obj[New].L;
      end;
    if(Obj[New].Kind=3)then begin //合并到圆
      if EP(Obj[New].L)then L:=0
        else begin
          setLine( 9, Obj[New].p0, Obj[New].Vec);
          getDotAngleByAxis( p0, 9, L); //L:圆周角
          p2.x:=0; p2.z:=towPi;
          end;
      end;
    Link[1]:=New; LinkName[1]:=Obj[New].Name;
    save(0,ID,1,true,true);  //保存编辑后的数据
    Edited:=true;  U:=true;
    end
  else if(Mode=1)and(New>0)and(Obj[New].Kind=1)then begin //合并到点
    if not bC then begin //默认为约束到点
      Mode:=2;
      Link[1]:=New; LinkName[1]:=Obj[New].Name;
      save(0,ID,1,true,false);
      end
    else begin  //按下Ctrl则合并两点
      if(New=1)then begin //迭代的父对象不能合并到原点
        for i:=ID+1 to ObjCount do begin
          if(Obj[i].Kind=13)then
            for j:=0 to LinkTime do
              if(Obj[i].Link[j]=ID)then exit;
          end;
        end;
      save(3,ID,1,false,true);
      n:=getSonNum(ID,ObjCount);//统计子对象数目
      if(n>0)then begin
        for i:=0 to n-1 do Obj[JoinLink[i,0]].Hot:=true; //标记子对象
        save(3,ID,n,false,true);//缓存Hot对象的Undo数据
        for i:=0 to n-1 do begin
          Obj[JoinLink[i,0]].Link[JoinLink[i,1]]:=New;
          Obj[JoinLink[i,0]].LinkName[JoinLink[i,1]]:=Obj[New].Name;
          end;
        end;
      Obj[ID].DelID:=ID;
      save(3,ID,n,true,false);
      end;
    end
  else if(Mode>1)and((Link[0]>0)or(Link[1]>0))then begin //从线上分离
    save(0,ID,1,false,true);
    CleanLink(ID,0); //for i:=0 to LinkTime do begin Link[i]:=0; LinkName[i]:=0; end;
    Mode:=1; U:=false;
    for i:=0 to LayerTime do ObjShow[i]:=true;
    p0.x:=p0.x+0.5; p0.y:=p0.y+0.5;
    save(0,ID,1,true,true);  //保存编辑后的数据
    Edited:=true;
    end
  else if(Mode=1)and(New=0)then begin //从点上分离
    k:=ID; if(ID=1)then k:=10;
    if(ID=1)then with Obj[10] do begin
      Kind:=1; Mode:=1; S:=Obj[1].S; W:=Obj[1].W; Color:=Obj[1].Color;   p0:=cgVector(0,0,0);
      TagN:=Obj[1].TagN; TagS:=Obj[1].TagS; TagC:=Obj[1].TagC;
      end;//ID=1 从原点上分离
    n:=getSonNum(ID,ObjCount);//统计子对象数目
    for i:=1 To n-1 do begin
      inc(ObjCount,1);
      for j:=ObjCount DownTo k+i do Obj[j]:=Obj[j-1]; // 插入新的点
      with Obj[k+i] do begin //添加自由点
        if(ID=1)then for j:=0 to LayerTime do ObjShow[j]:=true; //从原点上分离
        Name:=getObjName(1);
        parent:=k+i;  
        Tag:=getTag(k+i);  texTag:=0;
        mainList:=glGenLists(1);  seleList:=glGenLists(1);
        t:=i*towPi/(n-1); //分布角度
        p0.x:=Obj[k].p0.x+cos(t);
        p0.y:=Obj[k].p0.y+sin(t);
        DelID:=k+i; //删除标志
        end;
      end;
    for i:=1 to n-1 do Obj[JoinLink[i,0]+n-1].Hot:=true; //标记子对象
    save(3,ID,n,false,false);//缓存Hot对象的Undo数据
    for i:=1 to n-1 do begin
      Obj[JoinLink[i,0]+n-1].LinkName[JoinLink[i,1]]:=Obj[k+i].Name;
      Obj[k+i].DelID:=0; //插入的点
      end;
    save(3,ID,n,true,false);
    upDateLink(ObjCount, true); //刷新链接
    ObjListUpdate(11,true);
    for i:=11 to ObjCount do Obj[i].Edited:=true;
    end;
  end;//with
  bDotJoin:=false;
  reRelate(11,ObjCount, false,false,false);
  SetProjection(true,false, 0);
end;
//======================= 粘贴数值纹理 ============================
procedure TfrmMain.menPasteTextureClick(Sender: TObject);//
  var a,b :integer;   Key:word;
begin
  if(SelRec[0]=1)and(SelRec[4]=1)and Clipboard.HasFormat(CF_BITMAP) then begin
    Key:=86;  FormKeyDown(nil, Key, [ssCtrl]); //粘贴图片
    end;
  if(SelRec[0]=2)and(SelRec[4]=1)and(SelRec[10]+SelRec[11]=1) then begin
    a:=SelRec[21];  b:=SelRec[22];   if(Obj[b].Kind=4)then SwapI(a,b);
    Obj[a].Link[10]:=b;  Obj[a].LinkName[10]:=Obj[b].Name;
    Obj[a].D:=true;
    Obj[a].sImage.sFormat:='';  Obj[a].sImage.sData:='';  Obj[a].info[0]:='';
    ReRelate( a, ObjCount, false,false,false);
    end;
end;

function DotAtCurve( a,b:integer; var N,aa,j:integer; asCircle:boolean):TcgVector;
  var i:integer;   nL,vL,xL :single; //aa:最接近pp的点，j:最接近pp的另一点
      pp,pc,pd,pv :TcgVector; isFooter:boolean;
begin
  pp:=Obj[a].p0;
  nL:=Obj[a].L;
  if(Obj[b].Kind=3)and asCircle then nL:=Obj[a].L/IIFf(Obj[a].Deg,360,towPi);//圆上的约束点
  aa:=0; j:=0;  result:=cgVector(0,0,0);   isFooter:=false;
  N:=high(LocaVct[b]);//曲线的点数  and(Obj[b].H=0)
  if(N<1)or EP(LocaVct[b,N].w)then exit;
  vL:=LocaVct[b,N].w;  //曲线总长
  if(Obj[a].Kind=18)
    and((Obj[b].Kind<>3)or(Obj[b].Kind=3)and(Obj[b].H=0))then begin //基点是曲线的约束点
    aa:=1;
    while(aa<=N)and( (LocaVct[b,aa].w/vL)<nL) do inc(aa);//
    if(cgDistance(pp,LocaVct[b,aa-1])<cgDistance(pp,LocaVct[b,aa]))then dec(aa);
    end
  else for i:=0 to N-1 do begin //计算最近的轨迹点
    xL:=cgDistance(pp, LocaVct[b,i]);
    if xL<vL then begin vL:=xL; aa:=i; end;
    end;
  pc:=LocaVct[b,aa];
  if(aa>0)then isFooter:= cgFooterAtLine(pp,LocaVct[b,aa-1],pc, pd, true);
  if isFooter then begin pc:=pd; j:=-1; end;
  if(aa<N)and(not isFooter)and cgFooterAtLine(pp,LocaVct[b,aa+1],pc, pd, true)
    then begin pc:=pd; j:=1; end;  //
  if(Obj[b].Kind=3)and(Obj[b].Mode<3)and(aa=0)
    and(not isFooter)and cgFooterAtLine(pp,LocaVct[b,N-1],pc, pd, true)
    then begin pc:=pd; j:=-1; end;
  result:=pc;
end;
procedure TfrmMain.DrawProjecteLines( ID:integer); //投影变换的投影线
  var aa,cc, i,j,mm,M,N:integer;  tempC:TcgColorF;  bb:boolean;
begin //
  with Obj[ID] do begin
  if(Mode<>7)then exit;
  aa:=Link[0];  cc:=Link[2];
  bb:=U and(Obj[cc].Kind=2)or(cc>10)and(Obj[cc].Kind=1);  //U 点光
  tempC:=color; tempC.A:=1;  glColor4fv( @tempC);//
  glDisable(GL_LIGHTING);  glEnable( GL_LINE_STIPPLE);
  glLineWidth(1);   glLineStipple( 1, stLineStyle[1] ); //设置线形
  glBegin(GL_LINES);
  if(Kind=1)then begin
    if bb then begin glVertex3fv(@Obj[cc].p0);  glVertex3fv(@p0); end
          else begin glVertex3fv(@Obj[aa].p0);  glVertex3fv(@p0); end;
    end
  else if(Kind=2)then begin
    if bb then begin glVertex3fv(@Obj[cc].p0);  glVertex3fv(@p0);
                     glVertex3fv(@Obj[cc].p0);  glVertex3fv(@p1); end
          else begin glVertex3fv(@Obj[aa].p0);  glVertex3fv(@p0);
                     glVertex3fv(@Obj[aa].p1);  glVertex3fv(@p1); end;
    end
  else if(Kind=4)then begin
    M:=high(LocaVct[ID])-1;
    for i:=0 to M do
      if bb then begin glVertex3fv(@Obj[cc].p0);    glVertex3fv(@LocaVct[ID,i]); end
            else begin glVertex3fv(@LocaVct[aa,i]); glVertex3fv(@LocaVct[ID,i]); end;
    end
  else if(Kind=6)then begin
    mm:=0;
    M:=high(FaceVct[aa]);
    if(Obj[parent].Mode=5)then dec(M); //凸多面体
    if(Obj[parent].Mode=3)and(Obj[parent].S in[2,12,6,4,14])then begin dec(M); inc(mm); end; //正六面体 正十二面体 长方体 不画上下低中点的投影线
    N:=high(FaceVct[aa,0]);
    for j:=mm to M do for i:=0 to N do
      if bb then begin glVertex3fv(@Obj[cc].p0);       glVertex3fv(@FaceVct[ID,j,i]); end
            else begin glVertex3fv(@FaceVct[aa,j,i]);  glVertex3fv(@FaceVct[ID,j,i]); end;
    end;
  glEnd;//GL_LINES
  end;//with Obj[ID]
  glEnable(GL_LIGHTING);  glDisable( GL_LINE_STIPPLE);  //关闭线形
end;
//======================= 1 点  =============================
procedure TfrmMain.Pointe( ID:integer; bDraw,bList,bOnlyDraw:boolean);
  var t,t1, x,y,z, aa,bb,cc, aR,bR :single;     //bRand用于迭代，随机产生约束点位置
      i,j,k, a,b,c,dd,ee,ff,gg, Ka,Kb,Kc, ma,mb, va,vb, M,N, listID,dotNum :integer; //dotNum交点数量
      pa,pb,pc,pd,pe,pf, px,py,pz, pp,dp, na,nb,nc :TcgVector;
      bC,bD,bbb, OK, isEven :boolean;  //Even 偶数
      mAmbient :TcgColorF;//材料环境色
      Vct:array[0..32]of TcgVector; //交点位置
      sinA,cosA,sinT,cosT :single;
  label OnlyDraw,SecondDot;
  procedure getLineBox(pa,pb:TcgVector; var t,b:TcgVector);
    begin t:=cgMax(pa,pb);  b:=cgMin(pa,pb);
    end;
  procedure getPlaneBox(pc,pd,pe,pf:TcgVector; var t,b:TcgVector);
    begin t:=cgMax(pc,pd);  t:=cgMax(t,pe);  t:=cgMax(t,pf);
          b:=cgMin(pc,pd);  b:=cgMin(b,pe);  b:=cgMin(b,pf);
    end;
  function LineFaceCanCross(pa,pb, pc,pd,pe,pf :TcgVector):boolean;
    var t1,b1,t2,b2:TcgVector;  //直线平面是否有相交的可能
  begin
    getLineBox(pa,pb, t1,b1);
    getPlaneBox(pc,pd,pe,pf, t2,b2);
    result:=not((t2.x<b1.x)or(t2.y<b1.y)or(t2.z<b1.z)
              or(t1.x<b2.x)or(t1.y<b2.y)or(t1.z<b2.z));
    end;
  function TowLineCanCross(pa,pb,pc,pd :TcgVector):boolean;
    var ka,kb,kc,kd, i:integer; //俩线段是否有相交的可能
  begin result:=true;
    for i:=1 to 3 do begin
      ka:=cgCheckSide(pa, pc,pd, i); kb:=cgCheckSide(pb, pc,pd, i);  result:=(ka*kb)<=0;
      if not result then exit;
      kc:=cgCheckSide(pc, pa,pb, i); kd:=cgCheckSide(pd, pa,pb, i);  result:=(kc*kd)<=0;
      if not result then exit;
      end;
    end;//function
  //直线与曲线的交点 pa,pb直线的端点 b曲线 pp,pq交点
  function LineCurveCross(ID,b,Num:integer; pa,pb:TcgVector; var pp:TcgVector; OneCross:boolean):integer; //返回交点数
    var i,N :integer; vA,vB, pc,pd,pTemp :TcgVector; OK:boolean;  //OneCross:只求一个交点
  begin
    N:=high(LocaVct[b]);  //曲线点数
    result:=0;  i:=0;   OK:=false;  pTemp:=pa;
    repeat
      if(Obj[b].Kind in[3,4])or aLink[b,i+1]then begin //  and aLink[b,i]
        pc:=LocaVct[b,i];   pd:=LocaVct[b,i+1];
        OK:= TowLineCanCross(pa,pb, pc,pd );    //俩线段是否可能相交
        if OK then begin
          vA:=cgVecSub(pa,pb);  vB:=cgVecSub(pc,pd);
          pp:=cgTowLineCross(pa,pc, vA,vB); //计算交点
          OK:=cgAt2Dot(pp,pc,pd)and not cgVecComp(pp,pTemp);//两线段共线时交点可能在曲线段之外
          end;
        if OK then begin
          pp.w:=i;    if not OneCross then Vct[result+Num]:=pp;
          pTemp:=pp;  inc(result);
          end;
        end;
      inc(i);
      until (i>=N)or(result>31)or OneCross and(result>0);
    end;
  //俩曲线之交点
  function TowCurveCross(ID,a,b, larger :integer; OneCross:boolean):integer;
    var i,M,N, bK :integer; pa,pb,pp :TcgVector;
  begin //Lst.Clear;
    N:=high(LocaVct[b]);    bK:=Obj[b].Kind;
    cgSetPrecision(0.0001);
    i:=0;   result:=0;
    repeat //
      pa:=LocaVct[b,i];   pb:=LocaVct[b,i+1]; //
      if(bK in[5,15,16,17,19])and(not alink[b,i+1])then M:=0 //轨迹线 相贯线 函数曲线 不可视线段不作交点
        else M:= LineCurveCross(ID,a,result+1, pa,pb,pp, OneCross);
      if(M>0)and((bK in[3,4,15,17,19])or(bK in[5,16])and(cgDistance(pa,pb)<Obj[b].H))
        then begin Vct[result]:=pp; inc(result,M); end;
      inc(i);
      until (i=N) or (result>larger);
    cgSetPrecision(0.00000001);
    end;
  //直线与曲面之交点
  function LineFaceCross(ID,b:integer; pa,pb:TcgVector; var pp:TcgVector; CrossNum:integer):integer;
    var i,j, M,N :integer; pc,pd,pe,pf,na,nc :TcgVector; OK,isImplicit :boolean;
  begin
    isImplicit:=(Obj[b].Kind=9)and(Obj[b].Mode=13);//隐函数曲面
    M:= high(FaceVct[b]);  N:= high(FaceVct[b,0]); if(isImplicit)then N:=1;
    na:=cgVecSub(pa,pb);
    j:=0; result:=0;
    repeat //遍历曲面的每一个网格
      i:=0;
      repeat
        if isImplicit then begin
          pc:=FaceVct[b,j,0];   pd:=FaceVct[b,j,1];
          pe:=FaceVct[b,j,2];   pf:=FaceVct[b,j,2];
          end
        else if(Obj[b].Kind=7)and(Obj[b].Mode=2)and(Obj[Obj[b].Link[0]].Kind=1)then
          begin //点-线之直纹曲面
          pc:=FaceVct[b,j,  i  ];   pf:=FaceVct[b,j+1,i  ];
          pe:=FaceVct[b,j+1,i+1];   pd:=FaceVct[b,j,  i+1];
          end
        else begin
          pc:=FaceVct[b,j,  i  ];   pd:=FaceVct[b,j+1,i  ];
          pe:=FaceVct[b,j+1,i+1];   pf:=FaceVct[b,j,  i+1];
          end;
        if LineFaceCanCross(pa,pb, pc,pd,pe,pf) then begin
          nc:= cgPlaneNormal( pc,pd,pe,pf, false);
          nc.w:=-cgDotProduct(pc,nc); //((abs(nc.x)>0.01)or(abs(nc.y)>0.01)or(abs(nc.z)>0.01))and
          OK:= cgLinePlaneCross(pa,na, pc,nc, pp); //pp 线面交点
          if OK then OK:= cgDotInBox(pp, pa,pb);
          if OK then OK:= cgDotInPlane(pp, pc,pd,pe,pf, false, not isImplicit);
          if OK then begin
            if(CrossNum>1)then Vct[result]:=pp;
            if(result>0)and cgVecComp(Vct[result],Vct[Result-1])
              then dec(result);
            inc(result);
            end;
          end;
        inc(i);
        until (i=N)or (CrossNum>0)and(result=CrossNum);
      inc(j);
      until (j=M)or (CrossNum>0)and(result=CrossNum);
    end;
  //曲线与平面之交点
  function CurvePlaneCross(ID, Num:integer):integer;
    var a,b,i,N:integer; pb,nb, pc,pd,nc, pp:TcgVector;  OK:boolean;
  begin //
    with Obj[ID] do begin
      a:=Link[0];   b:=Link[1];   pb:=Obj[b].p0;  nb:=Obj[b].Vec;
      end;
    N:=high(LocaVct[a]);
    i:=0; result:=0;
    repeat
      if(Obj[a].Kind=3)or aLink[a,i+1] then begin
        pc:=LocaVct[a,i];   pd:=LocaVct[a, i+1];  nc:=cgVecSub(pc,pd);
        OK:=cgLinePlaneCross(pc,nc, pb,nb, pp); //pp:直线(pa,pb)与平面的交点
        if OK then OK:=cgDotInBox(pp, pc,pd);//线段(pa,pb)是否与平面相交
        if OK then begin Vct[result]:=pp; inc(result); end; //第一个交点
        end;
      inc(i);
    until (i=N)or(result>Num);
  end;
  //曲线与曲面之交点
  function CurveFaceCross(ID, Num:integer):integer;
    var a,b,i,N:integer; pc,pd,pp:TcgVector;
  begin
    a:=Obj[ID].Link[0];   b:=Obj[ID].Link[1];
    N:=high(LocaVct[a]);
    i:=0; result:=0;
    repeat
      pc:=LocaVct[a,i];   pd:=LocaVct[a,i+1];
      M:=LineFaceCross(ID,b, pc,pd, pp, 1);//每次只寻找一个交点
      if(M>0)then begin
        Vct[result]:=pp;
        if(result>0)and cgVecComp(Vct[result],Vct[Result-1])
            then dec(result);
        inc(result);
        end;
      inc(i);
    until (result>Num) or (i=N);
  end;
  function CirclePlaneCross(ID:integer):integer;
    var pa,pb,pc, na,nb,nc :TcgVector;   t:single;
  begin
    result:=0;
    with Obj[ID] do begin
      pa:=Obj[Link[0]].p0;  na:=Obj[Link[0]].Vec;
      pb:=Obj[Link[1]].p0;  nb:=Obj[Link[1]].Vec;
      hide:=cgPlaneSection(pa,na, pb,nb, pc,nc); //pc,nc 相惯线之点和向量
      Obj[ID+1].Hide:=hide; if hide then exit;
      with Obj[10] do begin Kind:=2; Mode:=1; p0:=pc; Vec:=nc; end;//相贯线
      pc:=Footer(pa, 10,true);
      hide:=pc.w>abs(Obj[Link[0]].L); //圆心在相贯线上的垂足
      Obj[ID+1].Hide:=hide; if hide then exit;
      t:=sqrt(sqr(Obj[Link[0]].L)-sqr(pc.w));  //交点至垂足的距离
      p0:=cgVecSubMult(pc,nc,t);
      Obj[ID+1].p0:=cgVecAddMult(pc,nc,t); //第二个交点
      end;//with
    result:=2;
  end;
  //曲线上的点
  function DotInLoca( ID,b:integer; tL:single):TcgVector;
    var i,M:integer; t:single;
  begin result:=cgVector(0,0,0);
    with Obj[ID] do begin
      M:=high(LocaVct[b]);  hide:=(M<1); if hide then exit; //轨迹点数
      if(tL=0)then begin //约束距离
        if(abs(L)>1)then L:=L-trunc(L); //大于1则取小数
        if(L<0)then L:=1+L;
        t:=L*LocaVct[b,M].w;  // L为约束比列
        end
      else               //比例距离
        t:=tL*LocaVct[b,M].w;
      for i:=1 to M do if(LocaVct[b,i].w>=t)then break;
      t:=t-LocaVct[b,i-1].w;
      if(LocaVct[b,i].w<>LocaVct[b,i-1].w)then t:=t/(LocaVct[b,i].w-LocaVct[b,i-1].w);
      Vec:=cgVecSub( LocaVct[b,i], LocaVct[b,i-1]);
      result:=cgVecAddMult( LocaVct[b,i-1], Vec,t );
      end;
    end;
  //函数曲面上的点
  function DotInFace( ID,b:integer):TcgVector;
    var i,j,M,N:integer;  dL,dR,dT, tL,tR:single;  pa,pb,pc,pd,pp:TcgVector;
  begin result:= cgVector(0,0,0);
    with Obj[ID]do begin
    if Mask then //曲面边缘上的点
      result:= DotInLoca(ID,b, 0)
    else begin   //曲面上的点
      N:=high(FaceVct[b]); M:=high(FaceVct[b,0])-1;   //网格数
      dL:=1/N;  i:=trunc(L/dL); tL:=(L-i*dL)/dL;
      dR:=1/M;  j:=trunc(R/dR); tR:=(R-j*dR)/dR;
      pp:=cgVecSub(FaceVct[b,i+1,j  ], FaceVct[b,i,j  ]); pa:=cgVecAddMult( FaceVct[b,i,j  ], pp, tL);
      pp:=cgVecSub(FaceVct[b,i+1,j+1], FaceVct[b,i,j+1]); pb:=cgVecAddMult( FaceVct[b,i,j+1], pp, tL);
      pp:=cgVecSub(FaceVct[b,i  ,j+1], FaceVct[b,i,j  ]); pc:=cgVecAddMult( FaceVct[b,i,j  ], pp, tR);
      pp:=cgVecSub(FaceVct[b,i+1,j+1], FaceVct[b,i+1,j]); pd:=cgVecAddMult( FaceVct[b,i+1,j], pp, tR);

      result:=cgTowLineCross(pa,pc, cgVecSub(pb,pa),cgVecSub(pd,pc)); //两直线之交点
      end;
    end;
    end;
begin
  with Obj[ID] do begin
  if(ID=1)then goto OnlyDraw;
  a:=Link[0]; b:=Link[1]; c:=Link[2]; dd:=Link[3]; ff:=Link[5]; gg:=Link[6];
  if(Mode=4)and D and(Obj[ID-1].Link[0]=a)and(Obj[ID-1].Link[1]=b)then begin
    if hide then exit else goto OnlyDraw;//第二个交点
    end; //
  hide:= Obj[a].hide or Obj[b].hide or(dd>0)and(Obj[dd].hide)
    or(c>0)and(Obj[c].hide)and(Mode<>4) or(gg>0)and(Obj[gg].hide); //关联构件是否存在
  if(Link[12]>0)then Color.A:=Obj[Link[12]].L;
  if(Mode=4)then H:=getCrossNum(Obj[a].Kind,Obj[b].Kind);//and(S>0)then for i:=1 to S do Obj[ID+i].Hide:=hide;
  if hide then begin
    if(Mode=4)then for i:=1 to trunc(H)do Obj[ID+i].Hide:=true;
    exit; // begin p0:=Obj[b].p0; exit; end;
    end;
  pa:=Obj[a].p0;  Ka:=Obj[a].Kind;   Na:=Obj[a].Vec;   Ma:=Obj[a].Mode;
  pb:=Obj[b].p0;  Kb:=Obj[b].Kind;   Nb:=Obj[b].Vec;   Mb:=Obj[b].Mode;
  pc:=Obj[c].p0;  Kc:=Obj[c].Kind;
  if Mode>2 then begin dp:=cgVecSub(pb,pa); end;// cgNormalize(dp);
  case Mode of
  1:begin  //自由点
    if a>0 then p0.x:=Obj[a].L;
    if b>0 then p0.y:=Obj[b].L;
    if c>0 then p0.z:=Obj[c].L;
    L:=cgVecLength(p0);
    end;
  2:begin  //约束点
    if a>0  then H:=getLinkVar( a, pb); //步长H
    if c>0  then L:=getLinkVar( c, pb); //约束值L
    if ff>0 then R:=getLinkVar(ff, pb); //约束值R
    if(Link[3]>10)then p2.x:=getLinkVar(Link[3], pb);
    if(Link[4]>10)then p2.z:=getLinkVar(Link[4], pb);
    if U and not( (kb=4) or(kb=6) or(kb=3)and(mb=1) )then //将点限制在起终值内   and(MarkObj=ID)
      Limit( L, p2.x,p2.x, p2.z,p2.z);
    case kb of
      1:if(mb=6)then begin //等分点上的点
          M:=high(LocaVct[b]); N:=round(L);
          p0:=LocaVct[b, N];
          end
        else
          if not bAdd then p0:=Obj[b].p0;
      2:begin //直线上的点
        if(Obj[b].Mode<>1)and EP(Obj[b].L) then
          p0:=Obj[b].p0
        else begin
          if D then t:=L  //沿直线的约束点 D:定长
               else t:=L*cgDistance(Obj[b].p4, Obj[b].p5);
          p0:=cgVecAddMult(Obj[b].p4, nb, t);
          end;
        end;
      3:case mb of
        1,2:begin
          if Deg then aR:=L/oneArc else aR:=L;
          if Mask then begin//圆内部的点
            if(R>Obj[b].L)then R:=Obj[b].L;
            p0:= DotInCircle( Obj[b].p0, b, aR, R, Obj[b].H, Obj[b].R ); //沿[点法圆]
            end
          else begin //圆周上的点
            bR:=Obj[b].R;  if(Obj[b].Mode=1)and(Obj[b].Deg)then bR:=bR/oneArc; //
            p0:= DotInCircle( Obj[b].p0, b, aR, Obj[b].L, Obj[b].H, bR ); //沿[点法圆]
            end;
          end;
        3:begin  //点法弧上
          aR:=L*Obj[b].H; if Obj[b].D then aR:=aR/Obj[b].L;
          if D then aR:=L/Obj[b].L;
          if(Obj[b].U)then aR:= towPi-aR; //反向圆弧上的点
          p0:= DotInCircle(  Obj[b].p0, b, Obj[b].R+aR, Obj[b].L, 0,0);  //延[点法弧]
          end;
        4:begin //三点弧上
          if(trunc(Obj[b].Vec.w)=999)then begin //半径无限大
            nc:=cgNormalVec(LocaVct[b,1],LocaVct[b,0]);
            if D then t:=L  //沿直线的约束点 D:定长
                 else t:=L*LocaVct[b,2].w;
            p0:=cgVecAddMult(LocaVct[b,0], nc, t);
            end
          else begin
            aR:= IIFf(D, L/Obj[b].L, L*Obj[b].H);
            p0:= DotInCircle( Obj[b].p0, b, Obj[b].R+aR, Obj[b].L, 0,0);  //延[三点弧]
            end;
          end;
        7,8,9,10,11,12,15: //变换后的圆不一定是正圆，故用"比例"定义约束点
          p0:=DotInLoca(ID,b,0);
      {  15:begin //反演圆上
          if(Obj[b].L<999)then DotInCircle( Obj[b].p0, b, L, Obj[b].L, 0,0);
          if(Obj[b].L=999)then p0:=DotInLoca(ID,b,0);
          end; }
        end; //DotInCircle( 圆心 法线 圆周角 半径)
      4:begin  //平面上的点
        if Mask then  //边界上的点
          p0:=DotInLoca(ID,b,0)
        else begin    //内部的点
          px:=LocaVct[b,0]; py:=LocaVct[b,1]; pz:=LocaVct[b,2]; //  Obj[b].p0; py:=Obj[b].p1; pz:=Obj[b].p2;//
          na:=cgNormalVec(pz, py); //后两点形成的直线
          nb:=cgNormalVec(px, Obj[b].p5); //第一点至直线的垂线向量
          pc:=cgVecAddMult(py, na, L);
          p0:=cgVecAddMult(pc, nb, R);  //Obj[b].p4;//
          N:=trunc(Obj[b].W); if(N=99)then N:=4; if(N>100)then N:=N-100;//W>100 正n边形
          bbb:=cgDotInPolygon(p0, LocaVct[b], N);  //是否在边界内
          if U and not bbb then begin  //限制在边界内
            N:=high(LocaVct[b])-1;
            pp:=LocaVct[b,0];   p0.W:=cgDistance( p0, pp);
            for i:= 0 to N do begin
              pc:=cgDotNearestLine( p0, LocaVct[b,i], LocaVct[b,i+1] );//最近点
              if(pc.w<p0.w)then begin pp:=pc; p0.w:=pc.w; end;
              end;
            p0:=pp;
            cgFooterAtLine(pp, pz,py, pa, false);//pa是垂点
            L:=cgDistance(pa,py);
            R:=cgDistance(pp,pa);
            end;
          end;
        end;
      5,15,16,17,19:begin //曲线上的点
        if trunc(Obj[b].L)=0 then
          p0:=Obj[Obj[b].Link[1]].p0
        else begin
          if(L=0)then p0:=LocaVct[b,0]
          else if(L=1)then p0:=LocaVct[b, high(LocaVct[b])]
          else p0:=DotInLoca(ID,b,0);

          end;
        end;
      9:p0:= DotInFace(ID,b);  //函数曲面上的点
      6:begin   //实体上的点
        x:=0; z:=0; y:=Obj[b].L; //母体半径
        if(Obj[b].Mode=15)and(y=999)then begin //模拟成平面的球
          M:=high(FaceVct[b]);
          na:=cgNormalVec( FaceVct[b,0,M], FaceVct[b,0,0]);
          px:=cgVecAddMult(FaceVct[b,0,0], na, L*na.w/TowPi);
          na:=cgNormalVec( FaceVct[b,M,0], FaceVct[b,0,0]);
          p0:=cgVecAddMult(px,na, (R+halfPi)*na.w/Pi);
          end
        else begin
          if(Obj[b].Mode in[1,6,15])then begin //球面上的点
            cosA:=cos(L);           sinA:=sin(L)*(1-Obj[b].W);
            cosT:=Obj[b].L*cos(R);  sinT:=Obj[b].L*sin(R)*(1-Obj[b].H);
            X:=cosT*sinA; Y:=cosT*cosA;
            pa:=cgVector( X*cos(Obj[b].R)-Y*sin(Obj[b].R), X*sin(Obj[b].R)+Y*cos(Obj[b].R), sinT );
            MoveDotPos( pa, Obj[b].p0, Obj[b].Vec);
            p0:=pa;
            end
          else begin //圆台上的点
            if(Obj[b].Mode=2)then begin z:=-R*Obj[b].H;  x:=y*(1-R*(1-Obj[b].W)); end; //沿圆台面
            pa:=cgVecSubMult(Obj[b].p0, Obj[b].Vec, z); //约束点所在圆心
            p0:=DotInCircle( pa, b, Obj[b].R+L, x, 0,0);
            end;
          end;
        end;
      13:begin //迭代像上的点
        M:=high(LocaVct[b]); N:=round(L); if(N>M)then N:=M;
        p0:=LocaVct[b, N];
        end;
      end; //case
    p0.w:=1;//拖动时的约束点p0.w会变成Nan，不知什么原因
    end;
  3:begin //最近点
    if(kB=2)then begin //线段上的最近点
      p0:=cgDotNearestLine(pa, Obj[b].p0, Obj[b].p1);
      end
    else if(kB=3)and EP(Obj[b].H)then begin //正圆周上的最近点
      pp:=Footer( pa, b, false); //圆周平面上的垂点
      t:=cgDistance( pb, pp);    //垂点至圆心的距离
      if EP(t)then p0:= LocaVct[b,0]
              else p0:=cgVecAddMult(pb, cgVecSub(pp,pb), Obj[b].L/t)
      end
    else begin //曲线上的最近点
      if(kB=4)then begin
        p0:= Footer(pa, b, false); //目标点在平面上的投影
        N:=trunc(Obj[b].W); if(N=99)then N:=4; if(N>100)then N:=N-100;//W=99矩形  W>100 正n边形
        if cgDotInPolygon(p0, LocaVct[b], N) then goto OnlyDraw; //被移动点限制在平面内
        end;
      N:=high(LocaVct[b])-1;
      p0:=LocaVct[b,0];   p0.W:=cgDistance( p0, pa);
      for i:= 0 to N do begin
        pc:=cgDotNearestLine( pa, LocaVct[b,i], LocaVct[b,i+1] );
        if(pc.w<p0.w)then p0:=pc;
        end;
      end;
    end;
  4:begin  //交点
    if(kA>kB)and(kA in[2,3,4,5,15,17,19])and(kB in[2,3,4,5,15,17,19])then begin //忘了作何用。会影响曲线与曲线曲面之交点
      SwapI(a,b); SwapI(kA,kB); SwapI(mA,mB);  cgVecSwap(pa,pb); cgVecSwap(na,nb);
      end;
//第一个构件为直线或棱边
    if Ka=2 then begin
      pc:=cgVecAddMult( pa, na,50); //将直线向两端方向延伸
      pd:=cgVecSubMult( pa, na,50);
      case Kb of
      2:begin //========= 俩直线的交点
        H:=0; R:=0; k:=0; j:=0; //H实际交点数 R总交点数
        nc:=na; cgInvertVec(nc);
        hide:=cgVecComp(na,nb) or cgVecComp(nc,nb);
        if not hide then hide:=cgForePointInOnePlane(pa,pb,Obj[a].p1,Obj[b].p1);//四点是否共线
        if hide then begin p0:=cgVector(0,0,0); exit; end;
        if not hide then p0:=cgTowLineCross2(pa, pb, na,nb);
        cgSetPrecision(0.000001);
        if U then  //限制在线段内
          hide:=not(cgDotInBox(p0, pa,Obj[a].p1)and cgDotInBox(p0, pb,Obj[b].p1));
        if not hide then k:=1;
        cgSetPrecision(0.00000001);
        end; //if
      4:if not D then begin //=========== 直线与平面的交点
        H:=1; R:=1; k:=1; j:=1; //H实际交点数 R总交点数 两个交点
        for i:= 0 to j do Obj[ID+i].D:=(i>0);
        hide:=not cgLinePlaneCross(pa,na, pb,nb, pp); Vct[0]:=pp; //pp:交点
        if hide then begin //直线平行于平面
          pp:=footer(pa, b, true);
          hide:=abs(pp.w)>0.00001; //不共面
          if hide then begin p0:=pa; exit; end;
          k:=LineCurveCross(ID,b,0, pa, Obj[a].p1, pp, false);
          end;
        Hide:=k<1;  Obj[ID+1].Hide:=(k<2);  if hide then exit;
        Obj[ID].p0:=pp;  Obj[ID+1].p0:=Vct[1];
        if U then begin //限制
          hide:=not cgAt2Dot(pp, pa,Obj[a].p1); //是否在线段内 //
          if not hide then   //是否在多边形内
            hide:=not cgDotInPolygon(pp, LocaVct[b], trunc(Obj[b].W));
          end;
        if hide then begin p0:=pa; exit; end;
        end;
      3:if(not D)then begin //========== 直线与圆的交点 第二个交点一并计算
        for i:= 0 to 1 do Obj[ID+i].D:=(i>0);
        k:=0; H:=1; R:=1; j:=1; //实际交点数 总交点数  两个交点
        bC:=EP(cgDotProduct(na,nb)); //直线向量和圆法线垂直
        bD:=EP(Footer(pa,b,true).w);//直线起点位于圆所在平面
        hide:=bC and not(bD);
        if(bC and bD)then begin //平行且同平面
          if(mA=4)and(Obj[a].Link[1]=b)then begin //切线与圆
            p0:=Obj[a].p5;    k:=1;   Obj[ID+1].D:=true;  Obj[ID+1].Hide:=true;
            goto OnlyDraw;
            end
          else
          if(mb in[1,8,9,10,11,12])and(Obj[b].H=0)
            or(mb=2)or(mb=15)and(Obj[b].L<999)then begin //直线与正圆
            k:=cgLineCircleCross(pa,na, pb,Obj[b].L, px,py);
            hide:=k=0;
            Vct[0]:=px; Vct[1]:=py;
            end
          else if(mb=15)and(Obj[b].L=999)then begin //直线与直线型的反演圆
            //直线的起终点p1,p2和法线p4均在Circle过程中赋值
            pb:=Obj[b].p1;  nb:=Obj[b].p4;
            nc:=na; cgInvertVec(nc);
            hide:=cgVecComp(na,nb) or cgVecComp(nc,nb);
            if not hide then hide:=cgForePointInOnePlane(pa,pb,Obj[a].p1,Obj[b].p2);//四点是否共线
            if hide then begin p0:=cgVector(0,0,0); exit; end;
            Vct[0]:=cgTowLineCross(pa, pb, na,nb);  Vct[1]:=Vct[0];
            k:=2;
            end
          else //直线与椭圆
            k:= LineCurveCross(ID,b,0, pc,pd,pp, false);
          end;
        Obj[ID+1].Hide:=hide; //if hide then exit;
        if(not bC)then begin //直线和圆异面，相当于跟平面相交
          hide:=not cgLinePlaneCross(pa,na, pb,nb, pp);
          Vct[0]:=pp; k:=1;  Obj[ID+1].D:=true;  Obj[ID+1].Hide:=true;
          end;
        end;
      6:if not D then begin //=== 直线与实体的交点
        S:=1; H:=1; k:=0; j:=1;
        Obj[ID+1].D:=true; Obj[ID+1].hide:=true;
        if(mb=7)and EP(cgDotProduct(na,nb))then hide:=true;//与投影平面平行
        if hide then begin Obj[ID+1].Hide:=true; p0:=pa; exit; end;
        if(mb=1)and(Obj[b].W=0)and(Obj[b].H=0)then begin //直线与正球体的交点
          pp:=Footer(pb, a, true); //球心在直线上的垂点
          hide:=pp.w>Obj[b].L;
          if not hide then begin
            t:=sqrt(sqr(Obj[b].L)-sqr(pp.w)); //垂点至交点的距离
            px:=cgVecSubMult(pp,na,t);   py:=cgVecAddMult(pp,na,t);
            Vct[0]:=px; Vct[1]:=py;
            end;
          k:=IIfi(hide,0,2);
          end //if ...
        else //一般实体
          k:= LineFaceCross(ID,b, pc,pd, pp, 2); //计算交点
        if k=1 then begin Vct[1]:=Vct[0]; k:=2; end;
        end; //kb=6
      5,7,9,15,16,17,19:if not D then begin //====== 直线与曲线曲面之交点
        if(mA=4)and(Obj[a].Link[1]=b)and(Obj[b].Kind=19)then begin //切线与椭圆
          p0:=Obj[a].p5;    k:=1;   for i:=1 to 3 do Obj[ID+i].Hide:=true;
          goto OnlyDraw;
          end
        else begin
          if(kb=19)then H:=3 else H:=31; //kb=19圆锥曲线与直线四个交点
          j:=trunc(H);
          for i:= 0 to j do Obj[ID+i].D:=(i>0); //共32个交点
          pb:=Obj[a].p1;
          cgSetPrecision(0.0001);
          if kb in[7,9]then k:= LineFaceCross( ID,b, pc,pd,pp, 32) //直线与曲面之交点
          else if(kb=19)and(Obj[a].Mode=4)and(Obj[a].Link[1]=b) //圆锥曲线切线的交点
            then begin Vct[0]:=Obj[a].p2; k:=1; end
            else k:= LineCurveCross(ID,b,0, pc,pd,pp, false);//直线与曲线之交点
          cgSetPrecision(0.00000001);
          for i:=1 to j do Obj[ID+i].Hide:= k<(i+1);
          if k>0 then for i:=0 to k-1 do Obj[ID+i].p0:=Vct[i];
          end;
        end;
      end; //case kb
      if not D and(k>0)and(kB in[3,4,6,15,16,17,19])then begin //交点顺序及限制 只分析前两个交点
        if(k>1)then Obj[ID+1].hide:=hide;// or Obj[ID+1].D;
        p0:=Vct[0];   px:=Vct[0];
        if(k=1)then py:=px else py:=Vct[1];
        if(k>1)then begin
          if(cgDistance(pc,px)<cgDistance(pc,py))
            then begin p0:=py; Obj[ID+1].p0:=px; end
            else begin p0:=px; Obj[ID+1].p0:=py; end;
          end;
        pb:=Obj[a].p1;
        if U then hide:=not cgAt2Dot(p0, pa,pb); //交点是否在线段内
        if(k>1)then with Obj[ID+1] do if U then hide:=not cgAt2Dot(p0, pa,pb); //交点是否在线段内
        end;
      if not D then for i:=0 to j do if not Hide then Obj[ID+i].Hide:= k<(i+1);

      end; //if Ka=2
//第一个构件为圆或平面
    if(not D)and(Ka=3)then begin
      j:=trunc(H); //总交点数
      for i:=0 to j do Obj[ID+i].D:=(i>0);
      if(Ka=3)and(Kb=3)then begin //====== 两圆的交点
        k:=0;
        bC:=(ma=1)and(Obj[a].H=0)or(ma=15); //or(ma>1)
        bD:=(mb=1)and(Obj[b].H=0)or(mb=15); //or(mb>1)
        if bC and bD then begin //俩正圆的交点 用解析法计算
          bbb:=cgVecParallel(na,nb); //   cgDotProduct(na, nb)=0则垂直，=1则平行
          hide:=not EP(cgDotProduct(na,dp))and bbb; //同向但不共面
          if hide then goto SecondDot;
          if bbb then begin //同面圆
            k:=cgTowCircleCross(pa,pb,na,Obj[a].L,Obj[b].L, px,py);
            hide:=k=0; if hide then goto SecondDot;
            p0:=px; Obj[ID+1].p0:=py;
            end
          else //异面圆的交点
            k:=CirclePlaneCross(ID);
SecondDot:
          end
{OK}    else begin //某一个圆为椭圆，用尺规法计算
          if(Obj[a].H>0)or(Obj[b].H=0)then SwapI(a,b);
          k:=TowCurveCross(ID, a,b, 4, true);
          if k>0 then for i:=0 to k-1 do Obj[ID+i].p0:=Vct[i];
          if(k>0)and(cgDistance(Obj[a].p0, LocaVct[b,0])<=Obj[a].L)then
            cgVecSwap(Obj[ID].p0, Obj[ID+1].p0); //若曲线起点在圆内则与第二点交换
          end;
        end; //ka=3 & kb=3
{OK}  if(Kb=4)then begin k:=0;  //=========圆/平面
        hide:=cgVecParallel(na,nb);  //俩法线是否相等
        if hide then begin //圆和平面平行
          pp:=footer(pa, b, true);
          hide:=abs(pp.w)>0.00001; //是否共面
          if hide then begin Obj[ID+1].hide:=hide; exit; end; //不共面则退出
          k:=TowCurveCross(ID, a,b, 20, false );
          if k>0 then for i:=0 to k-1 do Obj[ID+i].p0:=Vct[i];
          end
        else begin //圆和平面不平行
          if(mA=1)and(Obj[a].H=0)or(mA>1)then begin //正圆和平面的交点，用解析法计算
            edtTemp.Text  :=''; //见鬼，没有这个就不行
            k:=CirclePlaneCross(ID);
            end;
          if(mA=1)and(Obj[a].H<>0)then begin //椭圆和平面的交点，用尺规法计算
            k:=CurvePlaneCross(ID,1);
            hide:=(k=0); Obj[ID+1].hide:=hide;
            if(k>0)then begin
              px:=Vct[0]; py:=Vct[1];
              cgPublicVerticalLine(pa,na, pb,nb, pc,pd,nc); //公垂线
              pc:=cgVecAddMult( pc,nc, 100); //延长相惯线之端点
              if cgDistance(pc,px)>cgDistance(pc,py)
                then begin p0:=py; Obj[ID+1].p0:=px; end
                else begin p0:=px; Obj[ID+1].p0:=py; end;
              if U and(not hide)then with Obj[b] do   //是否在可视平面内
                Obj[ID].hide:=not cgDotInPlane(Obj[ID].p0, p0,p1,p2,p3, true,L>0);
              if Obj[ID+1].U and(not Obj[ID+1].hide)then with Obj[b] do   //是否在可视平面内
                Obj[ID+1].hide:=not cgDotInPlane(Obj[ID+1].p0, p0,p1,p2,p3, true,L>0);
              end;
            end;
          end;
        end; //ka=4 or kb=4
      if(Kb in[5,15,16,17,19])then begin //圆与曲线之交点
        k:=TowCurveCross(ID, a,b, trunc(H), true );
        if k>0 then for i:=0 to k-1 do Obj[ID+i].p0:=Vct[i];
        if(k>0)and(cgDistance(Obj[a].p0, LocaVct[b,0])<Obj[a].L)then begin
          cgVecSwap(Obj[ID].p0, Obj[ID+1].p0); //若曲线起点在圆内则与第二点交换
          if(k=1)then begin Obj[ID].Hide:=true; Obj[ID+1].Hide:=false; end;
          end;
        end;
  {OK}if(Kb in[6,7,9])then begin //圆与曲面之交点
        if kb=6 then j:=19 else j:=31;
        k:=CurveFaceCross(ID,j);
        for i:=0 to j do Obj[ID+i].Hide:= k<(i+1);
        if k>0 then for i:=0 to k-1 do Obj[ID+i].p0:=Vct[i];
        end;
      for i:=0 to j do Obj[ID+i].Hide:= k<(i+1);
      end;//ka=3
    if(not D)and(Ka in[4,5,15,16,17,19])then begin //曲线与曲线曲面之交点
      for i:=0 to trunc(H) do Obj[ID+i].D:=(i>0);
      if(ka=4)then
        k:=CurvePlaneCross(ID,31)           //平面与曲线之交点
      else if(kb in[3,5,15,16,17,19])then
        k:=TowCurveCross(ID, a,b, 31, true) //俩曲线之交点
      else if(kb in[6,7,9])then
        k:=CurveFaceCross(ID,31);           //俩曲面之交点
      for i:=0 to trunc(H) do Obj[ID+i].Hide:= k<(i+1);
      if k>0 then for i:=0 to k-1 do Obj[ID+i].p0:=Vct[i];
      end;
    if(k-1)>trunc(R) then R:=k-1; //实际交点数
    for i:=0 to trunc(R) do Obj[ID+i].L:=cgDistance(Obj[ID+i].p0 ,Obj[1].p0);//交点与原点之距
    end;//交点
  5:begin  //中点
    case Ka of
      1:if(c>0)and(Kc=1)then begin//三角形四心
          cgCenter( pa,pb,pc, pp,Vec, trunc(H));
          p0:=pp;
          end
        else
          p0:=cgVecMid(pa, Footer( pa, b, false)); //点/线面之中点
      2:if(Link[1]=0)then
          p0:=cgVecMid(Obj[a].p0,Obj[a].p1)
        else begin //两直线之中点
          if cgVecComp(na,nb)
            then pb:=Footer(pa,b, true)
            else cgPublicVerticalLine(pa, na, pb, nb, pa,pb,na); //公垂线
          p0:=cgVecMid(pa, pb);
          end;
      3,6:p0:=Obj[a].p0; //圆心 球心
      4:if(Obj[a].W=3)then begin //三角形四心
          cgCenter( LocaVct[a,0],LocaVct[a,1],LocaVct[a,2], pp,Vec, trunc(H));
          p0:=pp;
          end
        else
          p0:=Centroid(a); //平面中点
      end;
    end;
  6:begin //等分点
    if(c>10)then L:=Obj[c].L;   k:=trunc(L);  if(k<2)then k:=2;                       //等分数
    if(a>10)then H:=Obj[a].L;   if(H<1)then H:=1; if(H>k-1)then H:=k-1; j:=trunc(H);  //等分点
    setLength( LocaVct[ID], k+1); pc:=cgVecSub( Obj[b].p1, Obj[b].p0);
    if(Kb=2)then //直线上的等分点
      for i:= 0 to k-2 do
        LocaVct[ID,i]:= cgVecAdd( Obj[b].p0, cgVecScale(pc, (i+1)/k))
    else if(Kb=3)and EP(Obj[b].H)then //圆周上的等分点
      for i:= 0 to k-1 do
        LocaVct[ID,i]:= DotInCircle( Obj[b].p0, b, Obj[b].R+i*towPi/k, Obj[b].L, Obj[b].H,0)
    else if(Kb=19)and(Mb=1)and(trunc(Obj[b].Angle)=1)or(Kb=3)and not EP(Obj[b].H)or(Kb=4)then //椭圆曲线（平面）上的等分点
      for i:= 0 to k-1 do begin
        LocaVct[ID,i]:= DotInLoca( ID, b, (i+1)/k);
        end
    else                        //曲线上的等分点
      for i:= 0 to k-2 do
        LocaVct[ID,i]:= DotInLoca( ID, b, (i+1)/k);
    p0:=LocaVct[ID,j-1];
    end;
  7:begin p0:=transVec(ID, pa); //投影变换
    if U then case Kb of
      2:hide:=not cgDotInBox(p0, pb, Obj[b].p1);
      3:hide:=cgDistance(p0,pb)>Obj[b].L;
      4:hide:=not cgDotInPolygon(p0, LocaVct[b], trunc(Obj[b].W));
      end;
    end;
  8..12,15,16,20: p0:=transVec(ID, pa);//变换
  14:TransCustom(ID);            //自定义变换
  end;  //case Mode
OnlyDraw:
  if(ID>10)and(Link[6]>10)then color:= getColor(ID);//参数着色
  if bDraw then begin
    listID:=getTraceListID( ID, bAdd);
    if(Mode=6)and((Obj[b].Kind=3)or(Kb=19)and(Mb=1)or(Obj[b].Kind=4))
      then j:=1 else j:=2;//等分点
    if bList then glNewList( ListID, GL_COMPILE);  //建立显示列表
      mAmbient:=cgColorF( 1, 1, 1, Obj[ID].color.A ); //材料环境色
      glMaterialfv( GL_FRONT_AND_BACK, GL_DIFFUSE, @mAmbient);
      glColor4fv( @Color);
      glPointSize(W);  //glLineWidth(1);
      glDisable(GL_LIGHTING);
      if(S=0)then begin
        glBegin(GL_POINTS);
        if(Mode=6)then for i:= 0 to k-j do glVertex3fv(@LocaVct[ID,i])
                  else glVertex3fv(@p0);
        glEnd;
        end
      else begin
        if(Mode=6)then for i:= 0 to k-j do SolidPoint(LocaVct[ID,i], Mode,S,W, false)
                  else SolidPoint(p0, Mode,S,W, false);
        end;
      if(Mode=7)and D then DrawProjecteLines(ID); //投影线
    if bList then glEndList;
    if bList then begin //被选择状态
      getListID(seleList,1);
      glNewList(seleList, GL_COMPILE);
      glColor4fv(@Obj[1].ColorB);
      if(S=0)then begin //平面点
        glPointSize(W+ Obj[1].p5.w);
        glBegin(GL_POINTS);
        if(Mode=6)then for i:= 0 to k-j do glVertex3fv(@LocaVct[ID,i])
                  else glVertex3fv(@p0);
        glEnd;
        end
      else begin //球状点
        if(Mode=6)then for i:= 0 to k-j do SolidPoint(LocaVct[ID,i], Mode,S,W, true) //
                  else SolidPoint(p0, Mode, S,W, true);
        end;
      glEndList;
      end;
    if not bAdd and bList and Trace then setTraceList(ID);//痕迹
    end;  //if bDraw then for m ...
  end; //with
end;
//======================= 俩有限平面的交惯线 =============================
function TfrmMain.CrossTowPlane( a,b:integer; var paa,pbb:TcgVector):boolean;
  var n :integer;
  function getCross(pa,pb:TcgVector; var Plane:TmyObject; var pc:TcgVector):boolean;
    var pn:TcgVector;
  begin
    pn:=cgVecSub(pa,pb);
    result:=cgLinePlaneCross(pa,pn, Plane.p0, Plane.Vec, pc); //pc 交点
    if result then
      result:=cgDotInBox(pc, pa,pb);
    if result then with Plane do
      result:=cgDotInPlane(pc, p0,p1,p2,p3, true,L>0);
    end; //function
  procedure getCrossPoint(a,b:integer; var n:integer; var paa,pbb:TcgVector);
    var i,j:integer;   pc:TcgVector;
        pp :Array[0..4]of TcgVector;
  begin
    with Obj[a] do begin
      if L>0 then j:=3 else j:=2;
      pp[0]:=p0; pp[1]:=p1; pp[2]:=p2; pp[3]:=p3;
      if L>0 then pp[4]:=p0 else pp[3]:=p0;
      end;
    for i:=0 to j do begin
      result:=getCross(pp[i], pp[i+1], Obj[b], pc);
      if(result)then begin
        if(n=0)then begin paa:=pc; inc(n); end
               else if not cgVecComp(paa,pc) then
                    begin pbb:=pc; inc(n); end;
        end;
      if n>1 then exit;
      end;
    end;
  function canCross(a,b:integer):boolean; //俩平面是否有相交的可能
    var t1,b1,t2,b2:TcgVector;
    procedure getBox(id:integer; var t,b:TcgVector);
      begin with Obj[id] do begin
        t:=cgMax(p0,p1); t:=cgMax(t,p2); t:=cgMax(t,p3);
        b:=cgMin(p0,p1); b:=cgMin(b,p2); b:=cgMin(b,p3);
        end;
      end;
  begin
    getBox(a, t1,b1);   getBox(b, t2,b2);
    result:=not((t2.x<b1.x)or(t2.y<b1.y)or(t2.z<b1.z)
              or(t1.x<b2.x)or(t1.y<b2.y)or(t1.z<b2.z));
    end;//function
begin n:=0; //有效端点数
  result:=not cgVecComp( Obj[a].Vec, Obj[b].Vec); //俩平面是否平行
  if not result then exit;
  if canCross(a,b) then begin
    getCrossPoint(a,b, n,paa,pbb);
    if n<2 then getCrossPoint(b,a, n,paa,pbb);
    result:= n>1;
    end
  else result:=false;
end;
//================ 平面与曲面的交惯线 ====================
function TfrmMain.CrossPlaneFace( ID:integer):integer;
  var M,N, a,b,i,j,Num:integer; pa,pb,pc,nc:TcgVector; //f:first
      bb,isImplicit :boolean;
begin
  with Obj[ID] do begin
    a:=Link[0]; b:=Link[1];
    if Obj[b].Kind=4 then SwapI(a,b);
    end;//witb
  isImplicit:=(Obj[Obj[b].parent].Kind=9)and(Obj[Obj[b].parent].Mode=13); //隐函数曲面
  M:=high(FaceVct[b]);
  N:=high(FaceVct[b,0]); if isImplicit then N:=1;
  setLength(LocaVct[ID], M*N*2+2);
  pc:=Obj[a].p0; nc:=Obj[a].Vec;  //平面上的点和法线
  Num:=0;
  for i:= 0 to M-1 do
    for j:= 0 to N-1 do begin //
      if isImplicit then //隐函数曲面
      bb:=cgPlaneCross(FaceVct[b,i,0], FaceVct[b,i,1],
                       FaceVct[b,i,2], FaceVct[b,i,2], pc,nc, pa,pb)
      else
      bb:=cgPlaneCross(FaceVct[b,i,  j  ], FaceVct[b,i,  j+1],
                       FaceVct[b,i+1,j+1], FaceVct[b,i+1,j], pc,nc, pa,pb);
      if not bb then begin
        LocaVct[ID,Num]:=pa; LocaVct[ID,Num+1]:=pb; inc(Num,2);
        end;
      end;
  result:=Num;
  if result>0 then setLength(LocaVct[ID], result+1)
              else setLength(LocaVct[ID], 2);
end;
//====================== 俩曲面的交惯线 =======================
function TfrmMain.CrossTowFace( ID:integer):integer; //
  var a,b,Num, ia,ja, ib,jb, Ma,Na, Mb,Nb :integer;
      pa,pb, n1,n2:TcgVector; isImplicitA,isImplicitB :boolean;
  procedure setPlane(PlaneID, a, i,j:integer; isImplicit:boolean);
  begin
    with Obj[PlaneID] do begin
      if isImplicit then begin ////隐函数曲面
        p0:=FaceVct[a,i,0]; p1:=FaceVct[a,i,1];
        p2:=FaceVct[a,i,2]; p3:=p2;
        end
      else begin
        p0:=FaceVct[a,i,  j  ]; p1:=FaceVct[a,i,  j+1];
        p2:=FaceVct[a,i+1,j+1]; p3:=FaceVct[a,i+1,j  ];
        end;
      L:=1;
      if cgVecComp(p0,p1)then begin p1:=p2; p2:=p3; L:=0; end
      else if cgVecComp(p0,p2)or cgVecComp(p1,p2)then begin p2:=p3; L:=0; end
      else if cgVecComp(p0,p3)or cgVecComp(p1,p3)or cgVecComp(p2,p3)then L:=0;
      n1:=cgVecSub(p0,p1);  n2:=cgVecSub(p1,p2);
      Vec:=cgCrossProduct(n1,n2);
      Vec.w:=-cgDotProduct(p0,Vec);
      end;
  end;
begin
  with Obj[ID] do begin
    a:=Link[0]; b:=Link[1];
    isImplicitA:=(Obj[Obj[a].parent].Kind=9)and(Obj[Obj[a].parent].Mode=13); //隐函数曲面
    Ma:=high(FaceVct[a]);  Na:=high(FaceVct[a,0]);  if isImplicitA then Na:=1;
    isImplicitB:=(Obj[Obj[b].parent].Kind=9)and(Obj[Obj[b].parent].Mode=13); //隐函数曲面
    Mb:=high(FaceVct[b]);  Nb:=high(FaceVct[b,0]);  if isImplicitB then Nb:=1;
    end; //with
  setLength(LocaVct[ID], 4096 );
  Num:=0;
  for ia:= 0 to Ma-1 do//5 to 5 do //
    for ja:= 0 to Na-1 do begin
      setPlane(9,a,ia,ja, isImplicitA);
      for ib:= 0 to Mb-1 do//7 to 7 do //
        for jb:= 0 to Nb-1 do begin
          setPlane(10,b,ib,jb, isImplicitB);
          if CrossTowPlane( 9,10, pa,pb) then begin
            LocaVct[ID,Num]:=pa; LocaVct[ID,Num+1]:=pb; inc(Num,2);
            end;
          if Num>2040 then break;
          end;
      if Num>2040 then break;
      end;
  result:=Num;
  if result>0 then setLength(LocaVct[ID], result+1)
              else setLength(LocaVct[ID], 2 );
  if result<2 then begin LocaVct[ID,0]:=pa; LocaVct[ID,1]:=pa; Obj[ID].L:=0; end;
end;
//================= 将相贯线或路径的各顶点顺序化 =================
function LinkPath(out Vct:array of TcgVector; N:integer):integer;
  var i,j,k :integer;
      pa,pb,pc,nc:TcgVector; //f:first
  procedure move(j,k:integer; pc,nc:TcgVector);
    var i,n:integer;
    begin
      if j<k then for i:= j+1 to k do begin
        n:=j*2+(k-i+1)*2;  Vct[n+1]:=Vct[n-1];  Vct[n  ]:=Vct[n-2];
        end;
      Vct[j*2]:=pc; Vct[j*2+1]:=nc;
    end;
  function soho(var k,N:integer; pa,pb:TcgVector):boolean;
    var pc,nc:TcgVector;
    begin
      repeat
        pc:=Vct[k*2];  nc:=Vct[k*2+1];
        result:= cgVecComp(pb,pc)or cgVecComp(pb,nc)
              or cgVecComp(pa,pc)or cgVecComp(pa,nc);
        inc(k);
      until (k>N)or result ;
      dec(k);
    end;
begin
  j:=0;
  pa:=Vct[0]; pb:=Vct[1];
  for i:= 1 to N do begin
    k:=i;
    if soho(k,N, pa,pb) then begin
      pc:=Vct[k*2];  nc:=Vct[k*2+1];
           if cgVecComp(pb,pc)then begin move(i,k,pc,nc); pb:=nc; end
      else if cgVecComp(pb,nc)then begin move(i,k,nc,pc); pb:=pc; end
      else if cgVecComp(pa,nc)then begin move(j,k,pc,nc); pa:=pc; end
      else if cgVecComp(pa,pc)then begin move(j,k,nc,pc); pa:=nc; end;
      end
    else begin
      j:=i;
      pa:=Vct[j*2]; pb:=Vct[j*2+1];
      end;
    end;//for i
  result:=N;
end;
//===================== 画曲线 ======================
function TfrmMain.DrawCurve(ID,listID,a, M,Ss,sTime:integer; ver:Cardinal; bList,bSport:boolean):integer;//画曲线
  var i :integer;   isParaColor :boolean;  pc,pn:TcgVector;
begin 
  result:=0;
  with Obj[ID]do begin
    if bList then begin
      getListID(wireList,1); getListID(stipList,1); getListID(seleList,1);
      end;
    isParaColor:=( high(LocaColor[ID])>=high(LocaVct[ID]) );
    if(Ss<4)or(Kind in[5,16,19])and(not F) then begin //
      if bList then glNewList( IIFi(a=0,listID,stipList), GL_COMPILE); //虚线显示列表
      if(a=4000)then Ss:=1; //遮挡状态
      glDisable(GL_LIGHTING);
      glEnable(GL_COLOR_MATERIAL);
      if not isParaColor then begin
        if(Link[6]=0)or(Kind=17) //17路径
          then glColor4fv( @Color)
          else setMultiColor( ID, trunc((Obj[Link[6]].L-trunc(Obj[Link[6]].L))*200),200,Color.A);
        end;
      glLineWidth(W); glPointSize(W); //点径或线宽
      if(Ss>0)then glLineStipple( 1, stLineStyle[Ss]); //设置线形
      setEnable(Ss>0, GL_LINE_STIPPLE);
      i:=0;
      repeat
        glBegin( ver);
        while(aLink[ID,i] or not aLink[ID,i]and aLink[ID,i+1])//
          and(i<=M)and(not bSport or(i<=sTime))do begin
          if isParaColor then glColor4fv( @LocaColor[ID,i]);
          glVertex3fv( @LocaVct[ID,i]);  //******* 轨迹点 ********
          if not aLink[ID,i+1]then break else inc(i);
          end;
        glEnd;
        inc(i);
      until(i>M) or (bSport)and(i>sTime); //逐点显示轨迹时SportTime在Timer事件中渐增
      glDisable( GL_LINE_STIPPLE);
      if(Kind in[15,17])and F then begin //填充相贯线或路径
        glEnable(GL_LIGHTING);
        ColorB:=Color;
        setTowFaceColor(ID,false);
        glPolygonMode( GL_FRONT_AND_BACK, GL_FILL);
        if(Kind=15)then begin   //相贯线
          glBegin(GL_POLYGON);
            pn:=cgGetNormal(LocaVct[ID,0],LocaVct[ID,trunc(M/2)],LocaVct[ID,trunc(M/0.7)]);
            glNormal3fv( @pn);  //法线
          for i:=0 to M do glVertex3fv(@LocaVct[ID,i]);
          glEnd;
          end;
        if(Kind=17)then begin   //路径
          pc:=cgVector(0,0,0);
          for i:=0 to M do pc:=cgVecAdd(pc,LocaVct[ID,i]);  //计算平均中点
          pc:=cgVecScale(pc,1/(M+1));
          glBegin(GL_TRIANGLES);
          for i:=0 to M-1 do begin
            pn:=cgGetNormal( pc, LocaVct[ID,i], LocaVct[ID,i+1]);
            glNormal3fv( @pn);  //法线
            glVertex3fv( @pc);  glVertex3fv(@LocaVct[ID,i]); glVertex3fv(@LocaVct[ID,i+1]);
            end;
          glEnd;
          end;
        end;
      if bList then glEndList;

      if bList and(a<>4000)then begin
        glNewList( seleList, GL_COMPILE); //ID+9000
        glColor4fv(@Obj[1].ColorB);
        glLineWidth(W+Obj[1].p5.w); glPointSize(W+Obj[1].p5.w);
        i:=0;
        repeat
          glBegin( ver);
          while(aLink[ID,i] or not aLink[ID,i]and aLink[ID,i+1])//
            and(i<=M)and(not bSport or(i<=sTime))do begin
            glVertex3fv( @LocaVct[ID,i]);  //******* 轨迹点 ********
            if not aLink[ID,i+1]then break else inc(i);
            end;
          glEnd;
          inc(i);
        until(i>M) or (bSport)and(i>sTime); //逐点显示轨迹时SportTime在Timer事件中渐增
        glEndList;
        end;
      end
    else
      SolidCurve(ID,listID,a, Ss,sTime,bSport,bList);
  end;//with
  result:=i;
end;
//======================= 15 相贯线 =============================
function TfrmMain.CrossLine( ID:integer; bDraw,bList,bOnlyDraw:boolean):integer;//相贯线
  procedure swap(var a,b:TcgVector);
    var c:TcgVector; begin c:=a; a:=b; b:=c; end;
  var M,N, a,b,c,i,j,k,Num,gg, Ka,Kb, listID :integer;
      bb:boolean;  tot:single;   pa,pb,pc,nc:TcgVector; //f:first
  label drawCopy, OnlyDraw;
begin //俩平面构成的相贯线视为直线（见LineDraw）
  result:=0;
  with Obj[ID] do begin
  a:=Link[0]; b:=Link[1]; gg:=Link[6]; Ka:=Obj[a].Kind;  Kb:=Obj[b].Kind;
  hide:= Obj[a].hide or Obj[b].hide or(Link[6]>0)and Obj[Link[6]].Hide ;
  if hide then exit;
//  Screen.cursor:=crHourGlass;
  if S>4 then S:=4;
  if bOnlyDraw then goto OnlyDraw;
  if(Mode>6)then goto drawCopy;
  if(Ka in[3,4])or(Kb in[3,4])
    then N:= CrossPlaneFace( ID)  //平面与曲面的交贯线
    else N:= CrossTowFace( ID);   //俩曲面的交惯线  itest:=0;
//  Screen.cursor:=crDefault;
  hide:=N<1; if hide then begin p0:=Obj[a].p0; exit; end;
  N:= N div 2-1;
  cgSetPrecision(0.001);
//以下，剔除重合的线段
  i:=0; M:=N;
  repeat
    pa:=LocaVct[ID,i*2]; pb:=LocaVct[ID,i*2+1];
    j:=i+1;
    repeat
      pc:=LocaVct[ID,j*2];  nc:=LocaVct[ID,j*2+1];
      bb:= cgVecComp(pa,pc)and cgVecComp(pb,nc)
        or cgVecComp(pa,nc)and cgVecComp(pb,pc);
      if bb then dec(M);
      if bb then
        for k:=j to M do begin
          c:=k*2; LocaVct[ID,c]:=LocaVct[ID,c+2]; LocaVct[ID,c+1]:=LocaVct[ID,c+3];
          end;
      inc(j);
     until(j>M)or bb;
    inc(i);
   until i>=M;
  if M<N then begin N:=M; setLength(LocaVct[ID],N*2+2); end;
  N:=LinkPath(LocaVct[ID],N); //将各线段首尾相连
  setLength(aLink[ID],N*2+2); //各线段之间的链接状态
  for i:=0 to N*2+1 do aLink[ID,i]:=true;
  i:=1; k:=2; pc:=LocaVct[ID,1];    //aLink[ID,1]:=true;
  repeat
    pa:=LocaVct[ID,i*2];  pb:=LocaVct[ID,i*2+1];
    aLink[ID,k]:=cgVecComp(pa,pc); //相邻线段是否首尾相连
    if not aLink[ID,k] then
      begin LocaVct[ID,k]:=pa; aLink[ID,k]:=false; inc(k); end;
    LocaVct[ID,k]:=pb;
    pc:=pb; inc(i); inc(k);
   until i>N;
  setLength(LocaVct[ID], k);
  setLength(aLink[ID], k);
  cgSetPrecision(0.00000001);
  p0:=LocaVct[ID,0];
drawCopy:  //投影复制、镜像复制、旋转复制
  if Mode in[7..12,15,16,20] then begin
    N:=high(LocaVct[a]);
    setLength( LocaVct[ID], N+1);
    setLength( aLink[ID], N+1);
    for i:=0 to N do begin //投影复制
      LocaVct[ID,i]:=transVec(ID,LocaVct[a,i]);
      aLink[ID,i]:=aLink[a,i];
      end;
    end;
  if(Mode=14)then N:=TransCustom(ID); //自定义变换
  N:=high(LocaVct[ID]);
  LocaVct[ID,0].w:=0;
  for i:=1 to N do  //各轨迹点至起点之间距
    if(not aLink[ID,i]) then LocaVct[ID,i].w:=LocaVct[ID,i-1].w
    else LocaVct[ID,i].w:=cgDistance(LocaVct[ID,i-1],LocaVct[ID,i])+ LocaVct[ID,i-1].w;
  L:=LocaVct[ID,N].w;
OnlyDraw:
  if not bDraw then exit;
  N:= high(LocaVct[ID]);
  result:=N;
    listID:=getTraceListID(ID,bAdd); //
  DrawCurve(ID,listID,0 ,N,S,0, GL_LINE_STRIP, bList,false);//画曲线
    if not bAdd and bList and Trace then setTraceList(ID);//痕迹
  DrawCurve(ID,ID, 4000, N,S,0, GL_LINE_STRIP, bList,false);//画遮挡部分的虚线
  end; // with
  Screen.cursor:=crDefault;
end;
//======================= 2 直线 =============================
  //============ 曲线上的切线 =================
  procedure TangentOfCurve(ID,b,N,i,j :integer; var pp,np:TcgVector);
    var k:integer;   t,aR,rR:single;
        pa,pc, na,nb,nc, pa1,pa2 :TcgVector;
  begin
    pa:=Obj[ID].p0;
    pc:=LocaVct[b,i];  na:=cgVector(0,0,0); nb:=na;
    if(i>0)then na:=cgNormalVec(LocaVct[b,i],LocaVct[b,i-1]);
    if(i<N)then nb:=cgNormalVec(LocaVct[b,i+1],LocaVct[b,i]);
    if(i=0)or(i=N)then begin //端点处的向量
      if(Obj[b].Kind=3)and(Obj[b].Mode<3)then begin //圆的切线
        na:=cgNormalVec(LocaVct[b,0],LocaVct[b,N-1]);
        nb:=cgNormalVec(LocaVct[b,1],LocaVct[b,0]);
        end
      else begin
        if(i=0)then k:=1 else k:=-1;
        cgFooterAtLine(LocaVct[b,i+2*k], LocaVct[b,i+k],LocaVct[b,i], pc,false);
        pa1:=cgVecSub(pc,LocaVct[b,i+k]); //垂点到第二点的向量
        pa2:=cgVecSub(pc,LocaVct[b,i+2*k]);  //垂点到平均向量端点的向量
        nc:=cgVecAdd(LocaVct[b,i],pa1);
        np:=cgVecAdd(nc,pa2);
        if(i=0)then na:=cgNormalVec(np,LocaVct[b,i]);
        if(i=N)then nb:=cgNormalVec(LocaVct[b,i],np);
        end;
      end;
    nc:=cgVecAdd(na,nb);  cgNormalize(nc); //顶点处的平均向量
    with Obj[ID]do begin
    if(j=0)and not((Obj[b].Kind=3)and(Obj[b].Mode<3))then
      np:=nc
    else begin
      rR:=cgDistance(LocaVct[b,i], pa);//切点至轨迹点之距
      if(Obj[b].Kind=3)and(Obj[b].Mode<3)and(i=0) //椭圆上的切线
        then aR:=LocaVct[b,1].w/2//俩轨迹点之中距
        else aR:=abs(LocaVct[b,i].w-LocaVct[b,i+j].w)/2;//俩轨迹点之中距
      if(aR=0)then t:=0 else t:=1-rR/aR;
      if( j<0)then pp:=na else pp:=nb;
      np:=cgVecSub(pp,nc); np:=cgVecSubMult(pp, np,t);
      end;
    pp:=pa;
    end;
  end;
procedure TfrmMain.Lineer(  ID:integer; bDraw,bList,bOnlyDraw :boolean);
  var rA,rR,aR,bR, t, kx,ky,kz, ax,bx,cx,ix,nx, Len,cL :single;
      pa,pb, pc,pd, pp, pa1,pa2 :TcgVector; //箭头坐标
      na,nb, nc,np :TcgVector;
      a,b,c, dd,gg, i,j,k,M,N, Ka,Kb,Kc,Kd, Ma,Mb, listID, x,x0,x1 :integer;
      bb, isUp, isSegment :boolean;
  const da=0.6; db=0.1;
  label OnlyDraw;
  function VecNorm( n:TcgVector):TcgVector; //向量格式化
    begin cgNormalize(n); result:=n; end; //很奇怪，只有一句代码，取消这个函数则角平分线就会出错
  procedure PrintNum(i:integer; x,y,z:single); //坐标轴刻度值
    var j,y0,y1:integer;
    begin i:=abs(i);
      y0:=AxisNum[0,i];   y1:=y0+AxisNum[1,i]-1;
      glPushMatrix;
      glTranslatef( x, y, z);
      if(z=0)then glScalef(0.03,-0.03,0) else glScalef(0, 0.03,-0.03);
      glBegin(GL_LINE_STRIP);
        if(z=0)then for j:=y0 to y1 do glVertex3f(AxisNum[0,j], AxisNum[1,j],0)   // AxisNum 在Parsglb单元中定义
               else for j:=y0 to y1 do glVertex3f(0,AxisNum[0,j], AxisNum[1,j]);
      glEnd;
      glPopMatrix;
    end;
  procedure DrawAxisNick(ID:integer); //坐标轴刻度
    var i,j :integer;  bx,bz :boolean;
    begin
    glLineWidth(1);  glColor4fv(@Obj[ID].color);
    if(ID=2)then begin
      bz:=cheAngle.Checked; //用三角法标注
      cL:=Obj[2].L-1; if bz then cL:=4*cL/pi;
      x:=trunc(cL);
      x0:=-trunc(Obj[2].R);         if bz then x0:=-trunc(Obj[2].R/quadPi);
      x1:=trunc(Obj[2].L-Obj[2].R); if bz then x1:=trunc((Obj[2].L-Obj[2].R)/quadPi);
      glBegin(GL_LINES); //刻度
        for i:=x0 to x1 do if(i<>0)then begin
          cL:=i; if bz then cL:=i*quadPi; //bz 用三角法标注
          glVertex2f(cL,-0.1); glVertex2f(cL,0.1); 
          end;
      glEnd; //caption :=itos(x0)+' '+itos(x1);
      if bz then begin //弧度标注
        x0:= x0 div 2;  x1:= x1 div 2;
        bx:= x0/2=trunc(x0/2); //x0为偶数
        for i:= x0 to x1 do begin
          bx:=not bx;   if(i=0)then continue;
          cL:=i*halfPi; j:=abs(i);
          PrintNum( 10, cL+IIFf(j<3,-0.1, 0.03), -0.2, 0); //Pi
          if bx then begin
            PrintNum( 2, cL-0.06, -0.5, 0);
            if(j>2)then PrintNum( i mod 10, cL-0.16, -0.2, 0);
            if(j>9)then PrintNum( i div 10, cL-0.3 , -0.2, 0);
            end
          else begin
            if(j>2)then PrintNum( i div 2, cL-0.15, -0.2, 0);
            end;
          if bx then begin //分数线
            glBegin(GL_LINES); glVertex2f(cL-0.16,-0.46); glVertex2f(cL+0.2,-0.46); glEnd;
            end;
          if(i<0)then begin //负号
            glBegin(GL_LINES); glVertex2f(cL-IIff(i<2,0.35,0.3),-0.32);
                               glVertex2f(cL-IIFf(i<2,0.25,0.2),-0.32); glEnd;
            end;
          end;
        end
      else             //常规标注
        for i:=(x0 div 2)to(x1 div 2)do if(i<>0)then begin
          j:=i*2;
          if(abs(j)>9)then PrintNum( j div 10, j-0.2, -0.2, 0);
          PrintNum( j mod 10, j-IIFf((j<10)and(i>0), 0.06, 0), -0.2, 0);
          if(j<0)then begin //负号
            glBegin(GL_LINES); glVertex2f(j-IIff(j<-9,0.4,0.2),-0.32);
                               glVertex2f(j-IIFf(j<-9,0.3,0.1),-0.32); glEnd;
            end;
          end;
      end;
    if(ID=3)then begin
      x:=trunc(Obj[3].L)-1; //Y轴长度
      x0:=-trunc(Obj[3].R); // x0:=0; if Obj[3].F then x0:=trunc(-x/2);
      x1:=trunc(Obj[3].L-Obj[3].R) ; // x1:=x; if Obj[3].F then x1:=trunc( x/2);
      glBegin(GL_LINES);
        for i:=x0 to x1 do if(i<>0)then
          begin glVertex2f(-0.1,i); glVertex2f(0.1,i); end; //刻度
      glEnd;
      for i:=(x0 div 2)to(x1 div 2)do if(i<>0)then begin
        j:=i*2;
        if(abs(j)>9)then PrintNum( j div 10, -0.5, j+0.1, 0);
        PrintNum( j mod 10, -0.3, j+0.1, 0);
        if(j<0)then begin //负号
          glBegin(GL_LINES); glVertex2f(IIff(j<-9,-0.7,-0.5), j-0.02);
                             glVertex2f(IIFf(j<-9,-0.6,-0.4), j-0.02); glEnd;
          end;
        end;
      end;
    if(ID=4)then begin
      x:=trunc(Obj[4].L)-1; //Y轴长度
      x0:=-trunc(Obj[4].R); //x0:=0; if Obj[4].F then x0:=trunc(-x/2);
      x1:=trunc(Obj[4].L-Obj[4].R); //x1:=x; if Obj[4].F then x1:=trunc( x/2);
      glBegin(GL_LINES);
        for i:=x0 to x1 do if(i<>0)then
          begin glVertex3f(0,-0.1,i); glVertex3f(0,0.1,i); end; //刻度
      glEnd;
      for i:=(x0 div 2)to(x1 div 2)do if(i<>0)then begin
        j:=i*2;
        if(abs(j)>9)then PrintNum( j div 10, 0,-0.5, j+0.1);
        PrintNum( j mod 10, 0,-0.3, j+0.1);
        if(j<0)then begin //负号
          glBegin(GL_LINES); glVertex3f(0, IIff(j<-9,-0.7,-0.5), j-0.02);
                             glVertex3f(0, IIFf(j<-9,-0.6,-0.4), j-0.02); glEnd;
          end;
        end;
      end;
    end;
begin
  with Obj[ID] do begin  //if ID<5 then H:=2;
  a:=Link[0]; b:=Link[1]; c:=Link[2]; dd:=Link[3]; gg:=Link[6];
  if(Mode=1)and Rand then SwapI(a,b); //线段反向
  hide:= Obj[a].hide or (Mode<>2)and Obj[b].hide or (c>0)and(Obj[c].hide)
      or(Mode=13)and(Lock) or(gg>0)and Obj[gg].Hide; //
  if hide then begin p0:=Obj[a].p0; p1:=Obj[a].p1; end;
  if hide then exit;
  if(Mode=13)then goto OnlyDraw;
  pa:=Obj[a].p0;    na:=Obj[a].Vec;   Ka:=Obj[a].Kind;  Ma:=Obj[a].Mode;
  pb:=Obj[b].p0;    nb:=Obj[b].Vec;   Kb:=Obj[b].Kind;  Mb:=Obj[b].Mode;
  pc:=Obj[dd].p0;   nc:=Obj[dd].Vec;  Kc:=Obj[c].Kind;  Kd:=Obj[dd].Kind;
  p0:=pa; p1:=pb; p4:=pa;  p5:=pb; //p0 p4起点 pb p5终点   p4 p5是计算点值的基础点
  if c>0 then L:=getLinkVar( c, pa); //长度关联
  if(Link[12]>10)then Color.A:=Obj[Link[12]].L;
  if bOnlyDraw then goto OnlyDraw;
  isSegment:=false;
  c :=IIFi(true, c,0);//见鬼，貌似没用的语句，但若不用则点斜式直线的轨迹面就作不出
  case Mode of
  1:begin  //=============== 两点式 ===================
    if(Ka=1)then begin
      Vec:=cgNormalVec(pb,pa);   //直线的向量
      Vec.r:=Vec.w; // if L<Vec.w then L:=Vec.w;
      end;
    if(D or F)then p1:=cgVecAddMult(p0, Vec, L) else L:=Vec.w ;
    isSegment:=true;
    end;
  2:begin  //=============== 点斜式 ===================
    if(ID in[2,3,4])then begin  //坐标轴不再计算向量
      if(L<>0)and(L<1)then L:=1;
      p4:=pa;
      case ID of 2:p0.x:=p0.x-R;  3:p0.y:=p0.y-R;  4:p0.z:=p0.z-R; end;//负轴长度
      end
    else if ID>10 then begin
      case(trunc(R))of
      0:begin //角向量
        rA:=IIFf(Link[3]=0, p2.x,Obj[Link[3]].L); if Deg then rA:=rA/oneArc; // 水平视角
        rR:=IIFf(Link[5]=0, p2.z,Obj[Link[5]].L); if Deg then rR:=rR/oneArc; // 垂直视角
        Vec.x:=cos(rR)*cos(rA);  Vec.y:=cos(rR)*sin(rA);  Vec.z:=sin(rR);
        if U then cgInvertVec(Vec);
        end;
      1:begin //位向量
        if(Link[3]>0)then p2.x:=Obj[Link[3]].L;
        if(Link[4]>0)then p2.y:=Obj[Link[4]].L;
        if(Link[5]>0)then p2.z:=Obj[Link[5]].L;
        p1:=cgVecAdd( p0, p2);
        Vec:=cgNormalVec(p1,p0);  L:=Vec.w;
        end;
      2:begin //和
        a:=Link[3];   b:=Link[4];   p0:=Obj[a].p0;
        p1:=cgVecAdd(Obj[a].p1, cgVecSub( Obj[b].p1, Obj[b].p0 ) );
        Vec:=cgNormalVec(p1,p0);  L:=Vec.w;
        end;
      3:begin //差
        a:=Link[3];   b:=Link[4];   p0:=Obj[a].p0;
        p1:=cgVecSub(Obj[a].p1, cgVecSub( Obj[b].p1, Obj[b].p0 ) );
        Vec:=cgNormalVec(p1,p0);  L:=Vec.w;
        end;
      4:begin //叉积
        a:=Link[3];   na:=Obj[a].Vec;  if trunc(Obj[a].H)=1 then cgInvertVec(na);
        b:=Link[4];   nb:=Obj[b].Vec;  if trunc(Obj[b].H)=1 then cgInvertVec(nb);
        p0:=Obj[a].p0;
        t:=cgDotProduct( na, nb);
        L:=Obj[a].L * Obj[b].L * sin(arcCos(t));
        Vec:=cgCrossProduct( nb, na); //叉积
        end;
      end;
      if(R<2)then p4:=pa else p4:=Obj[Link[3]].p0;
      end;
    p1:=cgVecAddMult( p0, Vec, L);   p5:=p1;
    end; // if
  3:begin //平行线
    if(Kb=2)then Vec:=Obj[b].Vec;
    if(Kb in[3,4])then begin
      np:=Obj[4].Vec;
      if cgVecComp(nb, np)then np:=Obj[3].Vec; //若平面与Z平面平行
      Vec:=cgCrossProduct(na,np);  cgNormalize(Vec);
      if(dd>0)then R:=getLinkVar( dd, pa); //转角
      pp:=cgVecAddMult(pa,Vec,1); //终点
      setLine( 9,pa,nb);
      pc:=getDotAngleByAxis( pp, 9, aR); //pc:圆心 aR:圆周角
      bR:=R; if Deg then bR:=bR/oneArc;
      pp:=DotInCircle(  pa, 9, aR+bR, 1, 0,0);
      Vec:=cgNormalVec(pp,pa);
      end;
    if U then cgInvertVec(Vec); //反向
    p1:=cgVecAddMult(pa,Vec,L);
    p4:=p0; p5:=p1;
    end; //else begin
  4,19:begin //============= 垂线/切线 ================
    if(Ka=1)then begin //过一点作直线、平面的垂线
      if(Kb=1)then begin //两点之中垂线
        hide:=cgVecComp(pa,pb); if hide then exit;//两点重合
        na:=cgVecSub(pb,pa);  nb:=Obj[4].Vec;  if(dd>0)then nb:=Obj[dd].Vec;
        p0:=cgVecAddMult(pa,na,Angle);
        if cgVecParallel(na,nb)then begin //如果两向量平行
          if cgVecParallel(na,Obj[4].Vec)then nb:=Obj[3].Vec else nb:=Obj[4].Vec;
          end;
        Vec:=cgCrossProduct(na,nb);  cgNormalize(Vec);
        if(dd=0)and not EP(R)then begin
          setLine( 9,pa,na);
          bR:=R; if Deg then bR:=bR/oneArc;
          p1:=DotInCircle(  p0, 9, bR, L, 0,0);
          Vec:=cgNormalVec(p1,p0);
          end;
        if U then cgInvertVec(Vec); //反向
        p1:=cgVecAddMult(p0,Vec,L);
        p4:=p0; p5:=p1;
        end;
      if(Kb in[2,4])then pp:= Footer( pa, b, true); //垂足 pp.w:垂线长
      if(Kb in[2,4])and(Ma=2)and(b=Obj[a].Link[1])and not F then D:=true; //
//直线的垂线
      if(Kb=2)then begin
        if not(F or D)then L:=pp.w;
        if EP(pp.w)then begin //基点在直线上,或椭圆约束点的切线
          gg:=4;//4 z轴
          if(dd=0)and cgVecParallel( Obj[b].Vec, Obj[4].Vec)then gg:=3;//3 y轴
          Vec:=cgCrossProduct( Obj[b].Vec, Obj[gg].Vec); 
          end
        else
          Vec:=cgVecSub( pp, pa);
        cgNormalize( Vec); if not(D or F)then L:=Vec.w;
        if(dd>0)and(Obj[dd].Kind=4)then begin //平行于另一平面
          Vec:=cgCrossProduct( Obj[dd].Vec, nb);  cgNormalize( Vec);
          end
        else begin
          if(dd>0)then R:=getLinkVar( dd, pa);
          if not EP(R) then begin
            if not(D or F)and not EP(pp.w)then L:=pp.w;
            if EP(pp.w)then pp:=cgVecAddMult( pa, Vec, L); //终点
            setLine( 9,pa,nb);
            pc:=getDotAngleByAxis( pp, 9, aR); //pc:圆心 aR:圆周角
            bR:=R; if Deg then bR:=bR/oneArc;
            pp:=DotInCircle( pa, 9, aR+bR, L, 0,0);
            Vec:=cgNormalVec( pp, pa);
            end;
          end;
        if U then cgInvertVec( Vec); //反向
        p1:= cgVecAddMult( pa, Vec,L);
        p4:=p0; p5:=p1;
        end;
//正圆/圆弧的切线
      if(Kb=3)and((Obj[b].H=0)and(Mb<3)or(Mb in[3,4]))then begin
        Obj[b].Vec.w:=-cgDotProduct(Obj[b].Vec, pb);
        p0:=Footer( p0, b, false);
        pa:=p0;  bR:=Obj[b].L;
        na:=cgNormalVec( pb, pa);     aR:=cgDistance( pa, pb);
        hide:=((aR-bR)<-EPS)and not((Ka=1)and(Ma=4)and(Kb=3)); if hide then exit;
        np:=cgCrossProduct( na, nb);
        if(abs(aR-bR)<0.0001)or(Ka=1)and(Ma=4)and(Kb=3) then begin //圆周上的点 或圆的交点
          if not U then cgInvertVec(np); Vec:=np; //向量
          if not D then F:=true;//圆上的点必须是射线或直线
          p1:= cgVecAddMult( pa, Vec, L);
          end
        else begin
          t:=arcSin( bR/aR); aR:=bR*sin(t);  bR:=bR*cos(t);
          pc:=cgVecSubMult(pb,na,aR);
          if U then pd:=cgVecAddMult( pc, np, bR)else pd:=cgVecSubMult( pc, np, bR);
          Vec:=cgNormalVec( pd, pa);   pp:=pd;  pp.w:=Vec.w;
          end;
        p4:=p0; p5:=pp; //保存切点 作交点时就不必重做了
        end;
//椭圆的切线
      if(Kb=3)and(Mb<3)and(Obj[b].H>0)then begin //or(Kb=19)and(Mb=1)and(OBj[b].Angle=1)
        p0:=Footer(pa,b,false); pa:=p0;  p4:=p0;
        pp:=LocaVct[b,0];
        np:=cgNormalVec(pp,pb); //长轴向量
        if(Kb=3)then begin  //扁圆的切线
          t:=sqrt(sqr(Obj[b].L)-sqr((1-Obj[b].H)*Obj[b].L)); //半焦距
          pc:=cgVecSubMult(pb,np,t);  pd:=cgVecAddMult(pb,np, t);//左右焦点
          end;
        if(Kb=19)then begin //圆锥曲线(椭圆)的切线
          pc:=Obj[b].p1; pd:=Obj[b].p2;
          end;
        bR:=2*Obj[b].L; //长轴
        if(Obj[a].Link[1]=b)then aR:=bR-cgDistance(pa,pc) //约束点或交点
          else aR:=cgDistance(pa,pd);   //aR 外点至左焦点的距离
        k:=cgTowCircleCross(pa,pc, nb, aR,bR, pa1,pa2);//pa1,pa2 俩圆之交点
        hide:=k=0; if hide then exit;
        if U then pp:=pa1 else pp:=pa2; //交换切点
        np:= cgNormalVec(pd,pp);
        Vec:=cgCrossProduct(nb, np);
        np:= cgNormalVec(pc, pp);
        pp:= cgTowLineCross(pa,pc, Vec, np);
        pp.w:=cgDistance(pa,pp);
        if(pp.w<0.001)then pp.w:=0 else Vec:=cgNormalVec(pp,pa);
        if D then p1:=cgVecAddMult(pa,Vec,L) //D射线
             else p1:=pp;
        p5:=p1; //保存切点 作交点时就不必重做了
        end; // if(Kb=3)
      if(Kb=4)then begin  //平面的垂线
        if pp.w<EPS then Vec:=Obj[b].Vec
                    else Vec:=cgNormalVec(pp,p0);
        if U then cgInvertVec(Vec);
        end;
      if(Kb in[2,3,4])then begin
        if D or F or(pp.w<EPS)
          then p1:=cgVecAddMult(pa,Vec,L) //D射线
          else begin p1:=pp;  L:=pp.w; end;
        p4:=p0;   p5:=p1;
        end;
{//抛物线的切线
      if(Kb=19)and(Mb=1)and(trunc(Obj[b].Angle)=0)then begin
        p0:=Footer(pa,b,false); pa:=p0;
        with Obj[b] do begin pc:=p5; nc:=p4; pb:=p1; nb:=p3; pd:=p2; end;
        aR:=cgDistance(pa,pc);
        if(Ma=2)and(Obj[a].Link[1]=b)then begin //约束点的切线
          pp:=cgDotLineFooter(pa, pb,nb, true);  //约束点在准线上的垂足
          if cgVecComp(pp,pd)then pa1:=cgVecAdd(pa,nb) else pa1:=cgVecMid(pc,pp);
          D:=true;
          end
        else begin
          k:=cgLineCircleCross(pb,nb, pa,aR, pa1,pa2);//直线与圆的交点
          hide:=k=0; if hide then exit;
          if U then pd:=pa1 else pd:=pa2; //U交换
          pp:=cgVecMid(pc,pd); np:=cgNormalVec(pc,pd); np.w:=-cgDotProduct(np,pp);//中垂面
          hide:=not cgLinePlaneCross(pd,nc, pp,np, pa1);
          end;
        p5:=pa1; //切点
        Vec:=cgNormalVec(pa1,pa);
        if D then p1:=cgVecAddMult(pa,Vec,L) //D定长
             else begin p1:=pa1; L:=Vec.w; end;
        end;
//双曲线的切线
      if(Kb=19)and(Mb=1)and(Obj[b].Angle=2)then begin
        p0:=Footer(pa,b,false); pa:=p0;
        with Obj[b] do begin pc:=p1; pd:=p2; aR:=p3.w; end;
        bR:=cgDistance(pa,pd);
        if(Ma=2)and(Obj[a].Link[1]=b)then begin //约束点的切线
          aR:=cgDistance(pa,pc); if(aR<bR)then begin Swapf(aR,bR); cgVecSwap(pc,pd); end;
          np:=cgNormalVec(pc,pa); pp:=cgVecAddMult(pa,np,bR);
          pa1:=cgVecMid(pp,pd);
          D:=true;
          end
        else begin
          k:=cgTowCircleCross(pc,pa,nb, aR,bR, pa1,pa2);
          hide:=k=0; if hide then exit;
          if U then pa1:=pa2; //U交换
          nc:=cgNormalVec(pa1,pc);
          pp:=cgVecMid(pa1,pd); np:=cgNormalVec(pa1,pd); np.w:=-cgDotProduct(np,pp);//中垂面
          hide:=not cgLinePlaneCross(pc,nc, pp,np, pa1);
          end;
        Vec:=cgNormalVec(pa1,pa);
        if D then p1:=cgVecAddMult(pa,Vec,L) //D定长
             else begin p1:=pa1; L:=Vec.w; end;
        p5:=p1; p4:=p0; //切点
        end;  }
//曲线的切线
      if(Kb=3)and(Mb in[8,9,11,15,19])or(Kb in[5,15,16,17])or(Kb=19)then begin //曲线的切线
        p0:=DotAtCurve( a,b,N,i,j,true); //切点
        TangentOfCurve(ID,b,N,i,j, p0,np);
        Vec:=np;  p1:=cgVecAddMult(p0, Vec, L);
        p4:=p0;   p5:=p1; D:=true;
        end;
      end;//Ka=1
//两条直线的公垂线
    if(Ka=2)and(Kb=2)then begin
      np:=nb; cgInvertVec(np);
      if(cgVecComp( na, nb)or cgVecComp(na, np))
        then begin
          pb:=Footer(pa, b, true); //垂点
          if pb.w<EPS then pb:=DotInCircle(pa,b, 0,1, 0,0);
          end
        else cgPublicVerticalLine(pa,na, pb,nb, pb,pa,nc); //公垂线 由右手规则定义
      p0:=pa; p1:=pb;  cgInvertVec(nc);
      rA:=cgDistance(pa,pb);  //两条直线空间距离
      if rA<EPS then Vec:=nc else Vec:=cgNormalVec(pb,pa); //这行似乎多余，但为了确保公垂线总是从第一条直线指向第二条直线
      if U then cgInvertVec(Vec);
      if not(D or F)and(rA>EPS )then L:=rA;// rA>0:俩线异面
      p1:=cgVecAddMult(pa, Vec, L);
      p4:=p0;  p5:=p1;
      isSegment:=true;
      end;   //
//直线与圆和平面的垂线
    if(Ka=2)and(Kb in[3,4])then begin
      if cgLinePlaneCross(pa,na, pb,nb, pp)  //直线与平面的交点
        then p0:=pp
        else p0:=Footer(pa, b, false); //直线与平面平行时无交点
      cgSetPrecision(0.000001); //
      if cgVecParallel(na,nb)then begin //如果两向量平行
        if EP(na.x)and EP(na.y) then nb:=Obj[3].Vec else nb:=Obj[4].Vec; //如果直线平行与z轴
        end;
      cgSetPrecision(0.00000001);
      nc:=cgCrossProduct(na,nb); cgNormalize(nc); Vec:=nc; //直线与平面法线的公垂线
      if U then cgInvertVec(Vec);
//      if not(D or F)then L:=Vec.w;
      p1:=cgVecAddMult(p0,Vec,L);
      p4:=p0; p5:=p1;
      end;
//俩圆之公切线
    if(ka=3)and(kb=3)then begin //俩正圆之公切线。内外切用 Lock 属性切换
      hide:=(Obj[a].H<>0)or(Obj[b].H<>0);
      if not hide then hide:=cgTowCircleTangent(pa,na,pb,nb, Obj[a].L,Obj[b].L,L, pc,pd, isSegment,Lock,U);
      if hide then exit;
      p0:=pc; p1:=pd; Vec:=cgNormalVec(pd,pc);
      p4:=p0; p5:=p1;
      if not(D or F)then L:=Vec.w;
      p1:=cgVecAddMult(p0, Vec, L);
      end;
    end;//垂线
  5:begin //================ 中线 =================
    if Link[4]>0 then R:=getLinkVar( Link[4], pa); //长度关联
//两点之中线  做法跟中垂线相同 是为兼容
    if(Ka=1)and(Kb=1)and(dd=0)then begin
      hide:=cgVecComp(pa,pb); if hide then exit;//两点重合
      na:=cgVecSub(pb,pa);    nb:=Obj[4].Vec;
      p0:=cgVecAddMult(pa,na, Angle);   //间比
      if cgVecParallel(na,nb)then begin //如果两向量平行
        if cgVecParallel(na,Obj[4].Vec)then nb:=Obj[3].Vec else nb:=Obj[4].Vec;
        end;
      nc:=cgCrossProduct(na,nb);  cgNormalize(nc);
      if not EP(R)then begin
        setLine( 9,pa,na);
        bR:=R; if Deg then bR:=bR/oneArc;
        p1:=DotInCircle(  p0, 9, bR, L, 0,0);
        nc:=cgNormalVec(p1,p0);
        end;
      end;           
//三点之角平分线
    if(Ka=1)and(Kb=1)and(dd>0)and(Kd=1)then begin
      na:=cgNormalVec(pa,pb);   nb:=cgNormalVec(pc,pb);
      if D then cgInvertVec(nb); //D 外分
      nc:=cgCrossProduct(na,nb); cgNormalize(nc);//公垂线
      p0:=pb;
      if(Angle=0.5)then nc:=cgVecAdd(na,nb) //D 外分
               else nc:=getMidLineVec(p0,nc, na,nb, Angle,0);
      end;
//点和直线之角分线
    if(Ka=1)and(Kb=2)then begin
      pb:=Obj[b].p4;
      na:=cgNormalVec(pa,pb); //点和直线起点之向量
      if D then cgInvertVec(nb); //D 外分
      nc:=cgCrossProduct(na,nb); cgNormalize(nc);//公垂线
      p0:=pb;  //起点为公垂线的中点
      if(Angle=0.5)then nc:=cgVecAdd(na,nb) //D 外分
               else nc:=getMidLineVec(p0,nc, na,nb, Angle,0);
      end;
//两直线之角平分线
    if(Ka=2)and(Kb=2)then begin
      if cgVecParallel(na,nb)then begin //俩直线平行
        p0:=cgVecAddMult(pa,cgVecSub(pb,pa),R);  //起点为公垂线的中点
        nc:=na;
        end
      else begin
        if D then cgInvertVec(nb); //D 外分
        cgPublicVerticalLine(pa,na, pb,nb, pa,pb,np); //np公垂线的向量
        p0:=cgVecMid(pa,pb);  //起点为公垂线的中点
        if(Angle=0.5)then nc:=cgVecAdd(na,nb) //D 外分
                 else nc:=getMidLineVec(p0,np, na,nb, Angle,0);
        end;
      end;
//直线与平面(圆)之角平分线
    if(Ka=2)and(Kb in[3,4])then begin
      bb:=cgLinePlaneCross(pa,na, pb,nb, pp); //pp交点
      if bb then begin
        pb:=Footer(Obj[a].p0, b, false); //
        pc:=Footer(Obj[a].p1, b, false);
        np:=cgNormalVec(pc,pb);  //if D then cgInvertVec(np); //D 外分
        cgPublicVerticalLine(pa,na, pp,np, pa,pb,nc); //公垂线
        nc:=getMidLineVec(pp,nc, na,np, Angle,0);
        p0:=pp;
        end
      else begin //平行
        pb:=Footer(pa, b, false);
        p0:=cgVecMid(pa,pb);
        if D then nc:=cgCrossProduct(na,nb)else nc:=na; //D 外分
        end;
      end;
    Vec:=VecNorm(nc); if U then cgInvertVec(Vec); //U 反向
    p1:=cgVecAddMult(p0,Vec,L);
    p4:=p0;   p5:=p1;
    end;
  6:if(Ka in[3,4])and(Kb in[3,4])or(Ka=19)then begin  //====平面交惯线 圆锥曲线渐近线/准线=============
    if(Ka=19)then begin //圆锥曲线的准线/渐近线
      if(Ma=1)and(Obj[a].Angle=0)or(Ma=2)and(Obj[a].R<=1)then begin //抛物线
        hide:=true; exit;
        end;
      pa:=Obj[a].p1;  pb:=Obj[a].p2;  pc:=cgVecMid(pa,pb); //pc左右曲线中点
      na:=Obj[a].p3;{焦线向量}  if U then cgInvertVec(na);  //na U交换
      nb:=Obj[a].p4;{准线向量}  ax:=nb.w; {半长轴}  bx:=nb.r; {半短轴}
      if(Ma=1)and(Obj[a].Angle=1)then begin //椭圆的准线
        ax:=2*sqr(ax)/na.w; //准线
        pd:=cgVecAddMult(pc,na,ax);
        p0:=cgVecSubMult(pd,nb,bx);
        end;
      if(Ma=1)and(Obj[a].Angle=2)or(Ma=2)and(Obj[a].R>1)then begin //双曲线
        if Rand then ax:=2*sqr(ax)/na.w; {准线距离} //Rand准线
        bx:=sqrt(sqr(na.w/2)-sqr(ax));  //半短轴
        pd:=cgVecAddMult(pc,na, ax);    //pd曲线顶点
        p0:=cgVecSubMult(pd,nb, bx);    if not Rand then pd:=pc; //Rand准线
        end;
      p1:=cgVecSub( pd, cgVecSub(p0,pd));
      Vec:=cgNormalVec(p1,p0); Vec.r:=Vec.w;
      end
    else begin //==== 平面交惯线 ====
      if(dd>0)then
        pc:=Obj[dd].p0
      else begin
        if(Ka=4)then pa:=Centroid(a);//形心
        if(Kb=4)then pb:=Centroid(b);//形心
        pc:=cgVecMid( pa,pb);
        end;
      hide:=cgPlaneSection(pa,na, pb,nb, pc,nc); //pc,nc 相惯线之点和向量
      if hide then exit;
      Vec:=nc;   p0:=pc;  p1:=cgVecAddMult(p0,Vec,L);
      end;
    p4:=p0; p5:=p1;
    end;
  7..12,16,20:begin //=============== 变换 ===============//自定义变换已转换成轨迹线 反演变换已转换成圆
    p0:=transVec(ID, Obj[a].p0);  p1:=transVec(ID, Obj[a].p1);
    p4:=transVec(ID, Obj[a].p4);  p5:=transVec(ID, Obj[a].p5);
    Vec:=cgNormalVec(p1,p0);      L:=Vec.w;
    end;
//13: 台体、正多面体、多边形等构件的棱边，其端点坐标已在计算母体时计算好了。
  end; // case mode
  if(ID>10)and(Mode in[1..6,19])and F then begin //F直线向两端延伸
    pp:=p4; if(ID>10)and(Mode=1)then pp:=cgVecMid(p4,p5);//两点线以中点为原点
    p0:=cgVecAddMult(pp, Vec,-L*0.5);
    p1:=cgVecAddMult(pp, Vec, L*0.5);
    if(Mode<>1)then p5:=p1;// 点向线 平行线
    end;
OnlyDraw:
  if(gg>10)then begin Color:=getColor(ID); ColorB:=Color; end;
  if bDraw then begin
    listID:=getTraceListID(ID,bAdd);
    getListID(stipList,1);  getListID(seleList,1);
    if S<4 then begin
      for j:= 0 to IIFi(bList,1,0) do begin //
        if bList then glNewList( IIfi(j=0,listID,stipList), GL_COMPILE);
        glDisable(GL_LIGHTING);
        if W<0.5 then W:=1; glLineWidth(W);
        if(S>0)or(j=1)then glEnable( GL_LINE_STIPPLE);
        glLineStipple( 1, stLineStyle[IIFi(j=1,1,S)]); //设置线形
        i:=trunc(H); //箭头状态
        glBegin( GL_LINES);
          glColor4fv(@color);
          if(Mode=1)and U and(Ka<>19)then glColor4fv(@Obj[a].color);//颜色随顶点
          pp:=p0;   if(i in[1,3])and(L>1)then pp:=cgVecAddMult(p0,Vec, 0.2);
          glVertex3fv( @pp);
          if(Mode=1)and U and(Ka<>19)then glColor4fv(@Obj[b].color);//颜色随顶点
          pp:=p1;   if(i>1)and(L>1)then pp:=cgVecSubMult(p1,Vec, 0.2);
          glVertex3fv( @pp);
        glEnd;
        if(j=0)and(ID<5)and cheMark.Checked then
          DrawAxisNick(ID); //坐标轴刻度
        if(Mode=7)and D then DrawProjecteLines(ID); //投影线
        glDisable( GL_LINE_STIPPLE); //关闭线形设置
        if(i>0)and(L>0.6)then begin //箭头状态
          t:=W/10+Deep/30;
          glPolygonMode( GL_FRONT_AND_BACK, GL_FILL);
          if(i=1)or(i=3)then begin //始端箭头
            glPushMatrix;
            glColor4fv(@color);
            if(Mode=1)and U and(Ka<>19)then glColor4fv(@Obj[a].color);//颜色随顶点
            ChangeAngle(ID,true); glScalef(t,t,t); glCallList(Obj[9].mainList);
            glPopMatrix;
            end;
          if(i>1)then begin //终端箭头
            glPushMatrix;
            glColor4fv(@color);
            if(Mode=1)and U and(Ka<>19)then glColor4fv(@Obj[b].color); //颜色随顶点
            glTranslatef( p1.x-p0.x, p1.y-p0.y, p1.z-p0.z);
            ChangeAngle(ID,false); glScalef(t,t,t);
            glCallList(Obj[9].mainList);
            glPopMatrix;
            end;
          end; // if H>0
        if bList then glEndList;
        end; // for ...begin
      if bList then begin //选择
        glNewList( seleList, GL_COMPILE); //glNewList( ID+9000, GL_COMPILE);
        glLineWidth(W+Obj[1].p5.w); glColor4fv(@Obj[1].ColorB);
        glBegin(GL_LINES);  glVertex3fv(@p0); glVertex3fv(@p1); glEnd;
        glEndList;
        end;
      end
    else //管状线
      for j:= 0 to IIFi(bList,1,0) do SolidLine(ID,j, listID, bList);

    if not bAdd and bList and Trace then setTraceList(ID);//痕迹
    end; // if bDraw
  end; // with
end;
//======================= 18 标注 ==============================
procedure TfrmMain.Marker( ID:integer; bDraw,bList,bOnlyDraw:boolean);
  var a,b, i,j,k,M,N :integer;  t,aR,rR :single;
      isPara, isVertical :boolean; //isPara是否平行 isVertical是否垂直
      pa,pb,pc,pp, na,nb,nc,nd,np:TcgVector;
      vColor:TcgColorF;
      Vct,Nor:array of TcgVector;//多边形顶点
  function DotInLocus( L:single; b:integer):TcgVector;
    var i,N :integer; t:single; pn:TcgVector;
  begin result:=cgVector(0,0,0);
      N:=high(LocaVct[b]);  if N<1 then exit;
      t:=L*LocaVct[b,N].w;  //约束距离 L为约束比列
      for i:=1 to N do if(LocaVct[b,i].w>=t)then break;
      t:=t-LocaVct[b,i-1].w;
      t:=t/(LocaVct[b,i].w-LocaVct[b,i-1].w);
      pn:=cgVecSub(LocaVct[b,i],LocaVct[b,i-1]);
      result:=cgVecAddMult(LocaVct[b,i-1], pn,t );
    end;
  function getAngle(var pa,na, pb,nb:TcgVector; U,Q,Mask,Rand :boolean):single; //U补角 Q优角 Mask对顶角
    var t,R,r0,r1 :single; pc,pd,np:TcgVector;
  begin
    if Rand then begin //方向角
      cgPublicVerticalLine(pa,na, pb,nb, pc,pd,np); //公垂线 pc交点 np法线
      setLine( 9, pc, Obj[4].Vec); //轴线
      pa:=cgVecAdd( pc, na);
      getDotAngleByAxis( pa,9, r0);
      pb:=cgVecAdd(pc,nb);
      getDotAngleByAxis( pb,9, r1);
      R:=r1-r0; if(r1<r0)then R:=towPi+R; if U then R:=R-towPi;
      end
    else begin
      if Mask then begin cgInvertVec(na); cgInvertVec(nb); end;//对顶角
      if U then cgInvertVec(nb); //补角
      t:=cgDotProduct(na, nb);
      if EP(abs(t)-1)then R:=IIFf(t>=0,0,Pi) else R:=arcCos(t);//两向量之夹角
      if Q then R:=TowPi-R; // U补角 Q优角 Mask对顶角
      end;
    result:=R;
    end;
begin
  with Obj[ID]do begin
  a:=Link[1];  b:=Link[2];
  hide:=Obj[a].Hide or(b>0)and Obj[b].Hide or(Link[6]>0)and Obj[Link[6]].Hide;
  if hide then exit;
  if(Obj[a].Kind=4)and(Obj[b].Kind=2)then SwapI(a,b);
  pa:=Obj[a].p0; na:=Obj[a].Vec; //被标注的直线
  pb:=Obj[b].p0; nb:=Obj[b].Vec; //角度标注的第二直线或平面
  if bList then begin
    getListID(mainList,1);  getListID(seleList,1);
    glNewList( mainList, GL_COMPILE);   //建立显示列表
    end;
  if(Mode=1)then begin //########### 线标注 #############
    setLength(Vct,S+2);  setLength(Nor,S+2);
    if(b>10)then L:=Obj[b].L;   Limit(L, 0,0,1,1); //    L:=TagP.z;

    if(Obj[a].Kind=2)then begin //直线标注
      pp:=cgVecAddMult(pa,na, L *Obj[a].L-(maxTrace-1)*H/2 ); //标注点 maxTrace标记片数
      p0:=pa; p1:=Obj[a].p1;      Vec:=na;  //L:=Obj[a].L;
      end;
    if(Obj[a].Kind in[3,5,15,16,17,19])then begin //曲线标注
      p0:=DotInLocus(L,a); //曲线上的点
      pp:=DotAtCurve(ID,a, N,i,j, false); //切点
      TangentOfCurve(ID,a, N,i,j, pa,na); //切线
      Obj[9].Vec:=na;
      pp:=cgVecAddMult(p0,na, -(maxTrace-1)*H/2 );
      end;
    Vec:=na;  Vct[0]:=pp;  Nor[0]:=na;
    for i:=0 to S do Vct[i+1]:= DotInCircle( pp, ID, i*TowPi/S, R, 0, 0);//顶点 //pc:圆心,b:法线,Fi:圆周角,L:半径
    if(Thick<>0)then Vct[0]:=cgVecAddMult(Vct[0],na, R*Thick*7 ); //锥度
    for i:=0 to S do Nor[i+1]:= cgGetNormal(Vct[0],Vct[i+1],Vct[i]);// cgVecSub(Vct[i+1], pp); //光照法线
    glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);//填充
    setTowFaceColor(ID,true);
    glLineWidth(w); glColor4fv(@Color);   //含透明
    glEnable(GL_LIGHTING);
    for j:=1 to maxTrace do begin
      if(maxTrace>1)and(j>1)then //平移顶点
        for i:=0 to S+1 do Vct[i]:=cgVecAddMult(Vct[i],na, H);
      if F then begin //填充扇形
        if EP(Thick)then glNormal3fv( @na);
        glBegin(GL_TRIANGLE_STRIP); //glBegin(GL_TRIANGLE_FAN); //
          for i:=1 to S do begin
            if EP(Thick)then glNormal3fv( @na) else glNormal3fv( @nor[i+1]);
            glVertex3fv(@Vct[0]);  glVertex3fv(@Vct[i]); glVertex3fv(@Vct[i+1]);  //glVertex3fv(@Vct[i]); //
            end;
        glEnd;
        end;
      for i:=1 to S do begin //线框
        glBegin(GL_LINE_Loop);
        if F then begin if(Thick<>0)then glNormal3fv( @na) else glNormal3fv( @nor[i+1]); end;
        if(Thick<>0)then glVertex3fv(@Vct[0]);
        glVertex3fv(@Vct[i]);  glVertex3fv(@Vct[i+1]);
        glEnd;
        end;
      end;
    glDisable(GL_LIGHTING);
    end;
  if(Mode=2)then begin //######### 角标注 Obj[ID].TagP.z记录标注位置 ##########
    np:=nb; cgInvertVec(np); isPara:=(cgVecComp(na,nb)or cgVecComp(na,np));//两向量是否平行

    if(Obj[a].Kind=2)and(Obj[b].Kind=2)then begin //####### 两线夹角 #########
      if isPara then begin //若两线平行
        pp:=Footer(pa, b, true); //垂足
        if EP(pp.w)then begin //共线
          pc:=pa; np:=Obj[4].Vec; if EP(na.x)and EP(na.y)then np:=Obj[2].Vec;
          end
        else begin
          np:=cgVecSub(pp,pa);
          np:=cgCrossProduct(na,np); cgNormalize(np); cgInvertVec(np); //圆弧法线
          end;
        end //
      else
        cgPublicVerticalLine(pb,nb, pa,na, pc,pp,np); //公垂线 pa,np圆弧法线
      cgNormalize(np);
      p0:=pc; p1:=cgVecAddMult(p0,na, 5); Vec:=na; //模拟一条直线，用于拖动标记
      pc:=cgVecAddMult(p0,na, TagP.z *5); //标注点 圆弧中心

      rR:=getAngle(pa,na, pb,nb, U,Q,Mask,Rand); //夹角
      if bAdd and EP(rR) then U:=true; //U:补角 添加标记时可避免找不到标记
      end;
    if(Obj[a].Kind=2)and(Obj[b].Kind=4)then begin //######## 线面夹角 #########
      if cgLinePlaneCross(pa,na, pb,nb, pa) then begin //直线与平面的交点
        if isPara then begin //直线向量与平面法线平行
          pb:=DotInCircle(pp, b,0,1,0,0); nb:=cgVecSub(pb,pp);
          end
        else begin
          np:=cgCrossProduct(na,nb);
          nb:=cgCrossProduct(nb,np); cgNormalize(nb);
          end;
        end
      else begin //直线向量与平面法线垂直，即直线与平面平行
        np:=cgCrossProduct(na,nb);  //圆弧法线
        nb:=na;
        end;
      pc:=cgVecAddMult(pa,na, TagP.z *5); //标注点
      np:=cgCrossProduct(na,nb); cgNormalize(np); cgInvertVec(np); //圆弧法线
      rR:=getAngle(pa,na, pb,nb, U,Q,Mask,false);
      p0:=pa; p1:=cgVecAddMult(pa,na, 5); Vec:=na; //模拟一条直线，用于拖动标记
      end;
    if(Obj[a].Kind=4)and(Obj[b].Kind=4)then begin //######## 面面夹角 #########
      if isPara then begin
        np:=cgNormalVec(pa,Obj[a].p1);  pp:=pa;
        end
      else begin
        pa:=Centroid(a);  pb:=Centroid(b); //形心  pc:=cgVecMid( pa, pb);
        pc:=footer(cgVecMid( pa, pb), a, false); //垂足
        np:=cgCrossProduct(na,nb); cgNormalize(np);//相贯线向量
        nc:=cgCrossProduct(na,np); cgNormalize(nc);//平面a上相贯线的法线
        cgLinePlaneCross(pc,nc, pb,nb, pp); //pp交点
        end;
      na:=cgCrossProduct(np,na); cgNormalize(na);
      nb:=cgCrossProduct(np,nb); cgNormalize(nb);
      np:=cgCrossProduct(nb,na); cgNormalize(np);  //圆弧法线
      p0:=pp; p1:=cgVecAddMult(pp,np, 5); Vec:=np; //模拟一条直线，用于拖动标记
      pc:=cgVecAddMult(p0,np, TagP.z *5); //标注点可在相贯线上移动
      rR:=getAngle(pa,na, pb,nb, U,Q,Mask,false);
      end;
    L:=rR;
    if bDraw then begin //bDraw
      t:=L; if Deg then t:=L*oneArc; //D 角度/弧度
      isVertical:=(abs(rR-HalfPi)<0.01);//是否垂直
      if isVertical then begin //直角
        M:=2; setLength(Vct,M+1);
        N:=IIFi(isVertical and(Obj[a].Kind=2)and(Obj[b].Kind=4), 1,0); //线面垂直时画两个直角
        for k:=0 to N do begin
          if(k<>0)then nd:=np else nd:=nb; //线面垂直时向两个方向画直角
          for j:=1 to maxTrace do begin
            t:=R+H*(j-1);
            Vct[0]:=cgVecAddMult(pc,na,t);
            Vct[1]:=cgVecAddMult(Vct[0],nd,t);
            Vct[2]:=cgVecAddMult(pc,nd,t);
            glColor4fv(@Color); //含透明
            if(j=1)and F then begin //填充扇形
              glBegin(GL_TRIANGLE_FAN);
                glVertex3fv(@pc); for i:= 0 to M do glVertex3fv(@Vct[i]);
              glEnd;
              end;
            vColor:=color; vColor.A:=1; glColor4fv(@vColor); //不含透明
            glBegin(GL_LINE_STRIP);
              for i:= 0 to M do glVertex3fv(@Vct[i]);
            glEnd;
            end;
          end;
        end
      else begin
        pp:=cgVecAddMult(pc,na,R);  //圆弧起点
        if(U<>Q)then cgInvertVec(np);  //优角，圆弧方向
        setLine( 9,pc, IIFv( Rand, Obj[4].Vec, np));
        getDotAngleByAxis( pp, 9, aR); //aR 圆弧起点的圆周角
        M:=trunc(5*abs(rR))+1; t:=rR/M; //顶点个数
        setLength(Vct, M+1);
        glColor4fv(@Color);
        for i:= 0 to M do Vct[i]:=DotInCircle(pc, 9, i*t+aR, R, 0,0);
        if F then begin //填充扇形
          glBegin(GL_TRIANGLE_FAN);
            glVertex3fv(@pc); for i:= 0 to M do glVertex3fv(@Vct[i]);
          glEnd;
          end;
        glLineWidth(w);
        vColor:=color; vColor.A:=1; glColor4fv(@vColor); //不含透明
        for j:=1 to maxTrace do begin //弧线
          if(j>1)then for i:=0 to M do begin
            nc:=cgNormalVec(Vct[i],pc); Vct[i]:=cgVecAddMult(Vct[i],nc,H);
            end;
          glBegin(GL_LINE_STRIP);
            for i:= 0 to M do glVertex3fv(@Vct[i]);
          glEnd;
          end;
        end;
      p2:=Vct[0]; if(isPara)then p2:=pa; //标签位置
      glLineWidth(1); t:=R+(maxTrace-1)*H+0.2;
      vColor:=Obj[a].Color; glColor4fv(@vColor);
      pp:=cgVecAddMult(pc,na, t);
        glBegin(GL_LINES); glVertex3fv(@pc); glVertex3fv(@pp); glEnd;
      vColor:=Obj[b].Color; glColor4fv(@vColor);
      pp:=cgVecAddMult(pc,nb, t);
        glBegin(GL_LINES); glVertex3fv(@pc); glVertex3fv(@pp); glEnd;
      if isVertical and(Obj[a].Kind=2)and(Obj[b].Kind=4)then begin //线面直角时再画一条圆弧边线
        pp:=cgVecAddMult(pc,np, t);
        glBegin(GL_LINES); glVertex3fv(@pc); glVertex3fv(@pp); glEnd;
        end;
      end; //bDraw
    end;// if(Mode=2) 角度标注
  if bList then glEndList;
  if bList then glNewList( seleList, GL_COMPILE);   //选择 ID+9000
  if bDraw then begin
    M:=high(Vct);
    glLineWidth(w+Obj[1].p5.w); glColor4fv(@Obj[1].ColorB);
    glBegin(GL_LINE_STRIP);
    for i:=0 to M do glVertex3fv(@Vct[i]);
    glEnd;
    end; //bDraw
  if bList then glEndList;
  if bDraw and(Mode=2)and Trace then GetTextList ( ID); //更新标签
  setLength(Vct,0);
  end; //with
end;
//======================= 4 平面 ==============================
function TfrmMain.Plane(  ID:integer; bDraw,bList:boolean):integer;
  type TPos=Record i:integer; r:single; b:boolean; end;
  var pa,pb,pc,pd, pn,pp, na,nb,nc, pp0,pp1,pp2,pp3 :TcgVector;
      a,b,c,dd,e,ff,gg,jj, i,j, M,N, Ka,Kb,Kc, listID :integer;
      ba,bb,bc :boolean;   CC:TcgColorF;
      aR,bR,aL,t, vA,vB,vC,lA,lB,lC,k,k1,k2,kx,ky,kz :single;
  label onlyDraw;
  function VecComp(v1,v2:TcgVector):boolean;
    const EPS=0.0001;
    begin Result := (Abs(v1.x - v2.x) < EPS)
                and (Abs(v1.y - v2.y) < EPS)
                and (Abs(v1.z - v2.z) < EPS);
    end;
  procedure DrawTess( ID,M:integer; isTop:boolean ); //任意多边形 但不能交叉
    var i:integer;
        Tess: PGLUtriangulatorObj;
        v: array of T3DArray; // Type in GLu.
    procedure tessBegin(atype: GLenum);  stdcall; begin glBegin(atype); end;
    procedure tessEnd;                   stdcall; begin glEnd; end;
    procedure tessVertex(data: Pointer); stdcall; begin glVertex3dv(data); end;
    begin
      setLength( v,M);
      if isTop then
        for i:=0 to M-1 do begin
          v[i,0]:=FaceVct[ID,0,i].x; v[i,1]:=FaceVct[ID,0,i].y; v[i,2]:=FaceVct[ID,0,i].z;
          end
      else
        for i:=0 to M-1 do begin
          v[i,0]:=LocaVct[ID,i].x; v[i,1]:=LocaVct[ID,i].y; v[i,2]:=LocaVct[ID,i].z;
          end;
      Tess := gluNewTess;
      gluTessCallback( Tess, GLU_BEGIN,  @tessBegin);
      gluTessCallback( Tess, GLU_END,    @tessEnd);
      gluTessCallback( Tess, GLU_VERTEX, @tessVertex);
      gluBeginPolygon( Tess);
      for i:=0 to j do
        gluTessVertex( Tess, v[i], @v[i]);
      gluEndPolygon( Tess);
      gluDeleteTess( Tess);
    end;
  procedure DrawWall(ID,j:integer; isTexture:boolean); //墙
    var i:integer; t:single;  pn:TcgVector;
    begin
      if not isTexture then for i:=0 to j do begin
        pn:=cgGetNormal( FaceVct[ID,0,i],FaceVct[ID,0,i+1],LocaVct[ID,i]);  glNormal3fv( @pn);
        glBegin( GL_QUAD_STRIP);
        glVertex3fv(@FaceVct[ID,0,i]);
        glVertex3fv(@LocaVct[ID,i]);
        if(i<j)then glVertex3fv(@FaceVct[ID,0,i+1])else glVertex3fv(@FaceVct[ID,0,0]);
        if(i<j)then glVertex3fv(@LocaVct[ID,i+1])  else glVertex3fv(@LocaVct[ID,0]);
        glEnd;
        end
      else with Obj[ID]do begin
        glEnable(GL_TEXTURE_2D);
        if isTexture then begin
          if Rand then t:=towPi/(j+1) //正多边形
          else begin t:=0.01; if(j=2)then begin t:=kw;if(p1.w<p4.w)then t:=kw*p1.w/p4.w; end; end; //t用于三角形平面纹理
          end;
        glBegin( GL_QUAD_STRIP);
        for i:=0 to j+1 do begin
          if isTexture then begin
            if Rand then //正多边形
              glTexCoord2d ( (1+cos(i*t))*0.5*kW, (1+sin(i*t))*0.5*kH )
            else case i of
              0,4:glTexCoord2d( t,kh);
              1:glTexCoord2d(0.01, 0.01);
              2:glTexCoord2d(  kw, 0.01);
              3:if(j=3)then glTexCoord2d(kw-0.01,kh-0.01)else glTexCoord2d(t,kh);
              end; // case i
            end;
          if(i>j)then glVertex3fv(@FaceVct[ID,0,0]) else glVertex3fv(@FaceVct[ID,0,i]);
          if(i>j)then glVertex3fv(@LocaVct[ID,0]) else glVertex3fv(@LocaVct[ID,i]);
          end;
        glEnd;
        glDisable(GL_TEXTURE_2D);
        end;
    end;
  procedure DrawPlane(ID,j:integer; isThick:boolean); //isThick有厚度的平面
    var i,iID:integer; t:single; isTexture:boolean;  pn:TcgVector;
  begin
    with Obj[ID]do begin
    iID:=ID;  i:=Link[10];
    if(i>10)and(Obj[i].Kind in[10,11])then begin //数值纹理
      iID:=i;
      if(Obj[i].Kind=10)then begin kW:=Obj[i].kW;     kH:=Obj[i].kH;    end;
      if(Obj[i].Kind=11)then begin kW:=Obj[i].kWtag;  kH:=Obj[i].kHtag; end;
      end;
    isTexture:=((i>10)or(texID>0))and D and not((Obj[parent].Mode=6)and not Obj[parent].Rand); //D 贴图  Rand正多边形
    if isTexture then begin  //绑定纹理
      glAlphaFunc(GL_GREATER, 0);  glBindTexture(GL_TEXTURE_2D, Obj[iID].texID);
      glEnable( GL_ALPHA_TEST);    glEnable(GL_TEXTURE_2D);
      if Rand then t:=towPi/(j+1) //正多边形
      else begin
        t:=0; if(j=2)then begin t:=kw;  if(p1.w<p4.w)and(p4.w<>0)then t:=kw*p1.w/p4.w; end; //t用于三角形平面纹理
        end;
      end;
    glNormal3fv( @Vec);   //设置法线向量
    glBegin( GL_POLYGON); //
      for i:=0 to j do begin
        if(gg=0)or(Mode=6)and(not Rand) then begin //任意多边形
          if U and(Mode<3)then //色随顶点//and not((Mode=5)and(Obj[a].Kind>1))then
            glColor4fv( @Obj[Link[i]].color);
          end
        else begin //等色构件
          color:=getColor(ID);  colorB:=color;  //, trunc((Obj[gg].L-trunc(Obj[gg].L))*200),200,Color.A);
          glColor4fv( @color);
          end;
        if isTexture then //贴图纹理
          if Rand then //正多边形
            glTexCoord2d ( (1+cos(i*t))*0.5*kW, (1+sin(i*t))*0.5*kH )
          else case i of
            0:glTexCoord2d ( t,kH);   3:glTexCoord2d (kW,kH);
            1:glTexCoord2d ( 0, 0);   2:glTexCoord2d (kW, 0);
            end; // case i
        if isThick then glVertex3fv(@FaceVct[ID,0,i])
                   else glVertex3fv(@LocaVct[ID,i]);
        end;
    glEnd; //GL_POLYGON
    glDisable(GL_TEXTURE_2D);
    end;
  end;
begin  // Kind=3
  result:=0;
  with Obj[ ID] do begin
  a:=Link[0];  b:=Link[1];  c:=Link[2]; dd:=Link[3];
  e:=Link[4]; ff:=Link[5]; gg:=Link[6]; jj:=Link[9];
  aL:=0;
  hide:= Obj[a].hide or Obj[b].hide or (c>0)and Obj[c].hide or(gg>0)and Obj[gg].Hide;
  if hide then exit;
  if(not bAdd)and((Mode=2)and(Obj[a].Kind=2)and(Obj[b].Kind=1)or(Mode=5)and(Obj[a].Kind in[3,4])and(Obj[b].Kind=2))
    then begin
    SwapI(a,b); SwapI(Link[0],Link[1]); SwapI(LinkName[0],LinkName[1]);
    end;
  if(Mode in[1..12])then begin
    if(Mode=6)and(not Rand)then begin //平面凸壳厚度
      if not EP(Angle)then Thick:=getLinkVar( trunc(Angle), p0);
      end
    else if(ff>0)then Thick:=getLinkVar( ff, p0); //厚度
    end;
  setLength(LocaVct[ID], 4);
  setLength(aLink[ID], 4); for i:=0 to 3 do aLink[ID,i]:=true;
  if Mode in[7..12,14,16,20]then begin //变换 反演变换已转换为球
    L:=Obj[a].L;  W:=Obj[a].W;  if(W>100)then W:=W-100; //W>100 正n变形
    N:=high(LocaVct[a]);// trunc(W);
    setLength(LocaVct[ID], N+1);
    for i:=0 to N do LocaVct[ID,i]:=transVec(ID, LocaVct[a,i]);
    for i:=0 to N do LocaVct[ID,i].w:=LocaVct[a,i].w;
    Thick:=Obj[a].Thick;    if(Thick=0)then setLength(FaceVct[ID], 0);
    if(Thick<>0)then begin //Thick厚度  not((Obj[parent].Mode=6)and(not Obj[parent].D))and
      setLength(FaceVct[ID], 1);
      setLength(FaceVct[ID,0], N);
      for i:=0 to N-1 do FaceVct[ID,0,i]:=transVec(ID, FaceVct[a,0,i]);
      end;
    M:=N;
    goto onlyDraw;
    end;
  if(Obj[b].Kind=1)and(Obj[a].Kind in[2,3,4]) then SwapI(a,b);
  pa:=Obj[a].p0;    na:=Obj[a].Vec;   Ka:=Obj[a].Kind; //基点
  pb:=Obj[b].p0;    nb:=Obj[b].Vec;   Kb:=Obj[b].Kind;
  pc:=Obj[c].p0;    nc:=Obj[c].Vec;   Kc:=0; if(c>0)then Kc:=Obj[c].Kind;
  if(Mode in[3,4,5])and(dd>0)then L:=getLinkVar( dd, p0); //长
  if(Mode in[3,4,5])and( e>0)then H:=getLinkVar( e,  p0); //宽
  if(Mode in[1.. 5])and(jj>0)then R:=getLinkVar( jj, p0); //转角
  if(Mode<3)and(R=0)then R:=1; //位似比
  case Mode of
    1:begin // 三点面
      p0:=pa;
      case ID of
        5:begin p0:=Obj[4].p1; p1:=Obj[3].p0; p2:=Obj[3].p1; p1.z:=Obj[4].p0.z; p2.z:=p1.z; end;//YOZ平面
        6:begin p0:=Obj[4].p1; p2:=Obj[2].p0; p1:=Obj[2].p1; p1.z:=Obj[4].p0.z; p2.z:=p1.z; end;//XOZ平面
        7:begin p0:=Obj[3].p1; p1:=Obj[2].p0; p2:=Obj[2].p1; p1.y:=Obj[3].p0.y; p2.y:=p1.y; end;//XOY平面
        else begin p1:=pb; p2:= Obj[c].p0; end;
        end;
      p3:=p0;
      pp0:=p0;  pp1:=p1;  pp2:=p2;  pp3:=p3;
      W:=3;
      end;
    2:begin // 点线面
      if(kA=1)then begin
        p0:=pa; p1:=pb; p2:= Obj[b].p1; p3:=p0;
        W:=3;
        pp0:=p0;  pp1:=p1;  pp2:=p2;  pp3:=p3;
        end;
      if(kA=2)and(kB=2)then begin //两线面
        p0:=pa; p1:=Obj[a].p1; p2:=Obj[b].p0; p3:=Obj[b].p1;
        ba:=VecComp(p0,p2)or VecComp(p1,p2);
        bb:=VecComp(p0,p3)or VecComp(p1,p3);
        bc:=VecComp(p0,p1);
        hide:=(ba and bb); if hide then exit; //两线重合
        setLength(LocaVct[ID],4);
        if ba or bb or bc then begin
          if ba then cgVecSwap(p2,p3);
          if bc then cgVecSwap(p1,p3);
          Vec:=cgGetNormal(p0,p1,p2);  Vec.w:=-cgDotProduct(Vec,p0);
          LocaVct[ID,0]:=p0; LocaVct[ID,1]:=p1; LocaVct[ID,2]:=p2; LocaVct[ID,3]:=p3;
          W:=3;
          end
        else begin
          ba:=cgDotAtLine(p0, p1,p2); bb:=cgDotAtLine(p0, p1,p3);
          hide:=(ba and bb); if hide then exit; //两线重合
          if ba then cgVecSwap(p2,p3);
          Vec:=cgGetNormal(p0,p1,p2);  Vec.w:=-cgDotProduct(Vec,p0);
          setPlane(10, p0, ID,0);             //虚拟平面
          p3:=Footer(p3,10,false);  //第四点投影到前三个点的平面上
          LocaVct[ID,0]:=p0; LocaVct[ID,1]:=p1; LocaVct[ID,2]:=p2; LocaVct[ID,3]:=p3;
          M:=cgShell(LocaVct[ID], 3);//计算凸壳
          W:=M;
          end;
        p0:=LocaVct[ID,0]; p1:=LocaVct[ID,1]; p2:=LocaVct[ID,2]; p3:=LocaVct[ID,3];
        pp0:=p0;  pp1:=p1; pp2:=p2;  pp3:=p3; //if(M=3)then pp3:=p2;
        end;
      end;
    3:begin  //平行面
      pn:=nb; cgInvertVec(pn);
      if(Ka=1)and((Kb=4)or(Kb=3))then nc:=nb; //平行于平面
      if(Ka=1)and(Kb=2)then begin   //平行于直线
        if cgDotAtLine(pa, pb,Obj[b].p1)then begin //基点位于直线上
          if(c>0)and(Kc=11)then pTR.x:= Obj[c].L;
          bR:=pTR.x; if Deg then bR:=bR/oneArc;
          pp:=DotInCircle( pa, b, bR, 1, 0,0);
          nc:=cgCrossProduct( nb, cgVecSub(pa,pp)); //法线
          end
        else if(c=0)or(c>0)and(Kc=11)then begin //以参数为角度
          pc:=getDotAngleByAxis( pa, b, aR); //pc:圆心 aR:圆周角
          setLine( 9,pa,nb);
          if(c>0)and(Kc=11)then pTR.x:= Obj[c].L;
          bR:=pTR.x; if Deg then bR:=bR/oneArc;
          pp:=DotInCircle( pa, 9, aR+bR, pc.w, 0,0);
          nc:=cgCrossProduct( nb, cgVecSub(pa,pp)); //法线
          end
        else begin
          if(Kc=1)then begin //平行于直线并过指定点
            pn:=cgNormalVec(pc,pa); nc:=cgCrossProduct(nb,pn);
            end;
          if(Kc=2)then begin //平行于两直线
            if VecComp(nc,nb)or VecComp(nc,pn)
              then nc:=cgGetNormal(pb, Obj[b].p1, pc)
              else nc:=cgCrossProduct(nb,nc);
            end;
          end;
        cgNormalize(nc);  //法线
        end;
      pc:=pa;
      end;
    4:begin  //垂面
      pn:=nb; cgInvertVec(pn);
      case Ka of
        1:case Kb of
          1: nc:=cgNormalVec(pb,pa);
          2: nc:=nb; //垂直于直线
          3,4: case Kc of
            1:begin //垂直于平面且过指定点
              pn:=cgNormalVec(pc,pa); nc:=cgCrossProduct(nb,pn);
              end;
            2:begin //垂直于平面且平行于直线
              if VecComp(nc,nb)
                then nc:=cgGetNormal(pa, pc, Obj[c].p1)
                else nc:=cgCrossProduct(nb,nc);
                end;
            3,4:begin //公垂面
              if VecComp(na,nb) //两面平行
                then nc:=cgNormalVec(Obj[b].p1, pb)
                else nc:=cgCrossProduct(nb,nc);
              end;
            end;
          end;
        3,4:if VecComp(na,nb)or VecComp(na,pn) //“面/面”公垂面
            then nc:=cgNormalVec(Obj[a].p1, pa) //两面平行
            else nc:=cgCrossProduct(na,nb);
        end; //case Ka
      cgNormalize(nc);
      pc:=pa;
      end;
    5:begin //中面
      if(Ka=1)and(Kb>0)and(c=0)then begin
        pb:=Footer( pa, b, false); //点/线(面)中面
        t:= cgDistance( pa, pb);
        if t<EPS then begin
          if Kb>1 then nc:=Obj[b].Vec else nc:=Obj[4].Vec;
          end
        else
          nc:=cgNormalVec(pb, pa);
        pp:=cgVecAddMult( pa, cgVecSub(pb, pa), Angle); //Angle角分比
        end;
      if(Ka=1)and(Kb=1)and(Kc=1)then begin //三个点定义的中面
        na:=cgNormalVec(pa,pb);     nb:=cgNormalVec(pc,pb);
        if U then cgInvertVec(nb); //U 外分
        pn:=cgCrossProduct(na,nb);  cgNormalize(pn);//公垂线
        if(R=0.5)then nc:=cgVecAdd(na,nb) // 角平分线
                 else nc:=getMidLineVec(pb,pn, na,nb, Angle, 0); //法线的角分线
        nc:=cgCrossProduct(nc,pn);  cgNormalize(nc);//中面的法线
        pp:=pb;
        end;
      if(Ka=2)and(Kb=2)then begin //俩直线交角的平分面
        nc:=nb; cgInvertVec(nc); //第二条直线的反向法线
        if VecComp(na,nb)or VecComp(na,nc) then begin //若俩直线平行
          pb:=Footer( pa, b, true);
          if EP(pb.w)then begin
            nc:=na; pp:=pa;
            end
          else begin
            nc:=cgNormalVec(pb, pa);   //法向量
            pp:=cgVecMid(pb, pa); //中点
            end;
          end
        else begin
          if U then cgInvertVec(nb); //第二条直线的向量置反。 U 外分
          cgPublicVerticalLine( pa,na, pb,nb, pa,pb,pn); //公垂线
          pp:=cgVecMid(pa,pb);  //起点为公垂线的中点
          if(R=0.5)then nc:=cgVecAdd(na,nb) //D 外分
                   else nc:=getMidLineVec(pp,pn, na,nb, Angle, 0); //法线的角分线
          nc:=cgCrossProduct(nc,pn); //中面的法线
          end;
        end;
      if(Ka=2)and(Kb in[3,4])then begin //直线与平面交角的平分面
        if not cgLinePlaneCross(pa,na, pb,nb, pp)then begin //pp0 直线与平面的交点
          pb:=Footer( pa, b, false);  //
          nc:=cgNormalVec(pb, pa);   //法向量
          pp:=cgVecMid(pb, pa); //中点
          end
        else begin
          if U then cgInvertVec(na);
          pb:=Footer(Obj[a].p1, b, false); //直线终点到平面的垂点
          pn:=cgNormalVec(pp, pb); //直线向量在平面上的分量
          nc:=cgVecAdd(na,pn);
          end;
        end;
      if(Ka in[3,4])and(Kb in[3,4])then begin //两面角的平分面
        nc:=na; cgInvertVec(nc);
        if VecComp(na,nb)or VecComp(na,nc)then begin //俩平面平行
          pa:=Centroid(a);  pb:=Centroid(b);
          pp:=cgVecSubMult(pa, cgVecSub(pa,pb), Angle);
          end
        else begin
          pa:=Centroid(a);
          cgPlaneSection(pa,na, pb,nb, pp,pn);  //pp,nc 相惯线之点和向量
          setLine( 9,pp,pn);
          pc:=cgVecMid( pa, Centroid(b));
          pp:=Footer(pc, 9,false); //基点
          if EP(Angle-0.5)then begin
            nc:=cgVecAdd(na,nb);  if U then nc:=cgVecSub(na,nb);  //U 外分
            end
          else if(Angle=0)then nc:=na
          else if(Angle=1)then nc:=nb
          else begin
            if U then cgInvertVec(nb); //U 外分
            pa:=cgVecAdd(pp,na); getDotAngleByAxis( pa, 9, aR);
            pb:=cgVecAdd(pp,nb); getDotAngleByAxis( pb, 9, bR);
            if(aR<bR)then t:= bR-aR else t:=towPi-aR+bR;
            pd:=DotInCircle( pp, 9, aR+t *Angle, 1, 0,0);
            nc:=cgVecSub(pp,pd);
            end;
          cgNormalize(nc);      nc.w:=-cgDotProduct(nc,pp);
          end;
        end;
      pc:=pp;   
      end;
    6:begin //多边形
      if Rand and(W>100)and(Link[11]>0)then begin //W>100 正n边形
        W:=trunc(Obj[Link[11]].L); if(W<3)then W:=3; if(W>99)then W:=99;
        W:=W+100;
        end;
      M:=trunc(W);  if(M=99)then M:=4;  if(M>100)then M:=M-100; //M=99矩形
      setLength(LocaVct[ID], M+1);
      if Rand then begin //Rand 正多边形
        p0:= Obj[a].p0;
        if Obj[b].Kind=1 then Vec:=cgNormalVec(Obj[b].p0, p0)
                         else Vec:=Obj[b].Vec;
        aR:=R;  if(dd>0)then aR:=Obj[dd].L ;
        if(dd>0)and(Obj[Link[3]].Kind=1)then begin
          if(Obj[dd].Mode in [2,9])then
            aR:=getLinkVar( dd, p0) // Link[3] 等角构件
          else
            aR:=getDotAngle(Obj[dd].p0, pa, ID, cgDistance(pa, Obj[dd].p0), false);
          end;
        if Deg then aR:=aR/oneArc;
        if(trunc(W)=99)then begin //长方形
          if c>0 then L:=getLinkVar( c,p0);//长
          if e>0 then H:=getLinkVar( e,p0);//宽
          LocaVct[ID,0]:= DotInCircle( p0, ID, aR+halfPi, H, 0, 0);
          LocaVct[ID,1]:= p0;
          LocaVct[ID,2]:= DotInCircle( p0, ID, aR, L, 0, 0);
          LocaVct[ID,3]:=cgVecAdd(LocaVct[ID,2], cgVecSub( LocaVct[ID,0], p0));
          LocaVct[ID,4]:= LocaVct[ID,0];
          end
        else begin //正多边形
          if c>0 then L:=getLinkVar( c, p0)
          else if e>0 then begin
            H:=getLinkVar( e, p0); //正多边形边长
            L:=H/sin(Pi/M)/2;
            end;
          t:=towPi/M;
          for i:=0 to M do
            LocaVct[ID,i]:= DotInCircle(  p0, ID, aR+i*t, L, 0, 0); //pc:圆心,b:法线,Fi:圆周角,L:半径
          if(e=0)then begin
            aL:= cgDistance(LocaVct[ID,0],LocaVct[ID,1]); //边长
            H:=aL;
            end;
          end;
        if(W<100)then
          for i:= 1 to M do  //顶点属性
            with Obj[ID+M+i] do begin
            Kind:=1;  Mode:=13; Link[0]:=ID;  Link[1]:=0; Link[2]:=0;
            p0:=LocaVct[ID,i-1];
            end;
        end
      else begin  //凸壳
        for i:=0 to M do LocaVct[ID,i]:= Obj[Link[i]].p0; //各顶点三维坐标
        hide:=cgDotAtLine(LocaVct[ID,0], LocaVct[ID,1], LocaVct[ID,2]);//前三点共线则退出
        if hide then exit;
        pn:=cgGetNormal( LocaVct[ID,0], LocaVct[ID,1], LocaVct[ID,2]); //法向量
        Vec:=pn; Vec.w:=-cgDotProduct(pn,LocaVct[ID,0]);
        setPlane(10, LocaVct[ID,0], ID,0); //虚拟平面
        for i:=3 to M do LocaVct[ID,i]:=Footer( LocaVct[ID,i], 10,false);//各顶点均投影到前三点平面上
        LocaVct[ID,M]:=LocaVct[ID,0];
{        if not bAdd then begin //======== 计算凸壳 =========
          M:= cgShell(LocaVct[ID], M-1);
          setLength(LocaVct[ID],M+1);
          LocaVct[ID,M]:=LocaVct[ID,0];
          end; //======== 凸壳结束 =========
        for i:= 1 to trunc(W) do Obj[ID+i].Lock:=i>M; //隐藏多余边线，在Line过程中会根据Lock属性设置线段的hide属性
}
         end;
      if(W<100)then for i:= 1 to M do  //棱边属性 W>100正N边形
        with Obj[ID+i] do begin
        Kind:=2;  Mode:=13; Link[0]:=ID;  Link[1]:=0; Link[2]:=0;
        p0:=LocaVct[ID,i-1];      p1:=LocaVct[ID, IIFi(m=i,0, i)];  //棱边
        Vec:=cgNormalVec(p1,p0);  p4:=p0; p5:=p1;
        if S=0 then aL:=cgDistance(p0,p1); //一般多边形
        L:=aL;  //W:=2;
        end;
      end;
    end; //case
  if(Mode<3)and(not((kA=2)and(kB=2)))then begin //三边形的第四点
    case trunc(L) of
      1:begin //菱形
        pp:=cgVecSub(p1,p0); p3:=cgVecAdd(pp,p2);
        pp0:=p0;  pp1:=p1;  pp2:=p3;  pp3:=p2;
        p2:=pp2;  p3:=pp3;
        end;
      2:begin //平行四边形
        pp:=cgVecSub(p2,p1); p3:=cgVecAdd(pp,p0);
        pp0:=p0; pp1:=p1; pp2:=p2; pp3:=p3; //交换第三、四点
        end;
      3:begin //矩形
        if Mode=1 then begin //将三点式平面的后两点做成一条直线
          Obj[10].Kind:=2;  Obj[10].Vec:=cgNormalVec(p2,p1);
          Obj[10].p0:=p1;   Obj[10].p1:=p2;   Obj[10].p2:=p3;
          pn:= Footer( p0, 10, false); //垂点
          end
        else begin
          if(Obj[Link[0]].Kind=1)then pn:= Footer( p0, b, false) //垂点
                                 else pn:= Footer( p0, a, false);
          end;
        pp:=cgVecSub(p0,pn);
        pp0:=cgVecAdd(p1,pp); pp1:=p1; pp2:=p2;  pp3:=cgVecAdd(p2,pp);
        p0:=pp0; p3:=pp3;
        end;
      end;
    if EP(L)then W:=3 else W:=4; //边数
    if(R<>1)then begin //位似比
      pp:=cgOrigin;
      pp:=cgVecAdd(pp,pp0);  pp:=cgVecAdd(pp,pp1);  pp:=cgVecAdd(pp,pp2);
      if not EP(L)then pp:=cgVecAdd(pp,pp3);
      pp:=cgVecScale(pp,1/W);//形心
      pp0:=cgVecAddMult( pp, cgVecSub(pp0,pp), R);
      pp1:=cgVecAddMult( pp, cgVecSub(pp1,pp), R);
      pp2:=cgVecAddMult( pp, cgVecSub(pp2,pp), R);
      pp3:=cgVecAddMult( pp, cgVecSub(pp3,pp), R);
      end;
    end;
  if Mode in [3,4,5] then begin //平行面 垂面 中面
    if D and(Link[10]>0)and(Obj[Link[10]].Kind=11)then //D贴图，用数值作纹理
      L:=H* Obj[Link[10]].TagSize.x/Obj[Link[10]].TagSize.y;
    hide:=cgGetRectangle(pc,nc,L,H ,pp1,pp0,pp3,pp2);
    if hide then exit;
    if not EP(R)then begin
      aL:=R; if Deg then aL:=R/oneArc;
      setLine( 9,pc,nc);
      pp:=getDotAngleByAxis( pp0, 9, aR); //pp:圆心 aR:圆周角
      pp0:=DotInCircle( pp, 9, aR+aL, pp.w, 0, 0);
      pp:=getDotAngleByAxis( pp1, 9, aR); //pp:圆心 aR:圆周角
      pp1:=DotInCircle( pp, 9, aR+aL, pp.w, 0, 0);
      nc:=cgVecSub(pp,pp0);   pp2:=cgVecAdd(pp,nc);
      nc:=cgVecSub(pp,pp1);   pp3:=cgVecAdd(pp,nc);
      end;
    W:=4; //边数
    end;  //if Mode in [3,4,5]
  if(Mode<6)then begin
    setLength(LocaVct[ID],5);
    LocaVct[ID,0]:=pp0; LocaVct[ID,1]:=pp1; LocaVct[ID,2]:=pp2;
    LocaVct[ID,3]:=pp3; LocaVct[ID,4]:=pp0;
    end;
  if Mode=1 then pc:=Obj[c].p0;
  if Mode=2 then pc:=Obj[b].p1;
  M:=calcLocaLength(ID); //复制轨迹点并计算轨迹点之间距
OnlyDraw:
  result:=M;
  pa:=LocaVct[ID,0]; pb:=LocaVct[ID,1]; pc:=LocaVct[ID,2]; pd:=LocaVct[ID,3];
  p0:=pa; p1:=pb; p2:=pc; p3:=pd;
  nb:=cgNormalVec( pc,pb); //后两点形成的直线
  pn:=cgVecSub( pb, pa);  t:=-cgDotProduct(nb, pn);
  p4.w:=cgDistance( pc, pb);
  p5:=cgVecAddMult( pb, nb, t); //第一点在后两点形成的直线上的垂足 计算约束点用
  p5.w:=cgDistance( p5, pa); //垂线长度
  p1.w:=cgDistance( p5, pb);
  pn:= cgGetNormal( pa, pb, pc);  //法线向量
  if EP(pn.z) then pn.z:=0;
  Vec:=pn; Vec.w:=-cgDotProduct(pn,pa);// (Vec.x*p0.x+ Vec.y*p0.y+ Vec.z*p0.z);
  p0:=Obj[a].p0;
  if not bDraw then exit; //######## 退出 #########

  if not(Mode in[7..12,14,16,20])and(Thick<>0)and((S=0)or(S=10))then begin // and not((Mode=6)and(not D))
    setLength(FaceVct[ID], 1);  //Thick 厚度
    setLength(FaceVct[ID, 0],M);
    for i:=0 to M-1 do FaceVct[ID,0,i]:=cgVecAddMult( LocaVct[ID,i], Vec, Thick); //Thick厚度
    end;
  if(Link[12]>10)then Color.A:=Obj[Link[12]].L;
  listID:=getTraceListID(ID,bAdd);
  getListID(stipList,1);  getListID(wireList,1);  getListID(maskList,1);  getListID(seleList,1);
  if bList then glNewList( listID, GL_COMPILE);  //建立显示列表
    j:=trunc(W)-1; if(j=98)then j:=3;  //W 边数  长方体W=99
    if(Mode=6)then j:=high(LocaVct[ID])-1;
    if not((Mode<3)and U)then setTowFaceColor(ID,false); //
    setEnable(not((Mode<3)and U), GL_LIGHTING); //not((Mode<3)and U 色随顶点
    glPolygonMode(GL_FRONT_AND_BACK, IIFc(S>7, GL_FILL,GL_LINE));

    if(Obj[parent].Mode=6)and not Obj[parent].Rand then begin //任意多边形
      glColor4fv(@color);
      glNormal3fv( @Vec); //设置法线向量
{      glBegin( GL_TRIANGLE_FAN);
      for i:=0 to j do glVertex3fv(@LocaVct[ID,i]); //凸多边形
      glEnd;}
      DrawTess( ID,M, false); //任意多边形
      end
    else begin //正多边形
      DrawPlane(ID,j, false);
      if(Mode=7)and D then DrawProjecteLines(ID); //投影线
      end;
    if(Thick<>0)and(S=10)then begin //Thick厚度 {and not((Obj[parent].Mode=6)and(not Obj[parent].D))}
      glPolygonMode(GL_FRONT_AND_BACK, GL_FILL); //IIFc(S>7, GL_FILL,GL_LINE));
      if(S=10)then begin
        if(Obj[parent].Mode=6)and not Obj[parent].Rand then
          DrawTess( ID,M, true) //任意多边形
        else
          DrawPlane(ID,j, true);
        end;
      DrawWall(ID,j, D and((texID>0)or(Link[10]>10))); //墙 D贴图 texID纹理
      if(F)then begin //反锯齿边框
        glLineWidth(0.5);
        glBegin( GL_LINE_STRIP);
        for i:=0 to j do begin
          glVertex3fv(@LocaVct[ID,i]);  glVertex3fv(@FaceVct[ID,0,i]);
          if(i<j)then glVertex3fv(@FaceVct[ID,0,i+1]) else glVertex3fv(@FaceVct[ID,0,0]);
          end;
        glEnd;
        end;
      end;
  if bList then glEndList;

  if not bAdd and bList and Trace then setTraceList(ID);//痕迹
  if F then begin // 边框
    for m:=0 to 1 do begin
      if bList then glNewList(IIFi(m=0, stipList, wireList), GL_COMPILE);  //glNewList( ID+ 5000+m*1000, GL_COMPILE);//实线边框
      glLineWidth( Obj[1].p1.w);  glColor4fv(@color);
      glLineStipple( 1, stLineStyle[ IIFi(m=0,1, (S Mod 10))] ); //设置线形
      setEnable((S>0)or(S=0)and(m=0), GL_LINE_STIPPLE);  //线形
      if(Thick<>0)and(S=0)then begin // and not((Mode=6)and(not D))
        glEnable(GL_LIGHTING);
        setTowFaceColor(ID,false);
        DrawWall(ID,j, false); //墙
        end;
      glDisable(GL_LIGHTING);
      glBegin( GL_LINE_LOOP);//
        for i:=0 to j do glVertex3fv(@LocaVct[ID,i]);
      glEnd;
      if bList then glEndList;
      end;
    end; //if bList
  if bList then begin //建立遮罩显示列表
    kx:=0; ky:=0; kz:=0;
    for i:=0 to j do begin
      kx:=kx+LocaVct[ID,i].x;  ky:=ky+LocaVct[ID,i].y;  kz:=kz+LocaVct[ID,i].z;
      end;
    k:=1/(j+1); pp:=cgVector(kx*k, ky*k, kz*k);//平面形心

    glNewList( maskList, GL_COMPILE); //glNewList( ID+4000, GL_COMPILE);
      glBegin( GL_POLYGON); glColor4fv(@color);
      for i:=0 to j do begin
        pn:=cgVecSub(LocaVct[ID,i],pp);  pa:=cgVecAddMult(pp,pn,0.98);
        glVertex3fv(@pa);
        end;
      glEnd;
    glEndList;
    
    glNewList( seleList, GL_COMPILE); //glNewList( ID+9000, GL_COMPILE); //选择
      glDisable(GL_LIGHTING); // U 色随顶点
      glLineWidth(3); glColor4fv(@Obj[1].ColorB);
      glBegin( GL_LINE_LOOP);//
      for i:=0 to j do glVertex3fv(@LocaVct[ID,i]);
      glEnd;
    glEndList;
    end;
  result:=j+1;//trunc(W);
  end; //with Obj[ID]
end;
//======================= 10 图片  ===============================
procedure TfrmMain.PicDraw(  ID:integer);
  var mAmbient :TcgColorF;//材料环境色
begin
  with Obj[ID] do begin
  hide:= (Link[6]>0)and Obj[Link[6]].Hide; if hide then exit;
  mAmbient:=cgColorF( 1, 1, 1, color.A ); //材料环境色
  glMaterialfv( GL_FRONT_AND_BACK, GL_DIFFUSE, @mAmbient);
  if(texID>0)then begin  //绑定纹理
    glAlphaFunc(GL_GREATER, 0);
    glEnable( GL_ALPHA_TEST);
    glBindTexture(GL_TEXTURE_2D, texID);
    glEnable(GL_TEXTURE_2D);
    end;
  getListID(mainList,1);  getListID(seleList,1);
  glNewList( mainList, GL_COMPILE);  //建立显示列表
  glColor4f(1,1,1,Color.A);
  glBegin( GL_POLYGON);//
    glTexCoord2d ( 0,  0);   glVertex2f( 0,0);
    glTexCoord2d ( 0, kh);   glVertex2f( 0,H);
    glTexCoord2d (kw, kh);   glVertex2f( W,H);
    glTexCoord2d (kw,  0);   glVertex2f( W,0);
  glEnd;
  glEndList;
  end; //with
end;
//======================= 3 圆、圆弧  ===============================
function TfrmMain.Circle(  ID,Nor:integer; var PosVct:TPosType):integer; //pc 圆心, ID 法线, L 半径
  var a,i,M :integer; t,aR :single; //Cen:圆构件 Nor:法线构件 L:半径
      pp,pn:TcgVector;
  label DrawCopy;
begin
  with Obj[ID] do begin
  a:=Link[0];
  if(Mode=15)and(L=999)then begin //由圆反演的直线
    M:=100;
    setLength( PosVct, M+1);  //动态设置数组长度  if(M>999)then M:=999;
    pn:=p4;//cgNormalVec(p1,Obj[a].p0);
    pn:=cgCrossProduct(p4,Vec); cgNormalize(pn);  p4:=pn;
    pp:=cgVecSubMult(p1,pn,50);
    for i:=0 to M do
      begin PosVct[i]:=cgVecAddMult(pp,pn,i); PosVct[i].w:=i; end;
    p2:=PosVct[M]; //直线终点
    end
  else if(Mode=15)and(U)then begin //由线段反演的圆弧
    M:=trunc(6+12*H); setLength( PosVct, M+1);
    t:=H/M;
    for i:=0 to M do
      PosVct[i]:= DotInCircle(  p0, Nor, i*t+p2.x, L, 0,0);
    end
  else begin
    if(Mode in[7..12,15,16,20])then begin
      M:= high(LocaVct[a]);     //复制圆周
      setLength( PosVct, M+1); 
      for i:=0 to M do PosVct[i]:= transVec(ID, LocaVct[a,i]); //复制
      Thick:=Obj[a].Thick;
      if(Thick<>0)then begin //Thick厚度
        setLength(FaceVct[ID], 1);
        setLength(FaceVct[ID,0],M+1);
        for i:=0 to M do FaceVct[ID,0,i]:=transVec(ID, FaceVct[a,0,i]);
        end;
      goto DrawCopy;
      end;

    if(Mode in[1..6,15])then begin
      if(Angle>2)then M:=trunc(Angle) else M:= 16*trunc(abs(L)+2); //顶点个数
      end;
    setLength( PosVct, M+1);  //动态设置数组长度  if(M>999)then M:=999;
    t:=towPi/M;
    aR:=R;  if(Mode=1)and Deg then aR:=R/oneArc;
    for i:= 0 to M do
      case Mode of
      1:PosVct[i]:= DotInCircle(  p0, Nor, i*t, L, H,aR ); //pc:圆心,b:法线,Fi:圆周角,L:半径
      2:PosVct[i]:= DotInCircle(  p0, Nor, towPi-i*t, L, H,aR); //三点圆
     15:PosVct[i]:= DotInCircle(  p0, Nor, i*t, L, 0,0);
      end; //case
    PosVct[M]:=PosVct[0];
    if(Thick<>0)then begin   //Thick厚度
      setLength(FaceVct[ID], 1);
      setLength(FaceVct[ID, 0],M+1);
      for i:=0 to M do FaceVct[ID,0,i]:=cgVecAddMult( PosVct[i], Vec, Thick);
      end;

DrawCopy:
    PosVct[0].w:=0;   t:= towPi*L/M; //顶点间距
    for i:= 1 to M do begin
      if(Mode in[7,10,14,20])or(H>0)//投影、缩放复制
        then PosVct[i].w:= PosVct[i-1].w+ cgDistance(PosVct[i-1], PosVct[i])
        else PosVct[i].w:= i*t;
      end;
    end;
  end; //with
  result:=M;
end;
function TfrmMain.Arc(  ID,M:integer; var PosVct:TPosType; isLoca:boolean):integer; //圆弧 n:点数
  var a,i :integer;  Ar,Ai,k :single;  pa,pb,pc,pn :TcgVector;  //bb:bool;
  label DrawCopy;
begin result:=2;
  with Obj[ID] do begin
  a:=Link[0];
  if(Mode>6)then begin //变换
    M:=high(LocaVct[a]);   D:=Obj[a].D; S:=Obj[a].S;
    setLength( PosVct, M+1);
    for i:=0 to M do PosVct[i]:= transVec(ID, LocaVct[a,i]);
    Thick:=Obj[a].Thick;
    if(Thick<>0)then begin //Thick厚度
      setLength(FaceVct[ID], 1);
      setLength(FaceVct[ID,0], M+1);
      for i:=0 to M do FaceVct[ID,0,i]:=transVec(ID, FaceVct[a,0,i]);
      end;
    goto DrawCopy;
    end;
  Ar:= H/IIFf( D, L, 1);     // D=false: 定弧长
  if(Angle>2)then M:=trunc(Angle)
             else M:=abs(trunc(Ar*L*4)+3);  // Ar*L 弧长; Angle 采样数
  if M<1 then M:=1; if M>255 then M:=255;
  setLength( PosVct, M+1);
  k:=Ar/M;
  if(Mode=4)and(trunc(Vec.w)=999)then begin //三点弧半径无限大
    if(Angle<3)then M:=2;
    setLength( PosVct, M+1);
    pa:=Obj[Link[0]].p0;   pb:=Obj[Link[1]].p0;  pc:=Obj[Link[2]].p0;
    if cgAt2Dot(pb,pa,pc)then begin PosVct[0]:=pa; PosVct[M]:=pc; end;
    if cgAt2Dot(pa,pb,pc)then begin PosVct[0]:=pb; PosVct[M]:=pc; end;
    if cgAt2Dot(pc,pa,pb)then begin PosVct[0]:=pa; PosVct[M]:=pb; end;
    pn:= cgVecSub( PosVct[M], PosVct[0] );
    for i:=1 to M-1 do PosVct[i]:= cgVecAddMult( PosVct[0], pn, i/M);
    goto DrawCopy;
    end;
  if(Mode=4)and not(EP(Vec.x)and EP(Vec.y))then cgInvertVec(Vec);
  for i:=0 to M do begin
    Ai:=i*k; if not isLoca then Ai:=i*Ar/M;
    if Ar<0 then Ai:=-Ai; if abs(Ai)>abs(Ar)+EPS then Ai:=Ar;
    Ai:=R+IIFf( U,-Ai,Ai);
    PosVct[i]:=DotInCircle(  p0, ID, Ai, L,0,0);
    end;
  if(Thick<>0)then begin   //Thick厚度
    setLength(FaceVct[ID], 1);
    setLength(FaceVct[ID, 0],M+1);
    for i:=0 to M do FaceVct[ID,0,i]:=cgVecAddMult( PosVct[i], Vec, Thick);
    end;
DrawCopy:
  PosVct[0].w:=0;
  for i:= 1 to M do
    PosVct[i].w:=PosVct[i-1].w+ cgDistance(PosVct[i-1], PosVct[i])
  end;//with
  result:=M;
end;

function TfrmMain.CircleDraw(  ID:integer; bDraw,bList,bLoca,bOnlyDraw:boolean):integer;  //bList: 是否建立显示列表(轨迹生成过程不建立显示列表)
  var a,b,c,cc,dd,e,ff,gg, i,j,M,ss,sss, listID, Ka,Kb,Kc,db :integer;
      Si,Ar,Ai,Fi,k, La,Lb :single;
      pa,pb,pc, pp,pn :TcgVector;
      r1,r2,r3,r4 :single; bb:bool; //  , isFan
  {环境色}mAmbient0, mAmbient1, {散射色}mDiffuse0, mDiffuse1 :TcgColorF;
  procedure DrawLine(ID,Mode,M :integer; ver :cardinal; isFan,isWire:boolean);
    var i:integer;  Vct:array of TcgVector; pa,pb, pc,pn:TcgVector;
  begin //
    glPolygonMode( GL_FRONT_AND_BACK, GL_FILL);
    with Obj[ID]do begin
    if(texID>0)and(Obj[parent].Kind=3)and(Obj[parent].Mode<3)and D then begin  //绑定纹理
      glAlphaFunc(GL_GREATER, 0);  glBindTexture(GL_TEXTURE_2D, texID);
      glEnable( GL_ALPHA_TEST);    glEnable(GL_TEXTURE_2D);
      end;
    if(Thick<>0)and((S=0)or((S mod 100)=10))then begin //厚度
      setTowFaceColor(ID, false ); //双面着色
      glLineWidth(1);   glEnable(GL_LIGHTING);
      setLength(Vct, M+1);
      for i:=0 to M do Vct[i]:=FaceVct[ID,0,i];// cgVecAddMult( LocaVct[ID,i], Vec, Thick); //圆周偏移
      pc:=cgVecAddMult( p0, Vec, Thick); //圆心偏移
      if not D then glDisable(GL_TEXTURE_2D);
      glBegin( GL_QUAD_STRIP); //弧壁板
        k:=towPi/M;
        for i:=0 to M do begin
          pn:=cgNormalVec(p0,LocaVct[ID,i]); glNormal3fv( @pn); //设置法线向量
          if(texID>0)and D then glTexCoord2d ( (1+cos(i*k))*0.5*kW, (1+sin(i*k))*0.5*kH );
          glVertex3fv(@Vct[i]);   glVertex3fv(@LocaVct[ID,i]);
          end;
      glEnd;
      glDisable(GL_TEXTURE_2D);
      pa:=Vct[M]; pb:=LocaVct[ID,M];
      if isFan then begin //扇形直壁板
        glBegin( GL_QUAD_STRIP);
          pn:=cgGetNormal( pc,p0,pa);  glNormal3fv( @pn);
          glVertex3fv(@pa);  glVertex3fv(@pb);
          glVertex3fv(@pc);  glVertex3fv(@p0);
          pa:=pc; pb:=p0;
        glEnd;
        end;
      if((S mod 100)=10)then begin
        glBegin( GL_QUAD_STRIP); //弓形直壁板
          pn:=cgGetNormal( Vct[0],pa,pb);  glNormal3fv( @pn);
          glVertex3fv(@pa);  glVertex3fv(@pb);
          glVertex3fv(@Vct[0]);  glVertex3fv(@LocaVct[ID,0]);
        glEnd;
        end;
      if(Obj[parent].Mode<3)and D then glEnable(GL_TEXTURE_2D);
      glBegin( ver);
        glNormal3fv( @Vec);
        if isFan then glVertex3fv( @pc);  //填充圆弧的扇形中点
        k:=towPi/M;
        for i:=0 to M do begin
          if(texID>0)and D and(S>9)
            then glTexCoord2d ( (1+cos(i*k))*0.5*kW, (1+sin(i*k))*0.5*kH );
          glVertex3fv( @Vct[i]);
          end;
      glEnd;
      glDisable(GL_TEXTURE_2D);
      setLength( Vct, 0);
      end;
    if(Mode<>7)then begin
      if(Obj[parent].Mode<3)and D then glEnable(GL_TEXTURE_2D);
      glBegin( ver);//GL_POLYGON); // GL_LINE_LOOP; //GL_POINTS);// GL_TRIANGLE_FAN
        if isFan or D and(S>9)then begin
          if(texID>0)and D then glTexCoord2d ( 0.5*kW, 0.5*kH);
          glVertex3fv( @Obj[ID].p0); //填充圆弧的扇形中点
          end;
        k:=towPi/M;
        for i:=0 to M do begin
          if(texID>0)and D and(S>9)then glTexCoord2d ( (1+cos(i*k))*0.5*kW, (1+sin(i*k))*0.5*kH );
          glVertex3fv( @LocaVct[ID,i]);
          end;
        if isWire and(S>3) then begin
          if isFan then pc:=Obj[ID].p0 else pc:=LocaVct[ID,0];
          glVertex3fv( @pc);
          end;
      glEnd;
      glDisable(GL_TEXTURE_2D);
      end
    else begin //Mode=7 投影变换
      i:=0;
      repeat
        glBegin( ver);//GL_LINE_STRIP);  //GL_POINTS);//
        if isFan then glVertex3fv( @Obj[ID].p0); //填充圆弧的扇形中点
        if(i=0)then glVertex3fv( @LocaVct[ID,i]);
        inc(i);
        while(i<=M)and(i>0)and(cgDistance(LocaVct[ID,i],LocaVct[ID,i-1])<10)do begin
          glVertex3fv( @LocaVct[ID,i]);
          inc(i);
          end;
        glEnd;
        until(i>M);
      end;
    end; //with Obj[ID]...
  end;
begin result:=0;
  with Obj[ID] do begin
  a:=Link[0]; b:=Link[1];   c:=Link[2]; dd:=Link[3];  e:=Link[4]; ff:=Link[5]; gg:=Link[6];
  if(a<=0)then a:=1;  if(not bAdd)and(b<=0)then b:=4;
  hide:= Obj[a].hide or Obj[b].hide or(gg>0)and Obj[gg].Hide
    or(Mode in[2,4])and Obj[c].hide
    or(Mode in[1,3])and(c>0)and Obj[c].hide;
  if hide then exit;
  pa:=Obj[a].p0;  Ka:=Obj[a].Kind;
  pb:=Obj[b].p0;  Kb:=Obj[b].Kind;
  pc:=Obj[c].p0;  Kc:=Obj[b].Kind;
  if(ff<>0)then Thick:=Obj[ff].L; //厚度
  if(Link[12]>10)then Color.A:=Obj[Link[12]].L;
  case Mode of
  1:begin  //点法圆
    if(Ka=1)then begin //圆心点和法线 先选择一个点
      pc:= Obj[a].p0; //圆心
      if bAdd and(rY=0)and(butLock.Down) or(c>0)then
        L:=getLinkVar( c, pc);  //2D圆之半径
      if(Kb=1)and((b>0)or(b=0)and bAdd) then //法线由圆心指向另一点
        Vec:=cgNormalVec( Obj[b].p0, pc)
      else
        if(b=0)then Vec:=cgVector(0,0,1) else Vec:=Obj[b].Vec;
      end
    else begin //圆周上的点和中轴线 先选择中轴线
      if(Ka=4)then cgCenter( LocaVct[a,0],LocaVct[a,1],LocaVct[a,2], pa,Vec, 0);//pa 圆心
      setLine( 9, pa, Obj[a].Vec);
      pc:=footer( pb, 9, true);
      L:=pc.w;    Vec:=Obj[a].Vec;
      R:= getDotAngle(pb,pc,9, L, false); // 圆周上的点相对中轴线的角度
      end;
    if dd>0 then H:=getLinkVar(dd, pc);  //扁度
    if  e>0 then R:=getLinkVar( e, pc);  //转角
    end;
  2:begin  //三点圆
    if(Ka=4)then begin pa:=LocaVct[a,0]; pb:=LocaVct[a,1]; pc:=LocaVct[a,2]; end;
    hide:= cgCenter( pa,pb,pc, pp,Vec, ord(U)); //pp 圆心 Vec法线 U内切
    if hide then exit;
    pc:=pp;  p0:=pp;  L:= pp.w; //半径
    end;
  3:begin  //点法弧
    Ka:=Obj[a].Kind;  Kb:=Obj[b].Kind;  Kc:=Obj[c].Kind;
    Vec:=Obj[b].Vec; //if U then cgInvertVec(Vec); //法线向量
    if(Kb=1)then begin
      Vec:=Obj[4].Vec; //默认以z轴为圆弧法线
      if(c>0)and(Kc=1)// and(pa.z<>pb.z)and(pa.z<>pc.z) //三个点不位于同一水平面
        then Vec:=cgGetNormal(pa,pb,pc); //第三点确定圆平面
      end;
    setLine( 9, pb, Obj[ID].Vec);
    pc:=getDotAngleByAxis( pa, 9, aR); //pc圆心 aR:圆周角
    L:= pc.w; R:=aR; //半径 基点圆周角
    if(c>0)then begin //由终点控制弧长
      getDotAngleByAxis( Obj[c].p0, 9, aI);
      Fi:=aR-aI;
      if Obj[ID].U then begin //反向圆弧
        if(aR<aI)then Obj[ID].H:= towPi+aR-aI else Obj[ID].H:=aR-aI;
        end
      else
        if(aR<aI)then Obj[ID].H:= aI-aR else Obj[ID].H:=towPi-aR+aI;
      end;

    if(c=0)and( (dd>0) or (bAdd)and(bC) )then
      with Obj[dd] do begin //弧长与其它构件绑定
      db:=Link[1];
      case Kind of //连接构件类型
        1:if(Mode=2)and(Obj[db].Kind<4)then
          case Obj[db].Kind of //关联约束点
            2:Obj[ID].H:=IIFf( D, L, L*Obj[db].L ); //直线上的约束点
            3:if Obj[db].Mode<3 then Obj[ID].H:=L
              else begin
                if Obj[ID].D then begin   //定弧长
                  if Obj[db].D
                    then Obj[ID].H:=IIFf(D, L, L*Obj[db].H)  //D-圆弧定弧长
                    else Obj[ID].H:=IIFf(D, L, L*Obj[db].H*Obj[db].L);
                  end
                else begin
                  if Obj[db].D
                    then Obj[ID].H:=IIFf(D, L/Obj[db].L, L*Obj[db].H/Obj[db].L)  //D-圆弧定弧长
                    else Obj[ID].H:=IIFf(D, L/Obj[db].L, L*Obj[db].H);
                  end;
                end;
            end
          else if(not bAdd)then begin //关联非约束点, 则计算该点与轴线所成平面的角度
            getDotAngleByAxis( Obj[dd].p0, 9, aI);
            Fi:=aR-aI;
            if Obj[ID].U then begin //反向圆弧
              if(aR<aI)then Obj[ID].H:= towPi+aR-aI else Obj[ID].H:=aR-aI;
              end
            else
              if(aR<aI)then Obj[ID].H:= aI-aR else Obj[ID].H:=towPi-aR+aI;
            end;
        2,11:Obj[ID].H:=L; //连接构件为直线
        3:if Mode<3 then Obj[ID].H:=L
            else Obj[ID].H:=IIFf( Obj[ID].D, IIFf(D, H, H*L), IIFf(D, H/L, H));
        end; //if.. with Obj[c] do case...
      end;
    end;
  4:begin   //三点弧
    cgCenter( pa,pb,pc, pc,Vec, 0); //圆心、半径(pc.w)和法线向量
    p0:=pc;  L:=pc.w;
    if(L=999)then begin L:=0; Vec.w:=999; end; //半径
    if(pc.w<999)then begin
      setPlane(10, pc, ID, L);  //虚拟一个平面
      r1:=getDotAngle( Obj[a].p0, pc, ID, L,false);  //起点的圆周角(参数：点  圆)
      r2:=getDotAngle( Obj[b].p0, pc, ID, L,true);  //中点的圆周角
      r3:=getDotAngle( Obj[c].p0, pc, ID, L,false);  //终点的圆周角
      bb:= EP(Vec.x)and EP(Vec.y); //法线平行于Z轴
      if(r1<r2)and(r2<r3)or(r3<r2)and(r2<r1)
        then begin
          if bb then if r1>r3 then cgInvertVec(Vec);
          if not bb then if r1<r3 then cgInvertVec(Vec);
          R:=IIFf( r1<r3, r1, r3); H:=abs(r3-r1); //p3.y-起始圆周角 H-弧角
          end
        else begin
          if bb then if r1<r3 then cgInvertVec(Vec);
          if not bb then if r1>r3 then cgInvertVec(Vec);
          R:=IIFf( r1<r3, r3, r1); H:=towPi-abs(r3-r1);
          end;
      end;
    end;
  7:begin
    pc:=Footer(Obj[a].p0,b,false);  Vec:=Obj[b].Vec;  L:=Obj[a].L;
    end;
  8..12,16,18:begin   //变换
    pa:=Obj[a].p0;                  pc:=TransVec( ID, pa);  //参照圆的圆心
    pb:=TransVec(ID, LocaVct[a,0]); L:=cgDistance(pc, pb); //半径
    pb:=cgVecAdd(pa, Obj[a].Vec);   pb:=TransVec( ID, pb);  //参照圆法线的终点
    Vec:=cgNormalVec(pb,pc);        H:=Obj[a].H;           //Vec法线 H椭圆度
    Thick:=Obj[a].Thick;  //厚度        //S:=Obj[parent].S;
    if Hide then edtTemp.Text:=itos(ID);//见鬼 这条永远不会执行 但若不写,在用缩放变换的圆作轨迹面时，有时会不显示曲面
    end;
  15:begin //反演变换
    pa:=Obj[a].p0;  Ka:=Obj[a].Kind;  La:=Obj[a].L;
    pb:=Obj[b].p0;  Kb:=Obj[b].Kind;  Lb:=Obj[b].L;
    if(c>0)then R:=Obj[c].L;
    pp:=Footer(pb, a, true);  Vec:=Obj[a].Vec;
    cgSetPrecision(0.0001);
    if(Ka=2)and(Kb=1)then begin //由直线反演成圆
      if EP(pp.w)then begin //反演中心在直线上
        if cgVecComp(Vec,Obj[7].Vec)
          then pn:=cgCrossProduct(Vec,Obj[6].Vec)
          else pn:=cgCrossProduct(Vec,Obj[7].Vec);
        cgNormalize(pn); Vec:=cgCrossProduct(Vec,pn); cgNormalize(Vec);
        L:=999;  pc:=cgVecAddMult(pp,pn,L); p1:=pp;//模拟直线
        end
      else begin
        pp:=cgInversion(pb,pp,R, Lock);//反演点
        pc:=cgVecMid(pb,pp);  L:=cgDistance(pb,pp)/2;//圆心 半径
        Vec:=cgGetNormal(pb,Obj[a].p1,Obj[a].p0);    //法线
        if U then begin //反演成圆弧
          setPlane(10, pc, ID, L);  //虚拟一个平面
          pp:=cgInversion(pb,Obj[a].p0,R, Lock);  //线段起点的反演点
          r1:=getDotAngle( pp, pc, ID, L,false);  //起点的圆周角
          pp:=cgInversion(pb,cgVecMid(pa,Obj[a].p1),R, Lock);  //线段中点的反演点
          r2:=getDotAngle( pp, pc, ID, L,false);  //中点的圆周角
          pp:=cgInversion(pb,Obj[a].p1,R, Lock);  //线段终点的反演点
          r3:=getDotAngle( pp, pc, ID, L,false);  //终点的圆周角
          bb:=cgVecComp(Vec,Obj[4].Vec);  //法线与Z轴平行
          if(r1<r2)and(r2<r3)or(r3<r2)and(r2<r1)then begin
            if bb then if r1>r3 then cgInvertVec(Vec);
            if not bb then if r1<r3 then cgInvertVec(Vec);
            p2.x:=IIFf( r1<r3, r1, r3); H:=abs(r3-r1); //p3.y-起始圆周角 H-弧角
            end
          else begin
            if bb then if r1<r3 then cgInvertVec(Vec);
            if not bb then if r1>r3 then cgInvertVec(Vec);
            p2.x:=IIFf( r1<r3, r3, r1); H:=towPi-abs(r3-r1);
            end;
          end;
        end;
      end;
    if(Ka=3)and(Kb=1)then begin //圆的反演
      if EP(pp.w)and(EP(cgDistance(pa,pp)-La))then begin //反演中心在圆周上
        pn:=cgNormalVec(pa,pp);
        pc:=cgVector( pa.x*2-pp.x, pa.y*2-pp.y, pa.z*2-pp.z); //对称点
        pp:=cgInversion(pp,pc, R, Lock); //反演点
        L:=999; pc:=cgVecAddMult(pp,pn,L);  p1:=pp; p4:=pn; //模拟直线
        end
      else begin
        pc:=pa;
        if cgVecComp(pp,pc)then begin //反演中心和圆心重合
          M:=high(LocaVct[a])div 2;
          pa:=LocaVct[a,0];     pa:=cgInversion(pb,pa, R,Lock);
          pp:=LocaVct[a,M];     pp:=cgInversion(pb,pp, R,Lock);
          pc:=cgVecMid(pa,pp);  L:=cgDistance(pa,pp)/2; //圆心 半径
          end
        else begin
          pn:=cgNormalVec(pp,pc);
          pa:=cgVecAddMult(pc,pn,La);  pa:=cgInversion(pb,pa,R,Lock);
          pp:=cgVecSubMult(pc,pn,La);  pp:=cgInversion(pb,pp,R,Lock);
          pc:=cgVecMid(pa,pp);  L:=cgDistance(pa,pp)/2;//圆心 半径
          if not EP(pp.w)then begin
            Vec:=cgCrossProduct(pn, Obj[a].Vec);
            pn:=cgVecSub(pp,pa);  Vec:=cgCrossProduct(Vec,pn); cgNormalize(Vec);
            end;
          end;
        if(Obj[a].Mode in[3,4])then begin //圆弧反演成圆弧
          M:=high(LocaVct[a]); pp:=pb;
          pa:=cgInversion(pp,LocaVct[a,0], R, Lock);  //线段起点的反演点
          pb:=cgInversion(pp,LocaVct[a,(M div 2)],R, Lock);  //线段中点的反演点
          pc:=cgInversion(pp,LocaVct[a,M],R, Lock);  //线段终点的反演点
          cgCenter( pa,pc,pb, pp,pn, 0);  //圆心pp、半径(pp.w)和法线向量pn
          L:=pp.w;  Vec:=pn;  //圆弧的半径 法线
          if U then begin
            setPlane(10, pp, ID, L);  //虚拟一个平面
            r1:=getDotAngle( pa, pp, ID, L,false);  //起点的圆周角
            r2:=getDotAngle( pb, pp, ID, L,false);  //中点的圆周角
            r3:=getDotAngle( pc, pp, ID, L,false);  //终点的圆周角
            bb:=cgVecComp(Vec,Obj[4].Vec);  //法线与Z轴平行
            if(r1<r2)and(r2<r3)or(r3<r2)and(r2<r1)then begin
              if bb then if r1>r3 then cgInvertVec(Vec);
              if not bb then if r1<r3 then cgInvertVec(Vec);
              p2.x:=IIFf( r1<r3, r1, r3); H:=abs(r3-r1); //p3.y-起始圆周角 H-弧角
              end
            else begin
              if bb then if r1<r3 then cgInvertVec(Vec);
              if not bb then if r1>r3 then cgInvertVec(Vec);
              p2.x:=IIFf( r1<r3, r3, r1); H:=towPi-abs(r3-r1);
              end;
            end;
          pc:=pp;
          end;
        end;
      end;
    if(Ka=3)and(Kb=3)and cgVecComp(Obj[a].Vec,Obj[b].Vec)then begin //逆相似圆
      if(La<Lb)then begin SwapI(a,b); SwapF(La,Lb); cgVecSwap(pa,pb); end;
      pn:=cgNormalVec(pb,pa);  Vec:=Obj[a].Vec;
      if((pn.w+Lb)<La)or(pn.w<(La+Lb))and Lock then begin //两圆内含 或相交时负幂
        Ar:=pn.w*La/(La+Lb);
        pc:=cgVecAddMult(pa,pn, Ar);    //圆心
        L:=sqrt((La-Ar)*(Lb+pn.w-Ar));  //半径
        end
      else begin //两圆分离
        if EP(La-Lb)and not Lock then begin //两圆等径
          pp:=cgVecMid(pa,pb); //圆心
          L:=999; pc:=cgVecAddMult(pp,pn,L);  p1:=pp;//模拟直线
          end
        else begin
          k:=Lb;        if Lock then k:=-k;  //Lock 负幂
          Ar:=pn.w*La/(La-k); //内外似中心距
          pc:=cgVecAddMult(pa,pn, Ar);  //圆心
          k:=Ar-pn.w;   if Lock then k:=-k;
          L:=sqrt((Ar-La)*(Lb+k));      //半径
          end;
        end;
      end;
    cgSetPrecision(0.00000001);
    if(L>999)then L:=999;
    end;
  end; //case Mode
  hide:=(abs(L)>999); if hide then exit;
  p0:= pc; //圆心 (圆弧的p0.w为半径, R 为起始点的圆周角)
  if(Vec.w<>999)then Vec.w:=-cgDotProduct(Vec, pc); //标准平面方程中的D 若三点弧的三点共线则Vec.w=999
  if bDraw or bList or bLoca or willAdd then begin //
    if(Obj[parent].Mode in[1,2,14,15,16])  //圆周
      then M:=Circle( ID,ID, LocaVct[ID]); //pc 圆心, ID 法线, L 半径  Mode=7时画圆的投影
    if(Obj[parent].Mode in[3,4])  //圆弧
      then M:=Arc( ID,trunc( IIFf(Mode=3, 4+4*abs(L), 8+2*L)), LocaVct[ID], bLoca);
    end;
  setLength(aLink[ID],M+1); for i:=0 to M do aLink[ID,i]:=true;
  result:=M;
  if(gg>10)then Color:=getColor(ID); //设置颜色
  if not bDraw then exit;
  ss:=(S mod 100);   sss:=ss mod 10; //ss填充模式 sss线型
  listID:=getTraceListID(ID,bAdd);
  if bList then glNewList( listID, GL_COMPILE);//
    glLineWidth( IIFf((ss<4)and(Thick=0), W, 1) );
    glEnable( GL_LIGHTING);      // glPointSize(2);
    glEnable(GL_COLOR_MATERIAL);
    setTowFaceColor(ID,(Link[6]>0)or(S<4) ); //双面着色
      glNormal3fv( @Vec); //设置法线向量
    if(gg>10)then glColor4fv(@Color);
    if(ss>7)then  //填充
      DrawLine(ID,Mode,M, GL_TRIANGLE_FAN, S>99 ,false);

    if(ss<10)or(ss>=10)and F then begin //单线 或填充加边框
      if(sss<4)then begin
        glColor4fv(@Color);
        glLineWidth( IIFf((ss<4)and(Thick=0), W, 1) );
        glLineStipple( 1, stLineStyle[sss] ); //线形 必须放在glBegin之前
        glEnable( GL_LINE_STIPPLE);
        DrawLine(ID,Mode,M, GL_LINE_STRIP, S>99, true );
        glDisable( GL_LINE_STIPPLE);
        end
      else
        SolidCircle(ID,listID,1, sss, false,false);
      end;
  if bList then glEndList;
  if not bAdd and bList and Trace then setTraceList(ID);//痕迹
  getListID(stipList,1); getListID(maskList,1); getListID(wireList,1); getListID(seleList,1);
  for j:= 0 to 1 do begin
    if(sss<4)then begin
      if bList then glNewList(IIFi(j=0,stipList,wireList), GL_COMPILE);//遮挡虚线 ID+ 5000+j*1000
        glDisable(GL_LIGHTING);
        glColor4fv(@Color);
        glLineWidth( IIFf((ss<4)and(Thick=0), W, 1) );  glPointSize(W);
        glLineStipple( 1, stLineStyle[ IIFi(j=0, 1, IIFi(sss<4, sss, 0))] ); //设置线形
        glEnable( GL_LINE_STIPPLE); //打开线形设置
          DrawLine(ID,Mode,M,IIFc(S>99, GL_LINE_STRIP, GL_LINE_STRIP), S>99, true );
      if bList then glEndList;
      if bList and(j=0)then begin //选择状态
        glNewList( seleList, GL_COMPILE);//ID+9000
        glLineWidth(W+Obj[1].p5.w); glColor4fv(@Obj[1].ColorB);
          DrawLine(ID,Mode,M, GL_LINE_STRIP, S>99, true);
        glEndList;
        end;
      end
    else
      SolidCircle(ID, IIFi(j=0,stipList,wireList),j,IIFi(j=0, 1, IIFi((ss Mod 4)<4, sss, 0)), bList,j=0);
    end; //for m
  end; //with Obj[ ID]
end;
//===================== 移动约束点 =======================
function TfrmMain.MovePoint(ID:integer; isOnly,isLocus:boolean):boolean; //移动约束点 a动点
  var a,b, bK,bM,k :integer;  start,ender, dH,t :single; //isOnly仅循环一次
      pa,pb,pc,pd, pp,pq,v1,v2 :TcgVector;
begin
  result:=true;  //到达终点则false
  with Obj[ID] do begin
    if(ID<11)or not((Kind in[1,11])and(Mode=2))then exit;
    a:=Link[0]; b:=Link[1];  bK:=Obj[b].Kind;  bM:=Obj[b].Mode;  //约束构件
    if(a>0)then H:=Obj[a].L;//H 步长
  if(b>4)and(bK=4)and not Mask then begin //平面上的约束点
    pa:=LocaVct[b,0];  pb:=LocaVct[b,1];  pc:=LocaVct[b,2];  pd:=LocaVct[b,3];
    if Rand then begin
      kW:=random(1000)/1000;  kH:=random(1000)/1000;
      end;
    pp:=cgVecSub(pc,pb);  pp:=cgVecAddMult(pb, pp,kW);
    pq:=cgVecSub(pd,pa);  pq:=cgVecAddMult(pa, pq,kW);
    pp:=cgVecSub(pp,pq);  pp:=cgVecAddMult(pq, pp,kH);//pp 动点位置
    setLine( 9, pb, cgNormalVec(pc,pb)); //辅助直线
    pq:=Footer(pp, 9,true);
    R:=pq.w;
    L:=cgDistance(pq,pb);
      t:=cgDotProduct(cgNormalVec(pc, pb),cgNormalVec(pp, pb));//动点与底边的角度为arcCos(t)
    if(t<0)then L:=-L;
    if Rand then exit; //Rand 随机动画

    if F then begin //F双向动画
      if(kW=1)and(kH=1)then Way:=true;
      if(kW=0)and(kH=0)then Way:=false;
      end
    else begin
      if(kW=1)and(kH=1)then begin kW:=0;  kH:=-H; end;
      end;
    if F and Way then begin
      if(kH=0)then begin kH:=1; kW:=kW-H; if(kW<0)then kW:=0; end
              else begin        kH:=kH-H; if(kH<0)then kH:=0; end;
      end
    else begin
      if(kH=1)then begin kH:=0; kW:=kW+H; if(kW>1)then kW:=1; end
              else begin        kH:=kH+H; if(kH>1)then kH:=1; end;
      end;
    if(kW=1)and(kH=1)then result:=false;
    end
  else if(bK in[7,9])then begin //曲面上的点

    end
  else begin
    start:=IIFf(Link[3]>0, Obj[Link[3]].L, p2.x); //起点
    ender:=IIFf(Link[4]>0, Obj[Link[4]].L, p2.z); //终点
    if Rand then begin  // Mask 随机
      L:=random(trunc((ender-start)*1000))/1000+start;
      if(bK=3)and not(Obj[b].Mask)then R:=random(trunc(Obj[b].L*1000))/1000; //圆内部的随机点
      exit;
      end;
    if F then begin //F双向
      if(L>=ender)then begin L:=ender; way:=true;
      end;
      if not way and(L<R)and((R-L)<abs(H))then //H 步长 双向移动时不考虑负步长
        L:=R
      else begin
        k:=1; if way then k:=-1;
        L:= L + k*abs(H);  if(L>=ender)then L:=ender;
        end;
      if(L<=start)then begin L:=start; way:=false; end;
      if isOnly and(not way)and EP(L-R)then result:=false;
      end
    else begin //F单向
      if(H>0)then begin
        if(L>=ender)then begin
          if isOnly and(R=start)then begin L:=ender; result:=false; exit; end; //isOnly单次(按钮)
          L:=start;
          end
        else begin
          if isOnly and(L<R)and(abs(R-L)<H)
            then L:=R
            else L:=L + H; //H 步长
          end;
        end
      else begin
        if(L<=start)then begin
          L:=ender;
          if isOnly and EP(L-R)then begin result:=false; exit; end;
          end;
        if isOnly and(L>R)and(abs(L-R)<abs(H))
          then L:=R
          else L:=L + H; //H 步长
        end;
      if(L>ender)then L:=IIFf(isOnly,ender,L-(p2.z-p2.x));// ender;
      if(L<start)then L:=IIFf(isOnly,start,L+(p2.z-p2.x));//start;
      if isOnly and not isLocus and EP(L-R)then result:=false; //isOnly单次(按钮)
      if isLocus and EP(L-ender)then result:=false;
      end;
    if(Kind=11)and(Mode=2)and Trace then setBarTrack(ID); //参数轴
    end;//bK<>4
  end; //with Obj[ID]
end;
//======================= 5 轨迹 ===============================
//轨迹线由“动点”和“限制点”生成。当限制点受约于圆周时，移动一周后停止。
//当限制点受约于直线时，移动到终点时停止。
//动点在限制点移动时也按自己的步长移动。
function TfrmMain.Locus( ID :integer; bDraw,bList,bOnlyDraw,bFace:boolean):integer;
  var a,i,V,M, oA,oB,Start,Ender, listID :integer;
      bb,isParaColor :boolean;
      LocaDot:array of TcgVector;//轨迹顶点
      LocaCol:array of TcgColorF;
      ShowDot:array of boolean;  //顶点是否存在
      BackObje :TObjType;   BackLink :TLinkType;
      BackLoca :TLocaType;  BackLocaC:TLocaColor;//轨迹线及顶点颜色
      BackFace :TFaceType;  BackFaceC:TFaceColor;//
  label drawCopy, OnlyDraw, isExit;
begin
  result:=0;
  if bOnlyDraw then goto OnlyDraw;
  with Obj[ID] do begin
    if bSport and U then goto OnlyDraw; //描点运动状态中直接跳转
    if(Mode>6)then goto drawCopy;       //复制轨迹
    oA:=Link[0];{轨迹点}
    oB:=Link[1];{限制点}
    hide:=Obj[oB].hide;
    if hide then exit;
    end; //with
  setLength( LocaDot, LocaTime+1); //动态设置数组长度
  setLength( ShowDot, LocaTime+1); //轨迹点是否存在
  isParaColor:=Obj[ID].U; //颜色、线宽随动点
  if isParaColor then setLength( LocaCol, LocaTime+1)
                 else setLength( LocaColor[ID], 0);
  SysBackup(ID, BackObje,BackLoca,BackFace,BackLink,BackLocaC,BackFaceC, true);//数据备份
  Obj[oB].Link[2]:=0;
  if EP(Obj[oB].H)then Obj[oB].H:=IIFf(Obj[oB].D,0.25,0.25/Obj[Obj[oB].Link[1]].L); //设置限制点的移动速度
  Start:=oB; Ender:=oA;
  for i:=0 to LocaTime do ShowDot[i]:=true;//假定所有的轨迹点都存在
  with Obj[oB]do begin
    if Obj[ID].D then p2.z:=IIFf(bFace, p2.y, L); //轨迹终点跟随限制点
    Link[4]:=0;  //终值链接对象，若不设为0则轨迹线的“跟随”属性将失效
    R:=p2.z; F:=false;
    end;
  if Obj[ID].Lock then begin //单调轨迹 仅考虑限制点
    for i:=oB+1 to oA do with Obj[i]do
      if(Kind in[1,11])and(Mode=2)then H:=0;
    with Obj[oB] do L:=p2.x;  //控制点
    end
  else
    for i:= oB to oA do with Obj[i] do //移动速度大于零的约束点置零
      if(Mode=2)and(H<>0)and((Kind=1)or(Kind=11)and(i=oB))then begin //约束点 (Obj[Link[1]].Kind<>4)and
        L:=IIFf(Link[3]>0, Obj[Link[3]].L, p2.x);
        end;
  for i:= oB to oA do Obj[i].way:=false;
  V:=0;  bb:=false;
  repeat  // v
    for i:=Start to Ender do if(i<>ID)then with Obj[i] do if(delID=0)then begin
      if((Kind=5)or(Kind=7)and(Mode=4))and(Link[1]=Ender)then continue;//忽略相同限制点的轨迹线或轨迹面
      case Kind of
        1:begin   //Obj[ID].Lock 单调轨迹
          if(Mode=2)and not(Obj[Link[1]].Kind=6)and(H<>0)and(V>0)then //运动速度大于零的约束点
            if not MovePoint(i, i=oB,true)and(i=oB)then bb:=true;
          Pointe( i,false,false,false);
          end;
        2:Lineer( i,false,false,bOnlyDraw);     //直线
        3:CircleDraw( i,false,false,true,false);//圆
        4:Plane( i, false,false);               //平面
        5:Locus( i, false,false,false,false);   //轨迹线
        6:Solid( i, false,false,false,false);   //多面体
        7:Face( i, false,false,false);          //曲面
       11:begin
          if(Mode=1)then calcFunc( i, res, false,false); //计算式
          if(Mode=2)and(i=oB)and(V>0)then begin //参数
            L:=L+H; if(L>p2.z)then begin L:=p2.z; bb:=true; end;
            DrawParaBar(i, 0, true,true);
            end;
          if(Mode>2)then res:=calcSize( i);     //度量
          if(Mode<>2)then L:=res;
          end;
       13:Iterate( i, false,false);             //迭代  if(Obj[oA].Mode=2)and(Obj[oA].Link[1]=i)then //迭代点集上约束点
       15:CrossLine( i,false,false,false);      //相贯线
       16:FuncCurve( i,false,false,false);      //函数曲线
       17:Path( i, false,false,false);          //路径
       18:Marker( i, false,false,false);        //标注
       19:Conic(i, false,false,false);          //圆锥曲线
        end; //case
      end; //for ...begin
    if Obj[oA].hide
      then ShowDot[V]:=false //轨迹点不存在
      else begin
        LocaDot[V]:=Obj[oA].p0;
        if isParaColor then begin LocaCol[V]:=Obj[oA].Color; LocaDot[V].r:=Obj[oA].W; end;
        end;
    inc( V);
  until bb or (V>LocaTime);//动态描绘状态下
  M:=0; bb:=true;
  for i:= 0 to V-1 do begin //剔除不存在的轨迹点
    if ShowDot[i] then begin
      LocaDot[M]:=LocaDot[i]; if isParaColor then LocaCol[M]:=LocaCol[i];
      ShowDot[M]:=bb; inc(M); bb:=true; end
    else begin
      if M>0 then bb:=false; ShowDot[M]:=bb; end; //bb:=false;
    end;
  SysBackup(ID, BackObje,BackLoca,BackFace,BackLink,BackLocaC,BackFaceC, false);//数据恢复
  Obj[ID].Hide:=M<2; if Obj[ID].Hide then goto isExit;
  if M>1 then begin
    setLength(  LocaVct[ID], M); for i:=0 to M-1 do LocaVct[ID,i]:=LocaDot[i];
    setLength(    aLink[ID], M); for i:=0 to M-1 do aLink[ID,i]:=ShowDot[i];
    if isParaColor then begin
      setLength(LocaColor[ID], M); for i:=0 to M-1 do LocaColor[ID,i]:=LocaCol[i];
      end;
    end
  else begin
    LocaVct[ID,0]:=Obj[a].p0; Obj[ID].L:=0;
    goto isExit;
    end;
drawCopy:  //投影复制、镜像复制、旋转复制
  if(Obj[ID].Mode=14)then M:=TransCustom(ID);
  M:=calcLocaLength(ID); //复制轨迹点并计算轨迹点之间距
onlyDraw:
  if bDraw then with Obj[ID] do begin
    if(Mode>6)and bSport then U:=Obj[Link[0]].U;
    M:=high(LocaVct[ID]); //轨迹点数
    listID:=getTraceListID(ID,bAdd); //
      DrawCurve(ID,listID,0, M,S,SportTime, IIFc( F, GL_LINE_STRIP, GL_POINTS), bList,bSport);//画曲线
    if not bAdd and bList and Trace then setTraceList(ID);//痕迹
    if(bSport)and(SportTime>=M)then setTimer(102,true);
    if not bSport then  //用于遮挡的虚线轨迹线
      DrawCurve(ID,ID,4000, M,S,0, GL_LINE_STRIP, bList,false);//画曲线
    if TagP.z>1 then TagP.z:=1; if TagP.z<0 then TagP.z:=0;
    p0:= LocaVct[ID][trunc(M*TagP.z)];
    end;//if bSraw then with...
isExit:
  result:=M;
  setLength( LocaDot, 0); setLength( LocaCol, 0);
  setLength( ShowDot, 0);
end;
//=========== 复制轨迹点并计算轨迹点之间距 ===================
function TfrmMain.calcLocaLength(ID:integer):integer; //
  var i,M:integer;  dH,vL:single;
begin
  with Obj[ID] do begin
  if(Mode>6)and(Mode<>14)then begin //
    M:=high(LocaVct[Link[0]]);
    setLength(LocaVct[ID], M+1);
    for i:=0 to M do LocaVct[ID,i]:=transVec(ID,LocaVct[Link[0],i]);
    if(Kind<>4)then begin
      setLength(  aLink[ID], M+1); for i:=0 to M do aLink[ID,i]:=aLink[Link[0],i];
      end;
    end;
  M:=high(LocaVct[ID]);
  if(Kind<>4)and(Mode<>14)then setLength( aLink[ID], M+1); //路径构件的连接状态在path函数中定义
  vL:=0; LocaVct[ID,0].w:=0;  //总长度
  if(Kind<>4)then begin if H<0.1 then H:=0.1; end; //H 阀值
  for i:=1 to M do begin //各轨迹点至起点之间距
    dH:=cgDistance(LocaVct[ID,i-1],LocaVct[ID,i]);
    if(Kind<>4)and(Kind<>17)and(Mode<>14)and(aLink[ID,i])
      then aLink[ID,i]:=(dH<=H);//路径构件的连接状态在path函数中定义
    if(Kind=4)or(aLink[ID,i])then vL:=vL+dH;
    LocaVct[ID,i].w:=vL;
    end;
  if(Kind=16)and D then aLink[ID,M]:=true;
  if(Kind<>19)and(Kind<>4)then L:=vL; //Kind=19圆锥曲线
  if(Kind<>4)then p0:=LocaVct[ID,M];    //用于打印标签
  end; // with Obj[ID]...
  result:=M;
end;
//======================= 17_1 路径 ===================
function TfrmMain.Path( ID:integer; bDraw,bList,bOnlyDraw:boolean):integer;  // 路径
  type TVct=array[0..LocaTime]of TcgVector;
       TCol=array[0..LocaTime]of TcgColorF;
  var a,b, i,j,k, N,M, ListID,Dens :integer; //Dens密度
      pa,pb,pc,pd, vb,vc,vi :TcgVector;
      kL,kR :single;           isParaColor, isRound :boolean;
      VcT,Top :TVct;  VcC,Col :TCol;
  const maxPath=1023;
  label drawCopy, OnlyDraw;
  procedure getEnder(a:integer; var pa,pb:TcgVector);//路径构件的起终点
    var k :integer;  //k:路径类型 pa,pb:端点
    begin
      k:=Obj[a].Kind;
      if(k<3)then begin pa:=Obj[a].p0; pa.r:=Obj[a].W; end
             else begin pa:=LocaVct[a,0]; pa.r:=Obj[a].W; end;
      if k in[1,4]then pb:=pa
      else if k=2 then pb:=Obj[a].p1
      else pb:=LocaVct[a,High(LocaVct[a])];
    end;
  function getVct(var Vct:TVct; var VcC:TCol; a,M:integer;var pa,pb:TcgVector):integer;
    var j,k,N :integer;
    begin //
      N:=M;
      case Obj[a].Kind of
        1:begin //点
          Vct[M]:=Obj[a].p0;  Vct[M].w:=a;
          Vct[M].r:=Obj[a].W; VcC[M]:=Obj[a].Color;
          inc(M);
          end;
        2:begin //直线
          Vct[M  ]:=Obj[a].p0; Vct[M  ].w:=a; Vct[M  ].r:=Obj[Obj[a].Link[0]].W;
          Vct[M+1]:=Obj[a].p1; Vct[M+1].w:=a; Vct[M+1].r:=Obj[Obj[a].Link[1]].W;
          inc(M,2);
          end;
        else begin //圆、曲线
          k:=High(LocaVct[a]);
          for j:=0 to k do Vct[M+j]:=LocaVct[a,j];
          for j:=0 to k do Vct[M+j].w:=a;
          inc(M,k+1);  // if not(Obj[a].Mode=6)and(not Obj[a].D)then inc(M);
          if(Obj[a].Kind=4)then // and
            begin Vct[M]:=LocaVct[a,0]; Vct[M].w:=a; end; //inc(M);
          end;
        end;//case
      pa:=Vct[N]; pb:=Vct[M-1];
      result:=M;
    end;
  procedure getBazil(out Vct:TVct;out VcC:TCol; pa,pb,pc,pd:TcgVector; ColA,ColB:TcgColorF; N:integer; isBazil, isParaColor:boolean);//贝塞尔曲线 Dens密度 Dist距离
    var i:integer;  t,k,kL,cR,cG,cB:single;  va,vb,vc, na,nb,nc:TcgVector;
    begin //贝塞尔曲线
      Vct[0]:=pa;  VcC[0]:=ColA;
      k:=1/N; kL:=0;
      if isParaColor then begin
        kL:=(pd.r-pa.r)*k;    //半径递增值
        cR:=(ColB.R-ColA.R)*k;
        cG:=(ColB.G-ColA.G)*k;
        cB:=(ColB.B-ColA.B)*k;
        end;
      va:=cgVecSub(pb,pa); vb:=cgVecSub(pc,pb); vc:=cgVecSub(pd,pc);
      for i:=1 to N do begin
        t:=i*k;
        na:=cgVecAddMult(pa,va,t);
        nb:=cgVecAddMult(pb,vb,t);
        nc:=cgVecAddMult(pc,vc,t);
        na:=cgVecAddMult(na,cgVecSub(nb,na),t);
        nb:=cgVecAddMult(nb,cgVecSub(nc,nb),t);
        Vct[i]:=cgVecAddMult(na,cgVecSub(nb,na),t);
        if isParaColor then begin //颜色随顶点
          Vct[i].r:=pa.r+i*kL; //线宽
          VcC[i]:=cgColorF(ColA.R+i*cR, ColA.G+i*cG, ColA.B+i*cB, 1);
          end;
        end;
    end;
begin result:=0;
  if bOnlyDraw then goto OnlyDraw;
  with Obj[ID] do begin
    if(Mode>6)then goto drawCopy;    //复制
    N:=0; a:=Link[0];
    if(H<1)then H:=1; if(H>8)then H:=8;   Dens:=trunc(H); //密度
    for i:=0 to LinkTime do if Link[i] in[1..ID-1] then inc(N);
    if bAdd then inc(N);
    hide:=(N<1); if hide then exit;
    M:=getVct(Vct,VcC, a, 0, pa,pb); pd:=pb; //第一条路径
    for i:=1 to N-1 do begin //遍历路径构件
      a:=Link[i]; //路径ID
      getEnder(a, pc,pd);
      M:=getVct(Vct,VcC, a, M,pc,pd); //初始顶点
      pb:=pd;  if(M=LocaTime)then Break;
      end;//for i
    isRound:= Link[0]=Link[M-1]; //环状
    end;//with
  setLength(LocaVct[ID], LocaTime);
  isParaColor:=Obj[ID].U; //色随动点
  if isParaColor then setLength(LocaColor[ID], LocaTime)
                 else setLength(LocaColor[ID], 0);
  if Obj[ID].D then begin //D 圆滑路径
    for i:=0 to M-1 do begin Top[i]:=Vct[i]; Col[i]:=VcC[i]; end;//路径点 顶点色
    N:=0;  k:=0;
    vb:=cgNormalVec(Top[0],Top[1]); //vb.w 两点间距
    vi:=vb;
    if isRound then begin
      vc:=cgNormalVec(Top[M-2],Top[0]);
      vi:=cgVecAdd(vb,vc); cgNormalize(vi);
      end;
    for i:=0 to M-2 do begin
      if(Obj[trunc(Top[i].w)].Kind>1)and(Obj[trunc(Top[i+1].w)].Kind>1)then //跳过非点构件
        begin LocaVct[ID,N]:=Top[i]; inc(N); continue;  end;

      pc:=cgVecSubMult(Top[i],vi, vb.w/3);
      if(i=M-2)and not isRound then
        pd:=cgVecMid(pc,Top[M-1]) //终点
      else begin
        if(i=M-2)and isRound
          then vc:=cgNormalVec(Top[i+1],Top[1])
          else vc:=cgNormalVec(Top[i+1],Top[i+2]);
        vi:=cgVecAdd(vb,vc); cgNormalize(vi); //下一顶点的平均向量
        pd:=cgVecAddMult(Top[i+1],vi, vb.w/3);
        end;
      if not isRound and(i=0)then pc:=cgVecMid(pd,Top[0]);

      k:=trunc(Dens*vb.w)+1;
      //========== 贝塞尔曲线 ==========
      getBazil( Vct,VcC, Top[i],pc,pd,Top[i+1], Col[i],Col[i+1], k, true, isParaColor);
      for j:=0 to k-1 do if(N+k)<LocaTime then begin
        Vct[j].w:=Top[i].w;   LocaVct[ID,N+j]:=Vct[j];
        if isParaColor then LocaColor[ID,N+j]:=VcC[j];
        end;
      vb:=vc;
      inc(N,k); if(N>=LocaTime)then Break;
      end;
    inc(N);
    if(N<LocaTime)then begin
      LocaVct[ID,N-1]:=Top[M-1];
      if isParaColor then LocaColor[ID,N-1]:=Col[M-1];
      end;
    M:=N;
    end
  else begin //直连路径
    if(Obj[ID].S>3)then begin
      for i:=0 to M-1 do begin Top[i]:=Vct[i]; Col[i]:=VcC[i]; end;//路径点 顶点色
      N:=0;  k:=0;
      for i:=0 to M-2 do begin
        vb:=cgNormalVec(Top[i+1],Top[i]); //vb.w 两点间距
        k:=trunc(Dens*vb.w);   kL:=vb.w/(k+1);
        if k>LocaTime then k:=LocaTime;
        kR:=(Top[i+1].r-Top[i].r)/k;
        for j:=0 to k do begin
          Vct[N]:=cgVecAddMult(Top[i], vb, j*kL);
          Vct[N].r:=Top[i].r;
          if isParaColor then begin
            Vct[N].r:=Top[i].r+kR*j;
            VcC[N].R:=Col[i].R+(Col[i+1].R-Col[i].R)*j/k;
            VcC[N].G:=Col[i].G+(Col[i+1].G-Col[i].G)*j/k;
            VcC[N].B:=Col[i].B+(Col[i+1].B-Col[i].B)*j/k;
            end;
          inc(N); if(N>(LocaTime-1))then N:=(LocaTime-1);
          end;
        end;
      Vct[N]:=Top[M-1];  VcC[N]:=Col[M-1];
      M:=N+1;
      end;
    for i:=0 to M-1 do LocaVct[ID,i]:=Vct[i];
    if isParaColor then for i:=0 to M-1 do LocaColor[ID,i]:=VcC[i];
    end;
  setLength(LocaVct[ID], M); if isParaColor then setLength(LocaColor[ID], M);
  setLength(  aLink[ID], M); for i:=0 to M-1 do aLink[ID,i]:=true;
  for i:=1 to M-1 do begin
    a:=trunc(LocaVct[ID,i-1].w);  b:=trunc(LocaVct[ID,i].w);
    if(a<>b)and(Obj[a].Kind>1)and(Obj[b].Kind>1)then aLink[ID,i]:=false;
    end;
drawCopy:  //投影复制、镜像复制、旋转复制
  if(Obj[ID].Mode=14)then TransCustom(ID); //自定义变换
  M:=calcLocaLength(ID); //复制轨迹点并计算轨迹点之间距
onlyDraw:
  if bDraw then with Obj[ID] do begin
    M:=high(LocaVct[ID]); //轨迹点数
    listID:=getTraceListID(ID,bAdd); //
      DrawCurve(ID,listID,0, M,S,0, GL_LINE_STRIP, bList,bSport);//画曲线
    if not bAdd and bList and Trace then setTraceList(ID);//痕迹
    if not((Kind=17)and(Mode=20))then //三视图除外
      DrawCurve(ID,ID,4000, M,1,0, GL_LINE_STRIP, bList,false);//被遮挡的虚线
    if TagP.z>1 then TagP.z:=1; if TagP.z<0 then TagP.z:=0;
    p0:= LocaVct[ID][trunc(M*TagP.z)];
    end;//if bSraw then with...
  result:=M;
end;
//======================= 17_2 三视图 ==========================
procedure TfrmMain.men172Click(Sender: TObject);
  var a,i,j :integer;   isSelect :boolean;
begin
  if SelRec[0]=0 then exit;
  HotMenu:=(Sender as TMenuItem);
  AppObjProc:=men172Click; //
  for i:=1 to SelRec[0] do
    if Obj[SelRec[20+i]].Kind in[1..7, 15..17,19] then isSelect:=true;//被选对象中是否含有可以作三视图的对象
  if not isSelect then  exit; //
  inc(ObjCount);  MarkObj:=ObjCount;  inc(backObj.maxName);
  with Obj[MarkObj]do begin
    Name:=getObjName(1);
    Kind:=17;   Mode:=2; L:=0; S:=1; W:=1;  //L=0 投影到三个坐标平面
    F:=true;    if(Obj[SelRec[21]].Kind=17)and(Obj[SelRec[21]].Mode=1)then F:=false;
    color:=cgTColorToCGColorF(255,1);
    CleanLink(MarkObj,0); // for i:=0 to LinkTime do begin Link[i]:=0; LinkName[i]:=0; end;
    for i:=0 to LayerTime do ObjShow[i]:=true;
    for i:=0 to 6 do begin Cutter[i,0]:=0; Cutter[i,1]:=0; Cutter[i,2]:=0; end;
//    GetTextList( ObjCount); //标签的显示列表
    j:=0;
    for i:=1 to SelRec[0] do begin
      a:=SelRec[20+i];
      if not((Obj[a].Kind in[1..7, 15,16,19])or(Obj[a].Kind=17)and(Obj[a].Mode=1))
        then continue;
      inc(j);
      Link[j]:=SelRec[20+i];  LinkName[j]:=Obj[Link[j]].Name;
      Obj[SelRec[20+i]].Hot:=false;
      end;
    Link[0]:=0; LinkName[0]:=0;  //留用于缩放关联
  end;//with
  save( 1, MarkObj, 1, true,false);
  ThreeView( MarkObj); //  ReRelate(11, MarkObj, false,false,false );
  SetProjection( false,false,1);
  ObjListUpdate( MarkObj, true); //if(HotTool<>nil)then HotTool.Down:=false;
end;

procedure TfrmMain.ThreeView( ID: integer); // 三视图
  var i,j,k,n, a, listID:integer;    r0,dr:single;
      BackObj: TmyObject;        pp,pq :TcgVector;
  procedure Draw3View( ID:integer);
  begin
    case Obj[ID].Kind of
      1:Pointe( ID,true,false,false);         // 点
      2:Lineer( ID,true,false,false);         //直线
      3:CircleDraw( ID,true,false,true,false);// 圆
      4:Plane( ID,true,false);                //平面
      5:Locus( ID,true,false,false,false);    //轨迹
      6:Solid( ID,true,false,false,false);    //实体
      7:Face( ID,true,false,false);           //曲面
     15:CrossLine( ID, true,false,false);     //相贯线
     16:funcCurve( ID, true,false,false);     //函数曲线
     17:if(Obj[ID].Mode=1)then Path( ID,true,false,false);           //路径
     19:Conic( ID,true,false,false);          //圆锥曲线
      end;
  end;
begin
  with Obj[ID]do begin
    listID:=getTraceListID( ID, false);
    getListID( seleList,1);
    if(Link[0]>0)then R:=Obj[Link[0]].L;
    if(R<-1)then R:=-1;   if(R>1)then R:=1;//缩放率
    end;
  BackObj:=Obj[ID]; //数据备份
  with BackObj do begin
    if(Link[0]>0)then R:=Obj[Link[0]].L; //投影率
    if(R<-1)then R:=-1; if(R>1)then R:=1;
    glNewList( listID, GL_COMPILE); //OpenGL显示列表
    for i:=1 to LinkTime do begin
      a:=Link[i];  if(a<11)then continue;
      Obj[ID]:=Obj[a];
      for j:=5 to 7 do begin
        if(BackObj.L=1)and(j<>5)or(BackObj.L=2)and(j<>6)or(BackObj.L=3)and(j<>7)
          then continue;
        with Obj[ID]do begin
          Mode:=20; Link[0]:=a;   Link[1]:=j;
          R:=BackObj.R;   F:=BackObj.F;   Color.A:=BackObj.Color.A;
          end;
        Draw3View(ID); //绘制三视图
        if(Obj[ID].Kind=1)and D then begin //投影线
          pp:=Obj[ID].p0;
          if(R<0)then begin
            pp:=Obj[a].p0;  case j of 5:pp.x:=0;  6:pp.y:=0;  7:pp.z:=0; end;
            end;
          glLineWidth(W); glColor3fv(@color);
          if(S>0)then glEnable( GL_LINE_STIPPLE);        //虚线使能
          glLineStipple( 1, stLineStyle[IIFi(j=1,1,S)]); //设置线形
          glBegin(GL_LINES); glVertex3fv(@Obj[a].p0); glVertex3fv(@pp); glEnd; //投影
          if(R<0)and((j<>6))then begin
            n:=abs(trunc(R*halfPI/0.05)); dr:=0; if(n>0)then dR:=abs(R*halfPI/n);//dr>0
            pq:=pp;
            glBegin(GL_LINE_STRIP); //圆弧
            for k:=0 to n do begin
              r0:=k*dR;   pq.y:=pp.y*cos(r0);
              if(j=5)then pq.x:=pp.y*sin(r0)* IIFi(Obj[a].p0.y<0,-1,1)* IIFi(Obj[a].p0.x<0,1,-1);
              if(j=7)then pq.z:=pp.y*sin(r0)* IIFi(Obj[a].p0.y<0,-1,1)* IIFi(Obj[a].p0.z<0,1,-1);
              glVertex3fv(@pq);
              end;
            glEnd;
            end;
          end;
        end;
      end;
    glEndList;
  end;
  Obj[ID]:=BackObj; //数据恢复
end;
//======================= 19 圆锥曲线 ===================
function TfrmMain.Conic( ID:integer; bDraw,bList,bOnlyDraw:boolean):integer;
  const maxVct=1024;
  var a,b,c,i,j,k,M,N,listID :integer;       isLine:boolean;
      t,Len,vL,dL,wL, ax,bx,cx, ix,nx, jx,jy :single;
      pa,pb,pc,pp,pt, na,nb,nc,np,nt :TcgVector;
      Vct:array[0..1,0..maxVct]of TcgVector;
  label drawCopy, OnlyDraw;
  procedure Parabola(pp,pt,np:TcgVector; L,H:single; U:boolean); //抛物线
    var i:integer; t,ix,jx, vL:single; pc:TcgVector;
    begin
      ix:=cgDistance(pp,pt);  //焦距
      if EP(ix)then begin     //退化成直线
        N:=3+trunc(L)*3; t:=L/N;
        for i:=0 to N do begin
          Vct[0,i]:=cgVecAddMult(pt,np,t*i); Vct[1,i]:=cgVecAddMult(pt,np,-t*i);
          end;
        end
      else begin
        t:=4*ix/H;  dL:=t/2;   isLine:=cgVecComp(pa,pb);
        i:=0;     vL:=0;  jx:=ix/2;
        repeat
          if not isLine then jx:=(sqr(ix)+sqr(dL))/(2*ix);
          pc:=cgVecAddMult(pt,np, jx); //主动点  U 半条
          Vct[0,i]:=cgVecAddMult(pc,na, dL); if not U then Vct[1,i]:=cgVecAddMult(pc,na,-dL);
          if(i=0)then Vct[0,0].w:=0 else vL:=vL+cgDistance( Vct[0,i], Vct[0,i-1] );
          dL:=dL+t;
          inc(i);
          until(not U and(vL>L/2)) or (U and(vL>L)) or (i>=maxVct);
        end;
      N:=i-2; 
      if U then M:=N else M:=2*N+1;  setLength(LocaVct[ID], M+1);
      for i:=0 to N do LocaVct[ID,i]:=Vct[0,N-i];
      if not U then for i:=0 to N do LocaVct[ID,N+i+1]:=Vct[1,i];//负半枝
    end;
  function Ellipse(ID:integer; pa,pc:TcgVector; Len,R:single):TcgVector;  //椭圆
    var i:integer;   aR, t:single;  // pa焦点 pc椭圆心 Len半径 R:椭圆度
    begin
      setLine(9,pc,Obj[ID].Vec);  getDotAngleByAxis(pa,9,aR); //长轴转角
      N:=trunc(Obj[ID].H/2); M:=N*2; //H密度
      setLength(LocaVct[ID], M+1);
      t:=towPi/M;
      for i:=0 to N-1 do LocaVct[ID,i]:=DotInCircle(pc,ID, i*t,Len,R,aR); //计算半条即可
      for i:=0 to N do LocaVct[ID,N+i]:=cgVecSub(pc,cgVecSub(LocaVct[ID,i],pc)); //再复制半条
      result:=pc;
    end;
  function Hyperbola(ID:integer; pa,pb,pp,np:TcgVector):TcgVector;  //双曲线 pa,pb焦点 pp过点   na,
    var i:integer;  Na,pc:TcgVector;  t, Ax,Bx,Ix,Jx,Nx, dL,vL :single;
    begin
      pc:=cgVecMid(pa,pb); //中点
      Na:=cgNormalVec(pb,pa);   //焦点连线向量
      Len:=na.w/2; //半焦距
      Ax:=abs(cgDistance(pp,pa)-cgDistance(pp,pb))/2; //Ax半长轴
      Nx:=Ax*Ax/Len;  if EP(Ax)then Bx:=0 else Bx:=1-sqr(Len/Ax);  //Bx半短轴
      with Obj[ID]do begin p1:=pa; p2:=pb; p3:=Na; p4:=np; p4.w:=Ax; end; //用于渐近线/准线
      Ix:=Len-nx;  t:=4*Ix/Obj[ID].H; //H密度
      i:=0;  dL:=t/2;  vL:=0;
      repeat
        if EP(bx)then Jx:=0 else Jx:=Nx+(Ix-sqrt(Ix*Ix*(1-Bx)-Bx*dL*dL))/Bx;
        pt:=cgVecAddMult(pc,np, dL);  Vct[0,i]:=cgVecAddMult(pt,Na, Jx);
        pt:=cgVecAddMult(pc,np,-dL);  Vct[1,i]:=cgVecAddMult(pt,Na, jx);
        if(i>0)then vL:=vL+cgDistance(Vct[0,i],Vct[0,i-1]);
        dL:=dL+t;
        inc(i);
        until not Obj[ID].U and(vL>Obj[ID].L/4)or (Obj[ID].U and(vL>Obj[ID].L/2)) or(i>=maxVct); // or(i>100)
      N:=i-1; M:=4*N+3; if Obj[ID].U then M:=2*N+1;
      setLength(LocaVct[ID], M+1);
      for i:=0 to N do LocaVct[ID,    i  ]:=Vct[1,N-i];
      for i:=0 to N do LocaVct[ID,  N+i+1]:=Vct[0,  i];
      if not Obj[ID].U then
        for i:=0 to N*2+1 do LocaVct[ID,2*N+i+2]:=cgVecSub(pc, cgVecSub( LocaVct[ID,i],pc));
      result:=pc;
    end;
begin
  with Obj[ID] do begin
  a:=Link[0]; b:=Link[1]; c:=Link[2];
  if bAdd and(Obj[a].Kind=1)and(b<11)then exit;
  hide:=Obj[a].Hide or Obj[b].Hide or Obj[c].Hide or(Link[6]>0)and Obj[Link[6]].Hide;
  if hide then exit;
  if(Mode>6)then goto drawCopy;
  pa:=Obj[a].p0; //抛物线准线起点，椭圆双曲线左焦点
  pb:=cgIIF(Mode=1, Obj[b].p0, Obj[a].p1); //抛物线准线终点，椭圆双曲线右焦点
  pp:=cgIIF(Mode=1, Obj[c].p0, Obj[b].p0); //抛物线焦点，椭圆双曲线上的点
  if cgVecComp(pa,pb)then begin //两焦点重合
    hide:=cgVecComp(pa,pp); if hide then exit; //第三点也重合
    np:=cgVecSub(pp,pa);
    if cgVecComp(np,Obj[7].Vec)
      then na:=Obj[2].Vec
      else na:=cgCrossProduct(Obj[7].Vec,np);
    Vec:=cgCrossProduct(np,na);
    pt:=pa; //pt 垂足
    end
  else begin
    na:=cgNormalVec(pb,pa);               //准线向量
    if cgDotAtLine(pp, pa,pb)
      then Vec:=cgVector(0,0,1)
      else Vec:=cgGetNormal(pp,pa,pb);    //曲线所在平面法线
    cgFooterAtLine(pp, pa,pb, pt,false);  //pt垂足  pt焦点在准线上的垂点
    if cgVecComp(pp,pt)
      then np:=cgCrossProduct(Vec,na)
      else np:=cgVecSub(pp,pt);//焦点连线向量
    end;
  cgNormalize(Vec);  cgNormalize(np);
  Vec.w:=-cgDotProduct(Vec,pp);           //曲线所在平面截距
  Len:=cgDistance(pa,pb)/2;               //半焦距
  if EP(H)then H:=8;   //H密度
  if(Mode=1)then //第一定律
    case trunc(Angle)of
    0:begin
      p5:=pp; p1:=pa; p2:=pt; p3:=na; p4:=np; //p5焦点 p3准线向量 p4中轴向量
      Parabola(pp,pt,np, L,H, U );  // 抛物线
      end;
    1:begin // 椭圆
      p0:=cgVecMid(pa,pb);  //p0圆心 pa,pb左右焦点
      Ax:=(cgDistance(pp,pa)+cgDistance(pp,pb))/2; //半长轴
      Cx:=cgDistance(pa,p0); //半焦距
      Bx:=sqrt( abs(sqr(Ax)-sqr(Cx)) );//半短轴
      with Obj[ID]do begin p1:=pa; p2:=pb; p3:=Na; p4:=np; p4.w:=Ax; p4.r:=Bx; end; //用于渐近线/准线
      if EP(Ax)then vL:=1 else vL:=1-Bx/Ax; //扁度
      Ellipse(ID,pa,p0,Ax,vL);  // 椭圆
      end;
    2:p0:=Hyperbola(ID,pa,pb,pp,np); // 双曲线
    end;//第一定律
  if(Mode=2)then begin // 第二定律
    if(Link[3]>0)then R:=Obj[Link[3]].L;
    t:=np.w/(R+1);  //t曲线顶点至准线之距离  np.w焦点至准线之距离
    if(R=1)then //抛物线
      Parabola(pp,pt,np, L,H, U )
    else if(R<1)then begin //椭圆
      ix:=(1-R*R);  Ax:=np.w*R/ix; //Ax半长轴
      ix:=sqrt(ix);   //半短轴 Bx:=Ax*ix;
      p0:=cgVecAddMult(pp,np, Ax-np.w+t); //p0椭圆心
      np:=na;
      Ellipse(ID,pp,p0,Ax,1-ix); //椭圆
      end
    else begin //双曲线
      pc:=cgVecAddMult( pt, np, t); //顶点
      t:=2*np.w/(R*R-1)+2*np.w;
      pb:=cgVecSubMult( pp, np, t );  //pb外焦点
      p0:=Hyperbola(ID,pb,pp,pc, na); // 双曲线
      end; //抛物线 双曲线
    end;  // 第二定律
  setLength(  aLink[ID], M+1); for i:=0 to M do aLink[ID,i]:=true;
  if((Mode=1)and(Angle=2) or (Mode=2)and(R>1)) and(not U)
    then aLink[ID,(M div 2)+1]:=false; //双曲线中间间断
drawCopy:  //投影复制、镜像复制、旋转复制
  if(Mode in[7..12,15,16,20])then begin
    M:=high(LocaVct[a]);
    setLength(LocaVct[ID], M+1); for i:=0 to M do LocaVct[ID,i]:=transVec(ID,LocaVct[a,i]);
    M:=high(aLink[a]);
    setLength(  aLink[ID], M+1); for i:=0 to M do aLink[ID,i]:=aLink[a,i];
    end;
  if(Mode=14)then M:=TransCustom(ID); //自定义变换
  vL:=0; LocaVct[ID,0].w:=0;  //总长度
  for i:=1 to M do begin //各轨迹点至起点之间距
    dL:=cgDistance(LocaVct[ID,i-1],LocaVct[ID,i]);
    if(aLink[ID,i])then vL:=vL+dL;
    LocaVct[ID,i].w:=vL; 
    end;
  if(Angle=1)then L:=vL; //椭圆周长
  end;//with
onlyDraw:
  if bDraw then with Obj[ID] do begin
    M:=high(LocaVct[ID]); //轨迹点数
    listID:=getTraceListID(ID,bAdd); //
      DrawCurve(ID,listID,0, M,S,0, IIFc( F, GL_LINE_STRIP, GL_POINTS), bList,bSport);//画曲线
    if not bAdd and bList and Trace then setTraceList(ID);//痕迹
      DrawCurve(ID,ID,4000, M,1,0, GL_LINE_STRIP, bList,false);//画曲线
    if TagP.z>1 then TagP.z:=1; if TagP.z<0 then TagP.z:=0;
    p0:= LocaVct[ID][trunc(M*TagP.z)];
    end;//if bSraw then with...
  result:=M;
end;
//======================= 7 曲面 ===================
procedure TfrmMain.Face( ID:integer; bDraw,bList,bOnlyDraw:boolean);
  var a,b, i,j,M,N, listID :integer;
  Label OnlyDraw;
begin //Cursor:=crHourGlass;
  with Obj[ID] do begin
  a:=Link[0]; b:=Link[1];
  hide:= Obj[a].hide or Obj[b].hide or(Link[6]>0)and Obj[Link[6]].Hide;
  if hide then exit;
  if bOnlyDraw then goto OnlyDraw;
  setLength(FaceVct[ID], 0);
  setLength(aLink[ID], 0);
  if Obj[a].Kind in[5,7,15,16,17,19] then begin
    N:=High(aLink[a]);
    if N>0 then begin
      setLength(aLink[ID],N+1);
      for i:= 0 to N do aLink[ID,i]:= aLink[a,i];
      end;
    end;
  case Mode of
    1:RollFace( ID,bList,bOnlyDraw);   //旋转曲面
    2:RureFace( ID,bList,bOnlyDraw);   //直纹曲面
    4:NormalFace( ID,bList,bOnlyDraw); //轨迹面
    7..12,15,20:begin //变换
      M:=high(FaceVct[a]);   N:=high(FaceVct[a,0]);
      setLength(FaceVct[ID],M+1);
      for j:= 0 to M do begin
        setLength(FaceVct[ID,j], N+1);
        for i:= 0 to N do FaceVct[ID,j,i]:= transVec( ID, FaceVct[a,j,i]);
        end;
      end;
    14:TransCustom(ID); //自定义变换
    end;
OnlyDraw:
  if bDraw then begin
    getListID(maskList,1); getListID(wireList,1); getListID(seleList,1);
    listID:=getTraceListID(ID,bAdd);
    j:=IIFi(bList,1,0);
    for i:=0 to j do begin //
      if bList then glNewList( IIFi(i=0,listID,seleList), GL_COMPILE); // listID+i*9000
      case Obj[parent].Mode of
        1,2,15:FaceDraw( ID,i>0, true,false,false,false,false); //旋转曲面 直纹曲面
//        3:FaceDraw( ID,i>0, false,false,false,false,false); //复合曲面
        4:FaceDraw( ID,i>0, (Obj[a].Kind=3)and(Obj[a].Mode<3), false,false,false,false);//轨迹面
        end;
      if bList then glEndList;
      if not bAdd and bList and Trace then setTraceList(ID);//痕迹
      end;//for i
    if(Mode=4)then labHint.caption :=itos(Mode); //见鬼，没用这句有时就不显示轨迹面
    end;
  p0:=FaceVct[ID,1,0];  //用于打印标签
  end; //with  //Cursor:=crDefault;
end;
//======================= 6_0 实体 ===================
procedure TfrmMain.SolidDraw(ID:integer; isSeled,isWire,isMask :boolean);
  var i,j,k, M,N,N0,N1, kM,kN,kS :integer;   ww,hh :single;  //
      pa,pb,pc,pd, pn,v0,v1 :TcgVector;   isShell:boolean;
      Vct:array of array of TcgVector;   Nor :array of TcgVector;
begin //Lst.Clear;
  if(Obj[ID].Kind<>6)then exit;
  M:=High(FaceVct[ID]);   setLength(Vct, M+1);
  N:=High(FaceVct[ID,0]); for i:=0 to M do setLength(Vct[i], N+1);//法线数组
  for i:=0 to M do for j:=0 to N do Vct[i,j]:=FaceVct[ID,i,j];  //备份

  with Obj[ID] do begin
  if(Obj[parent].Mode<3)or(Mode=15)then begin //球体 圆台体
    v0:=cgVecSub(p0,p1);  v1:=v0;  cgInvertVec(v1);
    end;
  if(Mode in[7..16])and(Obj[parent].Mode in[3,4])
    then glLineWidth(W)
    else glLineWidth(Obj[1].p2.x);
  if not((Kind=6)and(Mode=5))and(Link[12]>10)then Color.A:=Obj[Link[12]].L; //Mode=5 凸壳
  setTowFaceColor(ID, not(Mode in[5,20])and(Link[6]>10));//Mode=20 凸壳
  glPolygonMode( GL_FRONT_AND_BACK, IIFi( isWire, GL_LINE, GL_FILL)); // GL_LINE);//

  glDisable( GL_TEXTURE_2D);
  setEnable(not isSeled, GL_LIGHTING);//
  setEnable(not isMask, GL_LIGHTING);
  setEnable(not isWire, GL_LIGHTING);
//  glColor4fv(@Color);
  if isWire and isSeled then begin //选择状态时，关闭材质变化
    glEnable(GL_COLOR_MATERIAL);
    glColor4fv(@Obj[1].ColorB); //被选择时的颜色
    end;
  if isWire and not isSeled and not isMask then
    glColor4fv(@Color);
  if isMask then
    glColor4fv(@ColorB); //遮挡部分虚线颜色
  if(Obj[parent].Mode in[1,2,6])and(texID>0)and D and not isWire then begin //绑定纹理
    glColor4f(1,1,1,1);
    glEnable(GL_ALPHA_TEST);  glAlphaFunc(GL_GREATER, 0);
    glEnable(GL_TEXTURE_2D);  glBindTexture(GL_TEXTURE_2D, texID);

    ww:=0.98*kw/M; hh:=0.98*kh; if(Mode<>2)then hh:=hh/N; //纹理比例
    end;
  setEnable(isWire and isMask and Mask, GL_LINE_STIPPLE);
  if(isWire and isMask and Mask)then glLineStipple( 1, stLineStyle[1]); //设置线形
  case Obj[parent].Mode of
  1,6,15:begin //1点法球 6三点球 15反演球
    if(Mode>6)then S:=Obj[Parent].S;
    isShell:= (Obj[Parent].Angle<0.0001); //是否整球
    kM:=M; if not isShell then kM:=M-2;   //若为球缺
    N0:=0; if(Obj[Parent].pTR.y>0)then N0:=1;   //球台起始角
    N1:=N; if(Obj[Parent].pTR.x>0)then N1:=N-1; //球台终止角
    if( isSeled or isWire )then begin // and isMask
      kS:=(S div 2)*2+2;
      kN:=(N1-N0) div S;
      for j:=0 to S do begin //纬线
        k:=kM; if(j=0)or(j=S)then k:=M;
        glBegin(GL_LINE_STRIP); for i:=0 to k do glVertex3fv( @Vct[i,j*kN+N0]); glEnd;
        end;
      kN:=kM div kS;
      for j:=0 to kS do begin //径线
        glBegin(GL_LINE_STRIP); for i:=N0 to N1 do glVertex3fv( @Vct[j*kN,i]); glEnd;
        end;
      if not isShell then begin
        glBegin(GL_LINES); glVertex3fv( @Vct[M-1,N1]); glVertex3fv( @Vct[M-1,N0]); glEnd;
        end;
      end
    else begin
      kN:=1; if(Color.A<1)and F or D then kN:=0; //透明状态不画网格线
      for kS:=0 to kN do begin //画两遍 第二遍画轮廓以消除锯齿
        for j:=N0 to N1 do
          for i:=0 to kM do begin //计算每个顶点的法向量
            if(j=0)or(j=N1)then  //or(H=0)and(W=0)
              Vct[i,j]:=cgNormalVec( Vct[i,j], p0) //极点向量
            else if(i=kM)then
              Vct[i,j]:=Vct[ IIFi(isShell,0,i-1), j]
            else
              Vct[i,j]:=cgPlaneNormal(FaceVct[ID,i,j],   FaceVct[ID,i+1,j+1],
                                      FaceVct[ID,i+1,j], FaceVct[ID,i,j+1],  false);
            end;//for i
        if kS=1 then glPolygonMode( GL_FRONT_AND_BACK, GL_LINE);//
        for j:=N0 to N1-1 do if(kS=0)or(kS=1)and(j>0)and(j<(N1-1))then begin
          glLineWidth(0.5);
          glBegin(GL_QUAD_STRIP);
          for i:=0 to kM do begin
            if D then glTexCoord2f( ww*(kM-i)+0.01, hh*(j+1) ); //纹理
            glNormal3fv(@Vct[i,j+1]);   glVertex3fv( @FaceVct[ID,i,j+1]);
            if D then glTexCoord2f( ww*(kM-i)+0.01, hh*(j) ); //纹理
            glNormal3fv(@Vct[i,j]);     glVertex3fv( @FaceVct[ID,i,j]);
            end;
          glEnd;
          end; //for j
        glDisable(GL_TEXTURE_2D); //关闭纹理
        if not U and  not isShell then begin //球缺 U球面
          for i:=kM to kM+1 do begin
            if(i=kM)then pn:=cgGetNormal( FaceVct[ID, kM,(S div 2)], p0, p1)
                    else pn:=cgGetNormal( FaceVct[ID,  M,(S div 2)], p1, p0);
            glNormal3fv(@pn);
            glBegin(GL_QUAD_STRIP);
            for j:=N0 to N1 do begin
              glVertex3fv( @FaceVct[ID,i+1,j]);  glVertex3fv( @FaceVct[ID,i,j]);
              end;
            glEnd;
            end;
          end;
        if not U and (Obj[Parent].pTR.x>0)then begin //上球台  U球面
          pn:=cgNormalVec(p0,p1);   glNormal3fv(@pn);
          glBegin( GL_TRIANGLE_FAN);
            glVertex3fv( @FaceVct[ID,M-1,N]);
            for i:=kM downto 0 do glVertex3fv( @FaceVct[ID,i,N-1]);
          glEnd;
          end;
        if not U and (Obj[Parent].pTR.y>0)then begin //下球台  U球面
          pn:=cgNormalVec(p1,p0);   glNormal3fv(@pn);
          glBegin( GL_TRIANGLE_FAN);
            glVertex3fv( @FaceVct[ID,M-1,0]);
            for i:=0 to kM do glVertex3fv( @FaceVct[ID,i,1]);
          glEnd;
          end;
        end; //for kS
      end;
    end;
  2:begin //圆台
    if(Obj[parent].Trace)then j:=1 else j:=0; //Trace 封底
    if isSeled or isWire then begin
      glBegin(GL_LINE_STRIP); for i:=0 to M do glVertex3fv(@Vct[i,j  ]); glEnd;
      glBegin(GL_LINE_STRIP); for i:=0 to M do glVertex3fv(@Vct[i,j+1]); glEnd;
      kS:=(S div 2)*2+2;  kM:=M div kS;
      for i:=0 to kS do begin
        glBegin(GL_LINES); glVertex3fv(@Vct[i*kM,j]); glVertex3fv(@Vct[i*kM,j+1]); glEnd;
        end;
      if(Angle>0)and Trace and not F then begin //扇形圆台
        glBegin(GL_LINES); glVertex3fv(@p0); glVertex3fv(@p1); glEnd;
        end;
      end
    else begin
      kN:=1; if(Color.A<1)and F then kN:=0;
      N:=M;  if(Obj[parent].Angle>0)and Obj[parent].Trace then N:=N-2;
      for kS:=0 to kN do begin //kN=1时画两遍 第二遍画轮廓以消除锯齿
        if(kS=1)and(W>0)then glPolygonMode( GL_FRONT_AND_BACK, GL_LINE);
        if(kS=1)and(W=0)then glPolygonMode( GL_FRONT, GL_LINE);
        if(kS=1)then glLineWidth(1);
        glBegin(GL_QUAD_STRIP);
        for i:=0 to N do begin
          k:=i; if(i=N)and(Obj[parent].Angle=0)then k:=0;
          if F then begin
            if(Mode in[7,9,20])then begin //投影 旋转 三视图
              if(i<N)then pn:=cgPlaneNormal(Vct[k,j], Vct[k+1,j+1], Vct[k+1,j], Vct[k,j+1], false);
              end
            else
              pn:=cgVecSub( Vct[i,j],p4);
            if(Mode=8)and(Obj[Link[1]].Kind in[1,4])then cgInvertVec(pn);//对称变换时法线作反
            glNormal3fv(@pn);
            end;
          if D then glTexCoord2f( ww*i+0.01, hh ); //纹理
          glVertex3fv( @Vct[k,j+1]);
          if D then glTexCoord2f( ww*i+0.01, 0 ); //纹理
          glVertex3fv( @Vct[k,j]);
          end;
        if(Obj[parent].Angle>0)and Obj[parent].Trace then //扇形圆台切面
          for i:=N to N+1 do begin
            if(kS=0)and F then begin
              pn:=cgGetNormal(Vct[i,1], Vct[i+1,1], Vct[i,2]);
              glNormal3fv(@pn);
              end;
            glVertex3fv( @Vct[i,1]);  glVertex3fv( @Vct[i,2]);
            glVertex3fv( @Vct[i+1,1]);  glVertex3fv( @Vct[i+1,2]);
            end;
        glEnd;
        if(Obj[parent].Trace)and not isWire and not Obj[parent].D then begin //封顶
          glBegin(GL_TRIANGLE_FAN);
            pn:=cgGetNormal(p1, Vct[1,1], Vct[0,1]); // cgVecSub( p0,p1);
            if(Mode=8)and(Obj[Link[1]].Kind in[1,4])then cgInvertVec(pn);
            glNormal3fv(@pn);
            glVertex3fv( @p0); for i:=M downto 0 do glVertex3fv( @Vct[i,1]);
          glEnd;
          glBegin(GL_TRIANGLE_FAN);
            cgInvertVec(pn);   glNormal3fv(@pn);
            glVertex3fv( @p1); for i:=0 to M do glVertex3fv( @Vct[i,2]);
          glEnd;
          end;
        end;
      end;
    end;
  3:begin
    if Rand then begin glEnable(GL_COLOR_MATERIAL); ww:=Color.A; end; //分色
    case S of //多面体
    1,11:if(isWire)then begin //四面体
        glBegin(GL_LINE_STRIP);
          glVertex3fv( @Vct[1,0]); glVertex3fv( @Vct[0,0]);
          glVertex3fv( @Vct[0,1]); glVertex3fv( @Vct[1,1]);
          glVertex3fv( @Vct[1,2]); glVertex3fv( @Vct[0,2]);
          glVertex3fv( @Vct[0,3]); glVertex3fv( @Vct[1,3]);
        glEnd;
        end
      else begin
        for i:=0 to 3 do begin
          if Rand then
            case i of //分色
              0:glColor4f(1,0,0,ww);  1:glColor4f(0,1,0,ww);
              2:glColor4f(1,1,0,ww);  3:glColor4f(0,0,1,ww);
              end;
          pn:=cgPlaneNormal(Vct[0,i],Vct[0,i+1], Vct[1,i+1],Vct[1,i],false);
          if(i in[1,3])then cgInvertVec(pn); glNormal3fv(@pn);
          glBegin(GL_QUADS);
            glVertex3fv( @Vct[1,i]);   glVertex3fv( @Vct[1,i+1]);
            glVertex3fv( @Vct[0,i+1]); glVertex3fv( @Vct[0,i  ]);
          glEnd;
          end;
        end;
    2,12,6:if(isWire)then begin //六面体 长方体
        for j:=0 to 3 do begin //线框
          glBegin(GL_LINE_STRIP);
            glVertex3fv( @Vct[1,j+1]); glVertex3fv( @Vct[1,j]);
            glVertex3fv( @Vct[2,j]);   glVertex3fv( @Vct[2,j+1]);
          glEnd;
          end;
        end
      else begin
        for j:=0 to 3 do begin //侧面
          if Rand then
            case j of //分色
              0:glColor4f(1,0,0,ww);      1:glColor4f(0,1,0,ww);
              2:glColor4f(1,0.5,0.5,ww);  3:glColor4f(0,0,1,ww);
              end;
          pn:=cgGetNormal(Vct[1,j], Vct[2,j], Vct[2,j+1]);
          glNormal3fv( @pn);  //法线
          glBegin(GL_POLYGON);
            glVertex3fv( @Vct[2,j]);   glVertex3fv( @Vct[2,j+1]);
            glVertex3fv( @Vct[1,j+1]); glVertex3fv( @Vct[1,j]);
          glEnd;
          end;
        pn:=cgGetNormal(Vct[1,0], Vct[1,1], Vct[1,2]); glNormal3fv( @pn); //上底法线
        if Rand then glColor4f(1,1,0,ww);
        glBegin(GL_POLYGON);
          for j:=0 to 4 do glVertex3fv( @Vct[1,j]); //上底
        glEnd;
        pn:=cgGetNormal(Vct[2,0], Vct[2,2], Vct[2,1]); glNormal3fv( @pn); //上底法线
        if Rand then glColor4f(0,1,1,ww);
        glBegin(GL_POLYGON);
          for j:=4 Downto 0 do glVertex3fv( @Vct[2,j]);//下底
        glEnd;
        end;
    3,13:if(isWire)then begin //八面体
        for j:=0 to 3 do begin
          glBegin(GL_LINE_STRIP);
            glVertex3fv( @Vct[0,0]);   glVertex3fv( @Vct[1,j]);
            glVertex3fv( @Vct[1,j+1]); glVertex3fv( @Vct[2,0]);
          glEnd;
          end;
        end
      else begin
        glBegin(GL_TRIANGLES);
        for j:=0 to 3 do begin //上半部
          if Rand then
            case j of //分色
              0:glColor4f(1,0,0,ww);  1:glColor4f(0,1,0,ww);
              2:glColor4f(1,1,0,ww);  3:glColor4f(0,0,1,ww);
              end;
          pn:=cgGetNormal( Vct[0,0], Vct[1,j], Vct[1,j+1]); glNormal3fv(@pn); //法线
          glVertex3fv( @Vct[0,0]);   glVertex3fv( @Vct[1,j]); glVertex3fv( @Vct[1,j+1]);
          end;
        glEnd;
        glBegin(GL_TRIANGLES);
        for j:=0 to 3 do begin //下半部
          if Rand then
            case j of //分色
              0:glColor4f(1,1,0,ww);  1:glColor4f(0,0,1,ww);
              2:glColor4f(1,0,0,ww);  3:glColor4f(0,1,0,ww);
              end;
          pn:=cgGetNormal( Vct[2,0], Vct[1,j+1], Vct[1,j]); glNormal3fv(@pn); //法线
          glVertex3fv( @Vct[1,j+1]);  glVertex3fv( @Vct[1,j]);glVertex3fv( @Vct[2,0]);
          end;
        glEnd;
        end;
    4,14:if(isWire)then begin //十二面体
        glBegin(GL_LINES);
        for j:=0 to 4 do begin  k:=j*2;
          glVertex3fv( @Vct[1,k]);   glVertex3fv( @Vct[1,k+2]);
          glVertex3fv( @Vct[1,k+2]); glVertex3fv( @Vct[2,k+2]);
          glVertex3fv( @Vct[2,k+2]); glVertex3fv( @Vct[2,k+1]);
          glVertex3fv( @Vct[2,k+1]); glVertex3fv( @Vct[2,k]);
          glVertex3fv( @Vct[2,k+1]); glVertex3fv( @Vct[3,k+1]);
          glVertex3fv( @Vct[3,k]);   glVertex3fv( @Vct[3,k+1]);
          glVertex3fv( @Vct[3,k+1]); glVertex3fv( @Vct[3,k+2]);
          end;
        glEnd;
        end
      else
        for i:=0 to 3 do begin
          glBegin(GL_QUADS);
          if Rand and(i=0)or(i=3)then glColor4f(1,1,0,ww);  ;//分色 上下底黄色  //
          for j:=0 to 9 do begin
            if Rand then begin //分色
              if(i=1)then case j of //上层
                0,1:glColor4f(1,0,0,ww); 2,3:glColor4f(0,1,0,ww);
                4,5:glColor4f(0,0,1,ww); 6,7:glColor4f(1,0,1,ww); 8,9:glColor4f(0,1,1,ww);
                end;
              if(i=2)then case j of //下层
                0,9:glColor4f(0,0,1,ww); 1,2:glColor4f(1,0,1,ww);
                3,4:glColor4f(0,1,1,ww); 5,6:glColor4f(1,0,0,ww); 7,8:glColor4f(0,1,0,ww);
                end;
              end;
            pn:=cgPlaneNormal(Vct[i,j],Vct[i,j+1],Vct[i+1,j+1],Vct[i+1,j], false);
            glNormal3fv(@pn);
            glVertex3fv( @Vct[i,j]);      glVertex3fv( @Vct[i+1,j]);
            glVertex3fv( @Vct[i+1,j+1]);  glVertex3fv( @Vct[i,j+1]);
            end;
          glEnd;
          end;
    5,15:if(isWire)then  //二十面体
        for j:=0 to 4 do begin k:=j*2;
          glBegin(GL_LINE_STRIP);
            glVertex3fv( @Vct[0,0]);    glVertex3fv( @Vct[1,k+2]);
            glVertex3fv( @Vct[2,k+2]);  glVertex3fv( @Vct[3,0]);
          glEnd;
          glBegin(GL_LINE_STRIP);
            glVertex3fv( @Vct[1,k+2]);  glVertex3fv( @Vct[1,k]);
            glVertex3fv( @Vct[2,k+1]);  glVertex3fv( @Vct[2,k]);
          glEnd;
        end
      else
        for i:=0 to 2 do
          for j:=0 to 9 do begin
            if Rand then begin //分色
              if(i=0)then case j of //上层
                0,9:glColor4f(0,0,1,ww); 1,2:glColor4f(0,1,0,ww);
                3,4:glColor4f(0,1,1,ww); 5,6:glColor4f(1,0,0,ww); 7,8:glColor4f(1,1,0,ww);
                end;
              if(i=1)then case j of //中层
                0,3:glColor4f(1,1,0,ww); 1,8:glColor4f(1,0,0,ww);
                2,5:glColor4f(0,0,1,ww); 4,7:glColor4f(0,1,0,ww); 6,9:glColor4f(0,1,1,ww);
                end;
              if(i=2)then case j of //下层
                0,9:glColor4f(0,1,0,ww); 1,2:glColor4f(0,1,1,ww);
                3,4:glColor4f(1,0,0,ww); 5,6:glColor4f(1,1,0,ww); 7,8:glColor4f(0,0,1,ww);
                end;
              end;
            glBegin(GL_QUADS);
            pn:=cgPlaneNormal(Vct[i  ,j  ], Vct[i  ,j+1],
                              Vct[i+1,j+1], Vct[i+1,j  ],false);
            glNormal3fv(@pn);
            glVertex3fv( @Vct[i  ,j  ]);  glVertex3fv( @Vct[i+1,j]);
            glVertex3fv( @Vct[i+1,j+1]);  glVertex3fv( @Vct[i,j+1]);
            glEnd;
          end;
    end; //case S
    end;
  4:begin //棱台
    if(Obj[parent].Trace)then j:=1 else j:=0; //Trace 封底
    N:=S; if(N>100)then N:=N-100; //正n棱台N>100
    if N=0 then N:=trunc(Obj[Obj[parent].Link[0]].W); //S=0 底面为任意多边形的凸棱台
    if(N=99)then N:=4; //底面为矩形
    with Obj[Link[0]]do isShell:=(Kind=4)and(Mode=6)and not Rand; //底面是否凸多边形
    if(isWire)then begin
      for i:=0 to N-1 do if not(isShell and Obj[Link[0]+i+1].Lock)then begin //
        k:=i+1; if(k=N)or(isShell and Obj[Link[0]+1+k].Lock)then k:=0; //跳过凸多边形里不存在的棱边
        glBegin(GL_LINE_STRIP);
          glVertex3fv( @Vct[i,  j]);  glVertex3fv( @Vct[k,j]);
          glVertex3fv( @Vct[k,j+1]);  glVertex3fv( @Vct[i,j+1]);
        glEnd;
        end;
      end
    else begin
      if(Obj[parent].Trace)then begin //封底
        glBegin(GL_TRIANGLE_FAN);
        pn:=cgGetNormal(p1, Vct[0,1], Vct[1,1]); // pn:=cgVecSub( p1,p0);
        glNormal3fv(@pn);
        for i:=0 to N do glVertex3fv( @Vct[i,1]);
        glEnd;
        glBegin(GL_TRIANGLE_FAN);
        cgInvertVec(pn);        glNormal3fv(@pn);
        for i:=N Downto 0 do glVertex3fv( @Vct[i,2]);
        glEnd;
        end;  //
      for i:=0 to N-1 do if not(isShell and Obj[Link[0]+1+i].Lock)then begin //侧面
        k:=i+1; if(k=N)or(isShell and Obj[Link[0]+1+k].Lock)then k:=0; //跳过凸多边形里不存在的棱边
        glBegin(GL_TRIANGLE_FAN);
        pn:=cgGetNormal(Vct[i,j], Vct[i,j+1], Vct[k,j+1]);
        glNormal3fv( @pn);  //法线
          glVertex3fv( @Vct[i,j  ]);  glVertex3fv( @Vct[i,j+1]);
          glVertex3fv( @Vct[k,j+1]);  glVertex3fv( @Vct[k,j]);
        glEnd;
        end;
      end;
    end;
  5:if(isWire)then begin // 凸壳
      glBegin(GL_LINES); //线框
{      for j:=0 to M-1 do begin
        glVertex3fv( @Vct[j,0]);  glVertex3fv( @Vct[j  ,1]);
        if(not isSeled)then begin
          glVertex3fv( @Vct[j,0]);  glVertex3fv( @Vct[j+1,0]);
          glVertex3fv( @Vct[j,1]);  glVertex3fv( @Vct[j+1,1]);
          end;
        end;  }
        M:=high(LocaVct[ID]) div 2;
      for j:=0 to M-1 do begin
        glVertex3fv( @LocaVct[ID, j*2]);  glVertex3fv( @LocaVct[ID, j*2+1]);
        end;
      glEnd;
      end
    else
      for j:=0 to M-1 do begin //侧面
        pn:=cgGetNormal(Vct[j,1], Vct[j,0], Vct[j+1,0]); //面片法线
        v0:=cgNormalVec(Vct[j,1], Obj[ID].p2); //形心p2已在计算凸壳顶点时计算好
        v1:=cgVecAdd(v0,pn);  v1.w:=sqrt(v1.x*v1.x +v1.y*v1.y +v1.z*v1.z);//形心到面片的向量
        if(v1.w<pn.w)then cgInvertVec(pn);//法线是否由内向外
        glBegin(GL_QUADS);
          glNormal3fv( @pn);  //法线
          glVertex3fv( @Vct[j,0]);      glVertex3fv( @Vct[j+1,0]);
          glVertex3fv( @Vct[j+1,1]);    glVertex3fv( @Vct[j,1]);
        glEnd;
        end;
  end;//case Mode
  end;//with
  setLength(Vct, 0);
end;

  function cgMidColor(a,b :TcgColorF; t:single):TcgColorF;
    begin
      result.R:=a.r+(b.r-a.r)*t;  result.G:=a.g+(b.g-a.g)*t;
      result.B:=a.b+(b.b-a.b)*t;  result.A:=a.a+(b.a-a.a)*t;
    end;
//======================= 7_0 曲面 ===================
procedure TfrmMain.FaceDraw( ID:integer; isSeled,isCircle,isBall,isSolid,isMask,isLine:boolean);
  var a,b,Ka,Ma,Kb,Mb, i,j,k, M,N,nM,nN :integer; //isWire 被选择时用 , start,ender
      pn,n0,v0,v1 :TcgVector;
      Nor :array of array of TcgVector;    ww,hh :single;
      isCircleDad, isRollFace, isParaColor, noSmooth :boolean;
begin
  M:=high(FaceVct[ID]);   N:=high(FaceVct[ID,0]);
  with Obj[ID] do begin
  a:=Link[0];  Ka:=Obj[a].Kind;  Ma:=Obj[a].Mode;
  b:=Link[1];  Kb:=Obj[b].Kind;  Mb:=Obj[b].Mode;
  noSmooth:=(Kind=7)and(Mode in[1,4,7..12,16])and((Obj[Obj[parent].Link[0]].Kind =4)or(Ka=17)and not Obj[a].D); //旋转曲面 轨迹面 母线为多边形或折线路径 K17路径
  isParaColor:=(Kind=7)and(high(FaceColor[ID])>0);//轨迹面的参数着色
  isCircleDad:=(Ka=3)and((Ma<3)or(Ma in[3,4])and(abs(Obj[a].H-6.2832)<0.001)); //轨迹面(或旋转曲面)的母线为圆
  isRollFace :=(Mode=1)and((abs(H-360)<0.001)or(abs(H-6.2832)<0.001));  //旋转曲面 旋转角为2Pi

  setLength(Nor, M+1);  for i:=0 to M do setLength( Nor[i], N+1); //面片的法线数组
  glLineWidth( Obj[1].p2.z);
    setEnable(not isSeled, GL_LIGHTING);
  glDisable(GL_TEXTURE_2D);
  setTowFaceColor(ID, isParaColor or U or(W>0) ); //W炫彩 U色随线
  if(texID>0)and D and not isSeled then begin //绑定纹理
    glColor4f(1,1,1,1);
    glEnable(GL_ALPHA_TEST);  glAlphaFunc(GL_GREATER, 0);
    glEnable(GL_TEXTURE_2D);  glBindTexture(GL_TEXTURE_2D, texID);
    end;
  if(Kind=7)and(Mode=4)and Lock then begin //轨迹面曲线族 Lock曲线族
    glLineWidth(Obj[1].p2.z);
    for i:=0 to M do begin
      if not isSeled then if(W=2)then Color:=setMultiColor(ID, i, M-1,Color.A); //炫彩
      glBegin(GL_LINE_STRIP);
      for j:=0 to N do begin
        if isParaColor then
          glColor4fv( @FaceColor[ID,i,j]) //参数着色
        else
          if not isSeled then if(W=1)then setMultiColor(ID, j, N-1,Color.A);
        if(FaceVct[ID,i,j].w>=0)then glVertex3fv( @FaceVct[ID,i,j]);
        end;
      glEnd;
      end;
    end
  else begin//曲面
    ww:=0.98*kw/M; hh:=0.98*kh/N;
    k:=high(aLink[ID]);
    nN:=0; if F and not isSeled then nN:=1; //填充时画两遍
    for i:=0 to N-1 do for j:=0 to M-1 do //计算每个面片的法线
      Nor[j,i]:=cgPlaneNormal(FaceVct[ID,j+1,i+1],  FaceVct[ID,j,i],
                              FaceVct[ID,j+1,i],  FaceVct[ID,j,i+1], false);
    for nM:=0 to nN do begin //为反锯齿而多画一遍线框
      glPolygonMode( GL_FRONT_AND_BACK, IIFc(F and(nM=0)and not isSeled, GL_FILL, GL_LINE) );
      if isSeled then glColor4fv(@Obj[1].ColorB); //被选择时的颜色
      for i:= 0 to N-1 do begin  //一层层的画
        if(Kind=7)and(Mode in[1,2,9])and(k>0)and(not aLink[ID,i+1])
            then continue;//aLink[]曲面断裂标志  and(W=1)
        if(W=1)and(not isSeled or F and(nM=0))then
          setMultiColor(ID, i, N-1,Color.A); //炫彩
        glBegin( GL_QUAD_STRIP);
        for j:= 0 to M do begin  //饶圆周画径线
          if(FaceVct[ID,j,i+1].w<0)then continue;
          if not isSeled then begin
            if isParaColor then //参数着色
              glColor4fv( @FaceColor[ID,j,i])
            else begin
              if(W=2)and(not isSeled or F and(nM=0))then
                setMultiColor(ID, j, M-1,Color.A); //炫彩
              end;

            if j<M then
              pn:=Nor[j,i]
            else begin        //最后一片的法线
              if isRollFace then pn:=Nor[0,i] else pn:=Nor[j-1,i];  //旋转曲面
              end;
            glNormal3fv( @pn);
            end; //if not isSeled
          if D then glTexCoord2f( ww*j+0.01, hh*(N-i) ); //纹理
          glVertex3fv( @FaceVct[ID,j,i]);   //纬线

          if not isSeled and not noSmooth then begin
            if(j<M)then begin
              if(i<N-1)then
                pn:=Nor[j,i+1]
              else begin
                if isCircleDad then pn:=Nor[j,0] else pn:=Nor[j,i]; //母线为圆
                end;
              end
            else begin
              if(i<N-1)then begin
                if isRollFace then pn:=Nor[0,i+1] else pn:=Nor[j-1,i+1]; //旋转曲面
                end
              else begin
                if isCircleDad then pn:=Nor[j-1,0] else pn:=Nor[j-1,i];  //母线为圆
                end;
              end;
            if(j=M)and(i=N-1)and isRollFace and isCircleDad then pn:=Nor[0,0];//圆的旋转曲面
            glNormal3fv( @pn);
            if isParaColor then glColor4fv( @FaceColor[ID,j,i+1]);//参数着色
            end;
          if D then glTexCoord2f( ww*j+0.01, hh*(N-i-1) ); //纹理
          glVertex3fv( @FaceVct[ID,j,i+1]); //纬线

          end;//for j
        glEnd;
        end;//for i
      end;//for nM
    glDisable(GL_TEXTURE_2D); 
    end;
  glDisable( GL_LIGHTING);
  end; //with
  for i:=0 to M do setLength(Nor[i],0); setLength(Nor,0);
end;
//=========================== 7_1 旋转曲面 ===============================
procedure TfrmMain.RollFace(  ID :integer; bList,bOnlyDraw:boolean);
  var Fa,Fb, aR,bR, aL,bL, dL :single;
      pa,pb,pn,pp :TcgVector;
      a,b,c,dd,ee, i,j, M,N :integer; //轨迹点数
begin
  with Obj[ID] do begin
  a:=Link[0]; b:=Link[1]; c:=Link[2]; dd:=Link[3]; ee:=Link[4];
  hide:= Obj[a].hide or Obj[b].hide;
  if hide then exit;
  Vec:=Obj[b].Vec;   //轴线的向量
  if(S>128)or(S<3)then
    begin if S>128 then S:=128; if S<3 then S:=3; varS.Caption:=ftos(S,4); end;
  if( c>0)then H:=Obj[ c].L;  bL:=H;  if Deg then bL:=bL/oneArc;//转角
  if(dd>0)then R:=Obj[dd].L;  aL:=R;  if Deg then aL:=aL/oneArc;//初角
  if(ee>0)then S:=trunc(Obj[ee].L);  if(S<3)then S:=3;
  Limit(aL, -towPi,-towPi, towPi,towPi);
  Limit(bL, -towPi,-towPi, towPi,towPi);

  aR:=towPi/S; //每段网格角度 S:圆度
  M:=trunc(bL/aR-0.0001); if(M*aR<bL)then inc(M); if(M<1)then M:=1; //
  setLength(FaceVct[ID], M+1);
  if not U then setLength(FaceColor[ID], 0);

  if(Obj[a].Kind=2)then begin //*********** 母线为直线 ***************
    pa:= Footer(  Obj[a].p0, b, true);     //母线起点的圆心
    setPlane(10, pa, b, pa.w);  //虚拟一个平面
    Fa:= aL+ getDotAngle( Obj[a].p0, pa, b, pa.w,false); //母线起点的初始角度
    pb:= Footer(  Obj[a].p1, b, true);     //母线终点的圆心
    setPlane(10, pb, b, pb.w);  //虚拟一个平面
    Fb:= aL+ getDotAngle( Obj[a].p1, pb, b, pb.w,false); //母线终点的初始角度
    if(L>128)or(L<1)then
      begin if L>128 then L:=128; if L<1 then L:=1; varL.Caption:=ftos(L,4); end;
    N:= trunc(L);  //层数
    for j:= 0 to M do setLength(FaceVct[ID,j], N+1);
    for j:= 0 to M do begin
      bR:=j*aR; if(bR>bL)then bR:=bL;
      p0:= dotInCircle(  pa, b, Fa+bR, pa.w,0,0);
      p1:= dotInCircle(  pb, b, Fb+bR, pb.w,0,0);
      pn:=cgVecSub(p1,p0);
      for i:= 0 to N do FaceVct[ID,j,i]:= cgVecAddMult(p0,pn,i/N);
      end;
    if Obj[ID].U then begin //色随母线
      setLength(FaceColor[ID], M+1);  for j:=0 to M do setLength(FaceColor[ID,j], N+1);
      if Obj[a].U then begin //母线是否色随母线
        for j:=0 to M do for i:=0 to N do
          FaceColor[ID,j,i]:=cgMidColor(Obj[Obj[a].Link[0]].Color, Obj[Obj[a].Link[1]].Color, i/N);
        end
      else
        for j:=0 to M do for i:=0 to N do FaceColor[ID,j,i]:=Obj[a].Color;
      end;
    end; //2:begin
{  if(Obj[a].Kind=3)and(Obj[a].Mode<5)then begin //******** 母线为圆(圆弧) **********
    if(L>128)or(L<1)then
      begin if L>64 then L:=128; if L<1 then L:=1; varL.Caption:=ftos(L,4); end;
    N:=trunc(Obj[ID].L);  //等份数
    with Obj[a] do begin
      if(Mode<3)then dL:=towPi else dL:= IIFi(U,-1,1)* H/IIFf( D, L, 1);
      if(Mode=15)then dL:=IIFf(U, H,towPi); //反演圆弧
      end;
    dL:=dL/N;
    for j:= 0 to M do setLength(FaceVct[ID,j], N+1);
    for j:= 0 to M do begin
      bR:=j*aR; if(bR>bL)then bR:=bL;
      for i:=0 to N do begin
        with Obj[a] do begin
          if(Mode<3)
            then pp:=DotInCircle(  p0, a, i*dL, L, H, R) //圆
          else if(Mode=15)and(U)
            then pp:=DotInCircle(  p0, a, p2.x+i*dL, L, 0, 0) //反演圆弧
          else pp:=DotInCircle(  p0, a, R+i*dL, L, 0, 0);//圆弧
          end;
        pn:= Footer( pp, b, true); //圆心、 LocaCnt[k].w 半径
        setPlane(10, pn, b, pn.w);  //虚拟一个平面
        Fa:= aL+ getDotAngle( pp, pn, b, pn.w,false); //初始角度
        FaceVct[ID,j,i]:= dotInCircle(  pn, b, Fa+bR, pn.w,0,0);
        end;
      end;
    if Obj[ID].U then begin //色随母线
      setLength(FaceColor[ID], M+1);  for j:=0 to M do setLength(FaceColor[ID,j], N+1);
      for j:=0 to M do for i:=0 to N do FaceColor[ID,j,i]:=Obj[a].Color;
      end;
    end; }
  if(Obj[a].Kind=3)and(Obj[a].Mode>4)or(Obj[a].Kind in[3,4,5,15,16,17,19])then begin //******** 母线为轨迹线 **********
    N:= high(LocaVct[a]);   //轨迹点数
    for j:= 0 to M do begin
      bR:=j*aR; if(bR>bL)then bR:=bL;
      setLength(FaceVct[ID,j], N+1);
      for i:= 0 to N do begin
        pn:= Footer( LocaVct[a,i], b, true); //圆心、 LocaCnt[k].w 半径
        setPlane(10, pn, b, pn.w);  //虚拟一个平面
        Fa:= aL+ getDotAngle( LocaVct[a,i], pn, b, pn.w,false); //初始角度
        FaceVct[ID,j,i]:= dotInCircle(  pn, b, Fa+bR, pn.w,0,0);
        end;
      end;
    if Obj[ID].U then begin //色随母线
      setLength(FaceColor[ID], M+1);  for j:=0 to M do setLength(FaceColor[ID,j], N+1);
      if Obj[a].U and(high(LocaColor[a])>=N)then  //Obj[a].U 母线是否色随母线
        for j:=0 to M do for i:=0 to N do FaceColor[ID,j,i]:=LocaColor[a,i]
      else
        for j:=0 to M do for i:=0 to N do FaceColor[ID,j,i]:=Obj[a].Color;
      end;
    end; //5:begin
  end; //with  Obj[ID]    `
end;
//======================= 7_2 直纹曲面 ===============================
procedure TfrmMain.RureFace(  ID:integer; bList,bOnlyDraw:boolean);
  var i, a,b, Ka,Kb, M,N :integer; t:single;
      pa,pb,pn :TcgVector; isParaColor:boolean;
begin
  a:=Obj[ID].Link[0];{边际线1}   b:=Obj[ID].Link[1]; {边际线2}
  if b<a then SwapI(a,b);
  Ka:=Obj[a].Kind;    Kb:=Obj[b].Kind;
  isParaColor:=Obj[ID].U and(high(LocaColor[b])>= high(LocaVct[b])); //颜色随母线
  if Kb<Ka then begin SwapI(a,b); SwapI(Ka,Kb); end;
  if(Ka=1)and(Kb=2)then begin //点与直线
    N:=Obj[ID].S; //精度
    setLength(FaceVct[ID], N+1);
    for i:= 0 to N do setLength(FaceVct[ID,i], 2);
    for i:= 0 to N do FaceVct[ID,i,0]:=Obj[a].p0;
    pa:=Obj[b].p0;  pb:=Obj[b].p1;  pn:=cgVecSub(pb,pa);
    for i:= 0 to N do FaceVct[ID,i,1]:= cgVecAddMult(pa,pn,i/N);
    setLength(FaceColor[ID], IIFi( Obj[ID].U, N+1, 0));
    if Obj[ID].U then begin //颜色随母线
      for i:=0 to N do setLength(FaceColor[ID,i], 2);
      for i:=0 to N do FaceColor[ID,i,0]:=Obj[a].Color;
      for i:=0 to N do FaceColor[ID,i,1]:=cgMidColor(Obj[b].Color,Obj[b].ColorB,i/N);
      end;
    end;
  if(Ka=1)and(Kb in[3,4,5,6,7,9,15,16,17,19])then begin //点与圆(弧)、轨迹、相贯线
    N:=high(LocaVct[b]);
    setLength(FaceVct[ID], N+1);
    for i:=0 to N do setLength(FaceVct[ID,i], 2);
    for i:=0 to N do FaceVct[ID,i,1]:=Obj[a].p0;
    for i:=0 to N do FaceVct[ID,i,0]:=LocaVct[b,i]; //轨迹点
    setLength(FaceColor[ID], IIFi( Obj[ID].U, N+1, 0));
    if Obj[ID].U then begin //颜色随母线
      for i:=0 to N do setLength(FaceColor[ID,i], 2);
      for i:=0 to N do FaceColor[ID,i,0]:=Obj[a].Color;
      if(high(LocaColor[b])>= high(LocaVct[b]))
        then begin for i:=0 to N do FaceColor[ID,i,1]:=LocaColor[b,i]; end
        else begin for i:=0 to N do FaceColor[ID,i,1]:=Obj[b].Color;   end;
      end;
    if Kb in[5,15,16,17,19] then begin
      setLength(aLink[ID],N+1); for i:=0 to N do aLink[ID,i]:=aLink[b,i];
      end;
    end;
  if(Ka=2)and(Kb=2)then begin //俩直线
    N:=Obj[ID].S;
    setLength(FaceVct[ID], N+1);
    for i:=0 to N do setLength(FaceVct[ID,i], 2);
    pa:=Obj[a].p0;  pb:=Obj[a].p1;  pn:=cgVecSub(pb,pa);
    for i:= 0 to N do FaceVct[ID,i,0]:= cgVecAddMult(pa,pn,i/N);
    pa:=Obj[b].p0;  pb:=Obj[b].p1;  pn:=cgVecSub(pb,pa);
    for i:= 0 to N do FaceVct[ID,i,1]:= cgVecAddMult(pa,pn,i/N);
    setLength(FaceColor[ID], IIFi( Obj[ID].U, N+1, 0));
    if Obj[ID].U then begin //颜色随母线
      for i:=0 to N do setLength(FaceColor[ID,i], 2);
      for i:=0 to N do FaceColor[ID,i,0]:=cgMidColor(Obj[a].Color,Obj[a].ColorB,i/N);
      for i:=0 to N do FaceColor[ID,i,1]:=cgMidColor(Obj[b].Color,Obj[b].ColorB,i/N);
      end;
    end;
  if(Ka=2)and(Kb in[3,4,5,6,15,16,17,19])then begin //直线与圆(弧)、轨迹
    N:=high(LocaVct[b]);
    setLength(FaceVct[ID], N+1);
    for i:=0 to N do setLength(FaceVct[ID,i], 2);
    for i:=0 to N do FaceVct[ID,i,1]:=LocaVct[b,i]; //轨迹点
    pa:=Obj[a].p0;  pb:=Obj[a].p1;  pn:=cgVecSub(pb,pa);
    for i:=0 to N do FaceVct[ID,i,0]:= cgVecAddMult(pa,pn,i/N);
    setLength(FaceColor[ID], IIFi( Obj[ID].U, N+1, 0));
    if Obj[ID].U then begin //颜色随母线
      for i:=0 to N do setLength(FaceColor[ID,i], 2);
      for i:=0 to N do FaceColor[ID,i,0]:=cgMidColor(Obj[a].Color,Obj[a].ColorB,i/N);
      if(high(LocaColor[b])>= high(LocaVct[b]))
        then begin for i:=0 to N do FaceColor[ID,i,1]:=LocaColor[b,i]; end
        else begin for i:=0 to N do FaceColor[ID,i,1]:=Obj[b].Color;   end;
      end;
    end;
  if(Ka in[3,4,5,15,16,17,19])and(Kb in[3,4,5,15,16,17,19])then begin //俩轨迹
    M:=high(LocaVct[a]);   N:=high(LocaVct[b]);
    if M>N then begin SwapI(a,b); SwapI(M,N); end;
    setLength(FaceVct[ID], N+1);  for i:=0 to N do setLength(FaceVct[ID,i], 2);
    t:=M/N;
    for i:=0 to N do begin
      FaceVct[ID,i,1]:=LocaVct[a,round(i*t)];  FaceVct[ID,i,1].w:=1;
      FaceVct[ID,i,0]:=LocaVct[b,i];           FaceVct[ID,i,0].w:=1;
      end;
    setLength(aLink[ID],N+1); for i:=0 to N do aLink[ID,i]:=true;
    setLength(FaceColor[ID], IIFi( Obj[ID].U, N+1, 0));
    if Obj[ID].U then begin //颜色随母线
      for i:=0 to N do setLength(FaceColor[ID,i], 2);
      for i:=0 to N do FaceColor[ID,i,0]:=cgMidColor(Obj[a].Color,Obj[a].ColorB,i/N);
      if(high(LocaColor[b])>= high(LocaVct[b]))
        then begin for i:=0 to N do FaceColor[ID,i,0]:=LocaColor[b,i]; end
        else begin for i:=0 to N do FaceColor[ID,i,0]:=Obj[b].Color;   end;
      if(high(LocaColor[a])>= high(LocaVct[a]))
        then begin for i:=0 to N do FaceColor[ID,i,1]:=LocaColor[a,round(i*t)]; end
        else begin for i:=0 to N do FaceColor[ID,i,1]:=Obj[a].Color;   end;
      end;
    end;
end;
//======================= 7_4 轨迹面 ===============================
procedure TfrmMain.NormalFace(  ID:integer; bList,bOnlyDraw:boolean);
  var a,b,i,j,V, oA,oB,oC,aK,bK, M,N,Num,step :integer;  t,dL,dR,dH :single;
      pa,pb,pc,pd, pp,pq, pn,pLast :TcgVector;  st:string;
      BackObje :TObjType;   BackLoca :TLocaType;
      BackFace :TFaceType;  BackLink :TLinkType;
      BackLocaC:TLocaColor; BackFaceC:TFaceColor;
      bb, LimitInPlane, isCircle, isParaColor :boolean;
begin //  Lst.Clear;
  with Obj[ID] do begin
    oA:=Link[0];{母线}   oB:=Link[1]; {限制点}  aK:=Obj[oA].Kind;
    if(Obj[oA].Kind in[1,11])and(Obj[oB].Kind>1)then SwapI(oA,oB);
    hide:=Obj[oB].hide or(Obj[oB].Kind=15); //限制点必须存在 排除相贯线
    if hide then exit;
    LimitInPlane:=(aK=1)and(Obj[Obj[oB].Link[1]].Kind=4);
    if EP(Obj[oB].H)then
      if LimitInPlane then Obj[oB].H:=0.2 else Obj[oB].H:=0.05; //设置限制点的移动速度
    if(aK=5)then with Obj[Obj[oA].Link[1]]do p2.y:=L; //若母线为轨迹线则保持其约束值
    end;
  SysBackup(ID, BackObje,BackLoca,BackFace,BackLink,BackLocaC,BackFaceC, true);//数据备份
  N:=1023;   if(Obj[oB].Kind=1)then Obj[oB].Link[2]:=0; //取消限制点的关联
  case aK of
    1:begin j:=Obj[oB].Link[1]; //母线为点
      dL:=Obj[j].p4.w;  if dL<3 then dL:=3; //约束平面的长宽
      dR:=Obj[j].p5.w;  if dR<3 then dR:=3;
      M:=trunc(dL/Obj[oB].H); if not EP(dL-M*Obj[oB].H)then inc(M);
      N:=trunc(dR/Obj[oB].H); if not EP(dR-N*Obj[oB].H)then inc(N);
      end;
    2:M:=1; //母线为直线 等份数
    3:begin M:=high(LocaVct[oA]);  Obj[oA].Angle:=M; end;
    else
      M:=High(LocaVct[oA]); //5,15,16,17,19母线为曲线
    end; //with Obj[oA] do case...
  Num:=M;
  if N>1023 then N:=1023;
  setLength(FaceVct[ID], N+1);  for j:=0 to N do setLength(FaceVct[ID,j], M+1);
  isParaColor:=Obj[ID].U;// and(Obj[oA].Kind in[1..3,5,15,16,17,19])and(high(LocaColor[oA])>0); //色随母线
  if isParaColor then begin
    setLength(FaceColor[ID], N+1);  for j:=0 to N do setLength(FaceColor[ID,j], M+1);
    end
  else
    setLength(FaceColor[ID], 0);
  for i:= oB to oA do with Obj[i] do begin //移动速度大于零的约束点置零
    if(i=oB)and Obj[ID].Mask then begin p2.z:=L; Link[3]:=0; Link[4]:=0; end; //Mask 曲面终边跟随限制点
    if((Kind=1)or(Kind=11)and(i=oB))and(Mode=2)and(Obj[Link[1]].Kind<>4)and(H>0)then begin
      L:=IIFf( Link[3]>0, Obj[Link[3]].L, p2.x);
      if(Kind=11)then DrawParaBar( i, 0, true,true);
      if(i=oB)then F:=false;//控制点强制单向
      end;
    if(i=oB)and(Obj[Link[1]].Kind=4)then begin
      L:=0;   R:=0;   iL:=0;  iR:=0;
      b:=Link[1]; pa:=LocaVct[b,0];  pb:=LocaVct[b,1];  pc:=LocaVct[b,2];  pd:=LocaVct[b,3];
      end;//限制点在平面上
    end;
  for i:= oB to oA do Obj[i].way:=false;
  V:=0; step:=0; bb:=false;
  labHint.Caption:=''; //见鬼，没有这行就显示不出曲面
  repeat
    for i:=oB to oA do with Obj[i] do if(delID=0)then begin //
      if((Kind=5)or(Kind=7)and(Mode=4))and(Link[1]=oB)then continue;//忽略相同限制点的轨迹线或轨迹面
      case Kind of
        1:begin
          bK:=Obj[Link[1]].Kind;
          if(Mode=2)and(H>0)and(bK<>6)then begin  //运动速度大于零的约束点  and(step>0)
            if(i=oB)and(bK=4)and not Mask then begin //限制点是平面上的约束点. Mask:平面边缘的点
              if(step>0)then begin
                if(iL<M)then inc(iL)
                        else begin if(iR>=N)then bb:=true else begin iL:=0; inc(iR); end; end;
                end;
              pp:=cgVecSub(pc,pb);  pp:=cgVecAddMult(pb, pp,iL/M);
              pq:=cgVecSub(pd,pa);  pq:=cgVecAddMult(pa, pq,iL/M);
              pp:=cgVecSub(pp,pq);  pp:=cgVecAddMult(pq, pp,iR/N);//pp 动点位置
              with Obj[9]do begin Kind:=2; Mode:=1; p0:=pb; Vec:=cgNormalVec(pc,pb); end;
              pq:=Footer(pp, 9,true);
              R:=pq.w;
              L:=cgDistance(pq,pb);
                t:=cgDotProduct(cgNormalVec(pc, pb),cgNormalVec(pp, pb));//动点与底边的角度为arcCos(t)
              if(t<0)then L:=-L;
              end
            else
              if(Step>0)and not MovePoint(i,i=oB,true)and(i=oB)then bb:=true;
            end;
          Pointe( i, false,false,false);
          if(i=oA)and(Obj[Obj[oB].Link[1]].Kind=4)and not hide then begin //由平面约束点驱动的点的轨迹
            FaceVct[ID, Obj[oB].iR, Obj[oB].iL]:=p0;
            if isParaColor then FaceColor[ID, Obj[oB].iR, Obj[oB].iL]:=Color;
            end;
          end;
        2:begin
          Lineer( i, false,false,false); //直线,仅计算而不作显示列表
          if(i=oA)and(not hide)then begin
            FaceVct[ID,V,0]:=p0;  FaceVct[ID,V,1]:=p1;
            if isParaColor then begin
              if Obj[oA].U then FaceColor[ID,V,0]:=Obj[Link[0]].Color else FaceColor[ID,V,0]:=Obj[oA].Color;
              if Obj[oA].U then FaceColor[ID,V,1]:=Obj[Link[1]].Color else FaceColor[ID,V,1]:=Obj[oA].Color;
              end;
            end;
          end;
        3:begin
          if(Link[2]=0)and(Link[3]=0)and(Link[4]=0)then begin
            with Obj[oB] do
            isCircle:=(Kind=1)and(Mode=2) //限制点是约束点
              and(Obj[Link[1]].Kind in[3,5,16,17,19])     //曲线上的约束点
              and(Obj[oA].Kind=3)and(Obj[oA].Mode<3)and(Obj[oA].Link[0]=oB)//圆心就是限制点
              and(Obj[Obj[oA].Link[1]].Kind=2)and(Obj[Obj[oA].Link[1]].Mode=4) //圆法线是切线
              and(Obj[Obj[oA].Link[1]].Link[1]=Link[1]); //圆的法线就是曲线的切线
            if(i<>oA)or not isCircle or(i=oA)and(v=0)and isCircle then
              CircleDraw( i, false,false,true,false);//圆(弧)
            if(i=oA)and(not hide)then begin
              if(v>0)and isCircle then begin //后续圆
                pa:=Obj[Link[0]].p0;  //圆心
                pLast:=pa;//
                end
              else //初始圆或圆弧
                pLast:=p0;//圆心
              end;
            end
          else begin
            Num:=CircleDraw( i, false,false,true,false);
            if(i=oA)and(not hide)then
              b:=Obj[i].parent;
            end;
          Num:=M;
          end;
        4:Num:=Plane( i, false,false);        //平面
        5:Num:=Locus( i, false,false,false,true);  //轨迹线
        6:Solid( i,false,false,false,false);  //实体
        7:Face(  i,false,false,false);        //曲面
        9:funcFace( i, false,false,false);    //函数曲面
       15:Num:=CrossLine(i,false,false,false);//相贯线
       11:begin
          if(Mode=1)then calcFunc( i, res, false,false);//计算式
          if(Mode=2)and(i=oB)and(V>0)then begin //参数
            L:=L+H; if(L>p2.z)then begin L:=p2.z; bb:=true; end;
            DrawParaBar( i, 0, true,true);
            end;
          if(Mode>2)then res:=calcSize( i);   //度量
          if(Mode<>2)then L:=res;
          end;
       16:Num:=FuncCurve(i,false,false,false);//函数曲线
       17:Num:=Path( i,false,false,false);    //路径
       19:Num:=Conic(i,false,false,false);    //圆锥曲线
        end; //case
      if(i=oA)and(Kind in[3,4,5,15,16,17,19])then begin //母线为曲线
        if(Num>M)then begin
          M:=Num; for j:=0 to N do setLength(FaceVct[ID,j], M+1);
          if isParaColor then
            for j:=0 to N do setLength(FaceColor[ID,j], M+1);
          end;
 //       if(Obj[oA].Kind<>3)then
          for j:=0 to Num do FaceVct[ID,V,j]:=LocaVct[oA,j];
        if isParaColor then begin
          if(not Obj[oA].U)or(Obj[oA].Kind=3)
            then for j:=0 to Num do FaceColor[ID,V,j]:=Obj[oA].Color
            else for j:=0 to Num do FaceColor[ID,V,j]:=LocaColor[oA,j];
          end;
        FaceVct[ID,V,0].w:=Num;
        end;
      end; //for i..if..with...
    if not Obj[oA].Hide then inc( V);
    inc(step);
  until bb or((step=N)or(V>=N))and not LimitInPlane;//动态描绘状态下
  if(Obj[oA].Kind in[5,15,16,17,19])then
    for i:=0 to V do begin
      Step:=trunc(FaceVct[ID,i,0].w);
      if(Step<M)then for j:=Step+1 to M do FaceVct[ID,i,j].w:=-1;
      end;
  if not LimitInPlane then begin //平面上的主动点
    setLength( FaceVct[ID],V);
    if isParaColor and(high(LocaColor[oA])>0)then setLength( FaceColor[ID],V);
    end;
  if Obj[ID].U then setLength( FaceColor[ID], V);
  SysBackup(ID, BackObje,BackLoca,BackFace,BackLink,BackLocaC,BackFaceC, false);//数据备份
  caption:=caption; //见鬼，一定要刷新一下标题栏，否则有些曲面在打开文件时就不显示
end;
{//======================= 7_3 复合曲面 ===============================
procedure TfrmMain.BinaryFace(  ID :integer; bList,bOnlyDraw:boolean);  //复合曲面
  var a,b,i,j, ObjA,ObjB :integer; //构成复合曲面的轨迹线
      M,N :integer;   //构成复合曲面的两条轨迹线的轨迹点数
      iA,iB :integer;   //轨迹线的限制构件
      start :single;
      bObjA,bObjB, bA,bB :boolean;//轨迹点、轨迹线的限制构件是否受约于圆周
      BackObje :TObjType;   BackLoca :TLocaType;
      BackFace :TFaceType;  BackLink :TLinkType;
      BackLocaC:TLocaColor; BackFaceC:TFaceColor;
  procedure MoveObj( Obj0, Obj1, v :integer);
    var i :integer;
  begin
    i:=Obj0-1; start:=0;
    repeat
      inc(i);
      with Obj[i] do begin
        case Kind of
        1:begin           // 点
          if U then start:=p2.x;
          if(Mode=2)and(H>0)then  //运动速度大于零的约束点 and(v>0)
            case Obj[Link[1]].Kind of       //约束构件
              2:L:=start+ v*H; //沿直线运动
              3:begin //沿圆周移动  if Obj[b].Mode<3 then
                  L:=v* IIFi( F,-1, 1)*H;
                  if(L>towPi)or(L<-towPi)then
                    if (bA)and( (i=iA)or(i=ObjA)and(bObjA) )
                     or(bB)and( (i=iB)or(i=ObjB)and(bObjB) )
                      then L:= 0;
                  end
                else L:=start+ v*H; //沿圆弧移动
            end;//case
          Pointe( i,false,false,false);
          end;
        2:Lineer( i,false,false,false);    //直线
        3:CircleDraw( i, false,false,false,false); // 圆 ,仅计算而不作显示列表
        4:Plane( i,false,false);   //平面,仅计算而不作显示列表
       11:begin
          if Mode=1 then calcFunc(  i, res, false,false); //计算式
          if Mode>2 then res:=calcSize( i); //度量
          if Mode<>2 then L:=res;
          end;
        end; // case
      end;//with
    until i>=Obj1;
  end;//MoveObj
begin
  with Obj[ID] do begin
  a:=Link[0]; b:=Link[1];
  hide:= Obj[a].hide or Obj[b].hide;
  if hide then exit;
  SysBackup(ID, BackObje,BackLoca,BackFace,BackLink,BackLocaC,BackFaceC, true);//数据备份
  if Obj[a].Link[0]>Obj[b].Link[0] then begin i:=a; a:=b; b:=i; end; //
  ObjA:=Obj[a].Link[0]; iA:= Obj[a].Link[1]; bA:= Obj[Obj[iA].Link[1]].Kind=3; //轨迹A的限制点
  ObjB:=Obj[b].Link[0]; iB:= Obj[b].Link[1]; bB:= Obj[Obj[iB].Link[1]].Kind=3; //轨迹B的限制点
  bObjA:= Obj[Obj[ObjA].Link[1]].Kind=3;
  bObjB:= Obj[Obj[ObjB].Link[1]].Kind=3;
  M:=high(LocaVct[a]); //第一条轨迹的动点和轨迹点数
  N:=high(LocaVct[b]); //第二条轨迹的动点和轨迹点数
  setLength(FaceVct[ID],M+1); for i:= 0 to M do setLength(FaceVct[ID,i],N+1);
  MoveObj( iA,ObjA, 0);
  for j:= 0 to M do begin
    MoveObj( iA, ObjA, j);        //FaceVct[ID,0]:= FaceVct[ID,1];
    for i:= 0 to N do begin
      MoveObj( ObjA, ObjB, i);  FaceVct[ID,j,i]:= Obj[ObjB].p0;
      end;//for Vb
    end;
  end;//with
  SysBackup(ID, BackObje,BackLoca,BackFace,BackLink,BackLocaC,BackFaceC, false);//数据备份
end; }
//======================= 6_1 球体 ========================
procedure TfrmMain.Sphere(  ID:integer; bDraw,bList:boolean); //半径R,精度N,是否填充F
var i,j,k, a,b,c,dd,e,ff,gg,ss :Integer;  isComp,isFan:boolean;
    t, aR,bR,dR, rX,rY,rZ, rZ0,rZ1 :single;
    pa,pb,pc,pd,pe,pf, pp,pn, nb,ne,nf :TcgVector;
begin
  with Obj[ID] do begin
  a:=Link[0];  b:=Link[1];   c:=Link[2];  dd:=Link[3];
  e:=Link[4]; ff:=Link[5];  gg:=Link[6];
  if(a<=0)then a:=1;  if(not bAdd)and(b<=0)then b:=4;
  hide:=Obj[a].hide or Obj[b].hide or(c>0)and Obj[c].hide or(gg>0)and Obj[gg].hide;
  if hide then exit;
  pa:=Obj[a].p0;  pb:=Obj[b].p0;  
  if(Mode=1)then begin //点法球
    p0:=pa;            //球心
    if(c>0)then L:=getLinkVar( c, pa) //半径
      else if(Obj[b].Kind=1)and not Rand then L:=cgDistance(pa,pb); //not Rand 以两点距离为半径
    if(Obj[b].Kind=1)and Trace then begin p0:=cgVecMid(pa,pb);  L:=cgDistance(pa,pb)/2; end;//两点式
    if(Obj[b].Kind=1)then Vec:=cgNormalVec(pb, pa) else Vec:=Obj[b].Vec;//轴线向量
    if dd>0 then R:=getLinkVar(dd, p0); //转角
    if  e>0 then H:=getLinkVar( e, p0); //扁度
    if ff>0 then W:=getLinkVar(ff, p0); //椭度
    if(Link[ 9]>0)then pTR.x:=Obj[Link[ 9]].L; Limit(pTR.x, 0,0, 1,1);//上截率
    if(Link[11]>0)then pTR.y:=Obj[Link[11]].L; Limit(pTR.y, 0,0, 1,1);//上截率
    if(pTR.x+pTR.y)>=1 then pTR.x:=1-pTR.y;
    if(Link[10]>0)then Angle:=getLinkVar(Link[10], p0); //终角
    if Deg then Limit(Angle, 0,0, 360,360)
           else Limit(Angle, 0,0, towPi,towPi);//
    aR:=R;      if Deg then aR:=aR/oneArc;
    bR:=Angle;  if Deg then bR:=bR/oneArc;  //球缺角
    rZ0:=arcCos(1-2*pTR.x); //下球冠
    rZ1:=Pi-arcCos(1-2*pTR.y);//上球冠
    end;
  if(Mode=6)then begin //三点球
    if(Obj[a].Kind=6)then begin
      if(Obj[a].Mode=3)then begin //正四面体
        pa:=Obj[a+7].p0;  pb:=Obj[a+8].p0;  pe:=Obj[a+9].p0;  pf:=Obj[a+10].p0;
        end;
      if(Obj[a].Mode=5)then begin //四点凸壳
        pa:=Obj[Obj[a].Link[0]].p0;   pb:=Obj[Obj[a].Link[1]].p0;
        pe:=Obj[Obj[a].Link[2]].p0;   pf:=Obj[Obj[a].Link[3]].p0;
        end;
      end
    else if(Obj[a].Kind=4)then begin //平面
      pa:=Obj[Obj[a].Link[0]].p0;  pb:=Obj[Obj[a].Link[1]].p0;
      if(Obj[Obj[a].Link[1]].Kind=2)then pe:=Obj[Obj[a].Link[1]].p1
        else pe:=Obj[Obj[a].Link[2]].p0;
      end
    else begin
      pe:=Obj[e].p0;   pf:=Obj[ff].p0;
      end;
    if dd>0 then R:=getLinkVar(dd, p0); //转角
    rZ0:=0; rZ1:=Pi; pTR:=cgVector(0,0,0);
    Angle:=0; aR:=R; bR:=0;
    if(ff>0)and(Obj[ff].Kind=1)or(Obj[a].Kind=6)then begin //四点球
      if U then begin //内切
        pn:= cgGetNormal(pb,pe,pf); pn.w:=-cgDotProduct(pn,pb); //底面法线
        setObj(9, 4,1,pb,pn); //将底面设置为平面
        pc:=Footer( pa, 9, true);   //顶点在底面上的垂点
        hide:= EP(pc.w);  if hide then exit;//四点共面则退出

        nb:= cgVecAdd( pn, cgGetNormal(pa,pb,pe)); cgNormalize(nb); //底面与侧面之中面
          nb.w:=-cgDotProduct(nb,pb);
        ne:= cgVecAdd( pn, cgGetNormal(pa,pe,pf)); cgNormalize(ne); //底面与侧面之中面
          ne.w:=-cgDotProduct(ne,pe);
        cgPlaneSection(pe,nb, pe,ne, pc,nb); //pc,nb 两中面之相惯线
        nf:= cgVecAdd( pn, cgGetNormal(pa,pf,pb)); cgNormalize(nf); //底面与侧面之中面
          nf.w:=-cgDotProduct(nf,pf);
        cgLinePlaneCross(pc,nb, pf,nf, pp); //pp线面之交点
        p0:=pp;   Vec:=cgNormalVec(pa,pp);
        pc:=Footer( pp, 9, true);   L:=pc.w;   //垂点
        end
      else begin //外接
        hide:= cgCenter( pb,pe,pf, pp,Vec, 0); //三点之圆心pp 、半径pp.w和中轴向量Vec
        if hide then exit;
        pc:=cgVecMid(pb,pa);  pn:=cgNormalVec(pa,pb);  pn.w:=-cgDotProduct(pn,pc);//第一点与第四点之中面
        cgLinePlaneCross(pp,Vec, pc,pn, pd); //pd 线面交点
        p0:=pd; L:=cgDistance(pa,pd); //圆心、半径
        end;
      end
    else begin //三点球
      hide:= cgCenter( pa,pb,pe, pp,Vec, Ord(U) ); //三点之圆心pp 、半径pp.w和中轴向量Vec, U內切
      if(c>0)then L:=Obj[c].L;  if(L<pp.w)then L:=pp.w;  //L 半径
      if not Rand then L:=pp.w; //not Rand 以最小半径
      t:=sqrt(L*L-pp.w*pp.w);
      p0:=cgVecAddMult(pp,Vec, t);  //圆心
      end;
    end;
  if(Mode=15)then begin //反演球
    if(c>0)then R:=getLinkVar( c, pb);
    W:=0; H:=0; p2:=p0;  Vec:=Obj[a].Vec;
    rZ0:=0; rZ1:=Pi; pTR:=cgVector(0,0,0);
    Angle:=0; aR:=R; bR:=Angle;
    if(Obj[a].Kind=4)then begin //由平面反演的球
      pp:=Footer(pb,a,true); pn:=Vec; isComp:=EP(pp.w);
      if not isComp then begin
        pp:=cgInversion(pb,pp,R,Lock); L:=cgDistance(pb,pp)/2;
        p0:=cgVecMid(pb,pp);
        end;
      end;
    if(Obj[a].Kind=6)then begin //由球反演的球
      pn:=cgNormalVec(pa,pb);  pp:=pa; Vec:=pn; isComp:=EP(pn.w-Obj[a].L);
      if isComp then begin //反演中心在球面上
        pp:=cgVecAddMult(pa,pn, Obj[a].L); //对称点
        pp:=cgInversion(pb,pp, R,Lock);//反演点
        end
      else begin
        pa:=cgVecAddMult(pp,pn,Obj[a].L);   pa:=cgInversion(pb,pa, R,Lock);
        pp:=cgVecSubMult(pp,pn,Obj[a].L);   pb:=cgInversion(pb,pp, R,Lock);
        p0:=cgVecMid(pa,pb); L:=cgDistance(pa,pb)/2;
        end;
      end;
    if isComp then begin //反演成平面
      k:=4+trunc(Obj[a].L*Pi);
      hide:=cgGetRectangle(pp,pn, k,k, pa,pb,pc,pd);
      p0:=pp; L:=999;
      end;
    end;//反演球
//  if bDraw then begin
    if(Mode=15)and(L=999)then begin //反演中心在球面上时，模拟的平面
      k:=4+trunc(Obj[a].L*Pi);
      setLength(FaceVct[ID], k+1); for i:=0 to k do setLength(FaceVct[ID,i],k+1);
      pn:=cgNormalVec(pb,pa);
      for j:=0 to k do FaceVct[ID,j,0]:=cgVecAddMult(pa,pn,j);
      pn:=cgNormalVec(pd,pa);
      for j:=0 to k do
        for i:=1 to k do FaceVct[ID,j,i]:=cgVecAddMult(FaceVct[ID,j,0],pn,i);
      end
    else begin
      if(S<2)then S:=2; if(S>15)then S:=2;
      isFan:=(Angle>0.00001);
      k:=SphereSlice[S,0]; rZ:=(rZ1-rZ0)/k;   // k径向分片
      a:=SphereSlice[S,1]; dR:=(bR-towPi)/a;  // a纬向分片
      b:=a;  if isFan then b:=a+2;
      setLength(FaceVct[ID], b+1);  for i:= 0 to b do setLength(FaceVct[ID,i], k+1);
      rY:=IIFf(Mode=15,0, aR); //Mode=15 反演球
      for j:= 0 to k do begin //从底向上一圈一圈计算圆周
        t:=L*cos(rZ0+(k-j)*rZ)*(1-H);
        pa:=cgVecAddMult(p0,Vec, t);
        if(j=0)then pb:=pa;   if(j=k)then pc:=pa;
        t:=L*sin(rZ0+(k-j)*rZ);
        for i:=0 to a do
          FaceVct[ID,i,j]:= DotInCircle( pa,ID, i*dR, t, W,rY);
        if isFan then begin
          FaceVct[ID,a+1,j]:=pa;  FaceVct[ID,b,j]:=FaceVct[ID,0,j];
          end;
        end;
      if(pTR.x>0)or(pTR.y>0)then begin //球冠
        c:=k; if(pTR.x>0)then inc(c);  if(pTR.y>0)then inc(c);
        for i:= 0 to b do setLength(FaceVct[ID,i], c+1);
        if(pTR.y>0)then
          for j:=k+1 downto 1 do
            for i:=0 to b do FaceVct[ID,i,j]:= FaceVct[ID,i,j-1];
        if(pTR.y>0)then for i:=0 to b do FaceVct[ID,i,0]:=pb;
        if(pTR.x>0)then for i:=0 to b do FaceVct[ID,i,c]:=pc;
        end;
      end;
    p1:=pa; //标签位置
//    end; //if bDraw
  end;//with Obj[ID]
end;
//======================= 6_2 圆台 ========================
procedure TfrmMain.Cone(  ID:integer; bDraw,bList:boolean);
var i,j,a,b,c,dd,e,ff,gg,kk, Kb :Integer;    t,aL, aR,bR,dR :single;   pp,pq :TcgVector;
begin
  with Obj[ID] do begin
  a:=Link[0]; b:=Link[1];   c:=Link[2];   dd:=Link[3];
  e:=Link[4]; ff:=Link[5]; gg:=Link[6];   kk:=Link[10];
  if(a<=0)then a:=1;  if(not bAdd)and(b<=0)then b:=4;
  hide:=Obj[a].hide or Obj[b].hide
      or(c>0)and(Obj[c].hide) or(dd>0)and(Obj[dd].hide)
      or(e>0)and(Obj[e].hide) or(gg>0)and(Obj[gg].hide) or(kk>0)and(Obj[kk].Hide);
  if hide then exit;

  p0:= Obj[a].p0;  Kb:=Obj[b].Kind; //下底圆心
  if(bAdd or(b>0))and(Kb=1)then Vec:=cgNormalVec(Obj[b].p0, p0)
                  else if(b=0)then Vec:=cgVector(0,0,1) else Vec:=Obj[b].Vec;
  if  c>0 then L:=getLinkVar( c, p0); //半径
  if dd>0 then R:=getLinkVar(dd, p0); //初角
  if  e>0 then H:=getLinkVar( e, p0); //高度
  if ff>0 then W:=getLinkVar(ff, p0); //锥度
  if kk>0 then Angle:=getLinkVar(kk, p0);
  if Deg then Limit(Angle, 0,0, 360,360)
         else Limit(Angle, 0,0, towPi,towPi);//终角
  aR:=R;      if Deg then aR:=aR/oneArc;
  bR:=Angle;  if Deg then bR:=bR/oneArc;
  p1:=cgVecAddMult(p0, Vec,H); //上底圆心  //标签位置
  if(Link[9]>0)then begin //偏移
    i:=Link[9];
    if(Obj[i].Kind=1)then p1:=Obj[i].p0; 
    if(Obj[i].Kind=2)then p1:=cgVecAdd( p0, cgVecSub( Obj[i].p1, Obj[i].p0));
    H:=cgDistance(p1, cgDotPlaneFooter( p1, p0, Vec));
    end;
  p2:=cgVecMid(p0,p1);         //中心点，用于计算遮罩
  p3:=p1;
  aL:=W*L; //上底半径
  t:=L*(L-aL)/H;    p4:=cgVecSubMult(p0, Vec,t); //光照法线中心
  if(S<2)then S:=2; if(S>15)then S:=4;
  a:=SphereSlice[S,1];//圆周分段数
  dR:=(towPi-bR)/a;  a:=trunc((towPi-bR)/dR+0.00001); if(a<1)then a:=1;
  b:=a; if(bR>0)and Trace then b:=a+2; //(bR<towPi)扇形圆台
  setLength(FaceVct[ID],b+1);   for i:=0 to b do setLength(FaceVct[ID,i], 2);
  for i:=0 to a do begin
    t:=i*dR;  if t>(towPi-bR)then t:=towPi-bR;
    FaceVct[ID,i,0]:= DotInCircle( p0,ID, bR+t, L, 0,aR);
    FaceVct[ID,i,1]:= DotInCircle( p1,ID, bR+t,aL, 0,aR);
    end;
  if Trace then //封闭端面
    for i:= 0 to b do begin
      setLength(FaceVct[ID,i], 4);
      FaceVct[ID,i,2]:= FaceVct[ID,i,1];
      FaceVct[ID,i,1]:= FaceVct[ID,i,0];
      FaceVct[ID,i,0]:=p0;
      FaceVct[ID,i,3]:=p1;
      end;
  if(b>a)then begin //扇形圆台
    FaceVct[ID,a+1,0]:=p0;   FaceVct[ID,a+2,0]:=FaceVct[ID,0,0];
    FaceVct[ID,a+1,1]:=p0;   FaceVct[ID,a+2,1]:=FaceVct[ID,0,1];
    FaceVct[ID,a+1,2]:=p1;   FaceVct[ID,a+2,2]:=FaceVct[ID,0,2];
    FaceVct[ID,a+1,3]:=p1;   FaceVct[ID,a+2,3]:=FaceVct[ID,0,3];
    end;
  end; //with Obj[ID]
end;
//======================= 6_3 多面体 ========================
procedure TfrmMain.Cubes(  ID:integer; bDraw,bList,bLine:boolean);
  var a,b,c,dd,ee,ff,gg, i,j,k, Kb,SS :Integer; aR, r0,r1, h0,h1 :single;
      pn,pt,pb :TcgVector;
      pos :array[0..24] of TcgVector;
  const side:array[1..6]of integer=(3,4,4,5,5,4); //等份圆周数
  procedure getVert(ID,k,S:integer; L,aR:single);//生成顶点
    var i :integer;  pa,pb,pc,pn, pc0,pc1,pc2,pc3 :TcgVector;  j,t,l0 :single;
    function getVector(ID,cc:integer; aR:single; var pa,pb,pc0:TcgVector; var t:single):TcgVector;
      begin
        pc0:= cgNormalVec( pb,pa);  t:=pc0.w;  //t 底边长度
      if(cc<1)then begin //无关联
        pc1:= Obj[4].Vec;   if EP(pc0.x)and EP(pc0.y)then pc1:=Obj[2].Vec;
        setLine( 9,pa,pc0);
        pc:= DotInCircle( pa, 9, aR, 1, 0,0);
        result:= cgNormalVec( pc,pa);
//        Obj[ID].Vec:= cgGetNormal(pa,pb,pc);
        end
      else
        case Obj[cc].Kind of //cc 转角关联
        1,2:begin
          if(Obj[cc].Kind=2)then pc:=Obj[cc].Vec
            else pc:= cgNormalVec( Obj[cc].p0, pa);
          pc:= cgCrossProduct( pc, pc0);  cgNormalize(pc);
          result:= cgCrossProduct( pc0, pc);
//          Obj[ID].Vec:= pc;
          end;
        3,4:begin
          result:= cgCrossProduct( Obj[cc].Vec, pc0);
//          Obj[ID].Vec:=Obj[cc].Vec;
          end;
        end;
      cgNormalize(result);
      end;
  begin
    with Obj[ID] do begin pa:=Obj[Link[0]].p0; pb:=Obj[Link[1]].p0;  pc:=p0;  pn:=Vec;  end;
    j:=towPi/k;
    case S of
    1,11:with Obj[ID] do begin  //正四面体
      if(S=1)then begin //以基点和中轴线定义
        r0:= L*0.942807;  h0:= L*0.333333;
        if Obj[ID].Trace then pc:=cgVecAddMult(pc,pn,h0); //中点移到底面
        Obj[ID].p2:=pc;   Obj[ID].p3:=pos[0];
        pos[0]:=cgVecAddMult(pc, pn, L); //上顶点坐标
        pc:=cgVecSubMult(pc, pn, h0);  //下底圆心
        for i:=0 to 3 do
          pos[i+1]:=DotInCircle(  pc, ID, aR+i*j, r0, 0, 0); //pc:圆心,b:法线,Fi:圆周角,L:半径
        end;
      if(S=11)then begin //以底边两端点定义
        pn:= getVector( ID,Link[3], aR, pa,pb, pc0,t);
        L:=t*0.61237244;   //sqrt(6)/4;
        pos[1]:= pa;   pos[2]:= pb;  pos[4]:=pos[1];
        pc:=cgVecMid(pa,pb);
        pos[3]:= cgVecAddMult( pc,pn, t*0.8660254);
        p0:= cgVecAddMult( pc, pn, t*0.28867513);    //下底中心
        Vec:= cgCrossProduct( pn,pc0);
        pos[0]:= cgVecAddMult( p0,Vec, L*1.333333 ); //上顶点坐标
        Obj[ID].p2:=p0;   Obj[ID].p3:=pos[0];
        end;
      setLength(FaceVct[ID],2); for i:=0 to 1 do setLength(FaceVct[ID,i],5);
      for i:=0 to 4 do FaceVct[ID,0,i]:=pos[IIFi(i in[1,2],0,1)];
      for i:=0 to 4 do FaceVct[ID,1,i]:=pos[IIFi(i in[2,3],3,2)];
      for i:=0 to 3 do Obj[ID+6+i+1].p0:=pos[i]; //顶点
      end; //1,11
    2,12:with Obj[ID] do begin  //正六面体
      setLength(FaceVct[ID],4); for i:=0 to 3 do setLength(FaceVct[ID,i],5);
      if(S=2)then begin //以基点和中轴线定义
        h0:=L/sqrt(3); //L-外接球半径 h0-半高
        r0:=L*sqrt(2/3); //顶点的水平半径
        if Obj[ID].Trace then pc:=cgVecAddMult(pc,pn,h0);//中点移到底面
        pt:=cgVecAddMult(pc,pn, h0); //上底
        pb:=cgVecSubMult(pc,pn, h0); //下底
        t:=-Pi/4; //对角线的水平角
        for i:=0 to 4 do begin
          t:=-t;    r1:=aR+ t;   if( i in[1,2])then r1:=r1+Pi;
          pos[i]:= DotInCircle( pt,ID, r1, r0, 0,0);
          end;
        t:=h0*2; //高度
        p0:=pb;
        end;
      if(S=12)then begin //以底边两端点定义
        pn:= getVector( ID,Link[3], aR, pa,pb,pc0, t);//pc0底边向量 t底边长
        pos[0]:= pa;   pos[1]:= pb;
        pos[2]:= cgVecAddMult( pb, pn, t);
        pos[3]:= cgVecAddMult( pa, pn, t);
        pos[4]:= pos[0];
        pn:= cgCrossProduct( pn, pc0);  cgNormalize(pn);
        for i:=0 to 4 do pos[i]:= cgVecAddMult( pos[i], pn, t);
        pt:= cgVecMid( pos[5], pos[7]);
        p0:= cgVecMid( pos[0], pos[2]);  L:=cgDistance( pa,p0);
        end;
      Obj[ID].p2:=p0;   Obj[ID].p3:=pt;
      for i:=0 to 4 do begin
        pos[i+5]:= cgVecSubMult(pos[i], pn,t); //t 棱边长
        FaceVct[ID,0,i]:= pt;
        FaceVct[ID,1,i]:= pos[i];
        FaceVct[ID,2,i]:= pos[i+5];
        FaceVct[ID,3,i]:= p0;
        end;
      for i:=0 to 3 do Obj[ID+12+i+1].p0:= pos[i];    //上顶顶点
      for i:=0 to 3 do Obj[ID+12+i+5].p0:= pos[i+5];  //下顶顶点
      end; //2,12
    6:with Obj[ID] do begin  //长方体
      setLength(FaceVct[ID],4); for i:=0 to 3 do setLength(FaceVct[ID,i],5);
      r0:=sqrt(L*L+W*W)/2; //底面半径
      pt:=cgVecAddMult(pc,pn, H);  //上底中心
      if(Link[9]>0)then pt:=cgDotPlaneFooter(Obj[Link[9]].p0, pt,Vec);
      if EP(L)then t:=-halfPi else t:=-arcTan(W/L); //对角线的水平角
      for i:=0 to 4 do begin //计算顶点
        t:=-t;    r1:=aR+ t;   if( i in[1,2])then r1:=r1+Pi;
        pos[i  ]:= DotInCircle( pc,ID, r1, r0, 0,0);  //上底顶点
        pos[i+5]:= DotInCircle( pt,ID, r1, r0, 0,0);  //下底顶点
        end;
      if Trace then begin //Trace 中点移到底面顶点
        pb:=cgVecSub(pos[0],pc);    for i:=0 to 9 do pos[i]:=cgVecAdd(pos[i],pb);
        end;
      for i:=0 to 4 do begin
        FaceVct[ID,0,i]:=pt;      FaceVct[ID,1,i]:=pos[i+5];
        FaceVct[ID,2,i]:=pos[i];  FaceVct[ID,3,i]:=pc;
        end;
      for i:=0 to 3 do Obj[ID+12+i+1].p0:= pos[i];   //上顶顶点
      for i:=0 to 3 do Obj[ID+12+i+5].p0:= pos[i+5]; //下顶顶点
      p2:=pt;
      end;
    3,13:begin  //正八面体
      setLength(FaceVct[ID],3); for i:=0 to 2 do setLength(FaceVct[ID,i],5);
      r0:=L; h0:=0;
      if Obj[ID].Trace then begin //中点移到底面
        pc:=cgVecAddMult(pc,pn,r0);
        r1:=r0*sin(Pi/4)*cos(Pi/6)*4/3; //底面三角形分布半径
        h1:=sqrt(r0*r0-r1*r1)*2; //高度
        for i:=0 to 5 do begin
          pc:=Obj[ID].p0; if(i in[1,3,5])then pc:=cgVecAddMult(pc,pn,h1);
          pos[i]:=DotInCircle(  pc, ID, aR+i*Pi/3, r1, 0, 0);
          end;
        pos[6]:=pos[3]; pos[3]:=pos[4]; pos[4]:=pos[5]; pos[5]:=pos[1];
        for i:=0 to 4 do FaceVct[ID,2,i]:=pos[0];
        for i:=0 to 4 do FaceVct[ID,0,i]:=pos[6];
        for i:=0 to 4 do FaceVct[ID,1,i]:=pos[i+1];
        end
      else begin
        pos[0]:=cgVecAddMult(pc, pn, r0);  pos[6]:=cgVecAddMult(pc, pn,-r0);
        Obj[ID].p2:=pc; Obj[ID].p3:=pos[0];
        for i:=0 to 4 do begin
          t:= aR+ i*j;
          pos[i+1]:=DotInCircle(  pc, ID, t, r0, 0, 0);
          FaceVct[ID,0,i]:=pos[0];
          FaceVct[ID,1,i]:=pos[i+1];
          FaceVct[ID,2,i]:=pos[6];
          end;
        end;
      Obj[ID+12+1].p0:=pos[0];  Obj[ID+12+6].p0:=pos[6];//上下顶点
      for i:=0 to 3 do Obj[ID+12+i+2].p0:=pos[i+1];     //中顶点
      end;
    4,14:begin  //正十二面体
        r0:=L*cos(0.91844); h0:=L*sin(0.91844);
        r1:=L*cos(0.18871); h1:=L*sin(0.18871);
        if Obj[ID].Trace then pc:=cgVecAddMult(pc,pn,h0);//中点移到底面
        pc0:=cgVecAddMult(pc, pn, h0);  pc1:=cgVecAddMult(pc, pn, h1);
        pc2:=cgVecAddMult(pc, pn,-h1);  pc3:=cgVecAddMult(pc, pn,-h0);
        Obj[ID].p2:=pc; Obj[ID].p3:=pc0;
        for i:=0 to k do begin
          t:= aR+ i*j;  //j:=towPi/k
          pos[i   ]:=DotInCircle(  pc0, ID, t, r0, 0, 0);
          pos[i+ 6]:=DotInCircle(  pc1, ID, t, r1, 0, 0);
          t:= t+ 0.62832; // towPi*0.1;
          pos[i+12]:=DotInCircle(  pc2, ID, t, r1, 0, 0);
          pos[i+18]:=DotInCircle(  pc3, ID, t, r0, 0, 0);
          end;
      setLength(FaceVct[ID],5); for i:=0 to 4 do setLength(FaceVct[ID,i],11);
      for i:=0 to 10 do begin
        FaceVct[ID,0,i]:=pc0;  FaceVct[ID,4,i]:=pc3;
        end;
      for i:=0 to 5 do begin
        pn:=cgVecMid(pos[i],pos[i+1]);
        FaceVct[ID,1,i*2]:=pos[i];    if i<5 then FaceVct[ID,1,i*2+1]:=pn;
        FaceVct[ID,2,i*2]:=pos[i+6];  if i<5 then FaceVct[ID,2,i*2+1]:=pos[i+12];
        if i=0 then pn:=cgVecMid(pos[22],pos[23])
               else pn:=cgVecMid(pos[i+17],pos[i+18]);
        FaceVct[ID,3,i*2]:=pn; if i<5 then FaceVct[ID,3,i*2+1]:=pos[i+18];
        end;
      for i:=0 to 4 do begin //20个顶点
        Obj[ID+30+i+ 1].p0:=pos[i];     Obj[ID+30+i+ 6].p0:=pos[i+6];
        Obj[ID+30+i+11].p0:=pos[i+12];  Obj[ID+30+i+16].p0:=pos[i+18];
        end;
      end;
    5,15:begin  //正二十面体
      if Obj[ID].Trace then begin //中点移到底面
        r0:=L*0.607062;     //底面三角形外接圆半径
        r1:=L*cos(0.18871); //中间圆半径
        h0:=L*0.79465447;   //内接球半径
        h1:=L*sin(0.18871); //球心与中间面之距
        pc0:=pc;
        pc1:=cgVecAddMult(pc,pn,h0-h1);
        pc2:=cgVecAddMult(pc,pn,h0+h1);
        pc3:=cgVecAddMult(pc,pn,h0+h0);
        pos[0 ]:=DotInCircle( pc0, ID, aR, r0, 0, 0);      //下顶点
        pos[1 ]:=DotInCircle( pc2, ID, aR, r1, 0, 0);
        pos[2 ]:=DotInCircle( pc1, ID, aR+Pi/3, r1, 0, 0);
        pos[3 ]:=DotInCircle( pc0, ID, aR+Pi*2/3, r0, 0, 0);
        pos[4 ]:=DotInCircle( pc0, ID, aR+Pi*4/3, r0, 0, 0);
        pos[5 ]:=DotInCircle( pc1, ID, aR+Pi*5/3, r1, 0, 0);
        pos[6 ]:=pos[1];

        pos[7 ]:=DotInCircle( pc3, ID, aR+Pi/3, r0, 0, 0);
        pos[8 ]:=DotInCircle( pc2, ID, aR+Pi*2/3, r1, 0, 0);
        pos[9 ]:=DotInCircle( pc1, ID, aR+Pi, r1, 0, 0);
        pos[10]:=DotInCircle( pc2, ID, aR+Pi*4/3, r1, 0, 0);
        pos[11]:=DotInCircle( pc3, ID, aR+Pi*5/3, r0, 0, 0);
        pos[12]:=pos[7];
        pos[13]:=DotInCircle( pc3, ID, aR+Pi, r0, 0, 0);  //上顶点
        end
      else begin
        r0:=L*cos(0.463645);  h0:=L*sin(0.463645);
        pos[13]:=cgVecAddMult(pc,pn, L);  pc2:=cgVecAddMult(pc,pn, h0);//上顶点
        pos[ 0]:=cgVecAddMult(pc,pn,-L);  pc1:=cgVecAddMult(pc,pn,-h0);//下顶点
        Obj[ID].p2:=pc;           Obj[ID].p3:=pos[0];
        for i:=0 to 5 do begin
          if Obj[ID].Trace then t:=i*j else t:= aR+ i*j;
          pos[i+1]:=DotInCircle(  pc1, ID, t, r0, 0, 0);
          t:= t+ towPi*0.1;
          pos[i+7]:=DotInCircle(  pc2, ID, t, r0, 0, 0);
          end;
        end;
      setLength(FaceVct[ID],4); for i:=0 to 3 do setLength(FaceVct[ID,i],11);
      for i:=0 to 10 do begin
        FaceVct[ID,3,i]:=pos[0];  FaceVct[ID,0,i]:=pos[13];
        end;
      for i:=0 to 5 do begin
        FaceVct[ID,2,i*2]:=pos[i+1];  if i<5 then FaceVct[ID,2,i*2+1]:=pos[i+2];
        FaceVct[ID,1,i*2]:=pos[i+7];  if i<5 then FaceVct[ID,1,i*2+1]:=pos[i+7];
        end;
      Obj[ID+30+1].p0:=pos[0];  Obj[ID+30+12].p0:=pos[13];//上下顶点
      for i:=0 to 4 do begin
        Obj[ID+30+i+ 2].p0:=pos[i+2]; Obj[ID+30+i+ 7].p0:=pos[i+7]; //中顶点
        end;
      end;
    end;// case
  end;
  procedure setVert(var j:integer; ia, ib:integer);
    begin  inc(j);
      Obj[j].p0:=pos[ia]; Obj[j].p1:=pos[ib];
      end;
begin
  with Obj[ID] do begin
  a:=Link[0]; b:=Link[1];   c:=Link[2]; dd:=Link[3];
  ee:=Link[4]; ff:=Link[5];gg:=Link[6];
  if(a<1)then a:=1;  if(not bAdd)and(MarkObj=ID)and(b<1)then b:=4;
  hide:=Obj[a].hide or Obj[b].hide or(c>0)and(Obj[c].hide) or(gg>0)and(Obj[gg].hide);
  if hide then exit;
  p0:=Obj[a].p0;   p2:=p0;  Kb:=Obj[b].Kind;
  if(bAdd or(b>0))and(Kb=1)then Vec:=cgNormalVec( Obj[b].p0, p0)
               else if(b=0)then Vec:=cgVector(0,0,1) else Vec:=Obj[b].Vec;
  if  c>0 then L:=getLinkVar( c, p0); //半径
  if dd>0 then R:=getLinkVar(dd, p0); //转角
  if ee>0 then H:=getLinkVar(ee, p0); //高度
  if ff>0 then begin
    W:=getLinkVar(ff, p0); //宽度
    if (S mod 10)<6 then L:=EdgeToRadius(W,S); //由棱长换算半径
    end;
  aR:=R; if Deg then aR:=aR/oneArc; //转角
  k:=side[S mod 10]; //等份圆周数
  getVert(ID, k,S, L,aR); //生成顶点 L半径 R转角 k等份数
    j:=ID;
  if bLine then //设置棱边的端点坐标
  case S of
    1,11:for i:=0 to k-1 do begin  //正四面体
        setVert(j, 0, i+1); setVert(j, i+1, i+2);
        end;// 1
    2,12,6:for i:=0 to k-1 do begin  //正六面体
        setVert(j, i, i+1); setVert(j, i, i+5); setVert(j, i+5, i+6);//顶边 //直边//底边
        end;// 2
    3,13:for i:=0 to k-1 do begin  //正八面体
        setVert(j, 0, i+1); setVert(j,i+1,i+2); setVert(j, 6, i+1);//上侧棱//边棱//下侧棱
        end;// 3
    4,14:for i:=0 to k-1 do begin //正十二面体
        setVert(j, i, i+1); setVert(j, i, i+6);   setVert(j, i+6, i+12);//顶边棱//上侧棱//中边棱
        setVert(j,i+7,i+12);setVert(j,i+18,i+12); setVert(j, i+18, i+19);//中边棱//下侧棱//底边棱
        end;// 4
    5,15:for i:=0 to k-1 do begin  //正二十面体
        setVert(j, 0, i+1); setVert(j, 13, i+8); setVert(j, i+1, i+2);//顶边棱//底边棱//上侧棱
        setVert(j,i+7,i+8); setVert(j,i+1, i+7); setVert(j, i+7, i+2);//下侧棱//中边棱//中边棱
        end;// 5
    end;// case S
  p1:=FaceVct[ ID, IIFi(S in[2,4, 12,14], 1,0), 1];  //标签位置
  k:=SolidEdge[S mod 10]; //棱边数
  for i:= 1 to k do with Obj[ID+i] do begin    //棱边属性
    Kind:=2;    Mode:=13;   f:=false; Vec:=cgNormalVec(p1,p0);
    L:=Vec.w;   p4:=p0;     p5:=p1;
    end;
  if(S<6)and(Obj[MarkObj].Kind=6)then begin //修改棱边属性时也会调用本过程
    W:=Obj[ID+1].Vec.w; //棱长
    if bNail then begin varW.Caption:=ftos(W,4); varW.Refresh; end;
    end;
  end; //with Obj[ID]
end;
//======================= 6_4 棱台/棱柱/棱锥 ========================
procedure TfrmMain.Table(  ID:integer; bDraw,bList,bLine:boolean);
var a,b,c,dd,e,ff,gg,SS, i,j,m, Kb :Integer; aR:single; //aR转角
    pt,pb :array[0..99] of TcgVector; //正n棱台最大棱数99
  function setVert( ID,SS, Off :integer; aR:single):TcgVector;
    var i :integer;  t:single;   pp,pq :TcgVector;
  begin
    with Obj[ID] do begin
    setLength(FaceVct[ID],SS+1); for i:=0 to SS do setLength(FaceVct[ID,i], 2);
    pp:=p0; // 下底圆心
    if(Off>0)then begin //偏移
      if(Obj[Off].Kind=1)then pq:=Obj[Off].p0;
      if(Obj[Off].Kind=2)then pq:=cgVecAdd( p0, cgVecSub( Obj[Off].p5, Obj[Off].p4));
      H:=cgDistance(pq, cgDotPlaneFooter( pq, pp, Vec));
      if(pnlProp.Visible)and(MarkObj=ID)then varH.Caption:=ftos(H,4);
      end
    else
      pq:=cgVecAddMult(pp,Vec,H); // 上底圆心
    for i:=0 to SS do begin
      t:=aR+ i*towPi/SS;
      pt[i]:=DotInCircle(  pq, ID, t,W*L, 0, 0); //pc:圆心,b:法线,Fi:圆周角,L:半径
      pb[i]:=DotInCircle(  pp, ID, t,  L, 0, 0); //pc:圆心,b:法线,Fi:圆周角,L:半径
      FaceVct[ID,i,0]:=pt[i]; FaceVct[ID,i,1]:=pb[i];
      end;
    for i:=0 to SS-1 do Obj[ID+(SS*3)+i+1   ].p0:=pt[i];//上顶点
    for i:=0 to SS-1 do Obj[ID+(SS*3)+i+1+SS].p0:=pb[i];//下顶点
    result:=pq; //上底圆心
    end;
  end;
begin
  with Obj[ID] do begin
  a:=Link[0]; b:=Link[1];   c:=Link[2]; dd:=Link[3];
  e:=Link[4]; ff:=Link[5]; gg:=Link[6];
  if(a<1)then a:=1;  if(not bAdd)and(MarkObj=ID)and(b<1)then b:=4;  //
  hide:=Obj[a].hide or Obj[b].hide
      or(c>0)and(Obj[c].hide) or(dd>0)and(Obj[dd].hide)
      or(e>0)and(Obj[e].hide) or(gg>0)and(Obj[gg].hide);
  if hide then exit;
  p0:=Obj[a].p0;  Kb:=Obj[b].Kind;   //下底圆心
  if(bAdd or(b>0))and(Kb=1)then Vec:=cgNormalVec(Obj[b].p0, p0)
               else if(b=0)then Vec:=cgVector(0,0,1) else Vec:=Obj[b].Vec;
  if c>0  then L:=getLinkVar( c, p0); //半径
  if dd>0 then R:=getLinkVar(dd, p0); //转角
  if e>0  then H:=getLinkVar( e, p0); //高度
  if ff>0 then W:=getLinkVar(ff, p0); //斜度
  aR:=R; if Deg then aR:=aR/oneArc;
  if(Mode=4)and(S>100)and(Obj[a].Kind=4)and(Obj[a].Mode=6)and(Obj[a].Rand)and(Obj[a].W>100)then begin
    L:=Obj[a].L;    Vec:=Obj[a].Vec;
    p0:=Obj[a].p0;  S:=trunc(Obj[a].W);
    end;
  if(Mode=4)and(S>100)and(Link[8]>0)then begin //正n棱台S>100
    SS:=trunc(Obj[Link[8]].L); if(SS<3)then SS:=3; if(SS>99)then SS:=99;
    S:=SS+100;
    end;
  SS:=S; if SS>100 then SS:=SS-100;
  p1:=setVert(ID,SS, Link[9], aR); //计算顶点 Link[9]偏移点
  p2:=cgVecMid(p0,p1); //中心 用于遮罩计算
  if bLine and(S<100)then begin //生成棱边
    j:=ID;
    for i:= 0 to SS-1 do begin m:=IIFi(i=SS-1, 0, i+1);
      inc(j); with Obj[j] do begin Mode:=13; //上棱边
              p0:=pt[i];  p1:=pt[m];  Vec:=cgNormalVec(p1,p0);
              L:=Vec.w;   p4:=p0;     p5:=p1; end;
      inc(j); with Obj[j] do begin Mode:=13; //下棱边
              p0:=pb[i];  p1:=pb[m];  Vec:=cgNormalVec(p1,p0);
              L:=Vec.w;   p4:=p0;     p5:=p1; end;
      inc(j); with Obj[j] do begin Mode:=13;  //侧棱边
              p0:=pt[i];  p1:=pb[i];  Vec:=cgNormalVec(p1,p0);
              L:=Vec.w;   p4:=p0;     p5:=p1; end;
      end;
    end;
  if Trace then  //封闭端面
    for i:= 0 to SS do begin
      setLength(FaceVct[ID,i], 4);
      for j:=2 downto 1 do FaceVct[ID,i,j]:= FaceVct[ID,i,j-1];
      FaceVct[ID,i,0]:=p1;
      FaceVct[ID,i,3]:=p0;
      p3:=p1;
      end;
  p1:=FaceVct[ID,0,0]; //标签位置
  end; //with Obj[ID]
end;
//==================== 6_4 凸棱台 ======================
procedure TfrmMain.CustomTable( ID:integer; bDraw,bList,bLine:boolean);  //凸棱台
  var a,i,j,k,M,N :integer;  pc,pn,pt,pp :TcgVector;
begin //暂不考虑上下底面
  with Obj[ID]do begin  // 不能为S赋值 凸棱台的S=0
  a:=Link[0];   Vec:=Obj[a].Vec;
  M:=high(LocaVct[a]);   N:=trunc(Obj[a].W);
  with Obj[a]do if(Kind=4)and(Mode<6)then begin
    if(trunc(L)>0)or(M>2)then M:=4;
    N:=4;
    end;
  setLength(FaceVct[ID], M+1); for i:=0 to M do setLength(FaceVct[ID,i], 2);
  for i:= 0 to M do FaceVct[ID,i,1]:=LocaVct[a,i]; //下底顶点等于多边形顶点
  for i:= 1 to N*3 do Obj[ID+i].Lock:=i>(M*3); //隐藏多余边线，在Line过程中会根据Lock属性设置线段的hide属性
  for i:= 1 to N do Obj[ID+N*3+i].Lock:=i>M; //隐藏多余顶点
  pc:=cgVector(0,0,0);
  for i:= 0 to M-1 do pc:=cgVecAdd( pc,FaceVct[ID,i,1]);
  p0:=cgVecScale(pc,1/M);//底面形心
  if Link[4]>0 then H:=getLinkVar( Link[4], p0); //高度
  if Link[5]>0 then W:=getLinkVar( Link[5], p0); //斜度
  if(Link[9]>0)then begin //偏移
    if(Obj[Link[9]].Kind=1)then pt:=cgVecSub( Obj[Link[9]].p0, p0);
    if(Obj[Link[9]].Kind=2)then pt:=cgVecSub( Obj[Link[7]].p5, Obj[Link[7]].p4);
    H:=Footer( Obj[Link[9]].p0, a,true).w; //高度
    if(pnlProp.Visible)and(MarkObj=ID)then varH.Caption:=ftos(H,4);
    end
  else
    pt:=cgVecSub( cgVecAddMult(p0,Vec,H), p0);
  for i:=0 to M do begin
    j:=i; if i=M then j:=0;
    pn:=cgVecSub(FaceVct[ID,j,1],p0);
    pp:=cgVecAddMult(p0,pn,W);
    pp:=cgVecAdd(pp,pt);
    FaceVct[ID,i,0]:=pp;//上底顶点
    end;
  if bLine then begin //生成棱边
    j:=ID;
    for i:= 0 to M-1 do begin k:=IIFi(i=M-1, 0, i+1);
      inc(j); with Obj[j] do begin Mode:=13;  //下棱边
              p0:=FaceVct[ID,i,0];  p1:=FaceVct[ID,k,0];  Vec:=cgNormalVec(p1,p0);
              L:=Vec.w;   p4:=p0;   p5:=p1; end;
      inc(j); with Obj[j] do begin Mode:=13;  //上棱边
              p0:=FaceVct[ID,i,1];  p1:=FaceVct[ID,k,1];  Vec:=cgNormalVec(p1,p0);
              L:=Vec.w;   p4:=p0;   p5:=p1; end;
      inc(j); with Obj[j] do begin Mode:=13;  //侧棱边
              p0:=FaceVct[ID,i,0];  p1:=FaceVct[ID,i,1];  Vec:=cgNormalVec(p1,p0);
              L:=Vec.w;   p4:=p0;   p5:=p1; end;
      end;
    end;
  for i:=0 to M-1 do Obj[ID+N*3+i+1].p0:=FaceVct[ID,i,0]; //上顶点
  p1:=FaceVct[ID,0,0]; //标签位置
  end; //with
end;
//==================== 6_5 凸壳 ======================
procedure TfrmMain.Polyhedron(ID:integer; bDraw,bList,bLine:boolean);//凸壳
  type TEdge=record  //棱边
    a,b,n, c,d :integer; //棱边俩端点指针、相邻面数目、基面对角点、包裹面对角点
    bLock:boolean;   //相邻面是否共面
    end;
  var Vct :array[0..33] of TcgVector; //顶点的空间坐标
      Edge:array[0..100] of TEdge; //三维凸壳的棱边
      aa,bb,cc,dd, i,j, M,N, Pa,Pb,Ea,Eb, nEdge, VecNum :integer;
      isEdgeA,isEdgeB, isSameSide,isSamePlane :boolean;
      x,y,z, k,delta,dx,dy :single;
      pc,pn :TcgVector;
  label foreVec;
  Function GetNormal( p0,p1,p2 :TcgVector) :TcgVector;
    var A,B,C, dx1,dy1,dz1, dx2,dy2,dz2 :single;
    begin
      dx1:=p1.x-p0.x;     dy1:=p1.y-p0.y;       dz1:=p1.z-p0.z;
      dx2:=p2.x-p0.x;     dy2:=p2.y-p0.y;       dz2:=p2.z-p0.z;
      A:=dy1*dz2-dz1*dy2; B:=-dx1*dz2+dz1*dx2;  C:= dx1*dy2-dy1*dx2;
      result:= cgVector(A,B,C); //A,B,C 为平面标准方程中的各项系数
    end;
  Function Vert( x,y,z,w, v :integer) :TEdge;
    begin with result do begin a:=x;  b:=y;  n:=z; c:=w; d:=v; bLock:=false; end;
    end;
  function DotInPlane(a,b,c, d:integer):boolean;//点d是否与平面abc共面
    var pn,pm :TcgVector;  k:single; j:integer;
    begin
      result:=false;
      if(a<0)or(b<0)or(c<0)or(d<0)then exit;
      pn:=getNormal(Vct[a],Vct[b],Vct[c]); //平面法线
      pm:=cgVecSub(Vct[d],Vct[a]);
      k:=cgDotProduct(pn,pm);     result:= EP(k);
      if result then
      for j:=1 to 3 do if result then
        result:= cgCheckSide( Vct[c], Vct[a],Vct[b], j)
          *cgCheckSide( Vct[d], Vct[a],Vct[b], j)<=0;
    end;
  function Angle(vp,vq :TcgVector):single; //俩平面之夹角
    var A0,B0,C0, A1,B1,C1 :single;
    begin
      A0:=vp.x; B0:=vp.y; C0:=vp.z; //基面的方程系数
      A1:=vq.x; B1:=vq.y; C1:=vq.z; //包裹面的方程系数
      result:=(A0*A1+B0*B1+C0*C1)/(sqrt(sqr(A0)+sqr(B0)+sqr(C0))*sqrt(sqr(A1)+sqr(B1)+sqr(C1))); //夹角
    end;
  function getTopVec(a,b,c :integer):integer;//用卷包裹法计算凸点 a,b是凸棱的端点 delta 夹角
    var V :single;   i:integer;
        pa,pb,pc,  vp,vq :TcgVector;
    begin result:=0;
      pa:=Vct[a];
      if b<0 then begin pb:=pa; pb.x:=pb.x+1; end else pb:=Vct[b];
      if c<0 then begin pc:=pa; pc.z:=pc.z+1; end else pc:=Vct[c];
      vp:=getNormal(pa, pb, pc);
      delta:=1000;
      for i:= 0 to M do //遍历所有顶点
        if(i<>a)and(i<>b)and(i<>c)then begin
          vq:=getNormal(pa, pb, Vct[i]);
          V:=Angle(vp,vq); //夹角
          if(V<delta)then begin delta:=V; result:=i; end; //最终得到夹角最小的平面
          end;
      Vct[result].w:=1;//凸点标记.计算遮罩时用
    end;
  procedure toLst(aa,bb:integer; S:string);
    var i:integer;  cs,ds:string;
    begin
 //     Lst.AddItem(itos(aa)+','+itos(bb)+' '+S,nil);
    for i:=aa to bb do
      with Edge[i]do begin
      if c<0 then cs:='@' else cs:=Obj[Obj[ID].Link[c]].Tag;
      if d<0 then ds:='@' else ds:=Obj[Obj[ID].Link[d]].Tag;
 //     Lst.AddItem(itos(i)+'  '+ Obj[Obj[ID].Link[a]].Tag+' '+Obj[Obj[ID].Link[b]].Tag
 //     +' '+itos(n)+'  '+cs +'  '+ds +' '+IIFs(bLock,'T','F'),nil);
      end;
    end;
begin
  M:=trunc(Obj[ID].W-1);//顶点总数 最大32
  for i:= 0 to M do begin Vct[i]:=Obj[Obj[ID].Link[i]].p0; Vct[i].w:=0; end; //Vct[i].w 凸点标记
  for i:= 0 to 96 do Edge[i]:=Vert(0,0,0,0,-1); // Edge[i].bLock\:=false;
  if(M=3)and not bAdd then with Obj[ID] do begin //仅有四个顶点时
    for i:=0 to 2 do begin
      Edge[i].a:=0;     Edge[i].b:=i+1;
      Edge[i+3].a:=i+1; Edge[i+3].b:=IIFi(i<2, i+2,1);
      Edge[i].d:=IIFi(i<2, i+2,1);   if(i=0)then Edge[3].d:=3;
      Vct[i].w:=1;  Vct[i+3].w:=1;
      end;
    nEdge:=5;
    goto foreVec;
    end;
//  Obj[ID].hide:=M<5; if Obj[ID].hide then exit;
  k:=1000;
  for i:= 0 to M do
    if Vct[i].y<k then begin k:=Vct[i].y; aa:=i; end; //y坐标最小的点为第一个凸点
  k:=1000;
  for i:= 0 to M do //用卷包裹法计算XOY平面上的第二个凸点
    if i<>aa then begin
      dy:=Vct[i].y-Vct[aa].y;  dx:=Vct[i].x-Vct[aa].x;
      if EP(dx) then delta:=halfPi else delta:=arcTan(abs(dy/dx));//与X轴的夹角
      if dx<0 then delta:= Pi-delta; //第二象限
      if delta<k then begin k:=delta; bb:=i; end; //b 第二个凸点
      end;
  Edge[0]:=Vert( aa,bb,1,-1, -1); //第一条三维凸棱
  nEdge:=0;{凸棱总数} i:=0;
//  Lst.Clear;
//  toLst(0,0,'One');//@@@@@@@@@@@@@@@
  repeat
    if(Edge[i].n=2)then begin
//  toLst(i,i,'TowEdge');//@@@@@@@@@@@@@@@
      dec(i);
      continue;
      end; //n相邻面数
    aa:=Edge[i].a; bb:=Edge[i].b; cc:=Edge[i].c; //基面
    dd:=getTopVec(aa,bb,cc);  //寻找下一个凸点
    Ea:=0; Eb:=0;    isEdgeA:=false; isEdgeB:=false;
    for j:=0 to nEdge do begin //遍历已有的棱边 判断新棱边是否已存在
      Pa:=Edge[j].a;  Pb:=Edge[j].b;
      if(Pa=aa)and(Pb=dd)or(Pa=dd)and(Pb=aa)then
        begin Ea:=j; isEdgeA:=true; end; //
      if(Pa=bb)and(Pb=dd)or(Pa=dd)and(Pb=bb)then
        begin Eb:=j; isEdgeB:=true; end;
      end;
    if not Edge[i].bLock then Edge[i].bLock:=DotInPlane(aa,bb,cc, dd);//新凸点是否跟基面共面

    if(isEdgeA)and(Edge[Ea].n=2) or (isEdgeB)and(Edge[Eb].n=2)
    then begin
//  toLst(i,i,'@'+' '+Obj[Obj[ID].Link[dd]].tag);//@@@@@@@@@@@@@@@
      dec(i); //新棱边已存在且相邻面数为2
      end
    else begin
      if Edge[i].d<0 then Edge[i].d:=dd;//第三点，用于画三角形
      if i>0 then Edge[i].n:=2;
//  toLst(i,nEdge, 'NewV');//@@@@@@@@@@@@@@@
      if isEdgeA
        then with Edge[Ea]do begin
          n:=2;  if c<0 then c:=bb;  if d<0 then d:=bb;
          if not bLock then bLock:=DotInPlane(a,b,d,c);
//  toLst(Ea,Ea, 'OldA');//@@@@@@@@@@@@@@@
          end
        else begin inc(nEdge); i:=nEdge; Edge[i]:=Vert(dd,aa,1,bb,-1);
//  toLst(i,nEdge, 'NewA');//@@@@@@@@@@@@@@@
          end;
      if isEdgeB
        then with Edge[Eb]do begin
          n:=2;  if c<0 then c:=aa;  if d<0 then d:=aa;
          if not bLock then bLock:=DotInPlane(a,b,d,c);
//  toLst(Eb,Eb, 'OldB');//@@@@@@@@@@@@@@@
          end
        else begin inc(nEdge); i:=nEdge; Edge[i]:=Vert(dd,bb,1,aa,-1);
//  toLst(i,nEdge, 'NewB');//@@@@@@@@@@@@@@@
          end;
      end;
  until(i<=0);
//  if not bAdd then toLst(0,nEdge,'Total');//@@@@@@@@@@@@@@@
foreVec://仅有四个顶点时
  N:=(M-1)*3; //if(nEdge>N)then nEdge:=N;
  if N>nEdge then for i:= nEdge+1 to N do Edge[i].bLock:=true; //隐藏多余棱边 在Line过程中将根据Lock属性设置hide属性
  Obj[ID].L:=nEdge+1; //棱边数
  for i:= 0 to N-1 do //棱边
    with Obj[ID+i+1] do begin
    Kind:=2;  Mode:=13; Link[0]:=ID;  Link[1]:=0;   Link[2]:=0;
    p0:=Vct[Edge[i].a]; p1:=Vct[Edge[i].b];   p4:=p0; p5:=p1; //棱边端点
    Vec:=cgNormalVec(p1,p0);//向量
    L:=Vec.w; // cgDistance(p0,p1);   //长度
    Lock:= Edge[i].bLock;   //隐藏共面棱边
    end;

  setLength(LocaVct[ID],N*2+2); //用于线状变换图像
  j:=-1;
  for i:=0 to N do if not Obj[ID+i+1].Lock then begin
    inc(j);
    LocaVct[ID,j*2  ]:= Obj[ID+i+1].p0;
    LocaVct[ID,j*2+1]:= Obj[ID+i+1].p1;
    end;
  setLength(LocaVct[ID],j*2+2);

  N:=0;
  for i:= 0 to nEdge do if(Edge[i].d>=0)then inc(N); //N 三角形面数
  setLength(FaceVct[ID], N*3+1);
  for i:= 0 to N*3 do setLength(FaceVct[ID,i],2);
  j:=0;
  for i:= 0 to nEdge do  //表面
    if(Edge[i].d>=0)then with Edge[i]do begin
      FaceVct[ID,j,0]:=Vct[a];  FaceVct[ID,j,1]:=Vct[a];  inc(j);
      FaceVct[ID,j,0]:=Vct[a];  FaceVct[ID,j,1]:=Vct[b];  inc(j);
      FaceVct[ID,j,0]:=Vct[d];  FaceVct[ID,j,1]:=Vct[d];  inc(j);
      end;
  if Obj[ID].Mask then begin //遮罩 所有的凸点均向凸壳中心位移
    N:=0; x:=0; y:=0; z:=0;
    for i:=0 to M do if(Vct[i].w>0)then begin
      x:=x+ Vct[i].x; y:=y+Vct[i].y; z:=z+Vct[i].z; inc(N);
      end;
    Obj[ID].p2:=cgVector(x/N, y/N, z/N);//凸壳形心
    end;
end;
//==================== 三维实体的遮罩 ======================
procedure TfrmMain.SolidMask( ID:integer; pc:TcgVector);//pc 实体的中心点
  var i,j,k,M,N :integer;       t :single;
      pn:TcgVector;
      BackVct:array of array of TcgVector;
begin
  M:=High(FaceVct[ID]);   setLength(BackVct, M+1);
  N:=High(FaceVct[ID,0]); for i:=0 to M do setLength(BackVct[i], N+1);
  for j:=0 to M do for i:=0 to N do BackVct[j,i]:=FaceVct[ID,j,i];  //备份
  if(pers<=2)then t:=0.5 else t:=0.12; //  with Obj[ID+1]do t:=(L-W/50)/L;
  with Obj[ID] do begin
  if(Obj[parent].Mode in[1,2,6])and(Color.A<1)and F then t:=0.05;
  pc:=cgVector(0,0,0);   k:=0;
  for j:=0 to M do for i:=0 to N do begin
    cgTranslate(pc,FaceVct[ID,j,i]);  inc(k);
    end;
  if(k=0)then k:=1;   pc:=cgVecScale(pc, 1/k); //形心
  for j:=0 to M do for i:=0 to N do begin
    pn:=cgNormalVec( FaceVct[ID,j,i], pc);
    FaceVct[ID,j,i]:= cgVecAddMult( pc, pn, pn.w- t);
    end;
  glNewList( maskList, GL_COMPILE);//遮罩开始 ID+4000
    if(Obj[parent].Mode in[1..6,15])then SolidDraw( ID, false, false, false);
  glEndList; //遮罩结束
  for j:=0 to M do for i:=0 to N do FaceVct[ID,j,i]:=BackVct[j,i];  //恢复
  setLength(BackVct, 0);
  glDisable(GL_LIGHTING);
  glNewList( stipList, GL_COMPILE);//虚线开始 ID+5000
    if(Obj[parent].Mode in[1..6,15])then SolidDraw( ID, false, true, true);
  glEndList;//虚线结束
  end; //with
end;
//==================== 6 三维实体 ======================
procedure TfrmMain.Solid(  ID:integer; bDraw,bList,bMask,bLine:boolean);//实体
  var i,j,a,b,c,dd,e, M,N :integer;  CC:TcgColorF;  bb:boolean;
begin //  Lst.Clear;
  with Obj[ID] do begin
  a:=Link[0]; b:=Link[1]; c:=Link[2]; dd:=Link[3]; e:=Link[4];
  hide:=Obj[a].hide or Obj[b].hide or(c>0)and(Obj[c].hide)
      or(dd>0)and(Obj[dd].hide) or(e>0)and(Obj[e].hide);
  if hide then exit;
  case Mode of
    1,6,15:Sphere(ID,bDraw,bList); // 球体
    2:Cone(  ID,bDraw,bList); // 圆台
    3:Cubes( ID,bDraw,bList,bLine);  //正多面体
    4:if(S=0)then CustomTable( ID,bDraw,bList,bLine)  //凸棱台
             else Table( ID,bDraw,bList,bLine);  //正棱台
    5:Polyhedron(  ID,bDraw,bList,bLine);  //凸壳
    7..12,16,20:begin //变换 20三视图
      M:=high(FaceVct[a]);   // if(Obj[parent].Mode=5)then dec(M);
      N:=high(FaceVct[a,0]);  if(Obj[parent].Mode=4)then S:=Obj[a].S;
      setLength(FaceVct[ID],M+1); for j:=0 to M do setLength(FaceVct[ID,j],N+1);
      p0:=transVec(ID, Obj[a].p0);
      p1:=transVec(ID, Obj[a].p1);
      p2:=cgVecMid(p0,p1);
      if(Obj[parent].Mode=2)then p4:=transVec(ID, Obj[a].p4);//用于圆台计算侧面法线
      for j:=0 to M do
        for i:=0 to N do FaceVct[ID,j,i]:=transVec(ID, FaceVct[a,j,i]);
      if(Obj[parent].Mode=5)then begin //凸壳
        M:=high(LocaVct[a]);  setLength(LocaVct[ID],M+1);
        for i:=0 to M do LocaVct[ID,i]:=transVec(ID, LocaVct[a,i]);
        end;
      end;
    14:TransCustom(ID); //自定义变换
    end;//case
  if not bDraw or Hide then exit;

  if bList then begin
    getListID(mainList,1);  getListID(wireList,1);
    getListID(maskList,1);  getListID(stipList,1);
    getListID(seleList,1);
    glNewList( mainList, GL_COMPILE);
    if(Mode=7)and(Obj[parent].Mode in[3,4])and D then DrawProjecteLines(ID);  //D:投影线
    end;
  SolidDraw(ID, false, not F, false);
  if bList then glEndList; //mainList end.
  if bList then begin
    if(Mode in[1,6,15])then
      SolidMask(ID,p2); //球体遮罩
    glNewList( seleList, GL_COMPILE); //选择状态 ID+9000
      SolidDraw(ID, true, true, false);
    glEndList;
    if bMask and Mask then
      SolidMask(ID,p2) //虚线遮罩
    else
      if(Mode in[7..14,16])and(Obj[parent].Mode in[3..6])and F and D then;//or(Mode=4)and(S>100)then //
      begin
        glNewList( wireList, GL_COMPILE);//填充状态下的实线边框 ID+5000
          SolidDraw(ID, false, true, false);
        glEndList;
        end;
    end;
  end;//with
end;
//================= 13 迭代 =======================
procedure TfrmMain.Iterate(  ID: integer; bDraw,bList:boolean);
  var aNum :array of integer;//每层迭代的映像数
      aObj :array of array of TIterate;//每层迭代的母像
      bObj :array of TIterate;
      aDot :array of TcgVector;//终像点集
      i,j,k, M,N, ss :integer;  isPlaneByTexture:boolean;
      He,Wi,Se, pageID, DotNum, maxDot :integer; //He原象数 Wi初象数 Se迭代深度
      cc:TcgColorF;
      bLast :boolean;
      BackObje :TObjType;   BackLoca :TLocaType;
      BackFace :TFaceType;  BackLink :TLinkType;
      BackLocaC:TLocaColor; BackFaceC:TFaceColor;
      BackIter :TIterateRule;
  label 10,20,30,40;
  procedure getSelCorner(Dot:TcgVector; var pTR,pBL:TcgVector); //迭代像包围框
    begin with Dot do begin
      if x<pBL.x then pBL.x:=x;   if x>pTR.x then pTR.x:=x;
      if y<pBL.y then pBL.y:=y;   if y>pTR.y then pTR.y:=y;
      if z<pBL.z then pBL.z:=z;   if z>pTR.z then pTR.z:=z;
      end;
    end; // ; var pTL,pBR:TcgVector
  function Draw(iID, jj:integer; bDraw:boolean; var TR,BL :TcgVector):integer; //bLast终像层
    var i,j,k,b,mM,nN :integer;  bb:boolean;  aR:single;
  begin
    result:=0; mM:=0; nN:=0;
    for i:=0 to He do with Obj[objArray[i,0]] do begin
      if(Kind=1)then F:=(Mode<3);
      if(Kind=11)and(Mode<>2)then U:=true; //不再计算了
      bObj[i].p0:= Obj[ objArray[i,jj] ].p0; //缓存原象，避免循环赋值
      bObj[i].L := Obj[ objArray[i,jj] ].L;
      end;
    for i:=0 to He do begin
      Obj[objArray[i,0]].p0:= bObj[i].p0;  //用缓存数据赋值
      Obj[objArray[i,0]].L := bObj[i].L;
      end;
    for i:= N to iID-1 do with Obj[i] do if delID=0 then begin
      bb:=ObjShow[pageID] and bDraw; // 当前页面中影藏的构件不参与迭代
      case Kind of
        1:begin  // 点
          b:=Link[1];
          if(Obj[ID].Rand)and(Mode=2)and(Obj[b].Kind in[2,3])then begin //Obj[ID].U随机
            L:= Random(100)/100;
            if(Obj[b].Kind=2)then begin //受约于直线
              p0:=cgVecAddMult( Obj[b].p0, Obj[b].Vec, L*Obj[b].L);
              end;
            if(Obj[b].Kind=3)then
              case Obj[b].Mode of
              1,2,6,8,9,10,11:begin //受约于圆
                L:= Random(628)/100;
                p0:=DotInCircle( Obj[b].p0, b, L, Obj[b].L, Obj[b].H, Obj[b].R ); //沿[点法圆] [三点圆]
                end;
              3:begin //受约于点法弧
                aR:= IIFf(D, L/Obj[b].L, L*Obj[b].H/IIFf(Obj[b].D, Obj[b].L, 1));
                if(Obj[b].U)then aR:= towPi-aR; //反向圆弧上的点
                p0:= DotInCircle( Obj[b].p0, b, Obj[b].R+aR, Obj[b].L, 0,0);  //延[点法弧]
                end;
              4:begin //受约于三点弧
                aR:= IIFf(D, L/Obj[b].L, L*Obj[b].H);
                p0:= DotInCircle( Obj[b].p0, b, Obj[b].R+aR, Obj[b].L, 0,0);  //延[三点弧]
                end;
              end; //case  and bDraw
            if Obj[ID].F and bb then begin // Obj[ID].F 显示点对象
              glPointSize(Obj[i].W);  glColor3fv(@Obj[i].color);
              if(Obj[i].S=0)then begin glBegin(GL_POINTS); glVertex3fv(@p0); glEnd; end
                            else SolidPoint( Obj[i].p0, Obj[i].Mode,Obj[i].S,Obj[i].W, false);
              end;
            end
          else begin
            if not(F and(Mode<3))then //F双向
              Pointe( i, bb and Obj[ID].F and not((Kind=1)and(Mode=13)and(not Obj[parent].U)), false,false);//  Obj[ID].F 在迭代象中显示点对象
            if(Mode<3)and(Obj[ID].F)and bb then begin
              glPointSize(Obj[i].W);  glColor3fv(@Obj[i].color);
              if(Obj[i].S=0)then begin glBegin(GL_POINTS); glVertex3fv(@p0); glEnd; end
                            else SolidPoint( Obj[i].p0, Obj[i].Mode,Obj[i].S,Obj[i].W, false);
              end;
            end;
          if Obj[ID].F and bb then begin //Obj[ID].F 显示点对象
            aDot[DotNum]:=p0; inc(DotNum);
            if(DotNum>=maxDot)then begin inc(maxDot,1000); setLength(aDot,maxDot); end;
            end;
          if(DotNum=0)then aDot[0]:=p0;
          mM:=1;
          end;
        2:begin Lineer( i, (Mode=13)and bDraw and Obj[Link[0]].ObjShow[pageID]
                   and(not Obj[Link[0]].F or Obj[Link[0]].D)
                   or (Mode<13)and bb ,false,false);     //直线
          mM:=2;
          end;
        3:mM:=CircleDraw( i,bb,false,true,false);   // 圆
        4:mM:=Plane( i,bb,false);    //平面
        5:mM:=Locus( i,true,false,false,false); //轨迹线
        6:begin
          if(Mode in[3,4])then Solid( i, bb and F,false,false,true)//实体
                          else Solid( i, bb,false,false,true);
          mM:=high(FaceVct[i]); nN:=high(FaceVct[i,0]);
          end;
        7:begin Face( i,bb,false,false); //曲面
          mM:=high(FaceVct[i]); nN:=high(FaceVct[i,0]);
          end;
        9:if(Mode=13)or(Obj[parent].Mode=13)
          then ImplicitFace( i, true,false,false)//隐函数曲面
          else funcFace( i, true,false,false);   //显函数曲面
       10:if Way then TextToBMP(i, Obj[i].info[2], false);
       11:if Way then //Way 生成纹理
            TextAndImage( i, true, true,true,false)
          else begin
            if(Mode=1)then calcFunc( i, res, false,false); //计算式
            if(Mode>2)then res:=calcSize( i); //度量
            if(Mode<>2)then L:=res;           //参数
            end;
       13:Iterate( i,true,false);           //迭代
       15:mM:=CrossLine( i, bb,false,false); //相贯线
       16:mM:=funcCurve( i, bb,false,false); //函数曲线
       17:if(Mode=1)then mM:=Path( i,bb,false,false);       //路径
       18:Marker( i,false,false,false);     //标注
       19:Conic( i,true,false,false);      //圆锥曲线
        end;
      if bb and(mM>0)then  //迭代像包围框
        case Kind of
        1:if(Obj[ID].F)then getSelCorner(p0, TR,BL);
        2:begin getSelCorner(p0, TR,BL); getSelCorner(p1, TR,BL); end;
        3,4,5,15,16,17: for j:=0 to mM do getSelCorner(LocaVct[i,j], TR,BL);
        13:begin
          getSelCorner(Obj[i].pBL, TR,BL);  getSelCorner(Obj[i].pTR, TR,BL);
          end;
        6,7:begin
          for j:=0 to mM do for k:=0 to nN do getSelCorner(FaceVct[i,j,k], TR,BL);
          end;
        end;
      end; //for i ... with Obj[i]
      result:=mM;
    end;
begin // Lst.Clear;
  BackIter:=objArray;  //备份迭代规则 用于复合迭代
  with Obj[ID] do begin
    pTR:=cgVector(-100,-100,-100);
    pBL:=cgVector( 100, 100, 100);
    He:=trunc(H); Wi:=trunc(W);  bLast:=D;//He原象数 Wi初象数 D终像
    RandSeed:= trunc(R);
    pageID:=trunc(L);//生成迭代时的所在页面
    if Link[0]>0 then S:=trunc(Obj[Link[0]].L); //迭代次数
    getListID(mainList,1); getListID(seleList,1);
    if S<1 then begin //迭代次数小于0则退出
      glNewList( mainList, GL_COMPILE); glEndList;
      exit;
      end;
    k:=0; Se:=S; N:=1000; //Se深度 N排列最前的对象序号
    for i:= 0 to He do for j:=0 to Wi do begin
      inc(k);   objArray[i,j]:=Link[k]; //读入迭代规则
      if(Link[k]<11)or(Link[k]>ID-1)then begin //坐标原点不能迭代
        MyMessage( SwitchS( iLanguage,' 迭代规则错误！ ', ' 疊代規則錯誤！ ',' Iterative rule errors! ',''));
        exit;
        end;
      if objArray[i,j]<N then N:=objArray[i,j]; //寻找序号最小的构件，该构件之前的构件不参与迭代
      end;
    end;//with Obj[ID]
  maxDot:=1000;
  setLength(aDot,maxDot); //迭代像中的可视点数
  SysBackup(ID, BackObje,BackLoca,BackFace,BackLink,BackLocaC,BackFaceC, true);//数据备份
  with Obj[ID]do begin
    for i:=N to ID-1 do if(Obj[i].DelID=0) then Obj[i].DelID:=ID; //当前存在的对象均视为删除
    for i:=1 to k do if(Obj[Link[i]].DelID=ID) then Obj[Link[i]].DelID:=0; //恢复初象
    for i:=N to ID-1 do if(Obj[i].DelID=ID) then with Obj[i]do begin //恢复与初象有关的对象
      j:=-1; repeat j:=j+1; until(j>LinkTime)or(Link[j]>10)and(Obj[Link[j]].DelID=0);
      if(j<=LinkTime)then Obj[i].DelID:=0;
      end;
    if U then begin //颜色 参数对象ID保存在p4,p5中(是为兼容而不改变原有数据结构)
      Vec.x:=Link[6]; Vec.y:=Link[7]; Vec.z:=Link[8];
      Link[6]:= trunc( p4.x); Link[7]:= trunc( p4.y); Link[8]:= trunc(p4.z); //颜色参数
      cc:=Color;
      end;
    end;
  for i:=N To ID-1 do with Obj[i]do begin //查找有没有平面使用数值纹理
    k:=Link[10];
    if(Kind=4)and(k>10)and((Obj[k].Kind=11)and(Obj[k].Mode<>2)or(Obj[k].Kind=10)and(Obj[k].Mode=1))then begin
      Obj[k].Way:= D or(Obj[k].Kind=10); //D平面贴图 Way需要刷新纹理的标记
      glGenTextures(1, Obj[k].texID);//
      end;
    end;
  for i:= 0 to He do with Obj[objArray[i,0]] do begin //He原象数 Wi初象数
    if(Kind=11)and(Mode=1)then Mode:=2;//若原象为计算式，则视为参数
    if(Kind= 1)and(Mode>1)then Mode:=1;
    end;
  if Wi>0 then begin
    setLength(aObj, Se+1);  for i:= 0 to Se do setLength( aObj[i], ID+1);//Se迭代深度
    setLength(bObj, ID+1);  //备份
    end;
  setLength(aNum, Se+1);
//  Screen.cursor:=crHourGlass;
  //    Caption:=trim(caption); //奇了怪了，非得重写标题栏，否则有时会慢如蜗牛
  Randomize; //随机种子
  ss:=0;  DotNum:=0;
  if bList then glNewList( Obj[ID].mainList, GL_COMPILE); //建立显示列表
  10: inc(ss);  aNum[ss]:=0;
      if(Wi>1)then for i:=N to ID-1 do
        begin aObj[ss,i].p0:=Obj[i].p0;  aObj[ss,i].L:=Obj[i].L;  end;
      goto 30;
  20: dec(ss);
  30: inc(aNum[ss]);
      if aNum[1]>Wi then goto 40; //结束
      if aNum[ss]>Wi then goto 20;
      if(Wi>1)and(aNum[ss]>1)then
        for i:=N to ID-1 do //恢复上一个迭代
          begin Obj[i].p0:=aObj[ss,i].p0;  Obj[i].L:=aObj[ss,i].L; end;
      with Obj[ID]do if U then begin //按深度着色，使用统一设置的颜色
        if Se=0 then cc:=cgColorF( 0,0,0, 0)
                else cc:=setMultiColor(ID, ss/Se*255,255, Color.A); //设置眩彩
        For i:= N to ID-1 do Obj[i].color:=cc;
        end;
      Draw(ID,aNum[ss], not(bLast and(ss<Se)), Obj[ID].pTR,Obj[ID].pBL); //@@@@@@@@ 迭代像 @@@@@@@@@@
      if ss<Se then goto 10 else goto 30;
  40:
  if bList then glEndList;    //
  Obj[ID].p1:=aDot[0];
  with Obj[ID] do if U then begin //颜色 参数对象ID保存在p4,p5中(是为兼容而不改变原有数据结构)
    Link[6]:= trunc( Vec.x); Link[7]:= trunc( Vec.y); Link[8]:= trunc(Vec.z); //恢复
    end;
  SysBackup(ID, BackObje,BackLoca,BackFace,BackLink,BackLocaC,BackFaceC, false);//数据恢复
  if bList then with Obj[ID]do begin
    glNewList( seleList, GL_COMPILE); //选择状态 迭代像包围框 ID+9000
    glDisable(GL_LIGHTING);
    glLineWidth(1);  glColor4fv(@Obj[1].ColorB); //  glColor4f(1,0,0,1); //
    glPolygonMode( GL_FRONT_AND_BACK, GL_LINE );
    glBegin( GL_QUAD_STRIP);//glBegin(GL_LINE_STRIP);//
      glVertex3f(pTR.x,pTR.y,pTR.z);  glVertex3f(pTR.x,pTR.y,pBL.z);
      glVertex3f(pBL.x,pTR.y,pTR.z);  glVertex3f(pBL.x,pTR.y,pBL.z);
      glVertex3f(pBL.x,pBL.y,pTR.z);  glVertex3f(pBL.x,pBL.y,pBL.z);
      glVertex3f(pTR.x,pBL.y,pTR.z);  glVertex3f(pTR.x,pBL.y,pBL.z);
      glVertex3f(pTR.x,pTR.y,pTR.z);  glVertex3f(pTR.x,pTR.y,pBL.z);
    glEnd;
    glEndList;    //
    end;
  if(DotNum=0)then M:=1 else M:=DotNum;
  setLength( LocaVct[ID], M);  for j:=0 to M-1 do LocaVct[ID,M-j-1]:=aDot[j];//迭代产生的点集供后续约束点使用
  setLength( aDot, 0);  setLength( aObj, 0);  setLength( bObj, 0);
  objArray:=BackIter; //恢复迭代规则 用于复合迭代
//  Screen.cursor:=crDefault;
end;
procedure TfrmMain.cheRandMouseUp(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
  with Obj[MarkObj] do begin
    D:=cheLast.Checked;     cheMask.Checked:=D;     //终象
    F:=cheDot.Checked;      cheSolid.Checked:=F;    //含点
    Rand:=cheRand.Checked;  cheColor.Checked:=Rand; //随机
    butRand.Enabled:=not bAdd and U;
    end;
  if not bAdd then Iterate( MarkObj,true,true);
end;
//================== 以上代码有关“迭代”==================

//======================= 8 自由块 ========================
{procedure TfrmMain.Block( ID:integer; BlockFile:string);
  var BlockCount, i,j,M :integer;
      bShow :bool;
      BackObje :TObjType;   BackLoca :TLocaType;
      BackFace :TFaceType;  BackLink :TLinkType;
begin
  if not FileExists(BlockFile) then begin
    Showmessage( '当前目录下未找到文件“'+ BlockFile +'”。'+chr(13)
       +chr(13)+ '块文件必须和模型文件位于同一目录。');
    exit;
    end;
  setLength( BackObje, ObjCount+1); setLength( BackLoca, ObjCount+1);
  setLength( BackFace, ObjCount+1); setLength( BackLink, ObjCount+1);
  for i:=0 to ObjCount do begin //备份数据
    BackObje[i]:= Obj[i];  //备份全部构件
    M:=high(FaceVct[i]);
    if M>0 then begin //备份曲面顶点
      setLength(BackFace[i], M+1);  for j:=0 to M do BackFace[i,j]:=FaceVct[i,j];
      end;
    M:=high(LocaVct[i]);
    if M>0 then begin //备份构件顶点
      setLength(BackLoca[i], M+1);  for j:=0 to M do BackLoca[i,j]:=LocaVct[i,j];
      end;
    M:=high(BackLink[i]);
    if M>0 then begin //备份顶点状态
      setLength(BackLink[i], M+1);  for j:=0 to M do BackLink[i,j]:=aLink[i,j];
      end;
    end;
  BlockCount:= OpenFile( BlockFile, false,false);
  setMem( BlockCount+1, false);
  glNewList( ID, GL_COMPILE);
  for i:= 11 to BlockCount do
    with Obj[i] do begin
    bShow:= ObjShow[Obj[1].S];  //页面数
    case Kind of
      1:Pointe( i, bShow, false,false);    // 点
      2:if(Mode=13)then begin // 棱边
          glColor4Fv( @color); glLineWidth( w);
          glBegin(GL_LINES); glVertex3Fv(@p0); glVertex3Fv(@p1); glEnd;
          end
        else Lineer( i, bShow, false,false);//直线
      3:CircleDraw( i, bShow, false,true,false); // 圆
      4:Plane( i ,bShow, false);          //平面
      5:Locus( i, bShow, false,false,false);    //轨迹
      6:Solid(i,bShow and(not((Obj[parent].Mode in[3,4])and not F)), false,false, not F);
      7:Face(i,bShow,false,false);
      9:if bShow then funcFace(  i, false,false,false);
     11:begin
        if Mode=1 then calcFunc(  i, res, false,false); //计算式
        if Mode>2 then res:=calcSize( i); //度量
        if Mode<>2 then L:=res;           //参数
        end;
     15:CrossLine( i, bShow,false,false); //相贯线
     16:FuncCurve(i,bShow,false,false);   //函数曲线
     17:Path( i, bShow, false,false);     //路径
    end; // case
    end; //with
  glEndList;
  for i:= 0 to ObjCount do begin //恢复数据
    Obj[i]:=BackObje[i]; //恢复场景
    M:=high(FaceVct[i]);
    if M>0 then begin //备份曲面顶点
      setLength(BackFace[i], M+1);  for j:=0 to M do BackFace[i,j]:=FaceVct[i,j];
      end;
    M:=high(BackLoca[i]);
    if M>0 then begin //恢复构件顶点
      setLength(LocaVct[i], M+1); for j:=0 to M do LocaVct[i,j]:=BackLoca[i,j];
      end;
    M:=high(BackLink[i]);
    if M>0 then begin //恢复顶点状态
      setLength(aLink[i], M+1);   for j:=0 to M do aLink[i,j]:=BackLink[i,j];
      end;
    end;
  setLength( BackObje, 0);  setLength( BackLoca, 0);
  setLength( BackFace, 0);  setLength( BackLink, 0);
end;
}
//####################### 计算网格顶点坐标值 ##################################
procedure TfrmMain.getExpressData(ID:integer; expr :string; k, xStep,yStep :integer);
  var i,j :integer;  Expression1 :TExpress;
      rr, dx,dy, a,b,c, x,y,z :single; b0:boolean;
begin
  Expression1 := TExpress.create(self);
  with Obj[ID] do begin
    if(Link[ 7]>0)then p1.x:=Obj[Link[ 7]].L;
    if(Link[ 8]>0)then p1.y:=Obj[Link[ 8]].L;
    if(Link[ 9]>0)then p2.x:=Obj[Link[ 9]].L;
    if(Link[10]>0)then p2.y:=Obj[Link[10]].L;
    dx:=(p1.y-p1.x)/xStep;
    dy:=(p2.y-p2.x)/(yStep-1);
    IF(Link[0]>0)then a:=Obj[Link[0]].L else a:=p3.x;
    IF(Link[1]>0)then b:=Obj[Link[1]].L else b:=p3.y;
    IF(Link[2]>0)then c:=Obj[Link[2]].L else c:=p3.z;
    IF(Link[3]>0)then x:=Obj[Link[3]].L else x:=p4.x;
    IF(Link[4]>0)then y:=Obj[Link[4]].L else y:=p4.y;
    IF(Link[5]>0)then z:=Obj[Link[5]].L else z:=p4.z;
    try
    Expression1.Expression := expr; //表达式
    Expression1.SetParameters( a,b,c, x,y,z, a,b,c, 0,0,0, 0,0,0, 0,0,0); //设置参数a,b,c,d,e,f
    for i:= 0 to xStep do begin  //z=f(x,y)直角坐标
      x:=p1.x+ i*dx;   
      for j:= 0 to yStep do begin
        y:=p2.x+ j*dy;  FaceVct[ID,i,j].w:=0;
        rr:=Expression1.TheFunction( x,y,0, b0); //变量 b0是返回值,必须是变量
        if(pars.Null or pars.Infi)then
          FaceVct[ID,i,j].w:=-1
        else
          case Mode of
            1:FaceVct[ID,i,j]:=cgVector(x,y,rr);
            3:if(Kind=9) //函数曲面
              then FaceVct[ID,i,j]:=cgVector(rr*sin(y)*cos(x), rr*sin(y)*sin(x), rr*cos(y))
              else FaceVct[ID,i,j]:=cgVector(rr*cos(x), rr*sin(x), 0);
            5:FaceVct[ID,i,j]:=cgVector(y*cos(x), y*sin(x), rr);
            2,4,6:case k of
              0:FaceVct[ID,i,j].x:=rr; 1:FaceVct[ID,i,j].y:=rr; 2:FaceVct[ID,i,j].z:=rr;
              end;
            end; //case
        end; //for j
      end;// for i
    except
      on E:Exception do messageDlg(E.Message,mtError,[mbOk],0);
    end;
  end; // with
  Expression1.Free;
end;
//===================== 隐函数曲线 ======================
function Intert( C1,C2 :TcgVector):TcgVector; //在两点之间插入等值点
  var mu : single;
begin
  if EP(C1.W-C2.W)then Result := C1
  else begin
    mu := C1.W/(C1.W-C2.W);
    Result.x:=C1.x+(C2.x-C1.x)*mu;
    Result.y:=C1.y+(C2.y-C1.y)*mu;
    Result.z:=C1.z+(C2.z-C1.z)*mu;
    end;
  end;
function TfrmMain.ImplicitCurve(  ID: integer; bDraw,bList,bOnlyDraw:boolean):integer;
  type TCube =Array [0..3] of ^TcgVector; // Points to 4 grid points
  const
    MaxVct=12040;//最大点数
    EdgeTab:array[0..15]of integer=($0,$9,$3,$a,$6,$f,$5,$c, $c,$5,$f,$6,$a,$3,$9,$0);
    LineTab:array[0..15,0..4]of integer=
     ((-1,-1,-1,-1,-1),( 0, 3,-1,-1,-1),( 0, 1,-1,-1,-1),( 1, 3,-1,-1,-1),
      ( 1, 2,-1,-1,-1),( 0, 1, 2, 3,-1),( 0, 2,-1,-1,-1),( 2, 3,-1,-1,-1),
      ( 2, 3,-1,-1,-1),( 0, 2,-1,-1,-1),( 0, 3, 1, 2,-1),( 1, 2,-1,-1,-1),
      ( 1, 3,-1,-1,-1),( 0, 1,-1,-1,-1),( 0, 3,-1,-1,-1),(-1,-1,-1,-1,-1));
    Mask  :array[0..3]of integer=(1,2,4,8);
    EdgeVct :array[0..1,0..3]of byte=((0,1,2,3),(1,2,3,0));
    dx :array[0..1,0..3]of byte=((0,1,1,0),(0,0,1,1));
  var i,j,k,N, cx,cy, xStep,yStep,Step2 :integer;//k顶点数
    CubeX,CubeY, a,b,c, x,y,z, r0,r1,rc,temp, Tx,Ry :single;
    y0,y1,yc :double;
    Grid:Array of Array of TcgVector;
    Cube:Array of Array of TCube;
    Vct :Array of TcgVector;   pa,pb,pc, pp,px,py, pn :TcgVector;
    vList :array[0..3]of TcgVector; //等值点
    expr :string;
    Express :TExpress;    b0,bb :boolean;
  label isHide;
  procedure GetCubeLines(out Cube :TCube; var N:integer); //分析体素 返回线段数
    var i, Index, Pos : Integer;
  begin
    Index:=0;
    for i:=0 to 3 do if Cube[i]^.W<=0 then Index:=Index or Mask[i];//遍历四个顶点
    if edgeTab[Index] = 0 then Exit; //是否含有等值点？

    for i:=0 to 3 do //在体素棱边的端点之间插入等值点
      if(EdgeTab[Index] and Mask[i])<>0 then
        vList[i]:=Intert( Cube[EdgeVct[0,i]]^, Cube[EdgeVct[1,i]]^); //插入等值点
    i:=0;  pos:=LineTab[ Index, i]; //画出线段
    while(pos>-1)do begin
      inc(N);  Vct[N]:=vList[pos];  //保存顶点
      inc(i);  pos:=LineTab[ Index, i];
      end; //while
  end;
begin
  with Obj[ID] do begin
    xStep:=trunc(p1.z);  yStep:=trunc(p2.z);
    if(Link[ 7]>0)then p1.x:=Obj[Link[ 7]].L;
    if(Link[ 8]>0)then p1.y:=Obj[Link[ 8]].L;
    if(Link[ 9]>0)then p2.x:=Obj[Link[ 9]].L;
    if(Link[10]>0)then p2.y:=Obj[Link[10]].L;
    if(Link[0]>0)then a:=Obj[Link[0]].L else a:=p3.x;
    if(Link[1]>0)then b:=Obj[Link[1]].L else b:=p3.y;
    if(Link[2]>0)then c:=Obj[Link[2]].L else c:=p3.z;
    if(Link[3]>0)then x:=Obj[Link[3]].L else x:=p4.x;
    if(Link[4]>0)then y:=Obj[Link[4]].L else y:=p4.y;
    if(Link[5]>0)then z:=Obj[Link[5]].L else z:=p4.z;
    CubeX:=(p1.y-p1.x)/xStep;
    CubeY:=(p2.y-p2.x)/yStep;
  Express:= TExpress.create(self);
  try
    expr:=info[2]; if(Mode=6)then expr:='#5'+expr;
    Express.Expression :=expr; //表达式
    Express.SetParameters( a,b,c, x,y,z, a,b,c, 1,1,1,1,1,1,1,1,1); //设置参数a,b,c,d,e,f
    if(Mode=5)then begin //直角坐标系
      SetLength(Grid, yStep+1); for i:=0 to yStep do setLength(Grid[i], xStep+1);
      SetLength(Cube, yStep+1); for i:=0 to yStep do setLength(Cube[i], xStep+1);
      for cY:= 0 to yStep do
        for cX:= 0 to xStep do with Grid[cY,cX] do begin
          X:=p1.x+ cX*CubeX;   Y:=p2.x+ cY*CubeY;   Z:=0;
          r0:=Express.TheFunction( X,Y,Z, b0);
          W:=r0; if EP(W)then W:=0;
          end;
      end;
    if(Mode=6)then begin //极坐标系
      Step2:=xStep*2; CubeY:=CubeX;
      SetLength(Grid, Step2+1); for i:=0 to Step2 do setLength(Grid[i], Step2+1);
      SetLength(Cube, Step2+1); for i:=0 to Step2 do setLength(Cube[i], Step2+1);
      for cY:= 0 to Step2 do
        for cX:= 0 to Step2 do with Grid[cY,cX] do begin
          X:=(cX-xStep)*CubeX;   Y:=(cY-xStep)*CubeY;  Z:=0;
          cgXYZtoAngle(X,Y,Z, Tx,Tx,Ry, false); //网格点转换为极坐标 Tx角度 Ry半径
          r0:=Express.TheFunction( Tx,Ry,Z, b0);
          W:=r0; if EP(W)then W:=0;
          end;
      end;
  except
      on E:Exception do messageDlg(E.Message,mtError,[mbOk],0);
  end;
  Express.Free;
  if(Mode=6)then begin xStep:=xStep*2; yStep:=xStep; end;
  N:=(xStep+1)*(yStep+1);  setLength(Vct, N*2+1);
  N:=-1;
  for cY:= 0 to yStep-1 do
    for cX:= 0 to xStep-1 do begin
      for j:= 0 to 3 do Cube[cY,cX][j] := @Grid[cY+dX[1,j], cX+dX[0,j] ]; //为每个体素的四个网格点编号
      GetCubeLines( Cube[cY,cX], N);//分析体素
      end;
  hide:=N<1; if hide then goto isHide;
  N:=N div 2;               //中油大庆 订单 沪201011000717 100t 70t 40t    021-6550314
  cgSetPrecision(0.0001);
  j:=0; cx:=0; cy:=1;
  while(j<N)do begin //把距离最近的顶点连接起来
    inc(j);  bb:=false;
    for i:=j to N do begin
      pa:=Vct[i*2]; pb:=Vct[i*2+1];
      if cgVecComp(Vct[cy],pa) or cgVecComp(Vct[cy],pb)then begin
        Vct[i*2]:=Vct[j*2];  Vct[i*2+1]:=Vct[j*2+1];
        if cgVecComp(Vct[cy],pa)then cgVecSwap(pa,pb);
        inc(cy); Vct[cy]:=pa;  bb:=true;
        end;
      if bb then break;
      if cgVecComp(Vct[cx], pa) or cgVecComp(Vct[cx], pb)then begin
        Vct[i*2]:=Vct[j*2];  Vct[i*2+1]:=Vct[j*2+1];
        if cgVecComp(Vct[cx],pb)then cgVecSwap(pa,pb);
        for k:=cy downto cx do Vct[k+1]:=Vct[k];
        inc(cy); Vct[cx]:=pb;  bb:=true;
        end;
      if bb then break;
      end;
    if(j<N)and not bb then begin
      cx:=cy+1;    Vct[cx]:=Vct[j*2];
      cy:=cx+1;    Vct[cy]:=Vct[j*2+1];
      end;
    end; // while
  cgSetPrecision(0.00001);
  N:=cy;

{  for i:=0 to N-1 do begin //把距离最近的顶点连接起来
    b:=cgDistance(Vct[i],Vct[i+1]);
    for j:=i+1 to k do  begin
      a:=cgDistance(Vct[i],Vct[j]);
      if a<b then begin b:=a; cgVecSwap(Vct[i+1],Vct[j]); end;
      end;
    end; }
  if D then begin inc(N);  setLength(Vct,N+1);  Vct[N]:=Vct[0]; end; //首尾相连
  end; // with
  setLength(LocaVct[ID], N+1); for i:= 0 to N do LocaVct[ID,i]:=Vct[i];
  setLength(  aLink[ID], N+1); for i:= 0 to N do aLink[ID,i]:=true;
isHide:
  result:=N;
  setLength(Grid, 0); setLength(Cube, 0); setLength(Vct, 0);
end;
//===================== 16 函数曲线 ======================
function TfrmMain.funcCurve(  ID: integer; bDraw,bList,bOnlyDraw:boolean):integer;//############
  var i, M,listID :integer;
      pn :TcgVector;
      bb :array[0..2]of boolean;
      aa :array[0..2]of single;
      Expression :TExpress;  b0:boolean;
  label drawCopy, onlyDraw;
begin
  M:=0; result:=0; //caption :=caption;
  if bOnlyDraw then goto OnlyDraw; //复制轨迹
  with Obj[ID] do begin
  if(Mode>6)then goto drawCopy; //复制曲线
  if(Mode in[5,6])then begin //隐函数曲线
    M:= ImplicitCurve(  ID, bDraw,bList,bOnlyDraw);
    hide:=M<1; if hide then exit;
    goto DrawCopy;
    end;
  if(Mode in[2,4])then begin  //判断参数方程
    Expression := TExpress.create(self);  //----------------------------------------
    for i:= 0 to 2 do begin  //测试三个表达式的自变量是否均为0
      Expression.Expression := '#4'+info[i]; //----------------------------------------
      aa[i]:= Expression.TheFunction( 0,0,0, b0);
      bb[i]:= aa[i]=Expression.TheFunction( 1,1,0, b0);
      end;
    Expression.Free;
    if bb[0] and bb[1] and bb[2] then begin //三个表达式的自变量均为0
      p0:= cgVector( aa[0],aa[1],aa[2]);
      SetLength( LocaVct[ID], 2);   SetLength( aLink[ID], 2);
      for i:=0 to 1 do aLink[ID,i]:=true; //
      LocaVct[ID,0]:=p0; LocaVct[ID,1]:=cgVector(p0.x+0.1,p0.y+0.1,p0.z+0.1);
      goto OnlyDraw;
      end;
    end;
  M:= trunc(p1.z);   //xStep
  SetLength(FaceVct[ID], M+1); for i:=0 to M do SetLength( FaceVct[ID,i], 1); //
  case Mode of
    1:getExpressData(ID, info[1], 1, M,0);    //y=F(x)
    3:getExpressData(ID, '#4'+info[2], 2, M,0);//r=F(t) $
    2,4:for i:= 0 to 2 do //x,y,z=F(t) 或 r,m,n=F(t) ###################
      getExpressData(ID, '#4'+info[i], i, M,0); // %
    end;//case
  setLength(LocaVct[ID], M+1);  //Lst.Clear;
  setLength(  aLink[ID], M+1);
  for i:= 0 to M do begin
    pn:=FaceVct[ID,i,0];
    aLink[ID,i]:=pn.w>=0;
    case Mode of
      1:LocaVct[ID,i]:=cgVector( pn.x, pn.z, 0);
      3:LocaVct[ID,i]:=cgVector( pn.x, pn.y, 0);
      2:LocaVct[ID,i]:=FaceVct[ID,i,0];
      4:LocaVct[ID,i]:=cgVector
        (cos(pn.x)*sin(pn.y)*pn.z, sin(pn.x)*sin(pn.y)*pn.z, cos(pn.y)*pn.z );
      end;
    end;
  if D then begin inc(M);  setLength(LocaVct[ID],M+1);  LocaVct[ID,M]:=LocaVct[ID,0]; end; //首尾相连
  setLength(FaceVct[ID],0);
drawCopy:  //投影复制、镜像复制、旋转复制
  if(Mode=14)then TransCustom(ID);
  M:= calcLocaLength(ID); //复制轨迹点并计算轨迹点之间距
onlyDraw:
  if bDraw then begin
    M:=high(LocaVct[ID]);
    Hide:=M<1;  if Obj[ID].hide then exit;
    if(Mode<7)and U then //限制在坐标轴范围内
      for i:=0 to M do with LocaVct[ID,i] do
        if(x>trunc(Obj[2].p1.x))or(x<trunc(Obj[2].p0.x))or
          (y>trunc(Obj[3].p1.y))or(y<trunc(Obj[3].p0.y))or
          (z>trunc(Obj[4].p1.z))or(z<trunc(Obj[4].p0.z))
        then aLink[ID,i]:=false;
    listID:=getTraceListID(ID,bAdd);
    DrawCurve(ID,listID,0 ,M,S,0, IIFc( F, GL_LINE_STRIP, GL_POINTS), bList,false);//画曲线
    if not bAdd and bList and Trace then setTraceList(ID);//痕迹
    DrawCurve(ID,ID,4000, M,S,0, GL_LINE_STRIP, bList,false);//画曲线
    p0:= LocaVct[ID][trunc(M*TagP.z)]; //标签位置
    end; //if bDraw
  end; //with
  result:=M;
//  if bAdd then caption:=Obj[ID].TagN;//这行没任何用处，否则第一个构件为曲线时必须按两次回车才显示曲线
end;

procedure TfrmMain.CurveFromFace(ID:integer); //用曲面边缘构造曲线
  var i,j,M,N :integer;
begin
  M:=high(FaceVct[ID]);  N:=high(FaceVct[ID,0]);
  SetLength(LocaVct[ID], (M+N-1)*2+1);  //边缘曲线
    for i:=0 to M   do LocaVct[ID,        i]:=FaceVct[ID,  i,    0];
    for i:=0 to N-1 do LocaVct[ID,M      +i]:=FaceVct[ID,M  ,    i];
    for i:=0 to M   do LocaVct[ID,M+N-1  +i]:=FaceVct[ID,M-i,N-1  ];
    for i:=0 to N-1 do LocaVct[ID,M+M+N-1+i]:=FaceVct[ID,  0,N-1-i];
  SetLength(aLink[ID],(M+N-1)*2+1);
    for i:=0 to (M+N-1)*2 do aLink[ID,i]:=true;
  calcLocaLength(ID); //复制轨迹点并计算轨迹点之间距
end;
//===================== 9 函数曲面 ======================
procedure TfrmMain.funcFace(  ID: integer; bDraw,bList,bOnlyDraw:boolean);//############
  var a,i,j, M,N, nM,nN :integer;    t,ww,hh :single;
      pn :TcgVector;
      nor:Array of TcgVector; //曲面各顶点的法线向量   [0..100]
      bb :array[0..2]of boolean;
      aa :array[0..2]of single;
      Expression :TExpress;   b0, isFace :boolean;
  label onlyDraw;
begin
  with Obj[ID] do begin
  getListID(mainList,1); getListID(seleList,1);
  if(Mode=14)then begin
    TransCustom(ID);
    M:=high(FaceVct[ID]);   N:=high(FaceVct[ID,0]);
    end;
  if(Mode in[7..12,15,16])then begin //复制曲面
    a:=Link[0];
    M:=high(FaceVct[a]);   N:=high(FaceVct[a,0]);
    setLength(FaceVct[ID],M+1);
    for j:= 0 to M do begin
      setLength(FaceVct[ID,j], N+1);
      for i:= 0 to N do FaceVct[ID,j,i]:= transVec( ID, FaceVct[a,j,i]);
      end;
    end;
  if(Mode in[7..12,14,15,16])then goto OnlyDraw; //复制曲面
  if(Mode in[2,4,6])then begin  //判断参数方程
    Expression := TExpress.create(self);  //----------------------------------------
    for i:= 0 to 2 do begin  //测试三个表达式的自变量是否均为0
      Expression.Expression := '#1'+info[i]; //----------------------------------------
      aa[i]:= Expression.TheFunction( 0,0,0, b0);
      bb[i]:= aa[i]=Expression.TheFunction( 1,1,0, b0);
      end;
    Expression.Free;
    if bb[0] and bb[1] and bb[2] then begin //三个表达式的自变量均为0
      p0:= cgVector( aa[0],aa[1],aa[2]);
      if bList then glNewList( mainList, GL_COMPILE);  //建立显示列表
      glPointSize(3);  glColor3f( 1,0,0);
      glBegin( GL_POINTS);
        glVertex3fv( @p0 );                 //作一个[点]
      glEnd;
      if bList then glEndList;
      exit;
      end;
    end;
  M:= trunc(p1.z);   //xStep
  N:= trunc(p2.z)+1; //yStep
  SetLength(FaceVct[ID], M+1); for i:=0 to M do SetLength( FaceVct[ID,i], N+1); //
  case Mode of
    1:getExpressData(ID, info[2], 2, M,N);      //z=F(x,y)
    3:getExpressData(ID, '#2'+info[2], 2, M,N); //r=F(m,n) $
    5:getExpressData(ID, '#3'+info[2], 2, M,N); //z=F(m,r) &
    2,4,6:for i:= 0 to 2 do                     //x,y,z=F(u,v) ###################
      getExpressData(ID, '#1'+info[i], i, M,N);
    end;//case
  if(Mode in[4,6])then
  for i:= 0 to M do
    for j:= 0 to N do begin
      pn:=FaceVct[ID,i,j];   t:=pn.w;
      case Mode of
        4:FaceVct[ID,i,j]:=cgVector(pn.z*sin(pn.y)*cos(pn.x),
                                    pn.z*sin(pn.y)*sin(pn.x),
                                    pn.z*cos(pn.y));
        6:FaceVct[ID,i,j]:=cgVector(cos(pn.x)*pn.y, sin(pn.x)*pn.y, pn.z);
        end;
      FaceVct[ID,i,j].w:=t;
      end;
onlyDraw:
  CurveFromFace(ID); //构造边缘曲线

  if not bDraw then exit;
  SetLength(nor, N+1);
  if bList then glNewList( mainList, GL_COMPILE);  //建立显示列表

  glEnable( GL_LIGHTING);
  glDisable( GL_LINE_STIPPLE);
  setTowFaceColor(ID, D or(Link[6]>0)or(W>0) ); //D贴图 W炫彩

  glPolygonMode( GL_FRONT_AND_BACK, IIFc( F, GL_FILL, GL_LINE));
  glLineWidth( 1);
  if Seled then  //被选择时的颜色
    glColor4fv(@Obj[1].ColorB)
  else begin
    if(Link[6]>0)then
        color:=setMultiColor(ID, trunc((Obj[Link[6]].L-trunc(Obj[Link[6]].L))*200),200,Color.A);
    glColor4fv( @Color);
    end;
  if(texID>0)and D then begin //绑定纹理
    glColor4f(1,1,1,1);
    glEnable(GL_ALPHA_TEST);  glAlphaFunc(GL_GREATER, 0);
    glEnable(GL_TEXTURE_2D);  glBindTexture(GL_TEXTURE_2D, texID);
    end;
  if F then
    for j:= 0 to N do begin
      nor[j]:=cgPlaneNormal( FaceVct[ID,0,j],   FaceVct[ID,1,j],
                         FaceVct[ID,1,j+1], FaceVct[ID,0,j+1],false);  //法线向量
      if U then cgInvertVec( nor[j]); //反光
      end;
  ww:=0.98*kw/M; hh:=0.98*kh/N;
  nN:=0; if F then nN:=1;
  for nM:=0 to nN do begin
    if(nM=1)then glPolygonMode( GL_FRONT_AND_BACK, GL_LINE);
    for i:= 0 to M-1 do begin
      if(W=1)and not D then setMultiColor(ID, i, M-1,Color.A);
      glBegin( GL_QUAD_STRIP);
      for j:= 0 to N-1 do
        if  (FaceVct[ID,i  ,j].w>=0)and(FaceVct[ID,i  ,j+1].w>=0)
         and(FaceVct[ID,i+1,j].w>=0)and(FaceVct[ID,i+1,j+1].w>=0)
        then begin
          if(W=2)and not D then setMultiColor(ID, j, N,Color.A);  //眩彩
          glNormal3fv( @nor[j]);
          if D then glTexCoord2f( ww*j+0.01, hh*(N-i) ); //纹理
            glVertex3fv( @FaceVct[ID,i,j]);
          pn:=cgPlaneNormal( FaceVct[ID,i,j+1], FaceVct[ID,i,j+1],
                             FaceVct[ID,i,j  ], FaceVct[ID,i+1,j],false);  //法线向量
          glNormal3fv( @pn);
          if D then glTexCoord2f( ww*j+0.01, hh*(N-i-1) ); //纹理
            glVertex3fv( @FaceVct[ID,i+1,j]);
          nor[j]:= pn;
          end;
      glEnd;
      end;
    end;
  if bList then glEndList;
  if bList then glNewList( seleList, GL_COMPILE);  //选择状态 ID+9000
    glEnable(GL_COLOR_MATERIAL);
    glDisable(GL_TEXTURE_2D);
    glLineWidth(1); glColor4fv(@Obj[1].ColorB);
    glPolygonMode( GL_FRONT_AND_BACK, GL_LINE);
    for i:= 0 to M-1 do begin
      glBegin( GL_QUAD_STRIP);
      for j:= 0 to N-1 do
        if  (FaceVct[ID,i  ,j].w>=0)and(FaceVct[ID,i  ,j+1].w>=0)
         and(FaceVct[ID,i+1,j].w>=0)and(FaceVct[ID,i+1,j+1].w>=0)
        then begin
          glVertex3fv( @FaceVct[ID,i,j]);
          glVertex3fv( @FaceVct[ID,i+1,j]);
          end;
      glEnd;
    end;
  if bList then glEndList;
  p0:=FaceVct[ID,0,0];

  end; //with
  setLength(nor,0);
  IntToStr(0);//当炫彩值w由0,1转为2时,不能即时显示曲面,加上这句就行了。真见鬼
end;
//===================== 隐函数曲面 ======================
procedure TfrmMain.ImplicitFace(  ID: integer; bDraw,bList,bOnlyDraw:boolean);//############
const
  MaxGrid = 127;    //数据场最大切片数
  MaxFace = 655350; //最大面片数
  Mask  :array[0..11]of integer=(1,2,4,8,16,32,64,128,256,512,1024,2048);
  EdgeL :array[0..11]of byte=(0,1,2,3,4,5,6,7,0,1,2,3);
  EdgeR :array[0..11]of byte=(1,2,3,0,5,6,7,4,4,5,6,7);
  dx:array[0..2,0..7]of byte=((0,1,1,0,0,1,1,0),(0,0,0,0,1,1,1,1),(0,0,1,1,0,0,1,1));
label DrawCopy;
var
  vList :array[0..11]of TcgVector; //等值点
  nList :array[0..11]of TcgVector; //法线
  a,i,j, cx,cy,cz :Integer;  N:longint;
  x0,x1,x2, y0,y1,y2, z0,z1,z2 :single;   //点集范围
  GridSizeX,GridSizeY,GridSizeZ :Integer; //体素密度
  CubeX,CubeY,CubeZ, GridX,GridY,GridZ :single;  //体素边长 点集边长
  aa,bb,cc,dd,ee,ff, GridRadiu, nx,ny,nz, rX,rY,rZ :single;
  expr :string;    b0:boolean; //expr函数式 b0无用却必须的变量
  GridCenter:TcgVector; //点集中心
  {环境色}mAmbient0, mAmbient1, {散射色}mDiffuse0, mDiffuse1 :TcgColorF;
  Express :TExpress;
  Grid : Array of array of array of TcgVector;
  Cube : Array of array of array of TCube;
  Vect : Array of array of array of TcgVector;  //Normal of Grid points
  Norm : Array of array of array of TCube;

  function GetCubeTriangles(out Cube, Norm :TCube; N:longint):longint;
    var i,j, Index, Pos : Integer;
  begin //分析体素 画出面片 返回面片数
    Index:=0; result:=0;//遍历八个顶点
    for i:=0 to 7 do if Cube[i]^.W < 0 then Index := Index or Mask[i];

    if edgeTable[Index] = 0 then Exit; //是否含有等值点？

    for i:=0 to 11 do //在体素棱边的端点之间插入等值点和法线
      if(EdgeTable[Index] and Mask[i])<>0 then begin
        vList[i]:=Intert( Cube[EdgeL[i]]^, Cube[EdgeR[i]]^); //插入等值点
        nList[i]:=Intert( Norm[EdgeL[i]]^, Norm[EdgeR[i]]^); //插入法向量
        if Obj[ID].U then cgInvertVec(nList[i]);
        end;
    i:=0;  //画出三角面片
    pos:=TriangleTable[ Index, i];
    while(pos<>-1)do begin
      for j:=0 to 2 do begin
        if(N+result)<MaxFace then FaceVct[ID,N+result,j+3]:=nList[pos];
        if(N+result)<MaxFace then FaceVct[ID,N+result,j  ]:=vList[pos];  //保存顶点
        Inc(i); pos:=TriangleTable[ Index, i];
        end;
      inc(result);
      end; //while
  end;
begin
  with Obj[ID]do begin
    a:=Link[0];
    if(Mode=14)then N:=TransCustom(ID);
    if(Mode in[7..12,15,16])then begin //复制曲面
      N:=high(FaceVct[a]);
      setLength(FaceVct[ID], N+1);
      for i:=0 to N do begin
        setLength(FaceVct[ID,i],6);
        for j:=0 to 2 do FaceVct[ID,i,j]:=TransVec(ID,FaceVct[a,i,j]);
        for j:=3 to 5 do FaceVct[ID,i,j]:=FaceVct[a,i,j];
        end;
      end;
    if(Mode in[7..12,14,15,16])then goto DrawCopy;
    expr:=info[2];
    IF(Link[0]>0)then aa:=Obj[Link[0]].L else aa:=p3.x;
    IF(Link[1]>0)then bb:=Obj[Link[1]].L else bb:=p3.y;
    IF(Link[2]>0)then cc:=Obj[Link[2]].L else cc:=p3.z;
    IF(Link[3]>0)then dd:=Obj[Link[3]].L else dd:=p4.x;
    IF(Link[4]>0)then ee:=Obj[Link[4]].L else ee:=p4.y;
    IF(Link[5]>0)then ff:=Obj[Link[5]].L else ff:=p4.z;

    IF(Link[ 7]>0)then x0:=Obj[Link[ 7]].L else x0:=p1.x-0.0001; //-0.0001不能缺，否则函数x=0就不出图像
    IF(Link[ 8]>0)then x1:=Obj[Link[ 8]].L else x1:=p1.y;
                                                x2:=p1.z;
    IF(Link[ 9]>0)then y0:=Obj[Link[ 9]].L else y0:=p2.x-0.0001;
    IF(Link[10]>0)then y1:=Obj[Link[10]].L else y1:=p2.y;
                                                y2:=p2.z;
    IF(Link[11]>0)then z0:=Obj[Link[11]].L else z0:=p5.x-0.0001;
    IF(Link[12]>0)then z1:=Obj[Link[12]].L else z1:=p5.y;
                                                z2:=p5.z;
    end;//with Obj[ID]

  GridSizeX:=trunc(x2);   if GridSizeX>MaxGrid then GridSizeX:=MaxGrid;//体素密度
  GridSizeY:=trunc(y2);   if GridSizeY>MaxGrid then GridSizeY:=MaxGrid;
  GridSizeZ:=trunc(z2);   if GridSizeZ>MaxGrid then GridSizeZ:=MaxGrid;
  GridX:=abs(x1-x0);      CubeX:=GridX/GridSizeX; //GridX点集边长 CubeX体素边长
  GridY:=abs(y1-y0);      CubeY:=GridY/GridSizeY;
  GridZ:=abs(z1-z0);      CubeZ:=GridZ/GridSizeZ;
  if(Obj[ID].S=1)then expr:='#6'+expr; //球面坐标
  if(Obj[ID].S=2)then expr:='#7'+expr; //柱面坐标

  setLength(Grid,GridSizeX+1); for j:=0 to GridSizeX do setLength(Grid[j],GridSizeY+1);
  setLength(Cube,GridSizeX+1); for j:=0 to GridSizeX do setLength(Cube[j],GridSizeY+1);
  setLength(Vect,GridSizeX+1); for j:=0 to GridSizeX do setLength(Vect[j],GridSizeY+1);
  setLength(Norm,GridSizeX+1); for j:=0 to GridSizeX do setLength(Norm[j],GridSizeY+1);

  for j:=0 to GridSizeX do for i:=0 to GridSizeY do setLength(Grid[j,i],GridSizeZ+1);
  for j:=0 to GridSizeX do for i:=0 to GridSizeY do setLength(Cube[j,i],GridSizeZ+1);
  for j:=0 to GridSizeX do for i:=0 to GridSizeY do setLength(Vect[j,i],GridSizeZ+1);
  for j:=0 to GridSizeX do for i:=0 to GridSizeY do setLength(Norm[j,i],GridSizeZ+1);

  GridRadiu:=cgVecLength(cgVector(GridX,GridY,GridZ))/2; //点集半径
  GridCenter:=cgVector( (x0+x1)/2, (y0+y1)/2, (z0+z1)/2);  //点集中心
  Obj[ID].Vec:=GridCenter;
  Obj[ID].L:=GridRadiu;
  Express := TExpress.create(self);  //----------------------------------------
  try
    Express.Expression := expr; //表达式
    Express.SetParameters( aa,bb,cc, dd,ee,ff, aa,bb,cc, 1,1,1,1,1,1,1,1,1); //设置参数a,b,c,d,e,f
    for cz := 0 to GridSizeZ do
      for cy := 0 to GridSizeY do
        for cx := 0 to GridSizeX do
          with Grid[cx, cy, cz] do begin
  //====== 将坐标值带入隐函数方程式 得到网格顶点的“值” ========
            rX:=cx*CubeX+ x0;  rY:=cy*CubeY+ y0;  rZ:=cz*CubeZ+ z0;
            case Obj[ID].S of
              0:begin X:=rX; Y:=rY; Z:=rZ; end; //直角坐标
              1:begin //球面坐标 //F(m,n,r)=0
{球面网格}      X:=rZ*cos(rY)*cos(rX); Y:=rZ*cos(rY)*sin(rX); Z:=rZ*sin(rY);
{直角网格        X:=rX; Y:=rY; Z:=rZ;
                rX:=cgXYtoAngle(x,y, rZ); //rX平角 rZ水平半径
                rZ:=sqrt(Z*Z+rZ*rZ);//球面半径
                if EP(rZ)then rY:=0 else rY:=arcSin(Z/rZ);  }
                end;
              2:begin X:=rY*cos(rX);  Y:=rY*sin(rX);  Z:=rZ; end; //柱面坐标 //F(m,r,z)=0
              end;//case
            W:=Express.TheFunction( rX,rY,rZ, b0);  if EP(W)then W:=0;
            end;
    Express.Free;
  //计算网格点的向量
    rX:=1/(2*CubeX);  rY:=1/(2*CubeY);  rZ:=1/(2*CubeZ);
    for cz := 0 to GridSizeZ do begin
{球面坐标}if(Obj[ID].S=1)and(cz>0)then rY:=1/(2*cz*CubeZ*CubeY); //
      for cy := 0 to GridSizeY do begin
{球面或柱面坐标}if(Obj[ID].S>0)and(cz>0)then rX:=1/(2*cz*CubeZ*CubeX); //
        for cx := 0 to GridSizeX do begin
          Vect[cx,cy,cz]:=Grid[cx,cy,cz];
          with Vect[cx, cy, cz] do begin
            W:=Grid[cx,cy,cz].W;
            if cx=GridSizeX then nx:=   W else nx:=   Grid[cx+1,cy,cz].W;
            if cx=0         then nx:=nx-W else nx:=nx-Grid[cx-1,cy,cz].W;
            if cy=GridSizeY then ny:=   W else ny:=   Grid[cx,cy+1,cz].W;
            if cy=0         then ny:=ny-W else ny:=ny-Grid[cx,cy-1,cz].W;
            if cz=GridSizeZ then nz:=   W else nz:=   Grid[cx,cy,cz+1].W;
            if cz=0         then nz:=nz-W else nz:=nz-Grid[cx,cy,cz-1].W;
            if(Obj[ID].S=1)and(nx=0)and(ny=0) then begin end  //球面坐标
            else{}
              if(Obj[ID].S=2)and(nx=0)and(nz=0) then Z:=0 //柱面坐标
            else
              begin X:=nx*rX;   Y:=ny*rY;   Z:=nz*rZ; end;
            end;
          end;//for cx...
        end;//for cy...
      end;//for cz...
  except
    on E:Exception do messageDlg(E.Message,mtError,[mbOk],0);
  end;
  setLength(FaceVct[ID], MaxFace+1); for i:=0 to MaxFace do setLength(FaceVct[ID,i],6);
  N:=0;
  for cx := 0 to GridSizeX-1 do
    for cy := 0 to GridSizeY-1 do
      for cz := 0 to GridSizeZ-1 do begin
        for j:= 0 to 7 do begin //定义体素 为每个体素的八个顶点编号
          Cube[cx,cy,cz][j] := @Grid[cx+dx[0,j], cy+dx[1,j], cz+dx[2,j] ];
          Norm[cx,cy,cz][j] := @Vect[cx+dx[0,j], cy+dx[1,j], cz+dx[2,j] ];
          end;
        N:=N+ GetCubeTriangles( Cube[cx,cy,cz], Norm[cx,cy,cz], N);//分析体素
        if N>=MaxFace then break;
        end;
  setLength(Grid,0); setLength(Cube,0); setLength(Vect,0); setLength(Norm,0);
DrawCopy:
  Obj[ID].Hide:=N<2; if Obj[ID].Hide then exit;
  if(N>=MaxFace)then N:=MaxFace-1;
  setLength(FaceVct[ID], N+1);
  if bList then with Obj[ID]do begin
    getListID(mainList,1); getListID(seleList,1);
    aa:=W;
    end;
  if bList then glNewList( Obj[ID].mainList, GL_COMPILE);  //建立显示列表
  glEnable(GL_LIghTING);
  setTowFaceColor(ID, aa>0 );

  glLineWidth(0.5);
  for a:=0 to IIFi(Obj[ID].F,1,0) do begin
    glPolygonMode( GL_FRONT_AND_BACK, IIFc( Obj[ID].F and(a=0), GL_FILL, GL_LINE));
    for i:=0 to N do begin
      glBegin( GL_TRIANGLES);//GL_POINTS);//GL_LINE_LOOP);//
      for j:=0 to 2 do begin
        if(aa=1)then setMultiColor(ID, cgDistance(FaceVct[ID,i,j],GridCenter), GridRadiu,Obj[ID].Color.A);
        if(aa=2)then setMultiColor(ID, FaceVct[ID,i,j].z- z0, GridZ,Obj[ID].Color.A);//z0 点集底面Z坐标
        glNormal3fv(@FaceVct[ID,i,j+3]);
        glVertex3fv(@FaceVct[ID,i,j]);
        end;
      glEnd;
      end;
    end;
  if bList then glEndList;
  if bList then glNewList( Obj[ID].seleList, GL_COMPILE);  //建立被选择的显示列表 ID+9000
  glEnable(GL_COLOR_MATERIAL);
  glColor4fv( @Obj[1].ColorB);
  for i:=0 to N do begin
    glBegin( GL_LINE_LOOP);
    for j:=0 to 2 do glVertex3fv(@FaceVct[ID,i,j]);
    glEnd;
    end;
  if bList then glEndList;
  Obj[ID].p0:=FaceVct[ID,0,0]; //标签位置
end;
//##################### 测试表达式 ################################
function TfrmMain.checkFunc( ID:integer):boolean;
  var i :Integer;  st,expr :string;
      Expression  :TExpress;
  function testFunc(st:string):boolean;
  begin //
//  try
    result:=true;
    Expression := TExpress.create(self);
    Expression.Expression:=st;
    if Expression.Error then result:= false; //检查表达式
//  except
    Expression.Free;
//  end;
  end;
begin
  with Obj[ID] do begin
  if Mode in[1,3,5,6,13] then begin //z=F(x,y)
    case Mode of 1:st:=''; 3:st:='#2'; 5:st:='#3';  end;
    if(Kind=16)and(Mode=5)then st:=''; //隐函数曲线曲面
    if(Kind=16)and(Mode=1)then expr:=info[1] else expr:=info[2];
    if(Kind=16)and(Mode=6)then st:='#5'; //极坐标隐函数曲线
    if(Kind=9)and(Mode=6)then st:='#1'; //柱坐标隐函数曲面
    if(Kind=9)and(Mode=13)then case S of 0:st:=''; 1:st:='#6'; 2:st:='#7'; end;
    result:=testFunc(st+expr);
    if not result then begin
      if(Kind=16)and(Mode=1)then edtY.SetFocus else edtZ.SetFocus;
      end;
    end
  else //x,y,z=F(u,v)
    for i:= 0 to 2 do begin
      expr:=info[i];  result:=testFunc('#4'+expr);
      if not result then begin
        case i of 0:edtX.SetFocus; 1:edtY.SetFocus; 2:edtZ.SetFocus; end;
        break;
        end;
      end;
  end;//with
  if not result then
    case iLanguage of
      0:MyMessage('表达式 '+ expr +' 有错！');
      1:MyMessage('表達式 '+ expr +' 有错！');
      2:MyMessage('Expression '+ expr +' Error!',)
      end;
end;
//================== 插入字符串 ====================
function TfrmMain.insExpr(Des,Sur:string; insPos:integer; var Pos:integer):string;
begin
  insert( Des, Sur, insPos+1);
  result:= Sur;
  pos:=insPos+length(Des)+1;
  IF(RightStr(Des,2)='()')then dec(pos);  //光标位置
end;

//#################### 点的值 ######################################//
function ValueOfDot(ID,a,b :integer; isMeasure:boolean):single; //
  var i,j,N :integer;   c0,c1,c2, t, res :double;  Dot,pp,pn :TcgVector;
begin
  result:=0;
  if Obj[a].Hide or Obj[b].Hide then exit;
  with Obj[ID]do begin
  Dot:=Obj[a].p0;
  case Obj[b].Kind of //======== 点的值 ==========
    2:begin //直线上的点
      if EP(Obj[b].L)then exit;
      pp:=Footer( Obj[a].p0, b, false);
      c0:=cgDistance( Obj[b].p4, Obj[b].p5);
      c1:=cgDistance( Obj[b].p4, pp);
      c2:=cgDistance( Obj[b].p5, pp);
      res:=c1/c0;  if(c2>c0)and(c2>c1)then res:=-res;
      if isMeasure then begin //来自度量
        if(Link[3]=0)then t:=p2.x else t:=Obj[Link[3]].L; //起值
        if(res<t)then res:=t;
        if(p2.z=0)then p2.z:=1; //终值。从v2.837开始这个属性，过去等于0
        if(Link[4]=0)then t:=p2.z else t:=Obj[Link[4]].L;
        if(res>t)then res:=t;
        end;
      end;
    3,4,5,15,16,17,19:begin   //曲线上的点
      N:=high(LocaVct[b]);
      j:=0;  pn:=LocaVct[b,0];
      c0:=cgDistance( Dot, pn);
      for i:=0 to N-1 do begin
        pp:=cgDotNearestLine( Dot, LocaVct[b,i], LocaVct[b,i+1]);
        c1:=cgDistance(Dot,pp);
        if(c1<(c0-0.000001))then begin c0:=c1; pn:=pp; j:=i; end;
        end;
      res:=(cgDistance(pn,LocaVct[b,j])+LocaVct[b,j].w)/LocaVct[b,N].w;
      end;
    end;
  result:=res;
  end;//with
end;
//================== 度量 ======================
function TfrmMain.calcSize( ID:integer):double;
  var a,b,c,dd, i,j,M,N, Ka,Kb,Kc,Ma :integer;
      c1,c2,c3,c4, r1,r2,r3,t, res :double;
      p, pa,pb,pc,pd, v1,v2 :TcgVector;
begin
  res:=0; result:=0;
  with Obj[ID] do begin

  for i:=0 to 2 do begin //链接件隐藏则本件隐藏
    if(Link[i]>0)then hide:=Obj[Link[i]].hide;
    if hide then begin result:=0; exit; end;
    end;
  a:=Link[0];   pa:=Obj[a].p0;  Ka:=Obj[a].Kind;  Ma:=Obj[a].Mode;
  b:=Link[1];   pb:=Obj[b].p0;  Kb:=Obj[b].Kind;
  c:=Link[2];   pc:=Obj[c].p0;  Kc:=Obj[c].Kind;
  r1:=Obj[a].L; r2:=r1*r1;      r3:=r2*r1;
  case Mode of
  3:case Ka of //======== 面积 ============
    3:if EP(Obj[a].H)then res:=Pi*r2 else res:=Pi*r2*(1-Obj[a].H); //圆/椭圆
    4:case Ma of  //平面面积
      1,2:begin   //三角形面积
        res:=cgTriangleArea( Obj[a].p0, Obj[a].p1, Obj[a].p2);//四边形
        if trunc(r1)>0 then res:=res*2; //三角形
        end;
      3,4,5:res:=r1*Obj[a].R; //平行面、垂面、中面面积
      6:if(Obj[a].W=99)then //矩形面积
          res:=r1*Obj[a].H
        else begin
          if Obj[a].Rand then begin//正多边形面积
            N:=trunc(Obj[a].W)mod 100;
            res:=sin(towPi/N)*N*r2/2;
            end
          else begin //任意多边形
            N:=high(LocaVct[a])-2;
            for i:=1 to N do
              res:=res+ cgTriangleArea(LocaVct[a,0], LocaVct[a,i],LocaVct[a,i+1]);
            end;
          end;
      7..13:begin
          N:=high(LocaVct[a])-1;
          for i:=1 to N do
            res:=res+ cgTriangleArea(LocaVct[a,0], LocaVct[a,i],LocaVct[a,i+1]);
        end;
      end;
    6:case Ma of  //实体面积
      1:if EP(Obj[a].W)and EP(Obj[a].H)then //正球
          res:=4*Pi*r2
        else begin //椭球
          t:=1.6075;  W:=1-Obj[a].W; H:=1-Obj[a].H;
          c1:=Power(W*r2,t); c2:=Power(H*r2,t);  c3:=Power(W*H*r2,t);
          res:=2*towPi* Power((c1+c2+c3)/3, 1/t);
          end;
      2:with Obj[a] do begin //圆台
        c1:=sqrt(sqr(L-W*L)+sqr(H)); //斜高
        res:=Pi*(L+W*L)*c1;
        if Trace then res:=res+Pi*( sqr(W*L) + r2); //两端面积
        end;
      3:if Obj[a].S<6 then begin
          case Obj[a].S of //正多面体
            1:t:=4.6188; 2:t:=6.9282; 3:t:=6.9283; 4:t:=10.51462; 5:t:=9.57454;
            end;
          res:=t*r2;
          end
        else
          with Obj[a] do res:= (L*W)*2 + (L+W)*H*2;
      4:with Obj[a] do begin //棱台
        r1:=L*Cos(Pi/S); r2:=r1*W; r3:=r1-r2;
        r3:=sqrt(sqr(r3)+sqr(H)); //斜高
        c1:=2*L*Sin(Pi/S); c2:=c1*W; //上下底边长
        res:=S*(c1+c2)*r3/2;
        if Trace then res:=res+ (1+W*W)*Sin(towPi/S)*S*r2/2; //两端面积
        end;
      5:begin end; //凸壳
      6:res:=4*Pi*r2; //三点球
      end;
    7:begin //曲面面积
      M:=high(FaceVct[a])-1;
      if(M>=0)then begin
        N:=high(FaceVct[a,0])-1;
        if(N>=0)then begin
          for i:=0 to M do
            for j:=0 to N do begin
            c1:= cgTriangleArea(FaceVct[a,i,j], FaceVct[a,i,j+1],FaceVct[a,i+1,j+1]);
            c2:= cgTriangleArea(FaceVct[a,i,j], FaceVct[a,i+1,j],FaceVct[a,i+1,j+1]);
            res:=res+(c1+c2);
            end;
          end;
        end;
      end;
    end;
  4:case Ma of //======== 体积 =============
    1:if EP(Obj[a].W)and EP(Obj[a].H)then //正球
        res:=2*towPi*r3/3
      else //三点球
        res:=2*towPi*r3*(1-Obj[a].W)*(1-Obj[a].H)/3;
    2:with Obj[a] do res:=(r2+r2*W*(1+W))*Pi*H/3; //圆台

    3:if Obj[a].S<6 then begin
        case Obj[a].S of //正多面体
          1:t:=0.5132; 2:t:=1.5396; 3:t:=1.33333; 4:t:=2.78516; 5:t:=2.536149;
          end;
        res:=t*r3;
        end
      else
        with Obj[a] do res:= L*W*H;
    4:begin //棱台
      i:=Obj[a].S;
      if(i=0)and(Obj[ Obj[a].Link[0]].w=3)then begin //底面为三角形的凸棱台
        with Obj[ Obj[a].Link[0]]do begin
          pa:=Obj[Link[0]].p0;  pb:=Obj[Link[1]].p0;  pc:=Obj[Link[2]].p0;
          end;
        with Obj[a] do begin
          c1:=cgTriangleArea( pa,pb,pc);//下底三角形面积
          c2:=c1*W*W; //上底面积
          res:=(c1+c2+sqrt(c1*c2))*H/3;
          end;
        end
      else with Obj[a] do begin   //棱台
        c1:=Sin(towPi/S)*S*r2/2; //下底面积
        c2:=c1*W*W; //上底面积
        res:=(c1+c2+sqrt(c1*c2))*H/3;
        end;
      end;
    5:if trunc(Obj[a].W)=4 then begin //四面体凸壳
        pa:=Obj[Obj[a].Link[0]].p0;  pb:=Obj[Obj[a].Link[1]].p0;
        pc:=Obj[Obj[a].Link[2]].p0;  pd:=Obj[Obj[a].Link[3]].p0;
        res:=cgTriangleArea( pa,pb,pc);//三角形面积
        with Obj[10]do begin Kind:=4; Mode:=1; p0:=pa;
          Vec:=cgGetNormal(pa,pb,pc); Vec.w:=-cgDotProduct(Vec,pa);
          end;
        t:=cgDotProduct(Obj[10].Vec, pd) + Obj[10].Vec.w; //高
        res:=res*t/3; //体积
        end;
    6:res:=4*Pi*r3/3; //三点球
    end;
  5:begin //======== 距离 =============
    if(Obj[a].Hide)or(Obj[b].Hide)then begin result:=999; exit; end;
    if(Ka=1)and(Kb=1)then  //点-点
      res:=cgDistance( pa, pb);
    if(Ka=1)and(Kb=2)then  //点-线
      res:=cgDistanceDotLine(pa,pb, Obj[b].Vec);
    if(Ka=1)and(Kb=4)then  //点-面
      res:=cgDotProduct(Obj[b].Vec, pa) + Obj[b].Vec.w;
    if(Ka=2)and(Kb=2)then begin //线-线
      v1:=Obj[a].Vec; v2:=Obj[b].Vec; pc:=v2; cgInvertVec(pc);
      if cgVecComp(v1,v2)or cgVecComp(v1,pc)
      then begin p:=Footer(pa,b,true);   res:=p.w; end
      else begin
        v1:=cgVecSub( pa, pb); //点到直线端点的向量
        t:=cgDeterminant3D1( Obj[a].Vec, Obj[b].Vec, v1);
        p:=cgCrossProduct( Obj[a].Vec, Obj[b].Vec);
        res:= t/cgVecLength(p);
        end;
      end;
    end;
  6:begin //======== 角度 =============
    if(Ka=3)then begin //圆弧角
      res:=Obj[a].H;  if Obj[a].D then res:= Obj[a].H/Obj[a].L;
      end
    else begin
      if(Ka=1)and(Kb=1)and(Kc=1) then begin //三点夹角
        v1:=cgNormalVec(pa, pb);    v2:=cgNormalVec(pc, pb);
        t:=cgDotProduct(v1,v2);
        end
      else if(Ka+Kb+Kc=4)and(Kc>0)then begin //两点一线之夹角
        pc:=Obj[c].p0;  pd:=Obj[c].p1;
        if(Ka=2)then begin pa:=pb;  pb:=pc;  pc:=Obj[a].p0; pd:=Obj[a].p1; end;
        if(Kb=2)then begin pb:=pc;  pc:=Obj[b].p0; pd:=Obj[b].p1; end;
        v1:=cgGetNormal(pa,pc,pd);  v2:=cgGetNormal(pb,pc,pd);
        t:=cgDotProduct(v1,v2);
        end
      else //线/线夹角  线/面交角
        t:=cgDotProduct(Obj[a].Vec, Obj[b].Vec);
      res:=arcCos(t);
      if(Ka in[3,4])and(Kb=2) or (Ka=2)and(Kb in[3,4])then res:=halfPi-res;
      if U then res:=Pi-res;  //补角
      if D then res:=res*oneArc; //转换为角度
      end;
    end;
  7:begin //======== 比值 =============
    if Ka=1 then begin 
      c1:=cgDistance(pa,pb);  c2:=cgDistance(pa,pc);
      if c1=0 then res:=0 else res:=c2/c1;
      if EP(c1) then res:=999999; //res>9999.9999
      if cgDotAtLine(pa, pb,pc)and cgDotInBox(pa, pb,pc)then res:=-res;
      end
    else begin
      if EP(Obj[b].L) then res:=999999 else res:=Obj[a].L/Obj[b].L;
      end;
    F:= abs(res)=999999; //无穷大
    if F then Hide:=true;
    end;
  8:case Ka of //======== 周长 =============
    2:if Ma<>6 then //直线长度
        res:= Obj[a].L
      else begin
        if(Obj[Obj[a].Link[0]].Kind=4)and(Obj[Obj[a].Link[1]].Kind=4)then
          res:= Obj[a].L   //俩直线的相惯线长度
        else
        end;
    3:case Ma of //圆周长
      1:if(Obj[a].H=0)then res:=r1*towPi //正圆或三点圆
        else res:= LocaVct[a,high(LocaVct[a])-1].w;
      2:res:=r1*towPi;
      3,4:res:=IIFf(Obj[a].D, Obj[a].H, r1*Obj[a].H); //圆弧
      else
        res:= LocaVct[a,high(LocaVct[a])-1].w;//投影复制、缩放复制
      end;
    4:with Obj[a] do //平面周长 
      if(Mode<3)and(trunc(L)=0)
        then res:=cgDistance(p0,p1)+cgDistance(p1,p2)+cgDistance(p2,p0)
        else res:=LocaVct[ a, high(LocaVct[a])].w;  //cgDistance(p0,p1)*2+ cgDistance(p1,p2)*2;
    5,15,16,17,19:begin //轨迹线相惯线长度
      M:=high(LocaVct[a]);
      if(M>0)then res:=LocaVct[a,M].w;
      end;
    end;
  9:begin //======== 斜率 ========
    if not cgLinePlaneCross(pa,Obj[a].Vec, pb,Obj[b].Vec, p)
    then res:=0
    else begin //c1*c2>=0 俩直线端点位于平面的同一侧
      pa:=Footer(Obj[a].p0,b,true);    pb:=Footer(Obj[a].p1,b,true);
      r1:=cgDistance(pa,pb);
      hide:=EP(r1); if hide then exit;
      v2:=Obj[b].Vec;
      c1:=cgDotProduct(v2, Obj[a].p0)+v2.w;
      c2:=cgDotProduct(v2, Obj[a].p1)+v2.w;
      if c1*c2>0 then t:= pb.w-pa.w else t:=pb.w+pa.w;
      if c2<0 then t:=-t;
      res:=t/r1;
      end;
    end;
  10:res:=pa.x;
  11:res:=pa.y;
  12:res:=pa.z;
  13:res:=ValueOfDot(ID,a,b, true); //点的值
  14:res:=Obj[a].L*2;//直径
  15:begin Vec:=pa; //三维坐标
    case trunc(R)of
      0:res:=sqrt(pa.x*pa.x + pa.y*pa.y + pa.z*pa.z);
      1:res:=pa.x;    2:res:=pa.y;    3:res:=pa.z;
      end;
    end;
  16:begin //======== 矢量 ========
    Vec:=Obj[a].Vec;  res:=0;
    if(Ka=1)and(Kb=1)then Vec:=IIFv(U, cgNormalVec(pb,pa), cgVecSub( pb, pa));  //U 格式化
    if(Ka=2)then Vec:=IIfv(U, Obj[a].Vec, cgVecSub( Obj[a].p1, Obj[a].p0));
    if(Ka in[3,4])then Vec:=Obj[a].Vec;
    case trunc(R)of
      0:res:=sqrt(Vec.x*Vec.x + Vec.y*Vec.y + Vec.z*Vec.z);
      1:res:=Vec.x;   2:res:=Vec.y;   3:res:=Vec.z;
      end;
    end;
  17:begin //======== 矢量运算 ========
    v1:=Obj[a].Vec;  if trunc(Obj[a].H)=1 then cgInvertVec(v1);
    v2:=Obj[b].Vec;  if trunc(Obj[b].H)=1 then cgInvertVec(v2);
    case trunc(R)of //0和 1差 2叉积 3点积
      0:begin//Vec:=cgVecAdd( v1, v2); //和
        Vec:=cgVecAdd(Obj[a].p1, cgVecSub( Obj[b].p1, Obj[b].p0 ) );
        p:=Vec; cgNormalize(p);  res:=p.w;
        if U then Vec:=p; //U 格式化
        end;
      1:begin//Vec:=cgVecSub( v1, v2); //差
        Vec:=cgVecSub(Obj[a].p1, cgVecSub( Obj[b].p1, Obj[b].p0 ) );
        p:=Vec; cgNormalize(p);  res:=p.w;
        if U then Vec:=p; //U 格式化
        end;
      2:begin //叉积 即两矢量所成平行四边形面积
        Vec:=cgCrossProduct( cgVecSub( Obj[a].p1, Obj[a].p0 ) , cgVecSub( Obj[b].p1, Obj[b].p0 ));
        p:=Vec; cgNormalize(p);  res:=p.w;
        if U then Vec:=p; //U 格式化
        end;
      3:begin //点积
        res:=cgDotProduct( cgVecSub( Obj[a].p1, Obj[a].p0 ) , cgVecSub( Obj[b].p1, Obj[b].p0 ));
        end;
      end;
    end;
  19:begin //======== 方程 ========
    p5:=pa; Vec:=Obj[a].Vec;
    if(Ka=3)then hide:=not EP(Obj[a].H); //不能度量椭圆
    if(Ka=3)and not hide then begin //圆方程系数
      c1:=sqrt(sqr(Vec.x)+sqr(Vec.y));    c2:=sqrt(sqr(Vec.x)+sqr(Vec.y)+sqr(Vec.z));
      p4.x:= Obj[a].L;  if not EP(c1)then p4.x:= Obj[a].L*Vec.y/c1;
      p4.y:=0;          if not EP(c1)then p4.y:= Obj[a].L*Vec.x*Vec.z/(c1*c2);
      p4.z:=0;          if not EP(c1)then p4.z:=-Obj[a].L*Vec.x/c1;
      p4.w:=Obj[a].L;   if not EP(c1)then p4.w:= Obj[a].L*Vec.y*Vec.z/(c1*c2);
      p4.r:=0;          if not EP(c1)then p4.r:=-Obj[a].L*c1/c2;
      end;
    //平面方程各系数已在Plane过程中生成
    end;
      
  end;//case
  if (Mode in[3,4,5,6,8]) then res:=abs(res);
  end;//with
  result:=res;
end;
//################# 检查/替换构件标签 ########################
function TfrmMain.checkExpr(ID:integer; var par:Tpara):string;
  var i,j,Len,n :integer; 
      s :string;  c:AnsiChar;
      st :array[1..18]of string;
      pos:array[1..18]of integer;
  const code='abcdefghijklmnopqr';
begin  //a..z 97..122
  expr:= trim(memExpr.Text); //计算式
  Len:=length(expr);
  for i:=1 to 18 do parID[i]:=0;
  n:=0;  s:='';
  for j:= 1 to Len+1 do begin
    c:= expr[j];
    if(j<=Len)and not(c in['+','-','*','/','(',')','^',','])then
      s:=s+c
    else if(s>'')then begin
      for i:= 11 to ID do
        if s= trim( Obj[i].Tag) then begin
          inc(n); st[n]:=s;
          pos[n]:=j-length(s); parID[n]:=i;
          end;
      s:='';
      end;
    end;
  if n>0 then
    for i:= n downto 1 do begin
      delete( expr, pos[i], length(st[i]));          //删除构件Tag
      insert( IIFs(n<19, code[i],'0'), expr, pos[i]); //插入字母
      par[i]:=Obj[parID[i]].L;; //常量参数
      end;
  labResult.Caption:= expr;
  result:= expr;
end;
//############### 将公式里的参数名复原为构件标签 ##############
function TfrmMain.ReplaceCode(ID:integer; expr:string):string;
  var i,j,L,n :integer;         ch,c0,c1:char;
      st :array[1..18]of char;   pos:array[1..18]of integer;
  const code='abcdefghijklmnopqr';
begin  //
  n:=0;   L:=Length(expr);
  for j:= 1 to L do begin
    if j>1 then c0:=expr[j-1]; //c0的作用是防止'pi'或'ei'被显示为p,e
    ch:=expr[j]; if j<L then c1:=expr[j+1] else c1:=')';
    if not(c0 in['e','E','p','P'])and(ch in['a'..'r'])and(c1 in['+','-','*','/','^',')',',']) //
      then begin inc(n); st[n]:=ch; pos[n]:=j; end;
    end;
  if(n>0)then
    for i:= n downto 1 do begin
      delete( expr, pos[i], 1);          //删除构件Tag
      insert( IIFs(n<19, Obj[Obj[ID].Link[(ord(st[i])-97)]].Tag ,'0'), expr, pos[i]); //插入字母
      end;
  result:= expr;
end;
//##################### 计算 ################################
function TfrmMain.calcFunc(  ID:integer; var res:double; check,show:boolean):boolean; //check=true 需要检测表达式
  var Expression:TExpress;  i:integer;  b0 :boolean; st:string;
begin result:=false;
  with Obj[ID] do
  for i:=0 to LinkTime do if(Link[i]>0)then begin //链接件隐藏则本件隐藏
    Hide:=Obj[Link[i]].Hide;
    if Hide then begin
      if(Obj[Link[i]].Kind<>11)
        then begin F:=false; U:=false; end
        else begin U:=Obj[Link[i]].U; F:=Obj[Link[i]].F; end;
      exit;
      end;
    end;
  if check then  //检查表达式
    expr:= checkExpr(ID, par)
  else with Obj[ID] do begin
    expr:= info[1];
    for i:=1 to 18 do
      if(Link[i-1]>0)then par[i]:=Obj[Link[i-1]].L else par[i]:=0;
    end;
  Expression := TExpress.create(self);
  try
    Expression.Expression:= expr; //检查表达式
    Expression.SetParameters( par[ 1],par[ 2],par[ 3],par[ 4],par[ 5],par[ 6],par[ 7],par[ 8],par[ 9], //参数
                              par[10],par[11],par[12],par[13],par[14],par[15],par[16],par[17],par[18]); //参数
    result:=not(Expression.Error); //检查表达式
  finally
    if result then begin
      res:= Expression.TheFunction( 0,0,0, b0);
      result:= not( Pars.Infi or Pars.Null ); //
      if Pars.Infi then st:='∞';
      Obj[ID].F:=Pars.Infi;
      if Pars.Null then st:=SwitchS( iLanguage,'未定义','未定義','undifined','');
      Obj[ID].U:=Pars.Null;
      if show then begin
        if result and check then pnlResult.Caption:= FtoS(res,Obj[ID].S);
        end;
      end;
    Expression.Free;
  end;
  if show and(not result)then pnlResult.Caption:= '?';
  if show and(Pars.Infi or Pars.Null)then pnlResult.Caption:=st;
//  Obj[ID].info[2]:=st;
end;
//将TPanel模拟为按钮，其中的图片也会随TPanel边框的变化而位移
procedure setBevel( b :boolean; pnl :Tpanel; img:Timage );
begin
  pnl.BevelOuter:= TBevelCut( IIFi( b, 1,2)); //bvLowered or bvRaised
  if img=nil then exit;
  img.Left:= IIFi(b, 4, 3); img.Top:= img.Left-2;
end;
//====================== cmbTag ======================
function IDtoItem( ID:integer):string;
  var st,ss:string;
begin
  with Obj[ID] do begin
    str( ShowID, st);
    if(Kind=2)and(Obj[Link[0]].Kind=19)
      then case iLanguage of
            0:ss:='渐近线/准线'; 1:ss:='漸近線/準線'; 2:ss:='Asymptote/Asymptote';
            end
    else if(Kind=3)and(Mode=15)and(Obj[Link[0]].kind=3)and(Obj[Link[1]].Kind=3)
      then case iLanguage of
            0:ss:='逆相似圆'; 1:ss:='逆相似圓'; 2:ss:='Inverse Similar Circle';
            end
    else if(Kind=4)and(Mode=6)then begin
      if(trunc(W)=99)
      then case iLanguage of
            0:ss:='矩形'; 1:ss:='矩形'; 2:ss:='Rectangle';
            end
      else case iLanguage of
            0:ss:=IIFs( D, '正多边形','多边形');
            1:ss:=IIFs( D, '正多邊形','多邊形');
            2:ss:=IIFs( D,'Regular Polygon','Polygon');
            end;
      end
    else if(Kind=6)and(Mode=3)
      then case iLanguage of
            0:ss:=IIFs(S in[1..5,11,12],'正多面体','长方体');
            1:ss:=IIFs(S in[1..5,11,12],'正多面體','長方體');
            2:ss:=IIFs(S in[1..5,11,12],'Polyhedron','Cuboid');
            end
    else ss:=stMode[kind,Mode];
    if ID<8 then result:= stAxis[ID]
            else result:= st+'. '+ Tag+ ' '+ss; //
    end; //with
end;

//==================== 自动生成构件标签 ===================
function TfrmMain.GetTag( ID :integer) :string;
  var i,j,k :integer;  ss:string;
//点:大写字母，圆:o1,o2...，平面:希腊字母。其它构件都用小写字母
  const s1:string='ABCDEFGHIJKLMNOPQRSTUVWXYZ';
        s2:string='abcdefghijklmnopqrstuvwxyz';
        s3:string='αβγδεθζηικλμνξοπρστυφχψω';
  function Find(ss:string):boolean;
    var i:integer;
    begin
      i:=0; repeat inc(i); result:=(Obj[i].Tag=ss); until result or(i>=ObjCount);
    end;
begin
  if ID=1 then begin result:='a'; exit; end;
  i:=0;
  case Obj[ID].Kind of
  1:repeat //点
      j:=i div 26; k:=(i mod 26);
      ss:=s1[k+1]; if j>0 then ss:=ss+'['+itos(j)+']';
      inc(i);
      until not Find(ss);
  3:repeat //圆
    inc(i); ss:='O['+IntToStr(i)+']';
    until not Find(ss);
  4,18:repeat //平面
    j:=i div 24; k:=(i mod 24);
    ss:=copy(s3,k*2+1,2); if j>0 then ss:=ss+'['+itos(j)+']';
    inc(i);
    until not Find(ss);
  else repeat //其它构件
    j:=i div 26; k:=(i mod 26);
    ss:=s2[k+1]; if j>0 then ss:=ss+'['+itos(j)+']';
    inc(i);
    until not Find(ss);
  end;
  result:=trim(ss);
  Obj[ID].Tag:=result;  Obj[ID].TagT:=Obj[1].TagT;  //'0000';
  GetTextList(ID);
end;

procedure TfrmMain.HideAllPanel;
begin
  pnlControl.Hide;
  pnlProp.Visible:=bNail;   pnlProp.Height:=44;
  pnlShow.Enabled:=true;
  tlbMain.Enabled:=true;    tlbMenu.Enabled:=true;
  cheCutter.Hide;
  bSelLink:=false;
  KeyPreview:=true;
end;

procedure TfrmMain.AddItem( ID,t:integer;  bFist,bEnable,bBreak:boolean);
  var st,ss:string;   itm:TMenuItem;
begin
  labHint.caption :=itos(ID); //很奇怪 若没有这条，父构件弹出菜单有时会乱码
  if(Obj[ID].DelID>0)then exit;// or(Obj[ID].Tag='')
  itm:=TMenuItem.Create(frmMain);  itm.OnClick:= frmMain.popObjClick;
  if bFist then begin
    popObj.Items.Clear;
    if(t=14)then itm.Caption:=SwitchS(iLanguage,'移 出','移 出','Move Out','')
            else itm.Caption:=SwitchS(iLanguage,'取消关联 ','取消關联 ','No Bound','');
    itm.Tag:=0;  itm.Enabled:=bEnable;
    end
  else begin
    str( Obj[ID].ShowID :3, st);//showID:构件列表里的顺序
    with Obj[ID] do begin
      if(Kind=4)and(Mode=6)then begin
        if Rand then ss:=SwitchS(iLanguage,'正多边形','正多邊形','Regular Polygon','')
                else ss:=SwitchS(iLanguage,'多边形','多邊形','Polygon','');
        end
      else if(Kind=6)and(Mode=3)then begin
        if(S in[1..5,11,12])then ss:=SwitchS(iLanguage,'正多面体','正多面體','Polyhedron','')
                else ss:=SwitchS(iLanguage,'长方体','长方體','Cuboid','');
        end
      else ss:=stMode[Kind,Mode];
      if trim(Tag)=''then Tag:='{#}'+itos(ID); //{#} 就是字符#
      ss:=st+'. '+ Tag+ ' '+ ss;
      end;
    itm.Caption:=IIFs(ID>7, ss, stAxis[ID] );
    if bBreak then itm.Break:=mbBreak;
    itm.Tag:=ID;
    end;
  popObj.Items.Add( itm);
end;
//================= 对象列表 ===============
procedure TfrmMain.scrListChange(Sender: TObject);
begin
  if(scrList.Position> scrList.Max-scrList.PageSize)then
     scrList.Position:=scrList.Max-scrList.PageSize+1;
  imgList.Top:=-scrList.Position*16;
end;

procedure TfrmMain.imgListDrawItem(ID,Index:integer; text:string;  isAppend,isUpdate:boolean);
  var k :integer; myRect,mySour:TRect;
begin
  if isAppend then begin //添加表项
    imgList.Height:=index*16;
    ObjListID[index].State:='00000';
    k:=ObjListID[index].ID;
    if(Obj[k].Hot)           then ObjListID[index].State[1]:='1';
    if(Obj[k].Dad)           then ObjListID[index].State[2]:='1';
    if(Obj[k].ObjShow[Layer])then ObjListID[index].State[3]:='1';
    if(Obj[k].Hide)          then ObjListID[index].State[4]:='1';
    if(Obj[k].Son)           then ObjListID[index].State[5]:='1';
    With imgList.Picture.Bitmap do begin Width:=imgList.Width; Height:=imgList.Height; end;
    end;
  With imgList.Picture.Bitmap.Canvas do begin
    Brush.Color:=clWhite; //clSkyBlue; //clGreen;//
    if(Obj[ID].Hot)then Brush.Color:=clHighlight; //clBlue; //选定时的颜色
    if(Obj[ID].Dad)then Brush.Color:=clGradientInactiveCaption; //父对象颜色
    if(Obj[ID].Son)then Brush.Color:=clMoneyGreen;//clSkyBlue; //子对象颜色
    myRect:=Rect(14, (index-1)*16, imgList.Width, index*16);
    FillRect(myRect);
    Font.Color:=clBlack;
    if(Obj[ID].Hot)then Font.Color:=clWhite;
    if(Obj[ID].Hide)then Font.Style:=[fsStrikeOut] else Font.Style:=[];
    TextOut(16, (index-1)*16+2, text);

    myRect:=Rect(0, (index-1)*16, 14, index*16);
    k:=IIFi(not Obj[ID].Hide and Obj[ID].ObjShow[Layer], 15, IIFi(Obj[ID].Hide,29,1) );
    mySour:=Rect(k, 0, k+14, 16);
    CopyRect(myRect, imgListMode.Canvas, mySour);
    Brush.Color:=clWhite; //clSkyBlue; //clGreen;//
    end; //With bmpList.Canvas
end;

procedure TfrmMain.imgListUpdate( ID,index: Integer; isFromOther,isLeft,isRight:boolean);//; isOne,isAll,isClear,isMark:boolean); //刷新对象列表
  var i,j,k,n,p, iID :integer;  isHot,isDad,isSho:boolean;  st:string;
begin  // exit; // Lst.Clear;
  iID:=ID;   if(Index<0)then index:=0;
  j:=ObjListID[0].ID;  n:=0;
  if isRight then// and not isFromOther or(MarkObj=0) then //按右键则清除全部选择状态
    for i:=1 to j do Obj[ObjListID[i].ID].Hot:= ObjListID[i].ID=ID;
  for i:=1 to j do begin //统计被选择的对象数目
    k:=ObjListID[i].ID;   Obj[k].Dad:=false;  Obj[k].Son:=false;
    if Obj[k].Hot then begin inc(n); if(not Obj[iID].Hot)then iID:=k; end;
    end;
  if(n=1)then begin //仅选择了一个对象
    MarkObj:=iID;
    for i:=0 to LinkTime do begin //标记父对象
      iID:=Obj[MarkObj].Link[i];  if(iID>10)then Obj[iID].Dad:=true;
      end;
    for i:=MarkObj+1 to ObjCount do with Obj[i]do if(DelID=0)then begin  //标记子对象
      for j:=0 to LinkTime do if(Link[j]=MarkObj)then Son:=true;
      end;
    with Obj[MarkObj]do begin
      if(Kind=10)and(Mode=2)and(info[0]>'')and Hide then
        stbBar.Caption:='The image file "'+info[0]+ '" does not exist.';
      end;
    end;

  if(MarkObj>10)and isFromOther then begin //若当前选择的对象超出列表框
    k:=Obj[MarkObj].ShowID;   p:=scrList.Position;  n:=pnlListBox.Height div 16;
    if(k<p)then p:=k-2 else if(p<0)then p:=0 else if(k>p)then p:=k-n+2;
    scrList.Position:=p;
    end;
  for i:=1 to j do begin
    k:=ObjListID[i].ID;  st:=ObjListID[i].State; 
    if ((st[1]='1')<>Obj[k].Hot)            or((st[2]='1')<>Obj[k].Dad)
     or((st[3]='1')<>Obj[k].ObjShow[Layer]) or((st[4]='1')<>Obj[k].Hide)
     or((st[5]='1')<>Obj[k].Son)
      then imgListDrawItem(k,i, ObjListID[i].Text, false,true);
    ObjListID[i].State:='00000';
    if(Obj[k].Hot)           then ObjListID[i].State[1]:='1';
    if(Obj[k].Dad)        then ObjListID[i].State[2]:='1';
    if(Obj[k].ObjShow[Layer])then ObjListID[i].State[3]:='1';
    if(Obj[k].Hide)          then ObjListID[i].State[4]:='1';
    if(Obj[k].Son)           then ObjListID[i].State[5]:='1';
    end;
end;

procedure TfrmMain.imgListMouseDown(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
  var i,j,k,n,Index, iID:integer;   st:string;
  label ReDraw;
begin
  if bAdd then exit;
  j:=ObjListID[0].ID;   if(j=0)then exit;  //列表行数
  index:=(Y div 16)+1;  imgList.Tag:=index; //记录行号，用于双击
  if(index>j)then exit;
  iID:=ObjListID[Index].ID;  //列表项所对应的对象ID
  if(bSelLink)and(MarkObj>10)and not bDouble then begin //选择关联构件
    posEdit.Tag:=0;
    Save( 0,MarkObj,1,false,true);
    SelLinkObj( iID );
    exit;
    end;
  if(x<16)and not bDouble then begin  //设置显隐状态
    Obj[iID].ObjShow[Layer]:=not Obj[iID].ObjShow[Layer];
    goto ReDraw;
    end;
  if bDouble then begin //双击时第二次点击 直接退出
    bDouble:=false;  Obj[iID].Hot:=true;
    end
  else if Button=mbRight then begin //右键 单选
    for i:=1 to j do Obj[ObjListID[i].ID].Hot:= false;
    Obj[iID].Hot:= true;
    end
  else if Button=mbLeft then
    Obj[iID].Hot:= not Obj[iID].Hot;

  MarkObj:=0; if Obj[iID].Hot then MarkObj:=iID;
  n:=0;
  for i:=0 to maxObj do selRec[i]:=0;
  for i:=1 to j do begin
    iID:=ObjListID[i].ID;
    with Obj[iID]do if Hot then begin
      inc(n); inc(SelRec[0]); inc(SelRec[Kind]); SelRec[20+n]:=iID;
      if(MarkObj=0)then MarkObj:=SelRec[20+n];
      end;
    pnlShow.Visible:=(MarkObj>0)and(not Obj[MarkObj].Hide)and(tlbMain.Visible);
    end; //if \
ReDraw:
    if(Obj[iID].Kind=14)and Assigned(Obj[iID].butID)then
      Obj[iID].butID.Visible:=bAll or Obj[iID].ObjShow[Layer];
  butProp.Down:=bNail;  ShowObjProp( MarkObj,0,0, true, bNail );  //显示构件属性框
  setProjection(false,false,23);
  CountObjNum(false, Button=mbRight); //该过程最后一行为imgListUpdate()
end;

procedure TfrmMain.imgListMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
begin
  if(x<16)then imgList.Cursor:=crHandPoint else imgList.Cursor:=crDefault;
end;

procedure TfrmMain.imgListDblClick(Sender: TObject);
begin
  if imgList.Tag> ObjListID[0].ID then exit;
  bDouble:=true;
  MarkObj:=ObjListID[imgList.Tag].ID;
  with Obj[MarkObj] do begin
    hot:=true;
    if not bC then begin
      if(Mode=16)then //仿射变换
        ShowControlBox(MarkObj,40,tabAffine)
      else begin
        if(Kind=10)and(Mode=1)then                 //文字
          ShowControlBox(MarkObj,10, tabText);
        if(Kind=10)and(Mode=2)then
          OpenPicture(MarkObj,true,true);          //图片
        if(Kind=11)and(not KeyDown)and(Mode=1)then //计算
          ShowControlBox(MarkObj, 11, tabCalc );
        if(Kind=13)and(not KeyDown)then            //迭代
          ShowControlBox(MarkObj, 13, tabIterate);
        if(Kind=14)then                            //控制按钮
          ShowControlBox(MarkObj,140+Mode, tabPath);
        if(Kind in[9,16])and(not KeyDown)then      //函数曲线曲面
          ShowControlBox(MarkObj, Kind, tabFunc);
        if(Kind=17)and(not KeyDown)then            //路径
          ShowControlBox( MarkObj,17, tabPath);
        end;
      end;
    end;//with
end;

procedure TfrmMain.scrListSet; //设置对象列表滚动条
begin
  scrList.Visible:=imgList.Height >pnlListBox.Height;
  if scrList.Visible then begin
    scrList.Max:=imgList.Height div 16;   scrList.Position:=0;
    scrList.PageSize   := pnlListBox.Height div 16+1;
    scrList.LargeChange:= pnlListBox.Height div 16-1;
    end;
end;
//====================== 更新对象列表 =======================
procedure TfrmMain.ObjListUpdate(IDx:integer; isNew:boolean);
  var i,j,kEdg,kDot, n,SS :integer; isSolid:boolean; st :string;
begin
  imgList.Top:=0;  imgList.Height:=0;  scrList.Position:=0;  scrList.PageSize:=1;
  n:=0;
  for i:= 11 to ObjCount do with Obj[i] do if(DelID=0)then begin
    if not((Kind in[1,2])and(Mode=13)or(Kind=1)and(Mode=4))then begin //非棱边 非交点
      inc(n);  ShowID:=n;   ObjListID[n].ID:=i;
      st:=IDtoItem(i);      ObjListID[n].Text:=st;
      imgListDrawItem(i,n,st,true,false);
      end;
    if(Kind=1)and(Mode=4)and(not D)then begin //交点
      inc(n);   ShowID:=n;  kDot:=0;
      ObjListID[n].ID:=i;  //if Obj[i].ObjShow[Layer]then ObjListID[n].State[3]:='1';
      str( n, st);
      for j:=0 to trunc(H) do if(not Obj[i+j].hide)then inc(kDot);
      st:=st +'.  ' +SwitchS(iLanguage,'交点','交點','Intersect Point ','')+'(' +itos(kDot) +')';
      imgListDrawItem(i,n,st,true,false);  ObjListID[n].Text:=st;
      end;

    isSolid:=(Kind=6)and((Mode in[3,5])or(Mode=4)and(S<100)) //棱台 正n棱台S>100
           or(Kind=4)and(Mode=6)and(W<100);//多面体 多边形
    if isSolid then begin
      SS:=S mod 10;
      if(Kind=4)and(Mode=6)then begin //多边形
        kEdg:=trunc(W); if(kEdg=99)then kEdg:=4;
        end;
      if(Kind=6)then //mode=3多面体, 4棱台 5凸壳
        case Mode of
          3:kEdg:=SolidEdge[SS]; //正多面体
          4:kEdg:=IIFi(SS=0,trunc(Obj[Link[0]].W)*3,SS*3);//S=0凸棱台 S>0正棱台
          5:kEdg:=(trunc(W)-2)*3; // 6:kEdg:=S*3;
          end;
      inc(n); ObjListID[n].ID:=i+1; str( n, st);
      st:=st+'.  '+SwitchS(iLanguage, '棱边','棱邊','Edges','')+'(' +itos(kEdg) +')';
      imgListDrawItem(i,n,st,true,false);  ObjListID[n].Text:=st;
      for j:=1 to kEdg do Obj[i+j].ShowID:=n;
      if(Kind=6)and(Mode in[3,4])or(Kind=4)and(Mode=6)and Rand then begin //
        if(Kind=6)then
          case Mode of
            3:kDot:=SolidVct[SS]; //正多面体
            4:kDot:=IIFi(SS=0,trunc(Obj[Link[0]].W),SS*2);
            end;
        if(Kind=4)then begin
          kDot:=trunc(W); if(kDot=99)then kDot:=4;
          end;
        inc(n); ObjListID[n].ID:=i+kEdg+1; str( n, st);
        st:=st+'.  '+SwitchS(iLanguage,'顶点','顶點','Vertexis','')+'(' +itos(kDot) +')';
        imgListDrawItem(i,n,st,true,false);  ObjListID[n].Text:=st;
        for j:=1 to kDot do Obj[i+kEdg+j].ShowID:=n;
        end;
      end;
    GetTextList( i); //标签
    end;//for ... with ...
  scrListSet;

  ObjListID[0].ID:=n; //对象列表项数
//  pnlListTitle.Caption:='[0/'+itos(n)+']';
end;

procedure TfrmMain.pnlListMouseDown(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
  x0:=x; y0:=y;
end;

procedure TfrmMain.pnlListMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
begin
  with pnlList do begin
    if(ssLeft in Shift)then begin
      if(Tag=1)or(Tag=2)then Width :=x; //拖动右边框
      if(Tag=2)or(Tag=3)then Height:=y; //拖动下边框
      if(Tag=4)then begin Left:=Left+x-x0; Width:=Width+x0-x; end;//拖动左边框
      if(Tag=5)then begin Top:=Top+y-y0; Height:=Height+y0-y; end;
      scrListSet; //设置滚动条
      imgList.Width:=Width;
      imgList.Picture.Bitmap.Width:=imgList.Width;
      end
    else begin
      if(y<Height-8)and(x>Width-16)then begin Cursor:=crSizeWE;   Tag:=1; end else
      if(y>Height-8)and(x>Width-16)then begin Cursor:=crSizeNWSE; Tag:=2; end else
      if(y>Height-8)and(x<Width-16)then begin Cursor:=crSizeNS;   Tag:=3; end else
      if(y<Height-8)and(x<8)       then begin Cursor:=crSizeWE;   Tag:=4; end else
      if(y<4)then begin Cursor:=crSizeNS;   Tag:=5; end else
      begin Cursor:=crDefault;  Tag:=0; end;
      end;
    end;
end;

//显示屏幕刷新速度
procedure TfrmMain.UpdateFPS(time:integer); {Updates the Frames per second counter}
begin
  if not cheFlash.Checked then exit;
  inc(frames);
  if time<OldTime then OldTime:=time; {If Time counter overflows, we don't want never to see a new FPS count again :)}
  if time>OldTime+FPSTime then Begin  {If time is past what it should be,update the counter}
    FPS:=frames*1000/(time-OldTime);  {Find FPS}
    frames:=0;    {Reset variables}
    OldTime:=time;
    end;
  pnlFPS.caption:=' '+ inttostr(round(FPS))+ ' fps';
  pnlFPS.Refresh;
end;
//========== 统计每种类型的构件数、设置作图按钮的状态 ================
procedure TfrmMain.CountObjNum(isFromObjList,isRight:boolean);
  var i,j,iK,jK,iM,jM, nL,nP :integer; st:string;  o1,e1,isBound,bTexture :bool;
      n0,n1,n2,n3,n4,n5,n6,n7,n9,n10,n11,n13,n14,n15,n16,n17,n18,n19,n21,n22 :integer;
  function DistanceDotLine(a,b:integer):single; //点到直线的距离
    begin
    if(Obj[a].Kind=2)then SwapI(a,b);
    result:=cgDistanceDotLine(Obj[a].p0,Obj[b].p0,Obj[b].Vec);
    end;
  function DotAtLine(a,b:integer):boolean;//点a与直线b共线
    begin result:=cgDotAtLine(Obj[a].p0, Obj[b].p0,Obj[b].p1); end;
  function DotAtPlane(a,b:integer):boolean;
    begin result:=EP(cgDotProduct(Obj[b].Vec, Obj[a].p0) + Obj[b].Vec.w); end;
begin  //d:点, l:线, c:圆, o:轨迹, f:约束点, g1:圆周上的约束点, e1:速度大于零的约束点
  n0 :=SelRec[0];  n1 :=SelRec[1];  n2 :=SelRec[2];  n3 :=SelRec[3];  n4 :=SelRec[4];
  n5 :=SelRec[5];  n6 :=SelRec[6];  n7 :=SelRec[7];  n9 :=SelRec[9];  n10:=SelRec[10];
  n11:=SelRec[11]; n15:=SelRec[15]; n16:=SelRec[16]; n17:=SelRec[17]; n19:=SelRec[19];
  n21:=SelRec[21]; n22:=SelRec[22];
  nL:=n2+n3+n4+n5++n15+n16+n17+n19;//线状构件合计
  nP:=n4+n6+n7+n9;//面状构件合计
//  if(n0=2)and(n1=1)and(Obj[n22].Kind=1)and()and()then//点线各一
  //  begin SwapI(n21,n22);   SwapI(SelRec[21],SelRec[22]); end;
  isBound:=(n0=2)and((n1=2)or(n1=1)and(n2=1))and((Obj[n21].Link[1]=n22)or(Obj[n22].Link[1]=n21));//选择了约束点和其父构建

  if(n0=2)and(n1=1)and(nL=1)then begin //点线合并
    if(Obj[n21].Mode=1)and(n21>1)then bMerge:=not(ObjIsDad(n21,n22));
    if(Obj[n22].Mode=1)and(n22>1)then bMerge:=not(ObjIsDad(n22,n21));
    end;
  bMerge:=false; bSplit:=false; bTexture:=false;
  if(n0=2)and((n1=2)or(n1=1)and((n4=1)or(nL=1) ))then //两点合并 点线合并 点面合并
    bMerge:=((Obj[n21].Mode=1)or(Obj[n22].Mode=1))and not(ObjIsDad(n21,n22)or ObjIsDad(n22,n21));
  bTexture:=(n0=2)and(n1+n4=1)and(n10+n11=1); //粘贴纹理
  if(n0=1)and(n1=1)then  //自我分离
    bSplit:=(Obj[n21].Mode>1)and(Obj[n21].Mode<>13)
          or(n21=1)and(getSonNum(n21,ObjCount)>1) //原点
          or(n21>10)and(Obj[n21].Mode=1)and(getSonNum(n21,ObjCount)>1); //子对象多于1个

  butJoin.Visible:=(bMerge or bSplit or bTexture); //合并/分离
  butJoin.ImageIndex:=IIFi(bMerge or bTexture,66,67);
  if butJoin.Visible then begin
    if bTexture then
      butJoin.Hint:=SwitchS(iLanguage,'合并','合并 ','Merge','')
    else
      case iLanguage of
      0:butJoin.Hint:=IIFs(not(bMerge or bSplit),'绑定/分离',IIFs(bMerge,'绑定/合并(Ctrl)','分离'));
      1:butJoin.Hint:=IIFs(bMerge,'绑定/合併(Ctrl)','分離');
      2:butJoin.Hint:=IIFs(bMerge,'Bound/Merge(Ctrl)','Split');
      end;
    butJoin.Tag:= IIFi((n0=2)and(n1=1)and(n10+n11=1), 43,81);
    menJoin.Tag:= butJoin.Tag;
    end;
  menJoin.Enabled:=butJoin.Visible; //合并/分离
  menJoin.Caption:=butJoin.Hint;
  menJoin.ImageIndex:=butJoin.ImageIndex; //合并/分离

  menLabel.Enabled:=(n0>0)and(SelRec[10]+SelRec[11]+SelRec[14]=0); //标签...
  menCutting.Enabled:=(n0=2)and(n4=1)and(n6+n7+n9=1); //切割

  pnlFont.Tag:=n21;
  if pnlFont.Visible then setFont(n21, n21>0, false); //设置字体工具
  pnlColor[18].Enabled:=n21>10;  pnlColor[18].Font.Color:=clGray* ord(n21<11);

  menCopyObj.Enabled:=n0>0;                   //复制对象
  menObjHide.Enabled:=n0>0;                   //隐藏对象
  menTagHide.Enabled:=n0>0;                   //隐藏标签
  menDotStyle.Enabled:=n1>0;                  //点型
  menLineStyle.Enabled:=(nL>0)or(butPen.Down);//线型
  menColor.Enabled:=(n0>0)or(butPen.Down); //颜色
    butPaintDel.Visible:=butPen.Down;
    butPaintRect.Visible:=butPen.Down;
    butPaintCircle.Visible:=butPen.Down;
  menTrace.Enabled:=(n0>0)and(n10+n11+n13+n14+n18=0); //踪迹
  but12.Visible :=(n0=nL)and(nL>0)or(n0=n4)and(n4>0)or (n0=n6)and(n6=1)and(Obj[n21].Mode=6)   //约束点
                or(n0=1)and(n7+n9=1);
  but13.Visible :=(n0=2)and((nL=1)or(n4=1))and(n1=1);          //最近点
  but14.Visible :=(n0=2)and((nL=2) or (nL=1)and(nP=1)); //交点
  but15.Visible :=(n0=2)and((n1=2)  //中点
                or(n1=1)and(n2=1)and not DotAtLine(n21, n22)
                or(n1=1)and((n3=1)or(n4=1))and not DotAtPlane(n21,n22))
                or(n0=1)and(nL=1)and(n19=0)   //直线中点
                or(n0=1)and(n3=1)and(Obj[n21].Mode in[2,4])//圆心
                or(n0=1)and(n6=1)and(Obj[n21].Mode>5)
                or(n0=1)and(n4=1) or(n0=3)and(n1=3);  //形心
  but16.Visible :=(n0=1)and(nL=1);  //等分点
  but21.Visible :=(n0=n1)and(n1>1)or(n0=1)and(n19=1)and(Obj[n21].Mode in[2,3]); //线段
  but22.Visible :=(n0=1)and(n1=1)   //向量
                or(n0=2)and(n2=2);  //向量运算
    if(n0=1)and(n1=1)then for i:=0 to 4 do popVector.Items[i].Enabled:= i<2;
    if(n0=2)and(n2=2)then for i:=0 to 4 do popVector.Items[i].Enabled:= i>1;
  but27.Visible :=but21.Visible;    //射线
  but28.Visible :=but21.Visible;    //直线
  but23.Visible :=(n0=2)and(n1=1)and(n2+n3+n4=1);//平行线
  but24.Visible :=(n0=2)and(n1+n2+n3+n4=2)and(n3+n4<2); //垂线
  but25.Visible :=(n0=3)and(n1=3) //三点之角分线
                or(n0=2)and(n1=2) //两点之中线
                or(n0=2)and(n2=2) //俩直线之角分线
                or(n0=3)and(n1=2)and(n4=1)  //两点之中垂线 与所选平面平行
                or(n0=2)and(n1=1)and(n2=1)and not DotAtLine(n21, n22)
                or(n0=2)and(n2=1)and(n4=1);
  but26.Visible :=(n0=2)and(n3+nP=2); //相贯线
  but29.Visible :=(n0=2)and(n1=1)and(n3+n5+n15+n16+n17+n19=1) //切线
                or(n0=2)and(n3=2)and(Obj[SelRec[21]].H=0)and(Obj[SelRec[22]].H=0);//公切线

  but31.Visible :=(n0=1)and(n1=1) or(n0=2)and((n1=2)or(n1=1)and(n2+n3+n4+n6=1)); //点向圆
  but32.Visible :=(n0=n1)and(n1=3)or (n0=1)and(n4=1)and((Obj[n21].W=103)or(Obj[n21].W=3)); //三点圆
  but33.Visible :=(n0=2)and(n1=1)and(n2+n3=1)and not DotAtLine(n21, n22)and(DistanceDotLine(n21,n22)>0.1) //点线距离
                or(n0=2)and(n1=2)or (n0=3)and((n1=3)or(n1=2)and(n2+n3+n4=1)); //点向弧
  but34.Visible :=(n0=n1)and(n1=3);    //三点弧

  but51.Visible :=(n0=2)and((n1=2)and((Obj[n21].Mode=2)or(Obj[n22].Mode=2)) //轨迹线
                or(n1=1)and(n11=1))and(ObjIsDad(n22,n21)or ObjIsDad(n21,n22))
                or(n0=1)and(n1=1)and(Obj[n21].Mode=2)
                  and not((Obj[ Obj[n21].Link[1] ].Kind=4)and not(Obj[n21].D));
  but171.Visible:=(n0=n1+nL)and(n0>1);//路径

  but41.Visible :=but32.Visible; //三点面
  but42.Visible :=(n0=2)and(n1=1)and(n2=1)and(not DotAtLine(n21, n22) or not DotAtLine(n22, n21)) //点线面
                or(n0=2)and(n2=2); //两线面
  but43.Visible :=(n0=2)and(n1=1)and(n2+n3+n4=1)  //平行面
                or(n0=3)and((n1=1)and(n2=2)or(n1=2)and(n2=1));
  but44.Visible :=(n0=n1)and(n1>1) //两点之垂面
                or(n0=n1+n2)and(n1=1)and(n2=1) //点线之垂面
                or(n0=n1+n3+n4)and(n1=2)and((n4=1)or(n3=1)) //过两点之垂面
                or(n0=n1+n2+n3+n4)and(n1=1)and(n2=1)and((n4=1)or(n3=1)) //平行于直线之垂面
                or(n0=n1+n3+n4)and(n0=3)and(n1=1);//公垂面
  but45.Visible :=(n0=2)and(n1=2) //两点之中面
                or(n0=2)and(n2=2) //两线之中面
                or(n0=2)and(n1=1)and(n2=1)and not DotAtLine(n21, n22)//点线之中面
                or(n0=2)and(n1=1)and(n3+n4=1)and not DotAtPlane(n21, n22) //点面或点圆之中面
                or(n0=2)and(n2=1)and(n3+n4=1) //线面之中面
                or(n0=2)and(n3+n4=2) //两面之中面
                or(n0=3)and(n1=3); //三点之中面
  but46.Visible :=(n0=2)and(n1=2)or(n0=2)and(n1=1)and((n2=1)or(n4=1))  //正多边形
                or(n0=n1)and(n1>3); //凸多边形

  but60.Visible :=(n0=1)and(n4=1);//and(Obj[n21].W<100);//凸棱台
  but62.Visible :=(n0=1)and(n1=1)or(n0=2)and((n1=2)or(n1=1)and(n2+n4=1)); //圆台
  but63.Visible :=but62.Visible; //棱台
  but64.Visible :=but62.Visible or(n0>3)and(n0=n1); //多面体
  but61.Visible :=but62.Visible or(n0=3)and(n1=3) //点法球 三点球
                or(n0=1)and(n4=1)and(Obj[SelRec[21]].Mode<3)
                or(n0=4)and(n1=4) //四点球
                or(n0=1)and(n6=1)and((Obj[n21].Mode=5)and(Obj[n21].W=4))or((Obj[n21].Mode=3)and(Obj[n21].S=1));
  but71.Visible :=(n0=2)and(n2>0)and(nL=2);  //旋转曲面 必须有一条直线
               // and not( (Obj[i].Mode=6)and not(Obj[i].D) or(Obj[j].Mode=6)and not(Obj[j].D)));//不能是凸多面体
  but72.Visible :=(n0=2)and( (n1=1)and(n2=1)and not DotAtLine(n21, n22) //直纹曲面 点和直线
                or(n1=1)and(n2=0)and(nL+n4+n7+n9=1)    //点和线(非直线)
                or(nL=2) );    //两线(包括两平面)

  i:=SelRec[21]; iK:=Obj[i].Kind; iM:=Obj[i].Mode;
  j:=SelRec[22]; jK:=Obj[j].Kind; jM:=Obj[j].Mode;
  but74.Visible :=(n0=2)and( //轨迹曲面
                  (nL=1)and(n15=0)and(n1+n11=1)
                 or(n1=2)and((iM=2)and(Obj[Obj[i].Link[1]].Kind=4)or(jM=2)and(Obj[Obj[j].Link[1]].Kind=4)))
               and((iK in[1,11])and(iM=2)and ObjIsParent(i,j)or(jK in[1,11])and(jM=2)and ObjIsParent(j,i));

  butSize03.Visible:=(n0=1)and((n3=1)or(n4=1)or(n6=1)and(Obj[i].Mode in[1..4,6])or(n7=1)); //面积
  butSize04.Visible:=(n0=1)and(n6=1)and(Obj[i].Mode in[1..4,6]); //体积
  butSize05.Visible:=(n0=2)and((n1=1)and(n2+n4=1)or(n1=2)); //距离
  butSize06.Visible:=(n0=1)and(n3=1)and(Obj[n21].Mode in[3,4] ) //圆弧角
                   or(n0=2)and((n2=2)or(n4=2)or(n2=1)and(n4=1)) //线面角 线线角 面面角
                   or(n0=3)and((n1=3)or(n1=2)and(n2=1));//三点角 
  butSize07.Visible:=(n0=2)and(nL=2)or(n0=3)and(n1=3);//比值
  butSize08.Visible:=(n0=1)and(nL=1); //长度 周长
  butSize09.Visible:=(n0=2)and(n2=1)and(n4=1);//斜率
  butSize13.Visible:=(n0=1)and(n1=1)and(Obj[i].Mode=2)
                   or(n0=2)and(n1=1)and(nL=1); //点的值
  butSize14.Visible:=(n0=1)and((n3=1)or(n6=1)and(Obj[i].Mode<5)); //直径
  butSize15.Visible:=(n0=1)and(n1=1);//坐标
  butSize16.Visible:=(n0=1)and(n2+n3+n4=1)or(n0=2)and(n1=2);//向量
  butSize17.Visible:=(n0=2)and(n2+n3+n4+n11=2);//向量运算
  butSize19.Visible:=(n0=1)and((n2+n4=1)or(n3=1)and EP(Obj[i].H));// 方程

  butSize.Visible:=butSize03.Visible or butSize04.Visible or butSize05.Visible //度量
                or butSize06.Visible or butSize07.Visible or butSize08.Visible
                or butSize09.Visible or butSize13.Visible or butSize14.Visible
                or butSize15.Visible or butSize16.Visible or butSize17.Visible;
  tlbShort.Refresh;
  menMark3.Enabled:=menMark3.Checked or(n0=1)and(n1+n2+n3+n4=1); //3标记对称中心/轴/平面
  menMark4.Enabled:=menMark4.Checked or(n0=1)and(n2=1)  or(n0=2)and(n1=2);  //4标记向量
  menMark5.Enabled:=menMark5.Checked or(n0=1)and(n2+n11=1)
                or(n0=2)and((n1=1)and(n2+n3+n4=1)or(n1=2)or(n2=2)); //5标记距离
  menMark6.Enabled:=menMark6.Checked or(n0=1)and(n11=1)       //6标记角度
                    or(n0=2)and(n2+n3+n4=2) or(n0=3)and((n1=3)or(n1=2)and(n2=1));
  menMark7.Enabled:=menMark7.Checked  or(n0=1)and(n11=1)   //7标记比
                    or(n0=2)and(n2=2) or(n0=3)and(n1=3)
                    or(n0=2)and(n1=1)and(n2+n4=1)
                    or(n0=2)and(n0=n2+n3+n11);
  men128.Visible:=(MarkTrans[8,0]>0) and(MarkTrans[8,1]>0) //自定义变换规则
                and(Obj[MarkTrans[8,0]].DelID=0) and(Obj[MarkTrans[8,1]].DelID=0);

  if(n0=1)or(n0=0)and(MarkTrans[3,0]>0)then begin
    i:=MarkTrans[3,0]; if(i>0)then i:=Obj[i].Kind;
    if(n1=1)or(n0=0)and(i=1)then {标 记 点}menMark3.Caption:= SwitchS(iLanguage,'标记中心(&M) ','標記中心(&M) ','&Mark Center','');
    if(n2=1)or(n0=0)and(i=2)then {标记轴线}menMark3.Caption:= SwitchS(iLanguage,'标记轴(&M) ','標記軸(&M) ','&Mark Axis','');
    if(n3+n4=1)or(n0=0)and(i in[3,4])then{标记平面}menMark3.Caption:= SwitchS(iLanguage,'标记平面(&M) ','標記平面(&M) ','&Mark Plane','');
    end;
  men172.Enabled:=false;  //三视图
    if(n0>0)then begin
      for i:=1 to n0 do with Obj[SelRec[20+i]] do
        if(Kind in[1..7, 15,16,19])or(Kind=17)and(Mode=1)then men172.Enabled:=true;
      end;
  if(n0=1)and(n1+n2+n4+n6=1)then begin //视点移到直线端点或平面上
    st:='...';  
    st:=Obj[SelRec[21]].Tag;
    if(trim(st)='')then st:='{#}'+ItoS(Obj[SelRec[21]].ShowID); //{#} 就是字符#
    menViewer.Caption:=SwitchS(iLanguage,'面对平面 (&Q)','面對平面 (&Q)','&Face to Plane ','')+st;
    end
  else begin
    menViewer.Caption:=SwitchS(iLanguage,'恢复 (&Q)','恢復 (&Q)','&Recovery','')+st;
    menViewer.Checked:=false;
    end;
  menMark8.Enabled:=false;    //自定义变换
  if(n0=2)and(n1=2)then begin
    if(n21>n22)then SwapI(n21,n22);
    for i:=n21 to 21 do Obj[i].iT:=0;
    Obj[n21].iT:=n21;
    for i:=n21+1 to n22 do with Obj[i] do if not(i in[8..10])then begin
      j:=-1;
      repeat inc(j); if(Link[j]>0)and(Obj[Link[j]].iT=n21)then iT:=n21;
      until(Link[j]=n21)or(j=LinkTime);
      end;
    if(Obj[n22].iT=n21)then menMark8.Enabled:=true; //自定义变换
    end;
  e1:=false; o1:=false;
  for i:= 11 to ObjCount do with Obj[i] do begin
    if(Kind=1)and(Mode=2)and(H<>0)then e1:=true; //移动步长>0的约束点
    if(Kind=5)then o1:=true;//轨迹线
    end;
  menSport.Enabled:=e1;  menStart.Enabled:=o1;
  i:=0; if(n0>0)then begin repeat inc(i); until(i>n0)or(SelRec[20+i]<11); end;
  menObjDel.Enabled:=(n0>0)and(i>n0);
  if n0=1 then with Obj[SelRec[21]]do
    st:=stMode[Kind,Mode]+' '+Tag+ SwitchS(iLanguage,' 被选择',' 被選擇',' be Selected','')
  else if n0>1 then st:=ItoS(n0)+SwitchS(iLanguage,' 个对象被选择',' 个對象被選擇',' Components Selected','')
  else st:='';
  stbBar.Caption:=st;
  j:=ObjListID[0].ID; // cmbTag.Items.Count;
  i:=SelRec[0]; if(i>j)then i:=j-1;
//  if(j>0)then pnlListTitle.Caption:='['+itos(i)+'/'+itos(j-1)+']';
//  if not bMove and(SelRec[0]<>1)then cmbTag.ItemIndex:=0;
  MarkObj:=SelRec[20+n0];
  if(MarkObj=0)or(MarkObj>10)then imgListUpdate( MarkObj, Obj[MarkObj].ShowID, true,bL,bR or isRight); //刷新对象列表
end;
//=============== 显示添加构件步骤 ================
function TfrmMain.SetHint( kind,mode,selNum :integer) :string;
  var j,jK:integer; b,c:bool; s:string;
  function Switch(t:integer; s1,s2,s3:string):string;
    begin case t of 0:result:=s1; 1:result:=s2; 2:result:=s3; end; end;
begin
  if not cheHint.Checked then exit;
  j:=Obj[ObjCount].Link[0];   jK:=Obj[j].Kind;
  b:=(selNum=0);  c:=selNum=1;
  if(Kind<>11)then begin //变换
    if iLanguage=0 then case Mode of
      7:s:='2-选择直线、圆或平面'; //垂点
      8:s:='2-选择对称轴(点、直线或平面)'; //对称点
      9:s:=Switch(selNum,'','2-选择点或轴线','3-选择向量对象'); //旋转点
     10:s:='2-选择缩放中心'; //复制
     12:s:=Switch(selNum,'','2-选择向量起点或直线','3-选择向量终点'); //向量变换
     14,20:s:='选择对象';
     15:s:='2-选择反演中心';
      end
    else if iLanguage=1 then case Mode of
      7:s:='2-選擇直線、圓或平面'; //垂点
      8:s:='2-選擇對稱軸(點、直線或平面)'; //对称点
      9:s:=Switch(selNum,'','2-選額點点或軸線','3-選擇向量對象'); //旋转点
     10:s:='2-選擇縮放中心'; //复制
     12:s:=Switch(selNum,'','2-選擇向量起點或直線','3-選擇向量终點'); //向量变换
     14,20:s:='選擇對象';
     15:s:='2-選擇反演中心';
      end
    else if iLanguage=2 then case Mode of
      7:s:='2-Select a Line, Circle or Plane'; //垂点
      8:s:='2-Select a Symmetrical Axis (Point, Line or Plane)'; //对称点
      9:s:=Switch(selNum,'','2-Select a Axis','3-Select a Vector'); //旋转点
     10:s:='2-Select a Scale Center Point'; //复制
     12:s:=Switch(selNum,'','2-Select First Point or Line','3-Select Second Point'); //向量变换
     14,20:s:='Select a Object';
     15:s:='2-Select Center of Inversion';
      end;
    end;
  case kind of
  1:case mode of //点
    2:s:=SwitchS(iLanguage,'选择约束构件','選擇約束構件', 'Select a Component with Bount',''); //约束点
    3:case iLanguage of  //最近点
      0:s:=IIFs(b, '1-选择基点', '2-选择平面、直线或曲线');
      1:s:=IIFs(b, '1-選擇基點', '2-選擇平面、直線或曲線');
      2:s:=IIFs(b,'1-Select a Point','2-Select a Plane or Line or Curve');
      end;
    4:case iLanguage of
      0:s:=IIFs(b, '1-选择直线或曲线', //交点
          '2-选择'+IIFs(jK=2,'直线、','')+'曲线、平面、实体或曲面');
      1:s:=IIFs(b, '1-選擇直線或曲線', //交点
          '2-選擇'+IIFs(jK=2,'直線、','')+'曲線、平面、實體或曲面');
      2:s:=IIFs(b,'1-Select a Line or Curve',
          '2-Select'+IIFs(jK=2,'Line,','')+'Curve,Plane,Solid or Surface');
      end;
    5:case iLanguage of
      0:s:=IIFs(b, '1-选择点、直线、圆', '2-选择'+IIFs(jK=2,'直线','点或直线、平面'));
      1:s:=IIFs(b, '1-選擇點、直線、圓', '2-選擇'+IIFs(jK=2,'直線','點或直線、平面'));
      2:s:=IIFs(b,'1-Select a Point,Line or Circle', '2-Select a Point,Line or Plane');
      end;
    6:s:=SwitchS( iLanguage,'选择直线或曲线','選擇直線或曲线','Select a Point,Line or Circle','');
    end;
  2:case mode of //直线
    1:case iLanguage of //两点式
      0:s:=IIFs(b, '1-选择起点', '2-选择终点');
      1:s:=IIFs(b, '1-選擇起點', '2-選擇終點');
      2:s:=IIFs(b,'1-Select Start Point','2-Select End Point');
      end;
    2:begin //向量
      if(Obj[ObjCount].R<2)then
        s:=SwitchS( iLanguage,'选择基点','選擇基點','Select a Base Point','')
      else
        s:=SwitchS( iLanguage,'选择两条直线','選擇两条直線','Select Tow Line','') //向量
      end;
    3:case iLanguage of  //平行线
      0:s:=IIFs(b, '1-选择基点', '2-选择平行直线');
      1:s:=IIFs(b, '1-選擇基點', '2-選擇平行直線');
      2:s:=IIFs(b,'1-Select a Base Point','2-Select a Parallale Line');
      end;
    4:case iLanguage of //垂线
      0:s:=Switch(selNum, '1-选择点或直线', '2-选择'+IIFs(jK=2,'直线','点、直线或平面'),'3-选择直线或平面');
      1:s:=Switch(selNum, '1-選擇點或直線', '2-選擇'+IIFs(jK=2,'直線','點、直線或平面'),'3-選擇直線或平面');
      2:s:=Switch(selNum, '1-Select a Point or Line','2-Select a '+IIFs(jK=2,'Line','Line or Plane'),'Select a Line or Plane');
      end;
    5:case iLanguage of //中线
      0:s:=Switch(selNum,'1-选择点或直线','2-选择'+IIFs(jK=1,'第二点或直线','直线或平面'),'3-选择第三点');
      1:s:=Switch(selNum,'1-選擇點或直線','2-選擇'+IIFs(jK=1,'第二點或直線','直線或平面'),'3-選擇第三點');
      2:s:=Switch(selNum,'1-Select a Point or Line','2-Select '+IIFs(jK=1,'second Point or a Line','a Line or Plane'),'3-Select the third Point');
      end;
    6:case iLanguage of //交惯线
      0:s:=Switch(selNum,'1-选择平面、实体、曲面或圆锥曲线', '2-选择'+IIFs(jK=4,'平面、','')+'实体或曲面' ,'');
      1:s:=Switch(selNum,'1-選擇平面、實體或曲面', '2-選擇'+IIFs(jK=4,'平面、','')+'實體或曲面' ,'');
      2:s:=Switch(selNum,'1-Select a Plane,Solid,Surface or Conic Curve','2-Select a '+IIFs(jK=4,'Plane,','')+'Solid or Surface','');
      end;
   19:case iLanguage of //切线
      0:s:=Switch(selNum, '1-选择点或曲线', '2-选择'+IIFs(jK=3,'圆',IIFs(jK=1,'曲线','点')),'');
      1:s:=Switch(selNum, '1-選擇點或曲線', '2-選擇'+IIFs(jK=3,'圓',IIFs(jK=1,'曲线','點')),'');
      2:s:=Switch(selNum, '1-Select a Point or Curve','2-Select a '+IIFs(jK=3,'圆', IIFs(jK=1,'Curve','Point')),'');
      end;
    end;
  3:case mode of //圆
    1:case iLanguage of //点法圆
        0:s:=IIFs(b, '1-选择圆心或轴线', IIFs(jK=1,'2-选择法线(点、直线或平面)','2-选择圆周上的点'));
        1:s:=IIFs(b, '1-选择圓心或轴线', IIFs(jK=1,'2-選擇法線(點、直線或平面)','2-選擇圓周上的點'));
        2:s:=IIFs(b,'1-Select Circle Center or Axis','2-Select a Normal Line(Point,Line or Plane)');
        end;
    2:case iLanguage of //三点圆
      0:s:=Switch(selNum, '1-选择第一点', '2-选择第二点','3-选择第三点');
      1:s:=Switch(selNum, '1-選擇第一點', '2-选择第二点','3-選擇第三點');
      2:s:=Switch(selNum,'1-Select First Point', '2-Select Second Point','3-Select Third Point');
      end;
    3:case iLanguage of //点法弧
      0:s:=Switch(selNum, '1-选择起点', '2-选择轴线(点、直线、圆)','3-选择终点');
      1:s:=Switch(selNum, '1-選擇起點', '2-選擇法線(點、直線、圓)','3-選擇終點');
      2:s:=Switch(selNum, '1-Select a Startpoint','2-Select a Point or Line or Circle','3-Select a Endpoint');
      end;
    4:case iLanguage of //三点弧
      0:s:=Switch(selNum, '1-选择第一点', '2-选择第二点','3-选择第三点');
      1:s:=Switch(selNum, '1-選擇第一點', '2-選擇第二點','3-選擇第三點');
      2:s:=Switch(selNum,'1-Select First Point', '2-Select Second Point','3-Select Third Point');
      end;
    end;
  4:case mode of //平面
    1:case iLanguage of
      0:s:=Switch(selNum, '1-选择第一点', '2-选择第二点','3-选择第三点');
      1:s:=Switch(selNum, '1-選擇第一點', '2-選擇第二點','3-選擇第三點');
      2:s:=Switch(selNum,'1-Select First Point', '2-Select Second Point','3-Select Third Point');
      end;
    2:case iLanguage of
      0:s:=IIFs(b, '1-选择点或直线', '2-选择点或直线');
      1:s:=IIFs(b, '1-選擇點或直線', '2-選擇點或直線');
      2:s:=IIFs(b, '1-Select a Point or Line','2-Select a Point or Line');
      end;
    3:case iLanguage of
      0:s:=Switch(selNum, '1-选择基点', '2-选择直线或平面','3-选择点或直线');
      1:s:=Switch(selNum, '1-選擇基点', '2-选择直线或平面','3-选择点或直线');
      2:s:=Switch(selNum, '1-Select a Base Point','2-Select a Line or Plane','3-Select a Point or Line');
      end;
    4:case iLanguage of
      0:s:=Switch(selNum, '1-选择基点', '2-选择点、直线或平面','3-选择点、直线或平面');
      1:s:=Switch(selNum, '1-選擇基點', '2-選擇點、直線或平面','3-選擇點、直線或平面');
      2:s:=Switch(selNum, '1-Select a Base Point','2-Select a Line or Plane','3-Select a Point, Line or Plane');
      end;
    5:case iLanguage of
      0:s:=Switch(selNum, '1-选择点、直线、平面', '2-选择'+IIFs(jK=1,'点、平面','平面'),'3-选择定位点');
      1:s:=Switch(selNum, '1-選擇點、直線、平面', '2-選擇'+IIFs(jK=1,'點、平面','平面'),'3-選擇定位點');
      2:s:=Switch(selNum, '1-Select a Point,Line or Plane','2-Select '+IIfs(jK=1,'Point,Plane','Plane'),'3-Select a Point');
      end;
    6:case iLanguage of
      0:s:=IIFs(not Obj[ObjCount].Rand,'逐点选取多边形的顶点(按右键结束选取)',IIFs(b,'1-选择基点','2-选择法线(点、直线或平面)'));
      1:s:=IIFs(not Obj[ObjCount].Rand,'逐点选取多边形的顶点(按右键结束选取)',IIFs(b,'1-選擇基點','2-選擇法線(點、直線或平面)'));
      2:s:=IIFs(not Obj[ObjCount].Rand,'Select Vertexes of Polygon(Right Click to Finish)',
        IIFs(b,'1-Select a Base Point','2-Select a Normal Line (Point,Line or Plane)'));
      end;
    end;
  5:if(Mode<7)then //轨迹
    case iLanguage of
    0:s:=IIFs(b, '1-选择轨迹点', '2-选择限制点(步长>0的约束点)');
    1:s:=IIFs(b, '1-選擇軌跡點', '2-選擇限制點(步長>0的約束點)');
    2:s:=IIFs(b,'1-Select Point of Locus','2-Select a Limited Point (Step must be over zero)');
    end;
  6:if(Mode<7)then case Mode of
    4:if(Obj[ObjCount].S=0)
      then s:=Switch(iLanguage,'选择多边形','選擇多边形','Select a Polygon') //凸棱台
      else s:=Switch(iLanguage,'选择基点和法线','選擇基點和法線','Select a Base Point and a Normal Line');
    5:s:=Switch(iLanguage,'逐点选取多面体的顶点(按右键结束选取)','逐點選取多面體的顶點(按右键結束選取)','Select Vertexes of Polydron(Right Click to Finish)'); //凸壳
    6:s:=Switch(iLanguage,'选择三点...','選擇三點...','Select 3 Points...'); //三点圆
    else
      case iLanguage of
      0:s:=IIFs(b, '1-选择中心点','2-选择法线(点、直线、圆或平面)');
      1:s:=IIFs(b, '1-選擇中心點','2-選擇法線(點、直線、圓或平面)');
      2:s:=IIFs(b,'1-Select a Center Point','2-Select a Normal Line (Point,Line,Circle or Plane)');
      end;
    end;
  7:case Mode of //曲面
    1:case iLanguage of  //旋转曲面
      0:s:=IIFs(b, '1-选择母线(直线、曲线)', '2-选择轴线(直线)');
      1:s:=IIFs(b, '1-選擇母線(直線、曲線)', '2-選擇軸線(直線)');
      2:s:=IIFs(b,'1-Select a Bus(Line or Curve)','2-Select a Axis(Line)');
      end;
    2:case iLanguage of  //直纹曲面
      0:s:=IIFs(b, '1-选择第一条边际线(点、', '2-选择第二条边际线(')+'直线、圆(圆弧)、轨迹线或相贯线)';
      1:s:=IIFs(b, '1-選擇第一条邊際線(點、', '2-選擇第二条邊際線(')+'直線、圆(圓弧)、軌跡線或相贯線)';
      2:s:=IIFs(b,'1-Select First Side Line(Point,','2-Select Second Side Line(')+'Line,Circle(Arc),Locus or Intersection Line)'
      end;
    3:case iLanguage of  //
      0:s:=IIFs(b, '1-选择第一条轨迹线','2-选择第二条轨迹线');
      1:s:=IIFs(b, '1-選擇第一条軌跡線','2-選擇第二条軌跡線');
      2:s:=IIFs(b,'1-Select First Locus','2-Select Second Locus');
      end;
    4:case iLanguage of  //轨迹面
      0:s:=IIFs(b, '1-选择轨迹点或母线', '2-选择约束点');
      1:s:=IIFs(b, '1-選擇軌跡點或母線', '2-選擇約束點');
      2:s:=IIFs(b,'1-Select a Bus(Line)','2-Select a Bound Point');
      end;
    end;
  8:case iLanguage of //合并/分离
    0:s:=IIFs(b, '1-选择基点2','2-选择直线、曲线、轨迹线...');
    1:s:=IIFs(b, '1-選擇基點','2-選擇直綫、曲綫、軌跡綫...)');
    2:s:=IIFs(b,'1-Select a Base Point','2-Select a Line, Curve, Locus)');
    end;
 11:case Mode of //度量、
    3:s:=Switch(iLanguage,'选择圆、平面、曲面或三维实体','選擇圓、平面、曲面或三維實體','Select a Circle,Plane,Curve Surface or Solid'); //面积
    4:s:=Switch(iLanguage,'选择三维实体','選擇三维實體','Select a Solid'); //体积
    5:case iLanguage of //距离
      0:s:=IIFs(b,'1-选择点或直线', '2-选择'+IIFs(jK=1,'点、直线或平面','直线'));
      1:s:=IIFs(b,'1-選擇點或直線', '2-選擇'+IIFs(jK=1,'點、直線或平面','直線'));
      2:s:=IIFs(b,'1-Select a Point or Line','2-Select '+IIfs(jK=1,'Point,Line or Plane','Line'));
      end;
    6:if b then s:=Switch(iLanguage,'1-选择点、直线或平面','1-選擇點、直再或平面','1-Select a Point,Line or Plane')
      else case iLanguage of //角度
          0:s:=IIFs(c,'2-选择'+IIFs(jK=1,'第二点','直线或平面'),'3-选择第三点');
          1:s:=IIFs(c,'2-選擇'+IIFs(jK=1,'第二點','直線或平面'),'3-選擇第三點');
          2:s:=IIFs(c,'2-Select '+IIFs(jK=1,'Second Point','Line or Plane'),'3-Select Third Point');
           end;
    7:if b then s:=Switch(iLanguage,'1-选择点、直线或圆(圆弧)','1-選擇點、直想或圓(圓弧)','1-Select a Point,Line or Circle(Arc)')
      else case iLanguage of //比值
          0:s:=IIFs(c,'2-选择'+IIFs(jK=1,'第二点','直线或圆(圆弧)'),'3-选择第三点');
          1:s:=IIFs(c,'2-選擇'+IIFs(jK=1,'第二點','直線或圓(圓弧)'),'3-選擇第三點');
          2:s:=IIFs(c,'2-Select '+IIfs(jK=1,'Second Point','Line or Circle(Arc)'),'3-Select Third Point');
           end;
    8:s:=Switch(iLanguage,'选择直线、曲线或平面','選擇直線、曲線或平面', 'Select a Line,Curve or Plane'); //长度
    9:case iLanguage of //斜率
      0:s:=IIFs(b,'1-选择直线', '2-选择平面');
      1:s:=IIFs(b,'1-選擇直線', '2-選擇平面');
      2:s:=IIFs(b,'1-Select a Line','2-Select a Plane');
      end;
    13:if b then s:=Switch(iLanguage,'1-选择点','1-選擇點','Select a Bound Point')
            else s:=Switch(iLanguage,'2-选择线状构件','2-選擇線状構件','Select a Line'); //点的值
    14:s:=Switch(iLanguage,'选择圆(弧)或三维实体','選擇圓(弧)或三維實體','Select a Circle(Arc) or Solid'); //直径
    15:s:=Switch(iLanguage,'选择点','選擇點','Select a Point'); //坐标值
    16:case iLanguage of //向量
      0:s:=Switch(selNum,'1-选择向量起点或直线、圆或平面','2-选择向量终点','');
      1:s:=Switch(selNum,'1-選擇向量起點或直線、圓或平面','2-選擇向量终點','');
      2:s:=Switch(selNum,'1-Select a Startpoint, Line or Circle','2-Select a Endpoint','');
      end;
    19:s:=Switch(iLanguage,'选择直线、圆或平面','選擇直線、圓或平面','Select a Line,Circle(Arc) or Plane'); //坐标
    end;
 12:s:=Switch(iLanguage,'选择对象','選擇對象','Select a Object');  //复制构件
 13:s:=Switch(iLanguage,IIFs(b, '1-选择源像点','2-选择映像点'),IIFs(b, '1-選擇源像點','2-選擇映像點'), IIFs(b,'1-Select a Source Point','2-Select Destinate Point'));
 14:s:=Switch(iLanguage,'选择约束点','選擇約束點','Select a Bound Point');//控制
 17:if(Mode<7)then s:=Switch(iLanguage,'选取路径构件(按右键结束选取','選擇路經構件(按右鍵結束選取','Select the Objects...');
 18:s:=Switch(iLanguage,'选择直线或平面','選擇直線或平面','Select Line');//标记
 19:case Mode of
    1:     if b then s:=Switch(iLanguage,'1-选择第一点','1-選擇第一點','1-Select First Point')
      else if c then s:=Switch(iLanguage,'2-选择第二点','2-選擇第二點','2-Select Second Point')
                else s:=Switch(iLanguage,'3-选择第三点','3-選擇第三點','3-Select Thied Point');
    2:if b then s:=Switch(iLanguage,'1-选择准线','1-選擇準線','1-Select a Directrix')
           else s:=Switch(iLanguage,'2-选择焦点','2-選擇焦點','2-Select a Focus')
    end;
  end;
  result:= ' '+stMode[Kind,Mode] +': '+ s+ '...';
end;
//===================== 添加构件  =======================
function TfrmMain.getObjName( N:integer):integer; //获取新建对象的名称
  var i,pos :integer;
begin
  result:=10; pos:=10; i:=0; if(N<1)then exit;
  repeat
    inc( pos); i:=0;
    if not ObjNameStack[ pos] then begin
      repeat inc(i); until(i=N)or ObjNameStack[ pos+i];
      if(i<N)then pos:=pos+i;
      end;
   until(i=N)or(pos+i>=maxObj);
  if(pos+i)>=maxObj then begin
    MyMessage( SwitchS( iLanguage,' 对象数目超限！', ' 對象數目超限！ ',' The number of objects is over limite! ',''));
    end;
  for i:=0 to N-1 do ObjNameStack[ pos+i]:=true;
  result:=pos;
end;

function TfrmMain.AddingCross(ID,ObjNum:integer):integer; //添加交点
  var j,k,Ka,Kb :integer;
begin
  with Obj[ID]do begin
    Ka:=Obj[Link[0]].Kind; Kb:=Obj[Link[1]].Kind;
    ObjNameStack[Name]:=false;
    k:=getCrossNum(Ka,Kb);
    Name:=getObjName(k+1);
    edited:=true;     D:=false;
    Tag:=getTag(ID);  H:=k;
    TagN:=Obj[1].info[1];  TagS:=trunc(Obj[1].TagP.z);
    TagC:=Obj[1].Link[10]; TagT:=Obj[1].TagT;
    if(K>0)then for j:=1 to k do begin //共轭交点之属性
      Obj[ID+j]:=Obj[ID];   //共轭交点
      with Obj[ID+j] do begin
        Name:=Obj[ID].Name+j;  //inc( backObj.maxName);  Name:=backObj.maxName;
        ObjNameStack[Name]:=true;
        Tag:=Tag+'['+itos(j)+']';//标签
        texTag:=0;      D:=true; //不单独计算
        Link[2]:=ID;    LinkName[2]:=Obj[ID].Name; //跟第一个交点链接
        TagN:=Obj[1].info[1];  TagS:=trunc(Obj[1].TagP.z);
        TagC:=Obj[1].Link[10]; TagT:=Obj[1].TagT;
        end;
      end;
    result:=ObjNum+k;
  end;//with
end;
function TfrmMain.AddingEdges(ID,ObjNum:integer):integer; //添加实体时附加的棱边
  var i,j :integer;  kEdge,kVct:integer;
begin
  getEdges(ID, kEdge,kVct); //棱边数 顶点数
  with Obj[ID] do begin
  for j:= 1 to kEdge do with Obj[ID+j] do begin //添加棱边
    for i:=0 to LayerTime do begin ObjShow[i]:=true; TagShow[i]:=false; end;
    CleanLink(ID+j,0); // for i:=0 to LinkTime do begin Link[i]:=0; LinkName[i]:=0; end;
    Name:=getObjName(1);  parent:=ID;
    Link[0]:=ID;   LinkName[0]:=Obj[ID].Name;
    Kind:=2; Mode:=13;    Tag:=Obj[ID].Tag+'_'+itos(j);  texTag:=0;
    TagN:=Obj[ID].TagN;   TagS:=Obj[ID].TagS;
    TagC:=Obj[ID].TagC;   TagT:=Obj[ID].TagT;
    if Obj[ID].Kind=4 then W:=Obj[1].p1.w;
    if Obj[ID].Kind=6 then W:=Obj[1].p2.x;
    S:=0; H:=0; F:=false; U:=false; hot:=false; Lock:=false;  hide:=false; delID:=0;
    Color:= Obj[ID].ColorB;  Color.A:=1;
    ColorB:=Color; TagP.z:=0.5;
    end;
  if(Kind=6)and(Mode in[3,4,6])or(Kind=4)and(Mode=6)and Rand then //多面体多边形添加顶点
    for j:= 1 to kVct do with Obj[ID+kEdge+j] do begin //添加顶点
      for i:=0 to LayerTime do begin ObjShow[i]:=true; TagShow[i]:=true; end;
      CleanLink(ID+kEdge+j,0); // for i:=0 to LinkTime do begin Link[i]:=0; LinkName[i]:=0; end;
      Name:=getObjName(1);  parent:=ID;
      Link[0]:=ID;   LinkName[0]:=Obj[ID].Name;
      Kind:=1; Mode:=13;    Tag:=Obj[ID].Tag+'_'+itos(kEdge+j); texTag:=0;
      TagN:=Obj[ID].TagN;   TagS:=Obj[ID].TagS;
      TagC:=Obj[ID].TagC;   TagT:=Obj[ID].TagT;
      W:=Obj[1].p1.x;     hot:=false;   hide:=false;  delID:=0;
      Color:=cgTColorToCGColorF( Obj[1].Link[1],1); Color.A:=1;
      ColorB:=Color;
      TagP.z:=0.5;  S:=1;  Trace:=false;
      end;
  if(Kind=6)and(Mode=3)and(S in[2,12])then begin //正六面体 设置顶点标签
    for j:=1 to 4 do Obj[ID+kEdge+j].Tag:=chr(64+j)+'''';
    for j:=1 to 4 do Obj[ID+kEdge+j+4].Tag:=chr(64+j);
    end;
  if(Kind=6)and(Mode=3)and(S=6)then begin //长方体 设置顶点标签
    for j:=1 to 4 do Obj[ID+kEdge+j+4].Tag:=chr(64+j)+'''';
    for j:=1 to 4 do Obj[ID+kEdge+j].Tag:=chr(64+j);
    end;
  result:=ObjNum+kEdge+kVct;
  end;//with
end;

procedure TfrmMain.AddingObj( t, kk:integer);
  var a,b,c, i,j, K21,K22,K23, nK,nM, LastNum, iID :integer;  pa,pb,pc,pn:TcgVector;
  procedure setProperty(nK,nM :integer);//设置通用属性
    var i:integer;
    begin
    inc(ObjCount);  iiD:=ObjCount;
    with Obj[ObjCount] do begin
    Name:=getObjName(1);//inc(backObj.maxName); Name:=backObj.maxName;
    CleanLink(ObjCount,0); // for i:=0 to LinkTime do begin Link[i]:=0; LinkName[i]:=0; end; //链接构件清零
    for i:=0 to LayerTime do begin ObjShow[i]:=i>=Layer; TagShow[i]:=cheTag.Checked and(nK=1); end;
    Kind:=nK; Mode:=nM; delID:=0;
    parent:=ObjCount;
    TagN:=Obj[1].info[1];  TagS:=trunc(Obj[1].TagP.z);
    TagC:=Obj[1].Link[10]; TagT:=Obj[1].TagT;
    Tag:=getTag(ObjCount); TagP.x:=-0.6; TagP.y:=0.1; TagP.z:=0; //Tag 位置
    Trace:=false; nTrace:=0; maxTrace:=10; //跟踪
    hide:=false; Lock:=false; Hot:=true;
    if(nK=11)and(Mode>2)then Mode:=kk;  //度量
    case nK of
      1:begin //约束点
        p0:=cgVector(0,0,0); U:=false; D:=false; bDown:=true;
        Randomize;  L:=Random(80)/100+0.1; R:=Random(80)/100+0.1;//0.1～0.9之间的随机数
        W:=Obj[1].p1.x; S:=1;  p2.x:=0; p2.z:=1;
        Color:=cgTColorToCGColorF( Obj[1].Link[1],1);
        Obj[0].Mode:=nM;
        end;//1
      2:begin //直线
        L:=5; S:=0; D:=Mode in[4,6]; H:=0; W:=Obj[1].p1.y;
        F:=Mode=6;  S:=trunc(defaultProp[3]);  //直线 相贯线
        if nM=2 then begin R:=kk; H:=2; end;
        if(nM=4)or(nM=5)then begin Angle:=0.5; R:=0; end; //两点之中垂线 间比
        if nM=7 then begin nM:=1; Mode:=1; L:=20; D:=true; F:=false; end;//射线
        if nM=8 then begin nM:=1; Mode:=1; L:=40; F:=true; D:=false; end;//直线
        TagP.z:=0.7; p2.x:=6; p2.z:=0;
        Color:=cgTColorToCGColorF( Obj[1].Link[2],1);
        if nM=5 then R:=0.5;//中线
        if nM=6 then begin //交惯线
          Link[0]:=5; Link[1]:=6;  W:=Obj[1].p2.y;//默认为坐标平面的相贯线
          Color:=cgTColorToCGColorF( Obj[1].Link[6],1);
          end; //直线,实线
        end;//2
      3:begin //圆 圆弧
        L:=4; S:=0; R:=0; H:=IIFf(nM<3, 0,2); TagP.z:=0.5; //F边框
        D:=false; F:=true; W:=Obj[1].p1.z;  S:=trunc(defaultProp[3]);
        Color:=cgTColorToCGColorF(Obj[1].Link[3],1);
        end;
      4:begin //平面
        F:=true; S:=10; TagP.z:=0.5; info[0]:='';   U:=false; //F边框
        Rand:=IIFb(Mode=6, kk>0, false); //多边形时，kk>0 正多边形
        W:=IIFf(Mode=6, kk, 3);  //顶点数量
        H:=IIFf(Mode in[3,4,5], 3, 0); if W=99 then H:=3;
        if(Mode=5)then Angle:=0.5;
        R:=IIFf(Mode=9, 1, 0);//垂面平行面的宽度
        L:=IIFf(Mode<3, 0, 5); //垂面平行面的长度
        TagP.z:=1; TagP.w:=1; //标签位置
        Color:=cgTColorToCGColorF(Obj[1].Link[4],1); color.A:=0.4;  ColorB:=Color;
        end;
      5,15,17,19:begin //轨迹线 曲线 nK=17路径
        F:=nK<>17;    S:=trunc(defaultProp[3]);
        TagP.z:=0.5;  H:=5; L:=12; W:=Obj[1].p2.y;//轨迹 相贯线 F:实线 H:阀值
        Color:=cgTColorToCGColorF(Obj[1].Link[6],1);   ColorB:=Color;
        end;
      6:begin   //实体
        L:=2; F:=true; U:=false; D:=Mode>2; if(Mode<4)then Angle:=0;
        Color:=cgTColorToCGColorF(Obj[1].Link[5],1); ColorB:=Color;
        case nM of 1,6:W:=0; 3:W:=1; 2,4:W:=0.5;end;  //球:椭度, 台体:锥度, 六面体:长宽比
        case nM of 1,6:H:=0; 3:H:=1; 2,4:H:=2;  end;  //球:扁度, 台体:高度, 六面体: 高径比
        case nM of 1,2,6:S:=32;      3,4:S:=kk; end;  //球(台)体为圆度，多面(棱台)体为面(棱)数, kk为函数头参数
        Mask:=false;    Trace:=(Mode=2)or(Mode=4)and(S>0); //底面
        if(nM=3)and(S=6)then begin H:=1.5; W:=3; end; //长方体
        if(nM=3)and(S=2)then begin F:=false; U:=true; Mask:=true; end; //正六面体
        end;
      7:begin   //曲面
        S:=32; L:=12;  W:=2; F:=true; TagP.z:=5;
          if(nM=2)then S:=16;   //直纹曲面
          if(nM=1)then H:=towPi;//旋转曲面
        Color:=cgTColorToCGColorF( Obj[1].Link[7],1);  ColorB:=Color;
        end;    //曲面, 不填充
     11:with Obj[ObjCount]do begin //度量
        F:=false; Mask:=true;  L:=1; R:=1; if(nM=15)or(nM=16)then R:=0;
        S:=trunc(Obj[1].p2.w); // S精度(小数位数)
        info[2]:= ''; TagN:='Arial'; TagS:=9; TagC:=Obj[1].Link[8]; TagT:='1000';
        TagSize.X:=70; TagSize.y:=14;
        end;
      end;//case nK
    end;//with
  end;//procedure
  procedure setLink0(Dot, Line,Plane :integer);//调整选择次序 设置关联
    var i:integer;
    begin i:=0;
      if(SelRec[0]=2)and(Obj[SelRec[21]].Kind=1)and(Obj[SelRec[22]].Kind=1)then begin
          setProperty(nK,nM);
          Obj[ObjCount].Link[0]:=SelRec[21];
          Obj[ObjCount].Link[1]:=SelRec[22];
          save(1,ObjCount,1,true,false);
        end
      else if(SelRec[Dot]=1)then begin
        repeat inc(i); until(i>SelRec[0])or(Obj[SelRec[20+i]].Kind=Dot);
        if(i>1)then SwapI(SelRec[20+i],SelRec[21]);
        for i:=1 to SelRec[0]-1 do begin
          setProperty(nK,nM);
          Obj[ObjCount].Link[0]:=SelRec[21];
          Obj[ObjCount].Link[1]:=SelRec[21+i];
          save(1,ObjCount,1,true,false);
          end;
        end
      else if(SelRec[Dot]=3)then begin
          setProperty(nK,nM);
        for i:=1 to 3 do begin
          Obj[ObjCount].Link[0]:=SelRec[21];
          Obj[ObjCount].Link[1]:=SelRec[22];
          Obj[ObjCount].Link[2]:=SelRec[23];
          end;
          save(1,ObjCount,1,true,false);
        end
      else if(SelRec[Dot]>1)and((SelRec[Line]=1)or(SelRec[Plane]=1))then begin
        repeat inc(i);
        until(i>SelRec[0])or(Obj[SelRec[20+i]].Kind=Line)or(Obj[SelRec[20+i]].Kind=Plane);
        if(i<SelRec[0])then SwapI(SelRec[20+i],SelRec[20+SelRec[0]]);
        for i:=1 to SelRec[0]-1 do begin
          setProperty(nK,nM);
          Obj[ObjCount].Link[0]:=SelRec[20+i];
          Obj[ObjCount].Link[1]:=SelRec[20+SelRec[0]];
          save(1,ObjCount,1,true,false);
          end;
        end;
    end;
  procedure setLink1;
    var i:integer;
    begin i:=0;
      repeat //两点线
      inc(i); setProperty(nK,nM);
      with Obj[ObjCount]do begin
        Link[0]:=SelRec[20+i];
        if(i<SelRec[1])then Link[1]:=SelRec[20+i+1] else Link[1]:=SelRec[21];
        end;
      save(1,ObjCount,1,true,false);
      until(i=SelRec[1])or(SelRec[1]=2)and(i=1);
    end;
begin
  LastNum:=ObjCount; iID:=ObjCount;  //原构件数
  nK:= round( int(t/10));    nM:= round( t mod 10);//添加的对象的类型
  if(nK=2)and(nM=9)then nM:=19;//切线
  if(nK=11)and(nM>2)then nM:=kk; //度量
  if(nK=6)and(nM=1)and((SelRec[0]>2)and(SelRec[1]>2)
      or(SelRec[0]=1)and(SelRec[6]=1)or(SelRec[0]=1)and(SelRec[4]=1))then nM:=6; //三点球或四点球
  a:=SelRec[21]; K21:=Obj[a].Kind; // SelRec[]:选择对象表
  b:=SelRec[22]; K22:=Obj[b].Kind;
  c:=SelRec[23]; K23:=Obj[c].Kind;
  i:=0;
  case nK of
  1:case nM of //点
    2:for i:=1 to SelRec[0] do begin //约束点
      setProperty(nK,nM);
      if(nM=2)then with Obj[ObjCount] do begin
        Link[1]:=SelRec[20+i];
        if(Obj[Link[1]].Kind=3)and(Obj[Link[1]].Mode<3)then begin //圆周上的约束点
          p2.z:=towPi;  L:=Random(628)/100;
          end
        else if(Link[1] in[5,6,7])then begin //坐标平面上的约束点
          L:=Random(trunc(Obj[IIFi(Obj[ObjCount].Link[1]=5,3,2)].L)*100)/100;
          R:=Random(trunc(Obj[IIFi(Obj[ObjCount].Link[1]=7,3,4)].L)*100)/100;
          end
        else
          p2.z:=1;
        end;
      save(1,ObjCount,1,true,false);
      end;
    3:begin //最近点
      setProperty(nK,nM);
      if(K22=1)
        then SwapI(SelRec[21],SelRec[22]);
      with Obj[ObjCount]do for i:= 0 to 1 do
        begin Link[i]:=SelRec[21+i]; LinkName[i]:=Obj[Link[i]].Name; end;
      save(1,ObjCount,1,true,false);
      end;
    4:begin //交点
      setProperty(nK,nM);
      if(K21 in[4,6,7,9])or(K22=2)
        then SwapI(SelRec[21],SelRec[22]);
      with Obj[ObjCount]do for i:= 0 to 1 do
        begin Link[i]:=SelRec[21+i]; LinkName[i]:=Obj[Link[i]].Name; end;
      j:=ObjCount;
      ObjCount:=AddingCross(ObjCount, j);
      save(1, ObjCount, ObjCount-j+1, true,false);
      end;
    5:begin //中点
      setProperty(nK,nM);
      if(SelRec[0]>1)and(K21>1)then SwapI(SelRec[21],SelRec[22]);
      for i:= 0 to 2 do Obj[ObjCount].Link[i]:=SelRec[21+i];
      save(1,ObjCount,1,true,false);
      end;
    6:begin //等分点
      setProperty(nK,nM); Obj[ObjCount].L:=5;
      Obj[ObjCount].Link[1]:=SelRec[21];
      save(1,ObjCount,1,true,false);
      end;
    end;//nK=1
  2:case nM of //直线
    1,7,8:if(Obj[SelRec[21]].Kind=19)then begin //渐近线/准线
        setProperty(nK,nM);
        Obj[ObjCount].Link[0]:=SelRec[21];
        save(1,ObjCount,1,true,false);
        end
      else setLink1; //线段
    2:begin //向量
        setProperty(nK,nM);
      if(SelRec[0]=1)and(SelRec[1]=1)then
        Obj[ObjCount].Link[0]:=SelRec[21];
      if(SelRec[0]=2)and(SelRec[2]=2)then
        for i:=0 to 1 do Obj[ObjCount].Link[3+i]:=SelRec[21+i];
      save(1,ObjCount,1,true,false);
      end;
    3,4,19:begin //平行线 垂线
      if(SelRec[1]=0)and(SelRec[2]+SelRec[3]+SelRec[4]=2)then begin //两直线之公垂线 两圆之公切线
        setProperty(nK,nM);
        if(K21>K22)then SwapI(SelRec[21],SelRec[22]);
        for i:= 0 to 1 do Obj[ObjCount].Link[i]:=SelRec[21+i];
        save(1,ObjCount,1,true,false);
        end
      else
        setLink0(1,2,2);
      if nM=19 then itos(t); //见鬼，若无这句，曲线的切线长度就会无限大
      end;
    5:begin //中线
      setProperty(nK,nM);
      if(K21>K22)then SwapI(SelRec[21],SelRec[22]);
      if(SelRec[23]>0)and(K23>0)and(K22>K23)then SwapI(SelRec[22],SelRec[23]);
      if(SelRec[23]>0)then SwapI(SelRec[23],SelRec[24]);
      for i:= 0 to 3 do Obj[ObjCount].Link[i]:=SelRec[21+i];
      save(1,ObjCount,1,true,false);
      end;
    6:begin //相贯线
      setProperty(nK,nM);
      if(K21>K22)then SwapI(SelRec[21],SelRec[22]);
      if(SelRec[4]+SelRec[3]) < 2 then begin //涉及多面体或曲面的相贯线
        with Obj[ObjCount]do begin Kind:=15; Mode:=1; parent:=15; W:=Obj[1].p2.y; F:=false; end; //
        end;
      for i:= 0 to 3 do Obj[ObjCount].Link[i]:=SelRec[21+i];
      save(1,ObjCount,1,true,false);
      end;
    end;//nK=2
  3:begin  //圆
 {   if(nM=1)then begin //点向圆
      if(K21>1)then begin
        pa:=Obj[a].p0;  pb:=Obj[b].p0;  pn:=Obj[a].Vec;
        if(K21=4)then cgCenter( LocaVct[a,0], LocaVct[a,1],LocaVct[a,2], pa,pn, 0);//pb 圆心
        setLine( 9, pa, pn);
        pc:=footer( pb, 9, true);
        if EP(pc.w)then SwapI(SelRec[21],SelRec[22]);
        end;
      end; }
    if(nM=3)then begin //点向弧
      if(K21>1)and(K22=1)then SwapI(SelRec[21],SelRec[22]);
      if(K21=1)and(K23>1)then SwapI(SelRec[22],SelRec[23]);
      end;
    setProperty(nK,nM);
    for i:=0 to 2 do Obj[ObjCount].Link[i]:=SelRec[21+i];
    save(1,ObjCount,1,true,false);
    end;//nK=3
  4:case nM of
    1:begin //三点面
      setProperty(nK,nM);
      for i:=0 to 3 do Obj[ObjCount].Link[i]:=SelRec[21+i];
      save(1,ObjCount,1,true,false);
      end;//三点面
    2:begin //点线面
      setLink0(1,2,2);
      if(SelRec[1]=0)and(SelRec[2]=2)then begin //两线面
        setProperty(nK,nM);
        for i:= 0 to 1 do Obj[ObjCount].Link[i]:=SelRec[21+i];
        save(1,ObjCount,1,true,false);
        end;
      end;//点线面
    3:begin //平行面
      setProperty(nK,nM);
      if(K21>1)and(K22=1)then SwapI(SelRec[21],SelRec[22]);//点-线圆面
      if(K21=1)and(K22=1)and(K23=2)then SwapI(SelRec[22],SelRec[23]);//点-线-点
      if(K21=2)and(K22=2)and(K23=1)then SwapI(SelRec[21],SelRec[23]);//点-线-线
      for i:= 0 to 2 do Obj[ObjCount].Link[i]:=SelRec[21+i];
      i:=SelRec[21];  j:=SelRec[22];
      if(Obj[i].Kind=1)and(Obj[j].Kind in[10,11])then with Obj[ObjCount] do begin //图片合并到点
        Link[1]:=0;   Link[10]:=j;  D:=true; F:=false;  color.A:=1;
        H:=Obj[j].kHtag;
        end;
      save(1,ObjCount,1,true,false);
      end;
    4:begin //垂面
      setProperty(nK,nM);
      //点面线
      if(K21=2)and(K22=1)and(K23>2)then SwapI(SelRec[21],SelRec[23]);//线点面>面点线
      if(K21>2)and(K22=2)and(K23=1)then SwapI(SelRec[21],SelRec[22]);//面线点>线面点
      if(K21=2)and(K22>2)and(K23=1)then SwapI(SelRec[21],SelRec[23]);//线面点>点线面
      if(K21>2)and(K22=1)and(K23=2)then SwapI(SelRec[21],SelRec[22]);//面点线>点面线
      if(K21=1)and(K22=2)and(K23>2)then SwapI(SelRec[22],SelRec[23]);//点线面>点面线
      //点面点
      if(K21=1)and(K22=1)and(K23>2)then SwapI(SelRec[22],SelRec[23]);//点点面>点面点
      if(K21>2)and(K22=1)and(K23=1)then SwapI(SelRec[21],SelRec[22]);//面点点>点面点
      //面面点(公垂面)
      if(K21>2)and(K22=1)and(K23>2)then SwapI(SelRec[22],SelRec[23]);//面点面>面面点
      if(K21=1)and(K22>2)and(K23>2)then SwapI(SelRec[21],SelRec[23]);//点面面>面面点
      //点线
      for i:= 0 to 2 do Obj[ObjCount].Link[i]:=SelRec[21+i];
      save(1,ObjCount,1,true,false);
      end;
    5:begin //中面
      if(SelRec[1]=0)and(SelRec[2]+SelRec[3]+SelRec[4]>0)then begin
        setProperty(nK,nM);
        if(K21>2)then SwapI(SelRec[21],SelRec[22]);
        for i:= 0 to 1 do Obj[ObjCount].Link[i]:=SelRec[21+i];
        save(1,ObjCount,1,true,false);
        end
      else
        setLink0(1,2,4);
      end;
    6:begin //多边形
      setProperty(nK,nM);
      if Obj[ObjCount].Rand then begin //正多边形
        if(K21<>1)then SwapI(SelRec[21],SelRec[22]);
        for i:= 0 to 1 do Obj[ObjCount].Link[i]:=SelRec[21+i];
        end
      else with Obj[ObjCount] do begin //凸多边形
        for i:=0 to SelRec[0]-1 do
          begin Link[i]:=SelRec[21+i];  LinkName[i]:=Obj[Link[i]].Name; end;
        W:=SelRec[0];
        end;
      save(1,ObjCount,1,true,false);
      if(Obj[ObjCount].W<100)then ObjCount:=AddingEdges(ObjCount,ObjCount);
     end;
   end;//nK=4
  5:begin //轨迹线
    setProperty(nK,nM);
    if(SelRec[22]=0)then SelRec[22]:=SelRec[21];
    if(SelRec[21]<SelRec[22])then SwapI(SelRec[21],SelRec[22]);
    for i:= 0 to 1 do Obj[ObjCount].Link[i]:=SelRec[21+i];
    with Obj[ObjCount]do if EP(Obj[Link[1]].H)then
      Obj[Link[1]].H:=IIFf(Obj[Link[1]].D,0.25,0.25/Obj[Obj[Link[1]].Link[1]].L); //设置限制点的移动速度
    save(1,ObjCount,1,true,false);
    end;
  6:begin //实体
    setProperty(nK,nM);
    case nM of
    1..4:begin
      if(K21<>1)and(SelRec[22]>0)and not((nM=4)and(Obj[ObjCount].S=0))
        then SwapI(SelRec[21],SelRec[22]);
      if(K21=4)and(nM=4)and(Obj[a].W>100)then Obj[ObjCount].S:=trunc(Obj[a].W); //正n棱台
      with Obj[ObjCount] do
        for i:=0 to 1 do begin Link[i]:=SelRec[21+i];  LinkName[i]:=Obj[Link[i]].Name; end;
      save(1,ObjCount,1,true,false);
      if(nM=3)and bC and(K21=1)and(K22=1)then inc(Obj[ObjCount].S,10); //以底边两点定义的正六面体
      if(nM>2)and(Obj[ObjCount].S<100)then ObjCount:=AddingEdges(ObjCount,ObjCount);
      end;
    5:begin //凸壳
      with Obj[ObjCount] do begin
        for i:= 0 to SelRec[0]-1 do
          begin Link[i]:=SelRec[21+i]; LinkName[i]:=Obj[Link[i]].Name; end;
        W:=SelRec[0];
        F:=false; U:=true; Mask:=true;
        end;
      save(1,ObjCount,1,true,false);
      ObjCount:=AddingEdges(ObjCount,ObjCount);
      end;
    6:begin //三点球
      with Obj[ObjCount] do begin
        Link[0]:=SelRec[21];  LinkName[0]:=Obj[Link[0]].Name;
        Link[1]:=SelRec[22];  LinkName[1]:=Obj[Link[1]].Name;
        Link[4]:=SelRec[23];  LinkName[4]:=Obj[Link[4]].Name;
        Link[5]:=SelRec[24];  LinkName[5]:=Obj[Link[5]].Name;
        end;
      save(1,ObjCount,1,true,false);
      end;
    end;
//    save(1,ObjCount,1,true,false);
    end;
  7:begin //曲面
    setProperty(nK,nM);
    case nM of
    1:if(K22<>2)then SwapI(SelRec[21],SelRec[22]);//旋转曲面
    2:if(K22=1) then SwapI(SelRec[21],SelRec[22]); //直纹曲面
    4:begin //轨迹曲面
      if(K21 in[1,11])and(K22>1)
        then SwapI(SelRec[21],SelRec[22]);
      if(K21=1)and(K22=1)and(SelRec[21]<SelRec[22])
        then SwapI(SelRec[21],SelRec[22]);
      end;
    end;
    for i:= 0 to 1 do Obj[ObjCount].Link[i]:=SelRec[21+i];
    save(1,ObjCount,1,true,false);
    end;
  8:begin //合并 分离
    if(SelRec[0]=2)and(SelRec[4]=1)and(SelRec[10]+SelRec[11]=1)then //合并图片到平面
      menPasteTextureClick(nil)
    else begin
      i:=SelRec[21];  j:=SelRec[22];
      if(SelRec[0]>1)and(Obj[i].Kind>1)and(Obj[j].Kind=1)then SwapI(i,j);
      LastNum:= PointJoin(i,j);
      end;
    end;
  11:begin //度量
    setProperty(nK,nM);
    if(nM in[5,9,13])and(K21>K22)
      then SwapI(SelRec[21],SelRec[22]); //点值、斜率、距离。其它度量不需作判断
    if(nM=13)and(SelRec[0]=1)
      then SelRec[22]:=Obj[SelRec[21]].Link[1];//点值
    for i:= 0 to 2 do Obj[ObjCount].Link[i]:=SelRec[21+i];
    if(nM=13)and(Obj[ Obj[ObjCount].Link[1]].Kind=2)then begin //点的值
      Obj[ObjCount].p2.x:=0; Obj[ObjCount].p2.z:=1;
      end;
    if(nM=5)then with Obj[ObjCount] do //距离
      Tag:=Obj[Link[0]].Tag + Obj[Link[1]].Tag;  //距离的标签为两对象标签之和
    appendExpr(ObjCount);
    save(1,ObjCount,1,true,false);
//    SetProjection(false,false,1);
    end;//nK=11
  15,17,19:begin //路径 相贯线
    setProperty(nK,nM);
    for i:= 1 to SelRec[0] do begin
      Obj[ObjCount].Link[i-1]:=SelRec[20+i];
      Obj[ObjCount].LinkName[i-1]:=Obj[ SelRec[20+i]].Name;
      end;
    save(1,ObjCount,1,true,false);
    end;
  end;//case nK
  with Obj[iID] do
    for i:= 0 to 10 do if(Link[i]>0)then LinkName[i]:=Obj[Link[i]].Name;
  if(nK<>8)and(ObjCount=LastNum)then exit;//未增加构件则直接退出
  ReRelate(LastNum+1, ObjCount, false,false,false );
  SetProjection(true,false, 22);
  iID:=IIFi(t=81, LastNum, ObjCount); //t=81合并/分离
  ObjListUpdate(iID,false);
  //if(nK=8)then exit;
  ClearSelRec(0); //清空选择记录
  MarkObj:=ObjSelected( iID, false,false,true,false);
  CountObjNum(false,false);
  if butProp.Down then ShowObjProp(MarkObj, 0,0, true,true);
end;

procedure TfrmMain.AppendObj( t, kk:integer);
  var i :integer; x,y:single;
 function getHotBut(t:integer; but,hot:TToolButton; pop:TPopupMenu):TToolButton;
 begin hot.Tag:=t;   hot.Hint:=but.Hint;
       hot.ImageIndex:=but.ImageIndex;
       hot.DropdownMenu:=pop; hot.Down:=true; result:=hot;
  end;
begin
  if(bAdd)then BreckAdding; //中断添加过程
  if butArrow.Down then ClearSelRec(0); //来自菜单添加时则清除选择队列
 // if(HotMenu.Tag>0)then for i:=1 to ObjCount do Obj[i].Hot:=false;
  timAuto.Enabled:=false;
  if kk=65 then t:=65; //凸壳
  hotToolK:=kk;
  selNum:=0;       // 构件选择计数器
  inc(ObjCount);  MarkObj:= ObjCount;// 直接增加构件总数
//  setMem( ObjCount+i, false); //设置构件数组
  Obj[0].p0:=cgVector(0,0,0);
  with Obj[ MarkObj] do begin;
    Name:=getObjName(1);    parent:=MarkObj;
    R:=0;  H:=0;  S:=0; D:=false; Rand:=false;//颜色随顶点; 移动速度为0
    Kind:= round( int(t/10));  nK:= Kind; //添加的对象的类型
    Mode:= round( t mod 10);
    if(nK= 2)and(Mode=9)then Mode:=19;  //切线
    if(nK=11)and(Mode>2)then Mode:=kk;  //度量
    if(nK=12)then inc(Mode,6);  //变换nK=12
    if(t=130)then begin nK:=12; Mode:=16; end; //仿射变换
    nM:= Mode; //添加的对象的样式
    CleanLink(MarkObj,0);  //链接构件清零
    for i:=0 to LayerTime do begin
      ObjShow[i]:=i>=Layer;
      TagShow[i]:=cheTag.Checked and(Kind=1) or(Kind=11)and(Mode=2);
      end;
    Tag:=getTag(MarkObj); //标签字符
    TagN:=Obj[1].info[1];  TagS:=trunc(Obj[1].TagP.z);
    TagC:=Obj[1].Link[10]; TagT:=Obj[1].TagT;
    TagP.x:=-16; TagP.y:=1; TagP.z:=0; hide:=false; Lock:=false; //Tag 位置
    delID:=0;  Obj[0].Kind:=1; Obj[0].Mode:=1;
    Color:=cgColorF(1,0,0,IIFf(Kind=4, 0.6, 1));//新添加的平面略加透明
    ColorB:=Color;
    W:= IIFf( Kind=1, 4, IIFf( Kind=10,0,1)); // 宽度、长度
    bAdd:= true; CancelNum:=1; bSelLink:=false; //bAdd进入添加状态
    Trace:=false; nTrace:=0; maxTrace:=10; Thick:=0; //Trace跟踪 Thick厚度
    case nK of
    1:begin  //[点]
      p0:=cgVector(0,0,0);  W:=Obj[1].p1.x;  S:=trunc(Obj[1].p1.r);  R:=0.3; L:=0.4;
      if(nM=6)then L:=5; //nM=6等分点
      U:=false; D:=false;   bDown:=true;
      color:=cgTColorToCGColorF( Obj[1].Link[1],1); ColorB:=Color;
      Obj[0].Mode:=nM;
      end;
    2:begin
      L:=5; W:=Obj[1].p1.y;  H:=0; TagP.z:=0.7; p2.x:=6; p2.z:=0;
      S:=trunc(defaultProp[3]); //线型
      D:=Mode in[4,6];  F:=false;//D射线 F直线
      if(Mode=7)then begin Mode:=1; nM:=1; D:=true; F:=false; L:=20; end;//射线
      if(Mode=8)then begin Mode:=1; nM:=1; D:=false; F:=true; L:=40; end;//直线
      color:=cgTColorToCGColorF( Obj[1].Link[2],1); ColorB:=Color;
      if nM=2 then begin R:=kk; H:=2; end;  //向量 R=0角向量 1位向量 2向量和 3向量差 4叉积
      if(nM=4)or(nM=5)then begin Angle:=0.5; R:=0; end;//两点之中垂线 中线
      if(nM=6)then begin    //交惯线
        W:=Obj[1].p2.y; color:=cgTColorToCGColorF( Obj[1].Link[6],1);
        Link[0]:=5; Link[1]:=6;//默认为坐标平面的相贯线
        end; //直线,实线
      end;
    3:begin
      L:=defaultProp[2]; R:=0; TagP.z:=0.5;  H:=IIFf(nM<3, 0,2);
      S:=trunc(defaultProp[3]); W:=Obj[1].p1.z;
      D:=false; F:=true;  //F边框
      Color:=cgTColorToCGColorF(Obj[1].Link[3],1); ColorB:=Color;
      end; //圆,不填充
    4:begin
      F:=true; S:=10; H:=3; info[0]:='';  U:=false; D:=false; //F边框
      Rand:=IIFb(Mode=6, kk>0, false); //Rand正多边形 多边形时，kk>0 正多边形
      W:=IIFf(Mode=6, kk, 3); if(Mode=5)then Angle:=0.5; //W顶点数量 Angle角分比
      L:=IIFf(Mode<3, 0, 5);  //垂面平行面的长度
      H:=IIFf((Mode in[3,4,5])or(Mode=6)and(W=99), 3, 0); //垂面平行面的宽度
      R:=IIFf(Mode=9, 1, 0);  //旋转变换默认转角1弧度
      TagP.z:=1; TagP.w:=1;   //标签位置
      color:=cgTColorToCGColorF(Obj[1].Link[4],1); color.A:=0.4; ColorB:=Color;
      end; //平面 F:填充,D:消影(写深度缓存), U:色随顶点, S:剪裁
    5,15,17,19:begin //轨迹 相贯线 路径 圆锥曲线
      L:=12; TagP.z:=0.5; W:=Obj[1].p2.y;  // F:实线 H:阀值
      R:=0;     if(nK=19)then begin R:=0.8; Angle:=2; end; //19圆锥曲线的离心率
      F:=nK<>17;  U:=false; D:=false;   S:=trunc(defaultProp[3]);
      case nK of 17:H:=3; 19:H:=32; else H:=5; end; //密度
      Color:=cgTColorToCGColorF(Obj[1].Link[6],1);  ColorB:=Color;
      end;
    6:begin   //实体
      L:=defaultProp[2];  W:=0;  H:=0;  Angle:=0;
      F:=true;  U:=false;     Mask:=false; /// D:=Mode>2; D纹理
      color:=cgTColorToCGColorF(Obj[1].Link[5],1);  colorB:=color;
      case nM of 1:W:=0; 3:W:=1; 2,4:W:=0.5; end; //球:椭度, 台体:锥度, 六面体:长宽比
      case nM of 1:H:=0; 3:H:=1; 2,4:H:=2;   end; //球:扁度, 台体:高度, 六面体: 高径比
      case nM of 1,2,6:  S:=8;   3,4:S:=kk;  end; //球(台)体为圆度，多面(棱台)体为面(棱)数, kk为函数头参数
      Trace:=(Mode=2)or(Mode=4)and(S>0); //圆台底面
      if(nM=3)and(S=6)then begin H:=1.5; W:=3; end; //长方体
//      if(nM=4)and(Obj[Link[0]].W>100)then Obj[ObjCount].S:=trunc(Obj[Link[0]].W); //正n棱台
      if(nM in[7..15])and(Obj[parent].Mode in[3,4])then W:=Obj[1].p2.x;
      //if(nM=3)and(S=2)then begin F:=false; U:=true; Mask:=true; end; //正六面体
      end;
    7:begin S:=32; L:=12; W:=2; F:=true; TagP.z:=5; //曲面
      color:=cgTColorToCGColorF( Obj[1].Link[7],1);  colorB:=color;
      end;    //曲面, 不填充
    8:begin L:=0.5; end;// [块]的缩放比例
    9,16:begin   //函数曲面/曲线
      F:=true;  H:=5;  S:=0;
      if nK=9 then color:=cgTColorToCGColorF( Obj[1].Link[7],1)
              else color:=cgTColorToCGColorF( Obj[1].Link[6],1);
      colorB:=color;
      x:=Obj[2].L; //X轴长度
      y:=Obj[3].L; //Y轴长度
      p1:=cgVector(IIFf(Obj[2].F,-x,0),x,100);
      p2:=cgVector(IIFf(Obj[3].F,-y,0),y,100);
      for i:=0 to 2 do info[i]:='0';
      ShowControlBox(MarkObj, nK, tabFunc);// pnlFuncShow;
      end;
   10:begin   //[文字]
      info[2]:='Text'; TagN:='Arial';  TagS:=14;  TagC:=clRed;
      L:=1; memText.Text:='Text';
      end;
   11:begin   //参数 计算 度量
      parent:=0;  Hot:=true; F:=false; U:=false; Mask:=true; //滑块样式
      S:=trunc(Obj[1].p2.w); cmbAccuracy.ItemIndex:=S; // S精度(小数位数)
      info[2]:= ''; TagN:='Arial'; TagS:=9; TagC:=Obj[1].Link[8]; TagT:='1000';
      TagP.x:=0;  TagSize.X:=70; TagSize.y:=14;
      L:=1; R:=1; Angle:=10; //Angle动画频率
      if nM=1 then ShowControlBox(MarkObj,11,tabCalc);// pnlCalcShow(MarkObj); //计算器
      if nM=2 then begin //参数
        L:=1; H:=1; p2.x:=-99; p2.z:=99;  maxTrace:=100;
        appendExpr(ObjCount); bAdd:=false;
        Save( 1,    ObjCount, 1,true,false); //保存Undo数据
        Color:=cgTColorToCGColorF(clSkyBlue,1); ColorB:=cgColorF(0,0,0,1); // 
        TextAndImage(ObjCount, false,true,true,false);
        createParaBar(ObjCount, true); //创建参数轴
        end;
      if(nM>1)then info[0]:=IIFs(F,'',Tag+' =')+FtoS(L,4);
      if(nM=15)or(nM=16)then R:=0; //坐标 向量的值形式 H=0:(x,y,z), =1:x, =2:y, =3:z
//      SetProjection(true,false,1);
      end;
   12:begin p4.x:=0; p4.y:=0; p4.z:=0; end;
   13:if(t=131)then begin //迭代
        S:=3; H:=0; W:=1; F:=true; L:=Layer; Link[0]:=0;//初始迭代次数为3
        ShowControlBox(MarkObj,13,tabIterate);// pnlIterateShow(true);
      end;
    end;//case nK
    if nK<>10 then GetTextList( ObjCount); //标签的显示列表
    if not((nK=1)and(nM=1)or(nK in[9,10,13,16])or(nK in[1,11])and(nM<3))then begin
      if cheHint.Checked then labHint.Top:= 25; labHint.Left:= 25;
      labHint.Caption:= SetHint( nK,nM,0); //选择链接构件的提示条 labHint.Show;
      end;
  end; // with
end;
{======================= 显示构件属性 =======================}
procedure TfrmMain.ShowProp( ID :integer; isMove:boolean);
  var a,b,c,dd,ee,ff,gg,hh,ii,jj,kk, i,j,n, aK,aM,bK,bM:integer;  bb:boolean;
      sa,sb,sc,sd,se,sf,sg,sh,sj, st:string;  t:single;
      k:array[0..1000]of boolean;
  const face:array[1..12]of integer=(4,6,8,12,20,6,0,0,0,0,4,6); //正多面体的面数
begin
  if ID<1 then exit;
  with Obj[ID] do begin
  if(ID>1)then begin
    a:=Link[0];     b:=Link[1];     c:=Link[2];     dd:=Link[3];    ee:=Link[4];
    ff:=Link[5];    gg:=Link[6];    hh:=Link[7];    ii:=Link[8];    jj:=Link[9];
    sa:=IDtoS(a);   sb:=IDtoS( b);  sc:=IDtoS(c);   sd:=IDtoS(dd);  se:=IDtoS(ee);
    sf:=IDtoS(ff);  sg:=IDtoS(gg);  sh:=IDtoS(hh);  sj:=IDtoS(jj);
    aK:=Obj[a].Kind;  aM:=Obj[a].Mode;  bK:=Obj[b].Kind;  bM:=Obj[b].Mode;
    end;
  varTag.Width:=IIfi(ID in[5..7],55,42);
  varTag.caption:= Tag;
  if(Kind=4)and(Mode=6)then begin
    if(trunc(W)=99)
    then pnl0.Caption:=SwitchS(iLanguage,'矩形','矩形','Rectangle','')
    else pnl0.Caption:=SwitchS(iLanguage,IIFs(D,'正多边形','多边形'),
                                         IIFs(D,'正多邊形','多邊形'),
                                         IIFs(D,'Regular Polygon','Polygon'),'');
    end
  else if(Kind=6)and(Mode=3)then
    pnl0.Caption:=SwitchS(iLanguage,IIFs(S in[1..5,11,12],'正多面体','长方体'),
                                         IIFs(S in[1..5,11,12],'正多面體','長方體'),
                                         IIFs(S in[1..5,11,12],'Polyhedron','Cuboid'),'')
  else if(Kind=2)and(Obj[Link[0]].Kind=19)then
    pnl0.Caption:=SwitchS(iLanguage,'渐近线/准线','漸近線/準線','Asymptote/Asymptote','')
  else
    pnl0.Caption:=stMode[Kind,Mode];
  labS.Enabled:=true;
  labColor.Caption:=SwitchS(iLanguage,'颜色','颜色','Color','');
  bb:=(ID>10)and not((Kind=4)and(Mode=6)and(not Rand)or(Kind=6)and(Mode=5)or(Kind=17)); //任意多边形或凸壳
  varC1.Visible:=(ID>10)and(Kind in[3,4,6,7,9])and(Link[6]<10)or(Kind=11)and(Mode=2);
  varC.Left:= IIFi(iLanguage=2, 74,38);
  varC.Width:= IIFi(varC1.Visible, 26,56);
  varC.Caption:='';
  if(ID>10)and not((Kind=4)and(Mode=6)and((not Rand))
      or(Kind=17)or(Kind=6)and(Mode=5)or(Kind=9)and(Mode=13))then begin
    if(Kind=13)then begin //迭代
      gg:=trunc(p4.x); hh:=trunc(p4.y); ii:=trunc(p4.z);
      end;
    if(gg>0)then varC.Caption:= IDtoS(gg);
    if(hh>0)then varC.Caption:=varC.Caption+','+IDtoS(hh);
    if(ii>0)then varC.Caption:=varC.Caption+','+IDtoS(ii);
    end;
  if Kind in[10,14]  //[文字]、[计算]
    then begin varC.Color:= clWindow;   varC.Font.Color:= clBlack; end
    else begin
      if(gg>0)and bb then varC.Color:= clWindow else varC.color:=cgColorFToTColor( Color);
      end;
  if(Kind in[3,4,6,7,9,11])then varC1.Color:=cgColorFToTColor( ColorB);
  varC1.Caption:=varC.Caption;

  varColor.Color:=TagC;  //varColor.Visible:=(Kind<>11);
  labA.Caption:= SwitchS(iLanguage,'透明度','透明度','Transparent','');
  varA.Caption:= IIFs((Link[12]=0), FtoS(Color.A,4), IDtoS(Link[12])); // 透明度
  cheColor.Checked:= U;  //颜色随顶点 垂线反向
  cheSolid.Enabled:= true; cheSolid.Checked:= F;
  cheSolid.Caption:=SwitchS(iLanguage,IIFs(Kind in[5,16,19], '连线','填充'),
      IIFs(Kind in[5,15,16,17,19], '連線','填充'),IIFs(Kind in[5,15,16,17,19], 'Wire','Fill'),'');
  cheSec.Checked:= Q; //剪裁
  cheLock.Checked:=Lock;  cheLock.Caption:=SwitchS(iLanguage,'锁定','鎖定','Lock',''); //锁定
  cheBlock.Checked:=Mask;cheBlock.Caption:=SwitchS(iLanguage,'遮挡','遮擋','Mask',''); //遮挡
  cheTrace.Checked:=Trace;    varTrace.Enabled:=Trace;
  cheSec.Caption:=SwitchS(iLanguage,'剪裁','剪裁','Shear',''); //在约束点里设置为‘反向’
  varTrace.Caption:=itos(maxTrace);
  cheTrace.Caption:=SwitchS(iLanguage,'痕迹','痕跡','Trace','');
  if(M15)and not K11 then begin //反演变换
    labR.Caption:=SwitchS(iLanguage,'反演率','反演率','Invers Ratio','');
    varR.Caption:=IIFs(c=0, FtoS(R,4), sc);   varR.Enabled:=true;
    cheLock.Caption:=SwitchS(iLanguage,'负幂','負幂','Negative power','');
    cheLock.Checked:=Lock;
    end;
  cheSel.Checked:=not noSel; //可被选择
  cheShow.Checked:=ObjShow[Layer];
  for i:=0 to LinkTime do Obj[0].Link[i]:=0;
  for i:=1 to ObjCount do k[i]:=false;
  n:=0;
  if(ID>1)then
  for i:=0 to LinkTime do if(Link[i]>0)and(not k[Link[i]])then
    begin Obj[0].Link[n]:=Link[i]; inc(n); k[Link[i]]:=true; end;
  butDad.Enabled:=n>0; //计算父对象数目
  n:=0;
  for i:= ID+1 to ObjCount do if(Obj[i].DelID=0)then
    for j:=0 to LinkTime do
        if(Obj[i].Link[j]=ID)then begin inc(n);  break; end;
  butSon.Enabled:=n>0; //计算子对象数目
  cheCutter.Clear; //截面
  with Obj[MarkObj]do
    for i:=0 to 5 do
      if(Cutter[i,1]>0)and(Obj[Cutter[i,1]].DelID=0)then begin
        cheCutter.AddItem(Obj[Cutter[i,1]].Tag, nil);
        if(Cutter[i,2]=1)then cheCutter.State[cheCutter.Count-1]:=cbChecked;
        if(Cutter[i,2]=2)then cheCutter.State[cheCutter.Count-1]:=cbGrayed;
        end;
  case Kind of
  1:begin
    labW.Caption:=SwitchS(iLanguage,'点径','點經','Size',''); varW.Caption:= FtoS( W,4); // 点直径
    labX.Caption:='X';  posX.Caption:=IIFs((a>0)and M1, sa,FtoS(p0.x,4));
    labY.Caption:='Y';  posY.Caption:=IIFs((b>0)and M1, sb,FtoS(p0.y,4));
    labZ.Caption:='Z';  posZ.Caption:=IIFs((c>0)and M1, sc,FtoS(p0.z,4));
    if(M2)then begin //约束点
      selWay1.Enabled:=true;
      labS.Caption:=SwitchS(iLanguage,'起值','起值','Start','');
        varS.Caption:=IIFs(dd=0, FtoS(p2.x,4), sd);     varS.Enabled:=true;
      labR.Caption:=SwitchS(iLanguage,'终值','终值','Finish','');
        varR.Caption:=IIFs( ee=0, FtoS(p2.z,4), se);     varR.Enabled:=true;
      labT.Caption:=SwitchS(iLanguage,'步长','步長','Step','');
        varT.Caption:=IIFs((a>0)and M2, sa, FtoS( H,4));
      cheColor.Caption:=SwitchS(iLanguage,'限制','限制','Limit','');  cheColor.Enabled:=true;
      cheSolid.Caption:=SwitchS(iLanguage,'双向','雙向','Bidirectional',''); cheSolid.Checked:=F;
      cheMask.Caption:=SwitchS(iLanguage,'边缘','邊緣','On the Edge','');
      cheMask.Enabled:=true;
      if(bK<>6)then begin
        cheBlock.Caption:=SwitchS(iLanguage,'随机','隨機','Random','');
        cheBlock.Checked:=Rand;
        labT.Enabled:=not Rand; varT.Enabled:=not Rand;
        end;
      if(bK in[2,3])then begin //直线或圆弧上的点
        selWay0.Enabled:=true;  selWay1.Enabled:=true;
        labL.Caption:=SwitchS(iLanguage,IIFs(D,'距离','比例'),IIFs(D,'距離','比例'),IIFs(D,'Distance','Ratio'), '');
        varL.Caption:= IIFs( c=0, FtoS( L,4), sc);
        if(bK=3)and(bM in[3,4])or(bK=2)then begin
          selWay0.Checked:=not D;  selWay1.Checked:=D;
          selWay0.Caption:=SwitchS(iLanguage,'定比','定比','Ratio','');
          selWay1.Caption:=SwitchS(iLanguage,IIFs(bK=2,'定距','定弧'),IIFs(bK=2,'定距','定弧'),IIFs(bK=2,'Distance','Ratio'),'');
          end;
        if(bK=3)and(bM<3)then begin
          selWay0.Caption:=SwitchS(iLanguage,'弧度','弧度','Radian','');selWay0.Checked:=not Deg;
          selWay1.Caption:=SwitchS(iLanguage,'角度','角度','Angle',''); selWay1.Checked:=Deg;
          selWay0.Checked:=not Deg;  selWay1.Checked:=Deg;
          if Deg then labL.Caption:=SwitchS(iLanguage,'角度','角度','Angle','')
                 else labL.Caption:=SwitchS(iLanguage,'弧度','弧度','Arc','');
          cheMask.Checked:=not Mask;
          if Mask then begin // 内部的点
            labR.Caption:=SwitchS(iLanguage,'半径','半徑','Ratio','');
            varR.Caption:=IIFs( dd=0, FtoS( R,4), sd);
            end;
          end;
        end;
      if(bK=4)or(bK=9)then begin //平面上的点  函数曲面上的点
        cheMask.Checked:=Mask;
        but51.Visible:=Mask; //允许作轨迹线
        if Mask then labL.Caption:= SwitchS(iLanguage,'比例','比例','Ratio','')
                else labL.Caption:='dX';
        varL.Caption:=IIFs(c=0, ftos(L,4),sc);
        if not Mask then labR.Caption:='dY'; //内部的点
        if not Mask then varR.Caption:=IIFs(ff=0, ftos(R,4),sf);
        if not U then cheMask.Enabled:=false;  if(bK=9)then cheMask.Enabled:=true;
        end;
      if(bK in[5,15,16,17,19])then begin //轨迹线上的点
        labL.Caption:=SwitchS(iLanguage,'比例','比例','Ratio','比例');
        varL.Caption:=IIFs( c=0, FtoS( L,4), sc);
        cheSolid.Caption:=SwitchS(iLanguage,'双向','雙向','Bidirectional','');
        end;
      if(bK=6)and(bM in[1,2,6,15])then begin //实体(球面)上的点
        labL.Caption:=SwitchS(iLanguage,'经度','經度','Longitude','');
        varL.Caption:=IIFs( c=0, FtoS( L,4), sc);//球面上的点
        labR.Caption:=SwitchS(iLanguage,IIFs(bM=1,'纬度','高度'),IIFs((bM=1),'緯度','高度'),IIFs((bM=1),'Latitude','Height'),'');
        varR.Caption:=IIFs(ff=0, FtoS( R,4), sf);//约束于球面、圆台的点
        end;  //else if
      if(bK=1)and(bM=6)or(bK=13)then begin  //等分点、迭代象上的点
        labL.Caption:=SwitchS(iLanguage,'位置','位置','Position','');
        varL.Caption:=IIFs( c=0, FtoS( L,0), sc);
        end;
      end;
    if(M4 or M7)then begin //交点 垂点
      cheColor.Caption:=SwitchS(iLanguage,'限制','限制','Limet',''); cheColor.Checked:=U;
      end;
    cheWay.Checked:=F;
    if(M6)then begin //等分點
      labL.Caption:=SwitchS(iLanguage,'等分数','等分數','Points','');
      varL.Caption:=IIFs( c=0, FtoS( L,0), sc);
      labH.Caption:=SwitchS(iLanguage,'等分点','等分點','Position','');
      varH.Caption:=IIFs( a=0, FtoS( H,0), sa);
      end;
    if not isMove then with cmbStyle  do begin
      labShape.Caption:= SwitchS(iLanguage,'点形','點形','Point Style','');
      Clear; AddItem(SwitchS(iLanguage,'圆形','圓形','Circle',''),nil);
             AddItem(SwitchS(iLanguage,'球形','球形','Sphere',''),nil);
             AddItem(SwitchS(iLanguage,'钻形','鉆形','"Diamond',''),nil);
             AddItem(SwitchS(iLanguage,'立方形','立方形','Cube',''),nil);
      ItemIndex:=S;
      end;
    end;
  2:begin //直线
    labW.Caption:=SwitchS(iLanguage,'线径','線經','Line Width','');
      varW.Caption:= FtoS( W,4);
    labL.Caption:=SwitchS(iLanguage,'长度','長度','Length','');
      varL.Caption:=IIFs((Mode<7)and(c>0), sc, FtoS( L,4));
    if M2 then begin //向量
      if(ID<5)then labR.Caption:=SwitchS(iLanguage,'负轴','負軸','Negative','')
              else labR.Caption:=SwitchS(iLanguage,'仰角','仰角','Z Angle','');
      if(ID<5)then varR.Caption:=FtoS(R,4)
              else varR.Caption:=IIFs(ff>0, sf,FtoS(p2.z,4));
      i:=trunc(R);   varR.Enabled:=true;
      if(i=0)then begin
        labS.Caption:=SwitchS(iLanguage,'平角','平角','Plate Angle','');
        varS.Caption:=IIFs(dd>0, sd,FtoS(p2.x,4)); varS.Enabled:=true;
        end;
      if(i=1)and(ID>10)then begin
        labS.Caption:=' i ';  varS.Caption:=IIFs(dd>0, sd,FtoS(p2.x,4));  varS.Enabled:=true;
        labH.Caption:=' j ';  varH.Caption:=IIFs(ee>0, se,FtoS(p2.y,4));  varH.Enabled:=true;
        labR.Caption:=' k ';  varR.Caption:=IIFs(ff>0, sf,FtoS(p2.z,4));  varR.Enabled:=true;
        end;
      varL.Enabled:= i=0;
      if(i<2)then labShape.Caption:= SwitchS(iLanguage,'模式','模式','Mode','')
             else labShape.Caption:= SwitchS(iLanguage,'运算','運算','Calculate','');
      with cmbStyle  do begin
        Clear;
        if i<2 then begin
          AddItem(SwitchS(iLanguage,'矢量','矢量','Vector',''),nil);
          AddItem(SwitchS(iLanguage,'角矢量','角矢量','Angle Vector',''),nil);
          end
        else begin
          AddItem(SwitchS(iLanguage,'和','和','"Vector Sum',''),nil);
          AddItem(SwitchS(iLanguage,'差','差','Vector Diff',''),nil);
          AddItem(SwitchS(iLanguage,'叉积','叉積','DotProduct',''),nil);
          i:=i-2;
          end;
        ItemIndex:=i;//
        end;
      end;
    if(M2 and(trunc(R)=0))or M3 or M4 or M5 and(aK=1)and(bK=1) then begin
      selWay0.Caption:=SwitchS(iLanguage,'弧度','弧度','Radian','');    selWay0.Checked:=not Deg;
      selWay1.Caption:=SwitchS(iLanguage,'角度','角度','Angle','');     selWay1.Checked:=Deg;
      end;
    labFill.Caption:=SwitchS(iLanguage,'线型','線型','Line Style','');
    if M1 then begin //线段
      cheColor.Caption:=SwitchS(iLanguage,'端点色','端點色','Point Color','');
      cheSolid.Caption:=SwitchS(iLanguage,'反向','反向','Reverse','');
      cheSolid.Checked:=Rand; cheSolid.Enabled:=true;
      end;
    if M6 and(aK=19)then begin //渐近线/准线
      cheColor.Caption:=SwitchS(iLanguage,'交换','交换','Exchange','');
      cheSolid.Caption:=SwitchS(iLanguage,'准线','準線','Alignment','');
      cheSolid.Checked:=Rand;
      end;
    if M3 or M4 or M5 then begin //平行线、垂线、中线
      cheColor.Caption:=SwitchS(iLanguage,'反向','反向','Reverse','');
      labR.Caption:=SwitchS(iLanguage,'转角','轉角','Angle','');
      varR.Caption:=IIFs(dd=0,FtoS(R,4),sd);  varR.Enabled:=true;
      labH.Caption:=SwitchS(iLanguage,'间比','间比','Ratio','');
      varH.Caption:=IIFs(ee=0,FtoS(Angle,4),se);  varH.Enabled:=true;
      end;
    if(M19)then  //切线
      if((Obj[b].Kind=3)or(Obj[b].Kind=19)and(Obj[b].Mode>0))
        then cheColor.Caption:=SwitchS(iLanguage,'交换','交换','Exchange','');
    if(M19)and((Obj[b].Kind=3)or(Obj[b].Kind=19)) //切线
      then cheLock.Caption:=SwitchS(iLanguage,'内切','内切','Inside','');
    if(M19)then varL.Enabled:=F or D;
    cheColor.Enabled:=true;
    case Mode of
      1,4,19:st:=SwitchS(iLanguage,'射线','射線','Ray',''); //线段 垂线 切线
      5:st:=SwitchS(iLanguage,'外分','外分','Exterio Angle',''); //中线
      end;
    cheMask.Caption:=st;  cheMask.Checked:=D;   cheMask.Enabled:=true;
    cheWay.Caption:=SwitchS(iLanguage,'直线','直線','Line','');  cheWay.Checked:= F;
    //if M1 or M4 then cheWay.Enabled:=D else
    cheWay.Enabled:=true; //直线
    setBevel(trunc(H)in[1,3], pnlLeft, imgLeft ); //箭头
    setBevel(trunc(H)in[2,3], pnlRight, imgRight ); //箭头
    end;
  3:begin //圆、圆弧
    labW.Caption:=SwitchS(iLanguage,'线径','線經','Line Width','');
    varW.Caption:=FtoS(W,4);  varW.Enabled:=not(S in[10..19]);
    labL.Caption:=SwitchS(iLanguage,'半径','半經','Radio','');
      varL.Caption:=FtoS(L,4); varL.Enabled:=Mode=1; //半径

    if(Mode<5)then begin
      labS.Caption:=SwitchS(iLanguage,'精度','精度',' Slices','');
      if(Angle>2)then varS.Caption:=FtoS(Angle,0) //精度（顶点数） Angle=0时自动计算
                 else varS.Caption:=ItoS(High(LocaVct[MarkObj]));
      varS.Enabled:=true;
      end;
    if(Mode=15)then labR.Caption:=SwitchS(iLanguage,'反演率','反演率','Invers Ratio','')
      else labR.Caption:=SwitchS(iLanguage,'转角','轉角','Rotate Angle','');
    labH.Caption:=SwitchS(iLanguage,'椭度','椭度','Ellipticity','');
    cheWay.Checked:=false;
    labT.Caption:=SwitchS(iLanguage,'厚度','厚度','Thickness','');
    varT.Caption:=IIFs(ff=0,FtoS(Thick,4), sf);  varT.Enabled:=true;
    case Mode of
      1:begin //点法圆
        varL.Caption:=IIFs( c=0,FtoS(L,4), sc);   //半径
        varR.Caption:=IIFs( ee=0,FtoS(R,4), se);  varR.Enabled:=true;  //转角
        varH.Caption:=IIFs(dd=0,FtoS(H,4), sd);   varH.Enabled:=true;  //椭度
        end;
      2:begin   //[三点圆]的半径
        varR.Caption:=IIFs( ee=0,FtoS(R,4), se);    varR.Enabled:=true;
        cheColor.Caption:=SwitchS(iLanguage,'内切','内切','Inner','');
        cheColor.Checked:=U;  cheColor.Enabled:=true;//内切
        varR.Caption:=IIFs( ee=0,FtoS(R,4), se);    varR.Enabled:=true; //转角
        end;
      3,4:begin //3点法弧 4三点弧
        varL.Caption:=FtoS(L,4); //半径
        if(Mode=3)then varH.Caption:=IIFs(dd=0, FtoS(H,4), sd) //弧长
                  else varH.Caption:=FtoS(H,4);
        cheWay.Caption:=SwitchS(iLanguage,'扇形','扇形','Sector','');
        cheWay.Checked:=S>99; cheWay.Enabled:=(S mod 100)>3;
        cheColor.Caption:=SwitchS(iLanguage,'反向','反向','Inverse','');
        end;
      6,7,8:varL.Caption:=FtoS(Obj[a].L,4); //半径
      9:begin
        varL.Caption:=FtoS(Obj[a].L,4);
        varH.Caption:=IIFs(c=0, FtoS(R,4), sc);
        end; //半径
     15:begin //反演变换
        varL.Caption:=FtoS(L,4);                  varL.Enabled:=false;
        varR.Caption:=IIFs( c=0,FtoS(R,4), sc);   varR.Enabled:=true;
        if(Obj[a].Kind=3)and(Obj[b].Kind=3)then
          pnl0.Caption:=SwitchS(iLanguage,'逆相似圆','逆相似圓','Inverse Similar Circle','');
        cheColor.Caption:=SwitchS(iLanguage,'圆弧','圓弧','Arc','');
        cheColor.Checked:=U;  cheColor.Enabled:=true;
        end;
      end;
    labFill.Caption:=SwitchS(iLanguage,'模式','模式','Style','');
    if Mode in[3,4] then labH.Caption:=
      SwitchS(iLanguage,IIFs(M9, '转角', IIFs( D,'弧长','弧角')),
                        IIFs(M9, '轉角', IIFs( D,'弧長','弧角')),
               IIFs(M9, 'Rotate Angle', IIFs( D,'Arc Length','Arc Angle')),'');
    cheSolid.Caption:=SwitchS(iLanguage,'边框','邊框','Frame','');
    cheSolid.Enabled:= S>=10;     
    if Mode in[1,2,9]then begin //圆
      selWay0.Caption:=SwitchS(iLanguage,'弧度','弧度','Radian','');selWay0.Checked:=not Deg;
      selWay1.Caption:=SwitchS(iLanguage,'角度','角度','Angle',''); selWay1.Checked:=Deg;
      end
    else begin                //圆弧
      selWay0.Caption:=SwitchS(iLanguage,'定角','定角','Limit Angle',''); selWay0.Checked:=not D;
      selWay1.Caption:=SwitchS(iLanguage,'定长','定長','Limit Arc','');   selWay1.Checked:=D;
      end;
    cheMask.Caption:=SwitchS(iLanguage,'贴图','貼圖','Texture','');
      cheMask.Checked:=D; cheMask.Enabled:= S>3;
    end;
  4:begin //平面,是否作为截面
    bb:=M6 and Rand and(trunc(W)<>99); //正多边形
    labW.Caption:=SwitchS(iLanguage,IIFs(bb,'边长','宽度'),IIFs(bb,'边长','宽度'),IIFs(bb,'Edge Num','Width'),'');
    if M6 and Rand then varW.Caption:=IIFs(ee>0, se, FtoS(H,4)) //正多边形 边长
                   else varW.Caption:=IIFs(ee>0, se, FtoS(IIFf(M6,W,H),4));
      varW.Enabled:=not( M6 and Rand and(c>0)and(W<99));//or(M6)and(W>100);
    if M6 then begin //正多边形的边数
      labW.Caption:=SwitchS(iLanguage,'边长','邊長','Edge Length','');
      N:=trunc(W);  if W>100 then N:=N-100; //W>100 正n边形的边数
      labS.Caption:=SwitchS(iLanguage,'边数','邊數','Edge Number','');
      varS.Caption:=IIFs(Link[11]>0, IDtoS(Link[11]), ItoS(N));
      if(W=99)then varS.Caption:=ItoS(4); //矩形
      varS.Enabled:=W>100;
      end;
    labL.Caption:=SwitchS(iLanguage,IIFs(bb,'半径','长度'),IIFs(bb,'半經','長度'),IIFs(bb,'Radio','Length'),'');
    if(Mode in[3,4,5])then varL.Caption:=IIFs(dd>0, sd, FtoS(L,4))
                      else varL.Caption:=IIFs( c>0, sc, FtoS(L,4));
      varL.Enabled:=not( bb and(ee>0));
    if(Mode=3)then begin  //平行面
      labH.Caption:=SwitchS(iLanguage,'线面角','線面角','Angle','');
      varH.Caption:=IIFs( c>0, sc, FtoS(pTR.x, 4)); varH.Enabled:=true;
      end;
    if M5 then begin  //中面
      labH.Caption:=SwitchS(iLanguage,'角分比','角分比','Angle Ratio','');
      varH.Caption:=FtoS(Angle,4); varH.Enabled:=true;
      end;
    if(Mode in[3,4])or M6 and Rand then begin //
      cheColor.Caption:=SwitchS(iLanguage,'顶点','顶點','Vertex','');
      selWay0.Caption:=SwitchS(iLanguage,'弧度','弧度','Radian','');selWay0.Checked:=not Deg;
      selWay1.Caption:=SwitchS(iLanguage,'角度','角度','Angle',''); selWay1.Checked:=Deg;
      end
    else begin
      if M5 then cheColor.Caption:=SwitchS(iLanguage,'外分',  '外分',  'Exterio',    '')
            else cheColor.Caption:=SwitchS(iLanguage,'顶点色','頂點色','Point Color','');
      end;
    labFill.Caption:=SwitchS(iLanguage,'模式','模式','Style','');
    if(Mode<3)then labR.Caption:=SwitchS(iLanguage,'缩放比','缩放比','Scale','')
              else labR.Caption:=SwitchS(iLanguage,'转角','轉角','Rotate','');
    if(Mode=6)then
      varR.Caption:=IIFs(dd=0, ftos(R,4), sd );//正多边形的转角
    if(Mode in[1..5])then
      varR.Caption:=IIFs(jj=0, ftos(R,4), sj );//垂面平行面中面等矩形的宽
    cheSolid.caption:=SwitchS(iLanguage,'边框','邊框','Frame','');
      cheSolid.Enabled:= (S>3)or(M6 and Rand);
    cheMask.Caption:=SwitchS(iLanguage,'贴图','貼圖','Texture','');
      cheMask.Checked:=D;  cheMask.Enabled:= true;
    butTex.Enabled:= cheMask.Enabled;
    //varA.Enabled:=bb or ( (S>3) and not U );
    if not isMove then with cmbStyle  do begin
      Clear; AddItem(SwitchS(iLanguage,'三角形','三角形','Triangle','三角形'),nil);
             AddItem(SwitchS(iLanguage,'菱形','菱形','Diamond','菱形'),nil);
             AddItem(SwitchS(iLanguage,'四边形','四边形','Quadrilateral','四边形'),nil);
             AddItem(SwitchS(iLanguage,'矩形','矩形','Rectangle','矩形'),nil);
      ItemIndex:=trunc(L);
      end;
    labT.Caption:=SwitchS(iLanguage,'厚度','厚度','Thickness','');
    varT.Enabled:=(Mode<7);
    if(Mode=6)and not D then //厚度
      varT.Caption:=IIFs( EP(Angle), FtoS(Thick,4), IDtoS(trunc(Angle)))
    else
      varT.Caption:=IIFs( ff=0, FtoS( Thick,4), sf);
    end;
  5,15,16:begin //轨迹 相贯线 函数曲线
    labW.Caption:=SwitchS(iLanguage,'线径','線經','Line Width','');  varW.Caption:=FtoS( W,4);
    labL.Caption:=SwitchS(iLanguage,'长度','長度','Length','');   varL.Caption:=FtoS( L,4);
    labShape.Caption:=SwitchS(iLanguage,'线形','線形','Style','');
    labH.Caption:=SwitchS(iLanguage,'阈值','阈值','Threshold',''); varH.Caption:=FtoS( H,4);
    if(K16) //函数曲线 限制在坐标轴范围内
      then cheColor.Caption:=SwitchS(iLanguage,'限制','限制','Limit','');
    cheColor.Checked:=U;
    if(K5)and(M1)then begin //轨迹
      cheColor.Caption:=SwitchS(iLanguage,'随点','隨點','Follow Point','');
      cheMask.Caption:=SwitchS(iLanguage,'跟随','跟隨','Following','');
      cheMask.Checked:=D; cheMask.Enabled:=true;
      end;
    if(K5)and(M1)then cheLock.Caption:=SwitchS(iLanguage,'简控','簡控','Simple Control',''); cheLock.Checked:=Lock;
    end;
  6:begin //实体
    if M1 or M2 then begin //球 圆台
      labX.Caption:=SwitchS(iLanguage, '上截率','上截率','Top Gap','');
        posX.Caption:=IIFs(Link[ 9]=0, FtoS(pTR.x,4), IDtoS(Link[9]));
      labY.Caption:=SwitchS(iLanguage, '下截率','下截率','Bottom Gap','');
        posY.Caption:=IIFs(Link[11]=0, FtoS(pTR.y,4), IDtoS(Link[11]));
      labZ.Caption:=SwitchS(iLanguage, '缺口角','缺口角','Gap Angle','');
        posZ.Caption:=IIFs(Link[10]=0, FtoS(Angle,4), IDtoS(Link[10]));
//      cheColor.Caption:=SwitchS(iLanguage, '通透','通透','Hyaline','');
      end;
    labL.Caption:=IIFs((Mode=3)and(S=6), SwitchS(iLanguage,'长度','長度','Length',''), SwitchS(iLanguage,'半径','半經','Radio',''));
    varL.Caption:=IIFs(c=0, FtoS(L,4), sc);
    if M1 then varL.Enabled:=not Trace;     //点法球
    if M3 and(S<6)then varL.Enabled:=(ff=0);//多面体
    case Mode of
      1:labW.Caption:=SwitchS(iLanguage, '椭度','椭度','Ellipticity','');
      2,4:labW.Caption:=SwitchS(iLanguage, '锥度','锥度','Taper Ratio','');
      3:if(S<6)then labW.Caption:=SwitchS(iLanguage, '边长','边長','Edge Length','')
            else labW.Caption:=SwitchS(iLanguage, '宽度','寬度','Width','');
      6:if(Link[5]>0)or(Obj[a].Kind=6)then
        pnl0.Caption:=SwitchS(iLanguage, '四点球','四點球','Sphere','');
      end;
    varW.Caption:=IIFs(ff=0, Ftos( W,4), sf);
      varW.Enabled:= K6 and(M1 or M2 or M4 or M6 or M3 and(S=6)or M3 and(S<6)and(c=0));
    if(Mode in[7..13])and(Obj[parent].Mode in[3,4])then begin
      labW.Caption:=SwitchS(iLanguage, '线宽','線寬','Edge Width','');
      varW.Enabled:=true;
      end;
    labS.Caption:=SwitchS(iLanguage,IIFs(Mode in[1,2,6,15],'圆度',IIFs(Mode=3,'面数','棱数')),
              IIFs(Mode in[1,2,6],'圓度',IIFs(Mode=3,'面數','棱數')),
              IIFs(Mode in[1,2,6], 'Ellipticity', IIFs(Mode=3,'Face Number','Edge Number')),'');
    i:=S; if(Mode=4)and(i>100)then i:=i-100; //正n棱台S>100
    varS.Caption:=IIFs( (Mode=4)and(S>100)and(Link[8]>0), IDtoS(Link[8]), FtoS(IIFi(Mode=3,face[i],i),0) );
    varS.Enabled:=(Mode in[1,2,6,15])or(Mode=4)and(S>100);
    labH.Caption:=SwitchS(iLanguage,IIFs(Mode=1,'扁度','高度'),IIFs(Mode=1,'扁度','高度'),IIFs(Mode=1,'Ellipticity','Height'),'');
    varH.Caption:=IIFs(ee=0, ftos(H,4), se );
    varH.Enabled:=not((Mode=1)and Trace);

    if(Mode<>15)then labR.Caption:=SwitchS(iLanguage,'转角','轉角','Rotate Angle','');
    if(Mode<>15)then varR.Caption:=IIFs(dd=0,FtoS(R,4),sd);

    varR.Enabled:=true; //转角
      selWay0.Caption:=SwitchS(iLanguage,'弧度','弧度','Radian','');selWay0.Checked:=not Deg;
      selWay1.Caption:=SwitchS(iLanguage,'角度','角度','Angle',''); selWay1.Checked:=Deg;

    if(Mode in[3,4])then cheColor.Caption:=SwitchS(iLanguage,'顶点','顶點','Vertexes','');
    if(Mode=6)or(Obj[a].Kind=6)then
      cheColor.Caption:=SwitchS(iLanguage,'内切','内切','Inner','');
    if(Mode=1)then
      cheColor.Caption:=SwitchS(iLanguage,'球面','球面','Face','');
    if(Mode=3)and(S=6)then cheWay.Caption:=SwitchS(iLanguage,'角点','角點','Corner','')
    else if(Mode=1)then cheWay.Caption:=SwitchS(iLanguage,'两点式','两點式','2-Point','')
    else cheWay.Caption:=SwitchS(iLanguage,'底面','底面','Bottom','');
    if(Mode=3)then cheBottom.Checked:=S>10; //以底边两端点定义正多面体
    cheWay.Checked:=Trace;
    if(Obj[parent].Mode in[1,2,6])then cheMask.Caption:=SwitchS(iLanguage,'贴图','貼圖','Texture','')
                                  else cheMask.Caption:=SwitchS(iLanguage,'棱边','棱邊','Edge','');
    cheBlock.Checked:=Mask;  //if F then Mask:=false;
    if(Obj[parent].Mode in[3,4,5])and(Kind<>6)and not F then D:=true;
    cheMask.Checked:=D;   cheMask.Enabled:=true;//贴图 棱边
    if(Obj[parent].Mode=4)and(S>100)and not F then cheMask.Enabled:=false;
    if(Obj[parent].Mode=3)and not F and not U then cheMask.Enabled:=false;
    cheTrace.Caption:=SwitchS(iLanguage,'炫彩','炫彩','Colourful',''); cheTrace.Checked:=Rand;
    labT.Caption:=SwitchS(iLanguage,'偏移','偏移','Offset','');   varT.Caption:=IIFs(Link[9]=0,'',Obj[Link[9]].Tag);
    end;
  7:begin //曲面
    cheSolid.Checked:=F;
    cheMask.Caption:=SwitchS(iLanguage,'贴图','貼圖','Texture','');
      cheMask.Checked:=D; cheMask.Enabled:=true;
    cheColor.Caption:=SwitchS(iLanguage,'色随线','色随線','Color With Line','');
      cheColor.Checked:=U;
    if(Mode=4)then cheLock.Caption:=SwitchS(iLanguage,'线族','線族','Curves','');
    if Mode=1 then begin //旋转曲面
      if(Obj[a].Kind=2)then begin
        labL.Caption:=SwitchS(iLanguage,'精度','精度','Slices','');
        varL.Caption:=FtoS( L,0); varL.Enabled:=true;
        end;
      labS.Caption:=SwitchS(iLanguage,'圆度','圓度','Ellipticity','');  varS.Caption:=IIFs(ee=0,FtoS( S,0),se); varS.Enabled:=true;
      labR.Caption:=SwitchS(iLanguage,'初角','初角','Start Angle','');  varR.Caption:=IIFs(dd=0,FtoS( R,4),sd);
      labH.Caption:=SwitchS(iLanguage,'转角','轉角','Rotate Angle',''); varH.Caption:=IIFs( c=0,FtoS( H,4),sc);
      selWay0.Caption:=SwitchS(iLanguage,'弧度','弧度','Radian','');    selWay0.Checked:=not Deg;
      selWay1.Caption:=SwitchS(iLanguage,'角度','角度','Angle','');     selWay1.Checked:=Deg;
      end;
    if Mode=2 then begin //直纹曲面
      labS.Caption:=SwitchS(iLanguage,'精度','精度','Slices','');       varS.Caption:=FtoS( S,0);  varS.Enabled:=true;
      end;
    if(Mode=4)then begin //轨迹面
      if(Obj[a].Kind=2)then begin
//        labL.Caption:=SwitchS(iLanguage,'精度','精度','Slices','');     varL.Caption:=FtoS( L,0); varL.Enabled:=true;
        end;
      cheWay.Caption:=SwitchS(iLanguage,'跟随','跟隨','Following','');  cheWay.Checked:=Mask;
      end;
    setBevel( W=1, pnlColorH, imgColorH);
    setBevel( W=2, pnlColorV, imgColorV);
    end;
{  8:begin //块
    labL.Caption:=SwitchS(iLanguage,'比例','比例','Ratio','');          varL.Caption:=IIFs( c=0,FtoS(L,4),sc); //缩放比例
    labR.Caption:=SwitchS(iLanguage,'转角','轉角','Rotate Anlge','');   varR.Caption:=IIFs(dd=0,FtoS(R,4),sd);
    end;}
  9:begin  //方程式 反向、填充
    setBevel( W=1, pnlColorH, imgColorH);
    setBevel( W=2, pnlColorV, imgColorV);
    cheMask.Caption:=SwitchS(iLanguage,'贴图','貼圖','Texture','');     cheMask.Checked:=D; cheMask.Enabled:=true;
    end;
 10:begin  //文字、图片
    labX.Caption:='X';  posX.Caption:=FtoS(IIFf(Link[10]=0,p0.x,p2.y),0);
    labY.Caption:='Y';  posY.Caption:=FtoS(IIFf(Link[10]=0,p0.y,p2.w),0);
    labZ.Caption:=SwitchS(iLanguage,'绑定','绑定','Bound','');    posZ.Caption:=IIFs(Link[10]=0,'',IDtoS(Link[10]));
    labL.Caption:=SwitchS(iLanguage,'缩放','縮放','Scale','');    varL.Caption:=FtoS(L,4);
    labS.Caption:=SwitchS(iLanguage,'隐阈','隱阈','Hidden','');   varS.Caption:=IIFs(c=0,FtoS(R,4),sc);
    labH.Caption:=SwitchS(iLanguage,'显阈','顯阈','Display','');  varH.Caption:=IIFs(b=0,FtoS(H,4),sb);
    labR.Caption:=SwitchS(iLanguage,'转角','轉角','Rotate Anlge','');   varR.Caption:=IIFs(dd=0,FtoS(Angle,4),sd);
    selWay0.Caption:=SwitchS(iLanguage,'弧度','弧度','Radian','');selWay0.Checked:=not Deg;
    selWay1.Caption:=SwitchS(iLanguage,'角度','角度','Angle',''); selWay1.Checked:=Deg;

    labT.Caption:=SwitchS(iLanguage,'行距','行距','Spacing','');  varT.Caption:=ItoS(S);  varC.Enabled:=true;
    cheColor.Caption:=SwitchS(iLanguage,'前置','前置','Forword','');
    cheColor.Checked:=U;  cheColor.Enabled:=true;   varR.Enabled:=true;
    cheMask.Caption:=SwitchS(iLanguage,'背景','背景','Background','');  cheMask.Checked:=D;
    varS.Enabled:=true;
    end;
 11:begin  //计算
    labX.Caption:='X';  posX.Caption:=FtoS(IIFf(Link[10]=0,p0.x,p2.y),0);
    labY.Caption:='Y';  posY.Caption:=FtoS(IIFf(Link[10]=0,p0.y,p2.w),0);
    labZ.Caption:=SwitchS(iLanguage,'绑定','绑定','Bound','');    posZ.Caption:=IIFs(Link[10]<11,'',IDtoS(Link[10]));
    labL.Caption:=SwitchS(iLanguage,'值','值','Value','');
      t:=L; if(Link[2]>10)then t:=Obj[Link[2]].L; //Link[2]参数
      if(M1 or M6)and Deg then t:=t*oneArc;
      varL.Caption:=IIFs(c=0, FtoS(t,4),sc);
      if(Mode in[1,7])and F then varL.Caption:='∞';
    labS.Caption:=SwitchS(iLanguage,'起值','起值','Start','');    varS.Caption:=IIFs(dd=0, FtoS(p2.x,4), sd); varS.Enabled:=true;
    labR.Caption:=SwitchS(iLanguage,'终值','终值','Finish','');   varR.Caption:=IIFs( ee=0, FtoS(p2.z,4), se); varR.Enabled:=true;
    labT.Caption:=SwitchS(iLanguage,'步长','步長','Step','');     varT.Caption:=FtoS( H,4);
    cheMask.Caption:=SwitchS(iLanguage,'标签','標籤','Tag','');   cheMask.Checked:=Mask;
    if M1 then begin //计算
      cheSec.Caption:=SwitchS(iLanguage,'算式','算式','Express','');  cheSec.Checked:=Q;
      end;
    if M2 then begin //参数
      labA.Caption:=SwitchS(iLanguage,'频率','頻率','Frequency','');
        varA.Caption:=FtoS(Angle,0);  varA.Enabled:=true;
      cheColor.Caption:=SwitchS(iLanguage,'动画','動畫','Dinamic','');
        cheColor.Checked:=U;  cheColor.Enabled:=true;
      cheSolid.Caption:=SwitchS(iLanguage,'双向','雙向','Bidirectional','');
        cheSolid.Checked:=F;  cheSolid.Enabled:=true;
      cheWay.Caption:=SwitchS(iLanguage,'动画钮','動畫鈕','Dynamic Button','');
        cheWay.Checked:=Q;    cheWay.Enabled:=true;
      cheBlock.Caption:=SwitchS(iLanguage,'随机','隨機','Random','');
        cheBlock.Checked:=Rand;
      cheTrace.Caption:=SwitchS(iLanguage,'滑尺','滑块','Track','');  cheTrace.Checked:=Trace;
      labTrace.Caption:=SwitchS(iLanguage,'尺长','尺長','Length','');
      if maxTrace<50 then maxTrace:=50; varTrace.Caption:=itos(maxTrace);
      varTrace.Enabled:=Trace;
      labT.Enabled:=not Rand; varT.Enabled:=not Rand;
      end;
    cmbAccuracy.ItemIndex:=S; //精度
    if M1 or M6 then begin //角度
      labL.Caption:=SwitchS(iLanguage,IIFs(Deg,'角度','弧度'),IIFs(Deg,'角度','弧度'),IIFs(Deg,'Angle','Radian'),'');
      cheWay.Caption:=SwitchS(iLanguage,'补角','补角','Supplementary','');
      cheWay.Checked:=U;  cheWay.Enabled:=true;
      selWay0.Caption:=SwitchS(iLanguage,'弧度','弧度','Radian','');  selWay0.Checked:=not Deg;
      selWay1.Caption:=SwitchS(iLanguage,'角度','角度','Angle','');   selWay1.Checked:=Deg;
      end;
    if M15 or M16 then begin //坐标、向量
      labShape.Caption:=SwitchS(iLanguage,'形式','形式','Shape','');
      with cmbStyle do begin Clear;
        AddItem('x,y,z',nil); AddItem('x',nil); AddItem('y',nil); AddItem('z',nil);  AddItem('x,y',nil);
        ItemIndex:=trunc(R);
        end;
      cheWay.Caption:=SwitchS(iLanguage,'格式化','格式化','Format','');
      cheWay.Checked:=U; cheWay.Enabled:=Obj[Link[0]].Kind<3;
      end;
    if M17 then begin //向量运算
      labShape.Caption:=SwitchS(iLanguage,'运算','運算','Operations','');
      with cmbStyle do begin Clear;
        AddItem( SwitchS(iLanguage,'和','和','Sum',''),nil);
        AddItem( SwitchS(iLanguage,'差','差','Difference',''),nil);
        AddItem( SwitchS(iLanguage,'叉积','叉積','Cross Product',''),nil);
        AddItem( SwitchS(iLanguage,'点积','點積','Dot Product',''),nil);
        ItemIndex:=trunc(R);
        end;
      cheWay.Caption:=SwitchS(iLanguage,'格式化','格式化','Format','');
      cheWay.Checked:=U; cheWay.Enabled:=Obj[Link[0]].Kind<3;
      end;
    end;
 13:begin  //迭代
    labS.Caption:=SwitchS(iLanguage,'次数','次數','Views','');  varS.Caption:=IIFs(a=0,ItoS(S),sa);  varS.Enabled:=true;
    labL.Caption:=SwitchS(iLanguage,'页面','頁面','Page','');  varL.Caption:=ItoS(trunc(L)+1);       varL.Enabled:=false;
    cheColor.Caption:=SwitchS(iLanguage,'随机','隨機','Random','');          cheColor.Checked:=Rand; cheColor.Enabled:=true;
    cheSolid.Caption:=SwitchS(iLanguage,'含点','含點','Includ Point','');    cheSolid.Checked:=F;    cheSolid.Enabled:=true;
    cheMask.Caption:=SwitchS(iLanguage,'终像','终像','Last Image','');       cheMask.Checked:=D;     cheMask.Enabled:=true;
    cheWay.Caption:= SwitchS(iLanguage,'原像色','原像色','Source Color',''); cheWay.Checked:=not U;  cheWay.Enabled:=true;
    end;
 14:begin  //控制按扭
    labX.Caption:='X';  posX.Caption:=FtoS(p0.x,0);
    labY.Caption:='Y';  posY.Caption:=FtoS(p0.y,0);
    labW.Caption:=SwitchS(iLanguage,'宽','寬','Width',''); varW.Caption:=ftos(W,0); varW.Enabled:=true;
    labH.Caption:=SwitchS(iLanguage,'高','高','Height',''); varH.Caption:=ftos(H,0); varH.Enabled:=true;
    labR.Caption:=SwitchS(iLanguage,'步长','步長','Step','');varR.Caption:=ftos(R,4); varR.Enabled:=true;
    labS.Caption:=SwitchS(iLanguage,'频率','頻率','Frequency','');  varS.Caption:=itos(S); varS.Enabled:=true;
    labColor.Caption:=SwitchS(iLanguage,'字体','字體','Font','');   varC.Caption:=TagN;

    if(Mode in[1,2,4])then cheColor.Caption:=SwitchS(iLanguage,'顺序','順序','Order',''); //动画 移动
    if(Mode=1)then cheSec.Caption:=SwitchS(iLanguage,'单次','單次','Single','');  //动画
    if(Mode=2)then cheSec.Caption:=SwitchS(iLanguage,'跟随','跟隨','Follow','');//移动
    if(Mode=3)then cheSec.Caption:=SwitchS(iLanguage,'长显','長顯','Always Show','');    //总是显示
    if(Mode=3)then cheColor.Caption:=SwitchS(iLanguage,'长隐','長隱','Always Hide','');  //总是隐藏
    if(Mode=3)then cheBlock.Caption:=SwitchS(iLanguage,'顺序','順序','Order','');
    if(Mode=3)then cheTrace.Caption:=SwitchS(iLanguage,'显后选','顯后選','Selected On Show','');//顯示后被選擇
    cheColor.Checked:=U;  cheSec.Checked:=Q;  cheBlock.Checked:=Mask;   cheTrace.Checked:=Trace;
//    labTrace.Caption:=SwitchS(iLanguage,'次数','次數','Times','');  varTrace.Caption:=itos(maxTrace); varTrace.Enabled:=true;
    end;
 17:begin //路径 三视图
    labW.Caption:=SwitchS(iLanguage,'线径','線經','Line Width',''); varW.Caption:=FtoS( W,4);
    if(M1)then begin //路径
      labL.Caption:=SwitchS(iLanguage,'长度','長度','Length','');   varL.Caption:=FtoS( L,4);
      labH.Caption:=SwitchS(iLanguage,'密度','密度','Density','');  varH.Caption:=FtoS( H,0);
      cheColor.Caption:=SwitchS(iLanguage,'随点','随點','Inherit Vector','');
      cheWay.Caption:=SwitchS(iLanguage,'圆滑','圓滑','Smooth',''); cheWay.Checked:=D;
      labShape.Caption:=SwitchS(iLanguage,'线型','線型','Style','');
      end
    else begin //三视图
      labR.Caption:=SwitchS(iLanguage,'投影率','投影率','Ratio','');  varR.Caption:=IIFs(a=0, FtoS( R,4), sa);
      cheSolid.Caption:=SwitchS(iLanguage,'填充','填充','Fill','');   cheColor.Checked:=F;
      cheWay.Caption:=SwitchS(iLanguage,'投影线','投影線','Rays',''); cheWay.Checked:=D;  cheWay.Enabled:=true;
      labShape.Caption:=SwitchS(iLanguage,'投影面','投影面','Shadow Plane','');
      if not isMove then with cmbStyle  do begin
        Clear; AddItem(SwitchS(iLanguage,'三视图','三视图','Three View',''),nil);
               AddItem(SwitchS(iLanguage,'yOz视图','yOz视图','yOz View',''),nil);
               AddItem(SwitchS(iLanguage,'xOz视图','xOz视图','xOz View',''),nil);
               AddItem(SwitchS(iLanguage,'xOy视图','xOy视图','xOy View',''),nil);
        ItemIndex:=trunc(L);
        end;
      end;
    end;
 18:begin //标记
    labW.Caption:=SwitchS(iLanguage,'线径','線經','Line Width',''); varW.Caption:=ftos(W,4); varW.Enabled:=true;
    labL.Caption:=SwitchS(iLanguage,'位置','位置','Position','');   varL.Caption:=IIFs(c=0, ftos(L,4),sc);
    labS.Caption:=SwitchS(iLanguage,'边数','邊數','Edges','');      varS.Caption:=ItoS(S);
    labR.Caption:=SwitchS(iLanguage,'半径','半徑','Ratio','');      varR.Caption:=FtoS(R,4);
    labH.Caption:=SwitchS(iLanguage,'间隔','間隔','Gap','');        varH.Caption:=ftos(H,4); varH.Enabled:=true;
    labT.Caption:=SwitchS(iLanguage,'锥度','錐度','Taper','');      varT.Caption:=ftos(Thick,4);

    labTrace.Caption:=SwitchS(iLanguage,'笔划','比劃','Nick','');  varTrace.Caption:=itos(maxTrace); varTrace.Enabled:=true;
    cheSolid.Caption:=SwitchS(iLanguage,'填充','填充','Fill','');   cheSolid.Checked:=F;
    if M2 then begin //角度标记
      labL.Caption:=SwitchS(iLanguage,IIFs(D,'角度','弧度'),IIFs(D,'角度','弧度'),IIFs(D,'Angle','Radian'),'');
        varL.Caption:=FtoS(L,4);
      bb:=(Obj[b].Kind=2)and(Obj[c].Kind=2)and EP(Obj[b].Vec.z)and EP(Obj[c].Vec.z);
      cheColor.Caption:=SwitchS(iLanguage,'方向角','方向角','Major','');
        if not bb then Rand:=false;   cheColor.Checked:=Rand;   cheColor.Enabled:=bb;
      cheSec.Caption:=SwitchS(iLanguage,'优角','優角','Major','');
        cheSec.Checked:=Q;      cheSec.Enabled:=not Rand;
      cheWay.Caption:=SwitchS(iLanguage,'补角','補角','Supplementary','');
        cheWay.Checked:=U;      cheWay.Enabled:=true;
      cheBlock.Caption:=SwitchS(iLanguage,'对顶角','对顶角','Opposite','');
        cheBlock.Checked:=Mask; cheBlock.Enabled:=not Rand;
      selWay0.Caption:=SwitchS(iLanguage,'弧度','弧度','Radian','');  selWay0.Checked:=not Deg;
      selWay1.Caption:=SwitchS(iLanguage,'角度','角度','Angle','');   selWay1.Checked:=Deg;
      cmbAccuracy.ItemIndex:=S; //精度
      end;
    cheTrace.Caption:=SwitchS(iLanguage,'标注','標注','Mark',''); cheTrace.Checked:=Trace;
    end;
 19:begin //圆锥曲线
    labW.Caption:=SwitchS(iLanguage,'线径','線經','Line Width',''); varW.Caption:=FtoS( W,4);
    if(Angle=1)then labL.Caption:=SwitchS(iLanguage,'周长','周長','Length','')
               else labL.Caption:=SwitchS(iLanguage,'长度','長度','Length','');
      varL.Caption:=FtoS( L,4);
    labR.Caption:=SwitchS(iLanguage,'离心率','离心率','Centrifugal Rate','');
      varR.Caption:=IIFs(dd>0,sd,FtoS(R,4));
    labH.Caption:=SwitchS(iLanguage,'精度','精度','Density','');    varH.Caption:=FtoS( H,0);
    cheWay.Caption:=SwitchS(iLanguage,'单边','單邊','Single','');   cheWay.Checked:=U;
    labShape.Caption:=SwitchS(iLanguage,'曲线','曲線','Curve','');
    with cmbStyle do begin
      Clear; AddItem(SwitchS(iLanguage,'抛物线','三角形','Parabola',''),nil);
             AddItem(SwitchS(iLanguage,'椭圆','菱形','Ellipse',''),nil);
             AddItem(SwitchS(iLanguage,'双曲线','四边形','Hyperbola',''),nil);
      ItemIndex:=trunc(Angle);
      end;
    end;
  end; //case
  if M7 and(Kind<>11)then begin //投影变换
    labR.Caption:=SwitchS(iLanguage,'投影率','投影率','Ratio','');   varR.Enabled:=true;
    if(dd=0)then varR.Caption:=FtoS(R,4)
      else if(dd>0)and(ee=0)and(ff=0)then varR.Caption:=sd
      else if(dd>0)and(ee>0)and(ff=0)then varR.Caption:=sd+'/'+se
      else if(dd>0)and(ee>0)and(ff>0)then varR.Caption:=sd+','+sf +'/'+ sd+','+se;
    labT.Caption:=SwitchS(iLanguage,'光线','光線','Light','');
      varT.Caption:=IIFs(c=0,'',Obj[c].Tag);  varT.Enabled:=true;
    cheColor.Caption:=SwitchS(iLanguage,'点光','點光','Point Light','');
      cheColor.Checked:=U; cheColor.Enabled:=(c>0)and(Obj[c].Kind=2);
    cheWay.Caption:=SwitchS(iLanguage,'投影线','投影線','Rays','');
      cheWay.Checked:=D;
    end;
  if M9 and(Kind<>11)then begin //旋转变换
    varL.Enabled:=false;
    labR.Caption:=SwitchS(iLanguage,'转角','轉角','Rotate Angle',''); varR.Enabled:=true;
    if(dd=0)then varR.Caption:=FtoS(R,4)
      else if(dd>0)and(ee=0)and(ff=0)then varR.Caption:=sd
      else if(dd>0)and(ee>0)and(ff=0)then varR.Caption:=sd+','+se
      else if(dd>0)and(ee>0)and(ff>0)then varR.Caption:=sd+','+se +','+ sf;
    cheColor.Caption:=SwitchS(iLanguage,'反向','反向','Inverse','');
    cheColor.Checked:=U;
    selWay0.Caption:=SwitchS(iLanguage,'弧度','弧度','Radian','');
    selWay1.Caption:=SwitchS(iLanguage,'角度','角度','Angle','');
    selWay0.Checked:=not Deg;   selWay1.Checked:=Deg;
    end;
  if M10 and(Kind<>11)then begin //缩放变换
    labR.Caption:=SwitchS(iLanguage,'缩放率','縮放率','Scale',''); varR.Enabled:=true;
    if(dd=0)then varR.Caption:=FtoS(R,4)
      else if(dd>0)and(ee=0)and(ff=0)then varR.Caption:=sd
      else if(dd>0)and(ee>0)and(ff=0)then varR.Caption:=sd+'/'+se
      else if(dd>0)and(ee>0)and(ff>0)then varR.Caption:=sd+','+sf +'/'+ sd+','+se;
    end;
  if M11 and(Kind<>11)then begin //平移变换
    cheWay.Caption:=SwitchS(iLanguage,'矢量平移','矢量平移','Vector','');
      cheWay.Checked:=U;  cheWay.Enabled:=true;
    labL.Caption:=IIFs(U,'dL','dX');   varL.Enabled:=true;
    labS.Caption:=IIFs(U,'rX','dY');   varS.Enabled:=true;
    labR.Caption:=IIFs(U,'rZ','dZ');   varR.Enabled:=true;
    varL.Caption:=IIFs(b>0, sb, FtoS( IIFf(U,pBL.x,pTR.x),4));
    varS.Caption:=IIFs(c>0, sc, FtoS( IIFf(U,pBL.y,pTR.y),4));
    varR.Caption:=IIFs(dd>0,sd, FtoS( IIFf(U,pBL.z,pTR.z),4));
    end;
  if M12 then begin //向量变换
    selWay0.Enabled:=true;  selWay1.Enabled:=true;
    varR.Caption:= IIFs(dd=0, FtoS( R,4), sd);
    if(dd=0)then varR.Caption:=FtoS(R,4)
      else if(dd>0)and(ee=0)then varR.Caption:=sd
      else if(dd>0)and(ee>0)then varR.Caption:=sd+','+se;
    bb:=D; if(Mode=12)then bb:=Deg;  //(Mode=12)向量变换
    labR.Caption:=SwitchS(iLanguage,IIFs(bb,'距离','比例'),IIFs(bb,'距離','比例'),IIFs(bb,'Distance','Ratio'), '');
    selWay0.Checked:=not bb;  selWay1.Checked:=bb;
    selWay0.Caption:=SwitchS(iLanguage,'定比','定比','Ratio','');
    selWay1.Caption:=SwitchS(iLanguage,'定距','定距','Distance','');
    end;
  if M14 and(Obj[a].Kind in[2,4])and(Kind<>11)then begin //自定义变换
    labR.Caption:=SwitchS(iLanguage,'精度','精度','Accuracy','');
    varR.Caption:=FtoS(R,0); varR.Enabled:=true;
    end;
  end; //with
end;
//===================== 更新控件属性 ===================
procedure TfrmMain.ShowObjProp(ID,x,y :integer; bL,bR :boolean);
  var i,hi,t, aK,bK,cK,aM,bM :integer;
  label Next;
  function fts( a:single; wid,len:integer):string;
    begin STR( a:wid:len, result); result:=trim(result); end;
begin
  tabProp.TabIndex:= IIFi((ID<1),1,0);
  posEdit.Hide;
  for i:=0 to LayerTime do with Obj[ID]do begin
    setBevel( not ObjShow[i], aObjShow[i], nil );  //对象显示状态
    setBevel( not TagShow[i], aTagShow[i], nil );  //标签显示状态
    end; // for i
//  pnlShow.Visible:=(MarkObj>10);
//  barPage.Visible:=not pnlShow.Visible;
  if(not butProp.Down)or(ID<1)then begin
    pnlProp.Visible:=bNail;   goto Next;
    end;
  with Obj[ID] do begin
   k1:=Kind=1;   k2:=Kind=2;   k3:=Kind=3;   k4:=Kind=4;   k5:=Kind=5;
   k6:=Kind=6;   k7:=Kind=7;   k8:=Kind=8;   k9:=Kind=9;  k10:=Kind=10;
  k11:=Kind=11; k12:=Kind=12; k13:=Kind=13; k14:=Kind=14; k15:=Kind=15;
  k16:=Kind=16; k17:=Kind=17; k18:=Kind=18; k19:=Kind=19; k20:=Kind=20;
  m1:=Mode=1; m2:=Mode=2; m3:=Mode=3; m4:=Mode=4; m5:=Mode=5;
  m6:=Mode=6; m7:=mode=7; m8:=Mode=8; m9:=mode=9; m10:=Mode=10;
  m11:=Mode=11; m12:=Mode=12; m13:=Mode=13; m14:=Mode=14;  m15:=Mode=15;
  m16:=Mode=16; m17:=Mode=17; m18:=Mode=18; m19:=Mode=19;
  if(ID>1)then begin
    aK:=Obj[Link[0]].Kind;  aM:=Obj[Link[0]].Mode;
    bK:=Obj[Link[1]].Kind;  bM:=Obj[Link[1]].Mode;
    cK:=Obj[Link[2]].Kind;
    end;
  if ID>0 then ShowProp( ID,false) else goto Next;     //显示属性值

  pnl2.Visible:= not(K8 or K10 or K11 or K14) or K11 and M2; //颜色
  pnl3.Visible:= K1 and(ID>9) or K6 and M1 or K10 or K11 or K14; //X
    posX.Enabled:=(K1 and M1) or K6 and M1 or K10 or K11 or K14;
  pnl4.Visible:= pnl3.Visible;  posY.Enabled:= posX.Enabled; //Y
  pnl5.Visible:= K1 and(ID>9) or K10 or K11 or K6 and(M1 or M2);
    posZ.Enabled:=(K1 and M1) or K10 or K11 or K6 and(M1 or M2); //Z

  pnl6.Visible:= (Kind in[1,2,3,5,15,16,17,19]) or(K9 and M3) //varW
              or K6 and((Mode<5)or(Mode>6))
              or K4 and(M3 or M4 or M5 or M6 and Rand)
              or K14 or K18; //按钮 标注
    varW.Enabled:=not(K4 and M6 and Rand and(Link[2]>0)and(W<99));// 除多边形之外

  pnl7.Visible:= K1 and(M2 and(bK>1) or(M2 and(bK=1)and(bM=6) or M6))  //varL
              or K2 and not(M6 and not((bK=4)and(aK in[3,4])) )  //线长、文字比例
              or K2 and M6 and(aK=19)
              or K4 and(M3 or M4 or M5 or(M6 and Rand)) //
              or K7 and M1 and((aK=2)or(aK=3)and(Obj[Link[0]].Mode<5)) //旋转曲面
//              or K7 and M4 and(aK=2) //轨迹面
              or K6 and(Mode in[1..4,6,15]) or K10 and(Mode=2) //实体、块、迭代
              or(K17 and M1) or K18 and(Mode=2) //角度标注
              or(Kind in[3,5,8,11,13,15,16,18,19]) or M11 ;
    varL.Enabled:=(Mode<13) //复制线 棱边
               and not(K2 and M6 and(aK=4)and(bK=4)and not D ) //俩平面的相惯线
               and not(K2 and(M1 or M4) and not(D or F) ) //两点线 垂线
               and not(K2 and M2 and(trunc(R)=1)) //坐标向量长度不能编辑
               and not(K3 and (Mode>1)) //点法圆
               and not(K11 and(Mode<>2))and not(Kind in[5,15,16,17]) or M12;
  pnl8.Visible:= K1 and M2 and(bK in[2,5,15,16,17,19])//varS
              or K1 and M2 and((bK=4)and Mask or (bK=3)and not Mask)
              or K2 and M2 and(ID>9)and(trunc(R)<2) //点斜线
              or K3 and(Mode<5) //圆(弧)精度
              or K4 and M6
              or K6 and(Mode in[1..4,6,15])
              or K7 and(M1 or M2 and((aK=2)or(aK=1))and(bK=2)) //直纹曲面 旋转曲面圆度;
              or K10 or K11 and(M2 or M13 and(bK=2)) //参数起始值
              or K13 or (K14 and(M1 or M2))
              or(K18 and M1)or(K10 and M1) //移动频率
              or M11 ;
  pnl9.Visible:= K1 and M6  //varH 等分点
              or K2 and M2 and(trunc(R)=1)and(ID>10) //位向量
              or K2 and(M5 or M4 and(aK=1)and(bK=1)) //两点之中线/垂线 间比
              or K3 and(M3 or M1)
              or K4 and(M3 or M5)//平行面
              or K5 and M1 //轨迹线
              or K6 and(Mode in[2,3,4])and not(M3 and(S<6)) //圆锥或台体的高/径比
              or K6 and M1 or(K17)and(M1)
              or K7 and M1 or K10 or K14 or K16 or K18 or K19; //旋转曲面终角
  pnl10.Visible:=K1 and(ID>9) or K2 and(ID>9) or K17 or K11 and M2
              or not(Kind in[1,2,8,11,13,14,17])or(not K11)and(Mode>6); //透明度([块]、[文字]除外)
    //varA.Enabled:=Kind in[1,2,3,4,5,6,7,9,10,15..19];//透明度

  pnl11.Visible:=K1 and M2 and(bK in[2,3,4,5,9,15,16,17,19]) //varT 约束点的步长 M7投影复制的光线
              or K3 or K4 and (Mode<7)// not((Mode>6) or (Mode=6)and(not D)) //厚度 Thick
              or K6 and(M2 or M4 or M3 and(S=6)) //偏移
              or(K10 and M1) or K18 and M1 or M7 //标注的位置
              or(K11 and M2); //参数终止值
  pnl12.Visible:=K1 and(M4 or M7) //cheColor 颜色随顶点 文字直列 圆弧反向
              or K1 and M2 and(bK in[2,3,4,5,15,16,17,19]) //锁定或限制[点]
              or K2 and(Mode in[1,3,4,5])and(ID>10)
              or K2 and(M19 or M6 and(aK=19))
              or K3 and(M2 or M3)
              or K3 and M15 and((aK=2)or(aK=3)and(Obj[Link[0]].Mode in[3,4]))  //线段反演为圆弧
              or K4 and(Mode in[1,2,5])and(MarkObj>10)
              or K4 and M6 and Rand and(W<100) //正n多边形(W>100)没有顶点
              or K6 and(M1 or M3 or M4 or M6) //  and( (aK=1)and(Link[5]>0)or(aK=6) )  and(S<100)
              or K5 or K7 and(Mode<7) or K16 //轨迹线色随点、曲面面色随线
              or K10 or K13 or K17 and M1
              or K14 and(M1 or M2 or M3 or M4)
              or K11 and M2 or K18 and M2
              or M7 or M9 and(Kind<>11); //or(K11 and M2)
  pnl13.Visible:=(Kind in[3..7,9,13,15..19]) //cheSolid 填充
              or K2 and(M1 or (aK=19)and(aM=1)and(R<>1)) //双曲线的准线
              or(K11 and M2)
              or K1 and M2 and(bK in[2,3,4,5,15,16,17,19]); //约束点 双向
  pnl14.Visible:=K1 and M2 and((bK=3)and(bM<3)or(bK=4)or(bK=9))   //cheMask 约束点内部/边界
              or K4 and(MarkObj>10)and not((Obj[parent].Mode=6)and not(Obj[parent].Rand)) //消影 定长(两点线) 外分(角分线)
              or K2 and(Mode in[1,4,5,19])  //线段
              or K2 and not(M3 or M6 and(aK<>4)or(bK<>4) or(Mode>5) )
              or K5 and M1 or K3 and(Obj[parent].Mode<3)  //
              or K6 or K7 or K11 or K13 or K9 and(Mode<13) or K10 and(Mode=2);
    butTex.Visible:=K6 and(Obj[parent].Mode in[1,2,6])
              or K4 or K7 or K3 and(Obj[parent].Mode<3)
              or K9 and(Mode<13) or K10 and(Mode=2); //贴图
  pnl15.Visible:=K2 and(ID>10)and(Mode in[1,3,4,5,6])  //cheWay
              or K2 and M19
              or K3 and(Mode in[3,4])
              or K6 and(Mode in[2,3])
              or K6 and M4 and(S>0)
              or K6 and M1 and(Obj[Link[1]].Kind=1)
              or M11 or M7 and((Kind in[1,2,4])or(Kind=6)and(Obj[parent].Mode in[3,4])) //M7 平行光投影变换 M11平移变换
              or K13 or K17 or K19
              or(K7 and M4) or (K18 and M2) or (K11 and M6)
              or K11 and(M2 or M16 or M17 or M18 or M19); //向量 格式化
    cheWay.Enabled:=(Obj[parent].Kind in[2,3,4,5,6,7,9,11,15,16,17]) or M11
              or(K1 and M7) or K19 and(M1 and(trunc(Angle)<>1) or M2 and(R>=1));
  pnl16.Visible:=K1 and M5 and((Link[2]>0)and(aK*bK*cK=1) //三点之中点
                            or (aK=4)and(Obj[Link[0]].W=3)) //三角平面之中点
              or K2 and(ID>9) or (Kind in[3,4,5,15,16,17,19]); //线形、填充图案  and not M6
    if pnl16.Visible then begin
      cmbFill.Clear;
      if(K1 and M5)and((Link[2]>0)and(aK*bK*cK=1)
                    or (aK=4)and(Obj[Link[0]].W=3))then begin //三角平面的中点
        labFill.Caption:=SwitchS(iLanguage,'四心','四心','Centers','');
        cmbFill.Top:=-2;
        cmbFill.Style:=csDropDown;
        cmbFill.AddItem(SwitchS(iLanguage,'外心','外心','Circumcenter',''),nil);
        cmbFill.AddItem(SwitchS(iLanguage,'内心','内心','Inner point',''),nil);
        cmbFill.AddItem(SwitchS(iLanguage,'重心','重心','Barycenter',''),nil);
        cmbFill.AddItem(SwitchS(iLanguage,'垂心','垂心','Orthocenter',''),nil);
        cmbFill.ItemIndex:=trunc(H);
        end
      else begin
        cmbFill.Top:=-4;
        cmbFill.Style:=csOwnerDrawFixed;
        case Kind of
          2,5,16,19: t:=7; 4:t:=12; 15:t:=4; 17:t:=IIFi(Obj[parent].Mode=1,7,3); else t:=16; end;
        for i:=0 to t do cmbFill.Items.Insert(i,'a');
        t:=S mod 100;   t:=IIFi(t>7,(t div 10)+7, t Mod 10);
        if(Kind=4)and(t>3)then t:=t-4;
        cmbFill.ItemIndex:=t;
        end;
      end;

  pnl18.Visible:= true; //父构件、子构件
  pnl19.Visible:=K1 and M2 and((bK=2)or(bK=3)and(bM<5))// 约束点
              or K2 and(M2 or(M3 and(bK in[3,4]))or(M4 and(bK<3)))and(ID>9)
              or K2 and M5 and(aK=1)and(bK=1) //两点之中线
              or K3 and(M1 or M2 or M3)
              or K4 and(M3 or M4 or M5 or M6 and Rand) // 点法弧 角度标注 正多边形
              or K6 and(Mode in[1..4,6])
              or K7 and M1  //旋转曲面
              or K11 and(M1 or M6) //角度
              or(K18 and M2) or M9 and(Kind<>11) or M12;
  pnl20.Visible:=K1 and M2 and(bK in[2..6,9,15..17,19]) //varR //转角
              or K2 and M2 and((trunc(R)<2)or(MarkObj<5))
              or K2 and M3 and(bK in[3,4])
              or K2 and M4 and(aK=1)and(bK<3) //垂线转角
              or K2 and M5 and(aK=1)and(bK=1)and(Link[3]=0) //中线
              or K3 and(M1 or M2)
              or K4 and(M3 or M4 or M5 or(M6 and Rand)) //垂面 平行面 中面 正多边形：旋转角
              or K4 and(M1 or M2)and not((bK=2)and(aK=2)) //三点面 点线面：位似比
              or(K7 and M1)or K6 and(Mode in[1..4,6])
              or K11 and(M2 or M13 and(bK=2))
              or K14 and M2 //移动按钮步长
              or(K17 and M2) //三视图
              or K18 or K19 and M2 //圆锥曲线二
              or M14 and(aK in[2,4])and(Kind<>11) //自定义变换 精度
              or M7 or M9 and(Kind<>11) or M10 or M11 or M12 or M15 and(Kind<>11);
  pnl21.Visible:=K4 and M1 and(MarkObj>10)          //三点式平面形状
              or K4 and M2 and not((aK=2)and(bK=2)) //点线式平面形状
              or K11 and(M15 or M16 or M17) //坐标度量
              or K2 and M2 and(MarkObj>10) //点向线 向量运算
              or K1 or K19 and M1 or K17 and M2;  //点形状 圆锥曲线一
  pnl22.Visible:=(MarkObj>10)and K2 and not M6; //直线箭头
  pnl23.Visible:=K2 and(ID>9)and(Mode<>13) or K4 and(MarkObj>10) //cheSec
              or(K11 and(M1)) // or M2
              or(K14 and(M1 or M2 or M3))or(K18 and M2) or K13
              or not(Kind in[1,2,4,10,11,14,18]); //文字 图像 计算 按钮不被剪裁
    butCutter.Visible:=(Kind in[2,3,4,5,6,7,9,13,15,16,19]) or K17 and M1;
  pnl24.Visible:=K7 or K9;// and(Mode<>13); //炫彩
  pnl25.Visible:=K1 and(M1 or M2)  //cheLock 锁定
              or K2 and(Mode in[1..6]) //内切
              or K2 and M19 and(aK=3)and(bK=3) //两圆公切线
              or K3 and(M1 or M3)
              or K4 and(M3 or M4 or M5 or(M6 and Rand))
              or K6 and(Mode<5) or(K7 and M4)
              or K5 and(M1) or K8 or K10 or K11
              or K14 or K17 or K18
              or M7 or M9 or M10 or M11 or M15;
  pnl26.Visible:=K1 and M2 and(bK<>6) //cheBlock 约束点随机
              or K2 and(Mode in[1..12,19])and(ID>10) //遮挡
              or(Kind in[3,4,5,6,15,16,19]) or K17 and M1  //遮挡
              or(K11 and M2) //参数随机
              or(K18 and M2) or K14 and(Mode=3); //角度标注 对顶角
  pnl27.Visible:=K1 and(ID>9) or K2 and(ID>9)  or(K11 and M2) //cheTrace
              or K4 and(MarkObj>10)
              or K6 and(Obj[parent].Mode=3)and((S mod 10)<7) //炫彩 正多面体/长方体
              or K14 and M3
              or(Kind in[3,5,7,15,16,19]) or(K18 and M2) or (K17 and not M2);//痕迹
  pnl28.Visible:=pnl27.Visible and not K6
              or K18; //参数动画的计算次数 痕迹长度 K14 and M1 or

  pnl29.Visible:=K11 or(K18 and M2); //计算精度
  pnl47.Visible:=MarkObj>10; //cheShow
  pnl48.Visible:=K6 and M3 and((S mod 10)<3)and(aK=1)and(bK=1); //以底边两端点作正六面体
             // or K4 and M6 and Rand and(aK=1)and(bK=1); //以底边两端点作正多边形
  CtrlNum:=-1;
  if ID>0 then //设置属性控件的位置
    for i:= 0 to 31 do
      if pnlArray[i].Visible then begin
        inc(CtrlNum); pnlArray[i].Top:= CtrlNum*15;
        end;
  end; //with
Next:
  with pnlProp do begin
    pnlProp.Height:= IIFi(ID>0, CtrlNum*15+74, 343); //属性框高度 341 230
    if(Top+Height>frmMain.ClientHeight)or(Top<0)then Top:=24;
    if(Left+Width>frmMain.ClientWidth)or(Left<0)then Left:=frmMain.ClientWidth-Width;
    Visible:=bNail or butProp.Down;
    end;
end;
//================== 切换属性窗口 ===================
procedure TfrmMain.tabPropChange(Sender: TObject);
begin
  if bAdd then BreckAdding;
  pnlProp.Height:=IIFi(tabProp.TabIndex=0,IIFi(MarkObj<11,44,CtrlNum*15+74),343);
  posEdit.Hide;  pnlColorPad.Hide;  
end;
//======================= 坐标指示线 ========================
procedure TfrmMain.PosDraw( ID:integer);
  var st:string[23];  p:TcgVector; Co:TcgColorF;
  function FtoS( v :single) :string;   //将浮点数转换为格式文本
    begin str( v:0:2, result); end;
begin //用鼠标拖动构件时，绘制构件的基点坐标指示线
  with Obj[ID]do begin
  case Kind of
    1:p:=p0;
    2:p:=p1;
    3:case Mode of
      1:p:=p4;
      3:p:=LocaVct[ID,high(LocaVct[ID])];
      2,4:p:=p0;
      end;
    end;
  if(ID=0)or(Kind=1)and(Mode=1)then begin
    glDisable( GL_LIGHTING);
    glColor4fv( @AxisColor);    glLineWidth(1);
    glEnable( GL_LINE_STIPPLE); glLineStipple(1,$1F1F);
    glBegin( GL_LINES); // GL_POINTS);//
      glVertex3f(p.x,p.y,0);  glVertex3fv(@p);
      glVertex3f(0,0,0);      glVertex3f(0,p.y,0);
      glVertex3f(p.x,0,0);    glVertex3f(p.x,p.y,0);
      glVertex3f(0,p.y,0);    glVertex3f(p.x,p.y,0);
      glVertex3f(0,0,0);      glVertex3f(p.x,0,0);
    glEnd;
    glDisable( GL_LINE_STIPPLE);
    end;
  if(cheHint.Checked)and(ID>10)and(Kind=1)and(Mode in[1,2,7,9,10])then begin
    Co:=cgColorF(0,0,0, 1);
    if BackColor.R<0.6 then Co.R:=1;
    if BackColor.G<0.6 then Co.G:=1;
    if BackColor.B<0.6 then Co.B:=1;
    glColor3fv( @Co); //坐标值颜色
    glRasterPos3f( p.x, p.y, p.z ); //三维点的屏幕坐标
    if(Mode in[7,10])then st:=FtoS(R) else st:=FtoS(L);
    if(Mode in[1,4,5])then //自由点 交点 中点
      st:=ftos(p.x)+', '+ftos(p.y)+', '+ftos(p.z);
    if(Mode=2)and(Obj[Link[1]].Kind=1)and not Mask then  //约束到点的点
      st:=ftos(Obj[Link[1]].p0.x)+', '+ftos(Obj[Link[1]].p0.y)+', '+ftos(Obj[Link[1]].p0.z);
    if(Mode=2)and(Obj[Link[1]].Kind=4)and not Mask then  //平面上的点
      st:=FtoS(L)+ ', '+FtoS(R);
    st:='   '+st;
    glCallLists( Length(st), GL_UNSIGNED_BYTE, PChar( @st)+1);
//  stbBar.Caption:=st; stbBar.Refresh;
    end;
  end; // with
end;
{===================== 坐标轴的显示列表 ==========================}
procedure TfrmMain.GridList; //坐标网格
  const c=0.1; a=-0.5; e=0.3;
  var i, x,x0,x1,y,y0,y1 :integer;  cL,cR:single;  bz:boolean;
begin
  glNewList(Obj[10].mainList, GL_COMPILE);  //网格线
    glDisable( GL_LIGHTING);  glDisable( GL_LINE_SMOOTH);
    with BackColor do
      glColor3f(r+IIFf(r>0.8,-c,c), g+IIFf(g>0.8,-c,c), b+IIFf(b>0.8,-c,c));
    bz:=cheMark.Checked and cheAngle.Checked; //弧度
    x0:=-trunc(Obj[2].R);         if bz then x0:=-trunc(Obj[2].R/quadPi);
    x1:=trunc(Obj[2].L-Obj[2].R); if bz then x1:=trunc((Obj[2].L-Obj[2].R)/quadPi);
    y0:=-trunc(Obj[3].R);
    y1:=trunc(Obj[3].L-Obj[3].R);
    glBegin( GL_LINES); //竖网格
      for i:= x0 to x1 do if not((i=0)and Obj[3].ObjShow[Layer]) then begin //if(i<>0)then begin //
        cL:=i; if bz then cL:=i*quadPi;
        glVertex3f(cL,y0,-0.01); glVertex3f(cL,y1,-0.01);
        end;
    glEnd;
    glBegin( GL_LINES); //横网格
      cL:=x0; if bz then cL:=x0*quadPi;
      cR:=x1; if bz then cR:=x1*quadPi;
      for i:= y0 to y1 do if not((i=0)and Obj[2].ObjShow[Layer]) then begin //if(i<>0)then begin //
        glVertex3f(cL,i,-0.01); glVertex3f(cR,i,-0.01);
        end;
    glEnd;
  glEndList;
end;

procedure TfrmMain.AxisList;
  const c=0.1; a=-0.5; e=0.3;
  var i, x,x0,x1,y,y0,y1 :integer;  cL,cR:single;  bz:boolean;
      p:array[0..6]of TcgVector;
begin
  setFog;
  AxisColor:= getScrColor(backColor);
  for i:=9 to 10 do with Obj[i]do begin
    getListID(stipList,1); getListID(mainList,1); getListID(wireList,1); getListID(seleList,1);
    end;
  with Obj[1]do begin //坐标原点
    Kind:=1; Mode:=1; // if(W<1)then W:=4; TagC:=Link[10];
    Pointe( 1,true,true,false);
    end;

  for i:=2 to 4 do Lineer( i, true, true,false);  //坐标轴相当于[直线]
  for i:=5 to 7 do Plane(i, true,true); //坐标平面

  glPushAttrib( GL_ALL_ATTRIB_BITS );
  p[0]:=cgVector(0,0,0);
  p[1]:=cgVector(c,0,a);  p[2]:=cgVector(-c,0,a);  p[3]:=p[0];
  p[4]:=cgVector(0,c,a);  p[5]:=cgVector(0,-c,a);  p[6]:=p[0];
  glNewList(Obj[9].mainList, GL_COMPILE);  //箭头
    glLineWidth(0.5);
    glBegin( GL_Triangles);   for i:=0 to 5 do glVertex3fv(@p[i]); glEnd;
    glBegin( GL_LINE_STRIP);  for i:=0 to 6 do glVertex3fv(@p[i]); glEnd;
  glEndList;
  GridList; //坐标网格
  for i:= 1 to 7 do GetTextList( i);
  glPopAttrib;
end;
{========================== 坐标轴 ===============================}
procedure TfrmMain.AxisDraw(bName,bMask:boolean);
  var   i,j, x,x0,x1 :integer;  cL:single;
begin
  setEnable( cheSmooth.Checked, GL_LINE_SMOOTH );
  glDisable( GL_LIGHTING); glLineWidth(1);  //关闭灯光
  if bMask then begin
    glDepthFunc( GL_GREATER); //写入深度较大的值
    if Obj[2].ObjShow[Layer] then glCallList(Obj[2].stipList);  //x轴
    if Obj[3].ObjShow[Layer] then glCallList(Obj[3].stipList);  //y轴
    if cheAxisZ.Checked and Obj[4].ObjShow[Layer] then glCallList(Obj[4].stipList);// 4+4000);
    glDepthFunc( GL_LESS);    //写入深度较小的值
    end;
  glLoadName( 2);
    if Obj[2].ObjShow[Layer]or bAll then glCallList(Obj[2].mainList);// 2); //X轴
  glLoadName( 0);
  glLoadName( 3);
    if Obj[3].ObjShow[Layer]or bAll then glCallList(Obj[3].mainList);// 3); //Y轴
  glLoadName( 0);
  if cheAxisZ.Checked then begin //Z轴
    glLoadName( 4);
    if Obj[4].ObjShow[Layer]or bAll then glCallList(Obj[4].mainList);// 4);
    glLoadName( 0);
    end;
end;
//=======================Main draw procedure========================
procedure TfrmMain.MainDraw( ModOrRender :GLEnum; isFlash:boolean; func:char);
  var i,k, m :integer; xL,xR :single;
      na,nb,pp :TcgVector;
      bMask, bName, bT :bool;  //如果存在线框消影的多面体或台体
      eqn:array[0..3] of gldouble; //剪切平面方程的系数
  label NoDraw, isSelect;
  procedure setSector(ID:integer; isSec:boolean); //设置截面
    var i,sec :integer;
    begin
      if bAll or not isSec then begin
        glDisable(GL_CLIP_PLANE0); glDisable(GL_CLIP_PLANE3);
        glDisable(GL_CLIP_PLANE1); glDisable(GL_CLIP_PLANE4);
        glDisable(GL_CLIP_PLANE2); glDisable(GL_CLIP_PLANE5);
        end
      else with Obj[ID] do begin
        Sec:=0;
        for i:=0 to 5 do//查找剪裁平面
          if(Cutter[i,2]>0)and(Cutter[i,1]>0)and(Obj[Cutter[i,1]].DelID=0)then begin
            inc(Sec); //H值:0,1,2
            pp:=Obj[Cutter[i,1]].Vec;
            if(Cutter[i,2]=2)then pp:=cgVecScale(pp,-1); //cgInvertVec(pp);//
            eqn[0]:=pp.x; eqn[1]:=pp.y; eqn[2]:=pp.z; eqn[3]:=pp.w;//剪切平面方程的系数A、B、C、D。
            case Sec of
              1:glClipPlane(GL_CLIP_PLANE0, @eqn);  //设置剪裁平面
              2:glClipPlane(GL_CLIP_PLANE1, @eqn);
              3:glClipPlane(GL_CLIP_PLANE2, @eqn);
              4:glClipPlane(GL_CLIP_PLANE3, @eqn);
              5:glClipPlane(GL_CLIP_PLANE4, @eqn);
              6:glClipPlane(GL_CLIP_PLANE5, @eqn);
              end;
            end;
        if(sec>0)then glEnable(GL_CLIP_PLANE0);
        if(sec>1)then glEnable(GL_CLIP_PLANE1);
        if(sec>2)then glEnable(GL_CLIP_PLANE2);
        if(sec>3)then glEnable(GL_CLIP_PLANE3);
        if(sec>4)then glEnable(GL_CLIP_PLANE4);
        if(sec>5)then glEnable(GL_CLIP_PLANE5);
        end;
    end;
  procedure printTag; // 显示标签
    var i,ID :integer;
  begin  // glDepthFunc( GL_ALWAYS); //不论是否通过深度检测
    for ID:=1 to ObjCount do
    if not(ID in[5..10])then //2,3,4,
    with Obj[ID] do if(delID=0)and not Hide then begin
      if(Mode=13)then with Obj[parent]do begin
        if(Kind=6)and not(U) then continue; //U:顶点
        if(Kind=6)and(Mode=4)and(Obj[Link[0]].Kind=4)and(Obj[Link[0]].Mode=1)and(Obj[Link[0]].L=0)and(ID=parent+16)
          then continue; //以三角形平面为底的凸棱台最后一个顶点
        end;
      bT:=TagShow[Layer] and (ObjShow[Layer] or Hot or bAll)
        or(ID=1)and ObjShow[Layer] and cheOrigin.Checked;
      if bAdd and(ID=ObjCount)then bT:=false;
      if(Kind=1)and(Mode=4)and Hide then bT:=false;
      if hot or Mask then glDepthFunc( GL_ALWAYS);  //不被其它构件遮挡
      if(bT)then
      case Kind of
        1:print( p0, ID); //点
        2:print( cgVecAddMult(p0,Vec,TagP.z*L),ID);
        3:begin case Mode of
            1,2,6,7,8,9: xL:=TagP.z; //圆
            3:xL:=R+TagP.z*H*IIFi(U,-1,1)/IIFf(D,L,1); //点法弧
            4:xL:=R+TagP.z*H; //三点弧
            end;
          pp:= DotInCircle(  p0, ID, xL, L,0,0);
          print( pp, ID);
          end;
        4:begin //平面标签位置  (ID in[5..7])
            pp:=cgOrigin; for i:=0 to 2 do pp:=cgVecAdd(pp,LocaVct[ID,i]); //各顶点坐标的平均值
            pp:=cgVecScale(pp,0.33);
            print(pp, ID); //平面
            end;
        6,13:print( p1, ID); //多面体 迭代
        5,7,9,15,16,19:print( p0, ID); //轨迹 多面体 曲面 方程式 相贯线
        17:if(Mode=1)then print( p0, ID); //路径
        8:print( Obj[Link[0]].p0,  ID); //块
        18:print(p2,ID); //标注
        end;//case Kind
      glDepthFunc( GL_LESS); //写入深度较小的值
      end;//with Obj[ID]
    end; //printTag
  procedure DrawDot(bDraw,bName,bVertex :boolean);//#### [点] ######################################
    var i,j :integer;
  begin
    glDisable(GL_LIGHTING);
    For i:= 1 to m do
      with Obj[i] do begin
      if hide or(DelID>0) or(Kind<>1)or(i in[2..10])then continue;
      if(i=1)and not cheOrigin.Checked then continue; //'o',原点
      if not(bAll or ObjShow[Layer] or Hot) then continue;
      if(Mode=13)then begin //多边形或多面体的顶点
        if not(Obj[parent].U)or not(Obj[Link[0]].ObjShow[Layer] or bAll) or Lock
          then continue;
        end;
      if(Mode=13)then with Obj[parent]do begin
        if(Kind=6)and(Mode=4)and(Obj[Link[0]].Kind=4)and(Obj[Link[0]].Mode=1)and(Obj[Link[0]].L=0)and(i=parent+16)
          then continue; //以三角形平面为底的凸棱台最后一个顶点
        end;
      if Trace then begin
        if bName then glLoadName(i);//*200+30000); //为下面绘制的对象命名
        if bDraw then glCallList(tracList);//i*200+30000); //跟踪
        end;
      if bName then glLoadName( i ); //为下面绘制的对象命名
      if bDraw then glCallList( mainList);
      if Hot or Seled then begin
        if(Mode<>6)and(S>0)then begin
          glPushMatrix;
          glTranslatef( p0.x, p0.y, p0.z); //移动原点
          glRotatef( -rx, 0,0,1);   glRotatef( -ry, 1,0,0);
          end;
        glCallList( seleList);//i+9000);
        if(S>0)then glPopMatrix;
        end;
      glLoadName( 0 );
      if bL and not bAdd and bAxis and(i=hit)then PosDraw( i); //拖动时画坐标指示线
      glDisable(GL_CLIP_PLANE0); glDisable(GL_CLIP_PLANE1); glDisable(GL_CLIP_PLANE2);
      if(ModOrRender=GL_RENDER)then begin
        for j:=i+1 to ObjCount do //是否有文本或图片链接
          if(Obj[j].DelID=0)and(Obj[j].Kind in[10,11])and(Obj[j].Link[10]=i)
          then TagScr:= GetDotPos(p0,true);//构件的屏幕坐标
        if bFrameSel and(not noSel)then begin //框选状态
          para[4]:=GetDotPos(p0,true); para[4].y:=ClientHeight-para[4].y+26;
          end;
        end;
      end;// for...with
    end;
  procedure DrawLine(bName,bLine, bMask,bNoMask :boolean); // 直线 轨迹线 相贯线 ##############
    var i,a,Ka :integer;  //bMask是否有遮挡构件
  begin
    glDepthFunc( GL_GREATER); //被遮挡的虚线 写入深度较大的值
    For i:= 11 to m do with Obj[i] do begin
      if hide or(DelID>0) or not(Kind in[2,5,15,16,17,18,19]) then continue; //
      if not(bAll or ObjShow[Layer] or Hot) then continue;
      a:=Link[0];    Ka:=Obj[a].Kind;
      if(Mode=13)and not(Obj[a].ObjShow[Layer] or bAll) then continue;
      if(Kind=2)and(Mode<>13) or (Kind in[5,15,16,17,18,19]) //直线 轨迹线
        or(Mode=13)and(Ka=6)and(Obj[a].D)  //台体 多面体的棱边
        or(Mode=13)and(Ka=6)and(Mode=6)
        or(Mode=13)and(Ka=4)and((Obj[a].F)and(Obj[a].S>3)or(Obj[a].S<4)) //平面的棱边
        then begin
          if bMask and not bNoMask and(Mask or (Mode=13)and(Obj[a].Mask))then begin //被遮挡的
            if Q then setSector(i,true);//设置截面
            if bName then glLoadName( i ); //为下面绘制的对象命名      and(Ka in[4,6])and
            glCallList(stipList);// i+4000); //虚线
            if Q then setSector(i,false);//取消截面
            end;
          end;
      end; //for...with Obj[i]
    glDisable( GL_LIGHTING);
    glDepthFunc( GL_LESS);    //写入深度较小的值
    For i:= 2 to m do with Obj[i] do begin
      if hide or(DelID>0) or not(Kind in[2,5,15,16,17,18,19]) then continue; //
      if not(bAll or ObjShow[Layer] or Hot) then continue;
      if bName and(i<11)then continue; //坐标轴已在AxisDraw中绘出
      a:=Link[0];    Ka:=Obj[a].Kind;
      if(Mode=13)and not(Obj[a].ObjShow[Layer] or bAll) then continue;
      if(Kind=2)and(Mode<>13) or (Kind in[5,15,16,17,18,19]) //直线 轨迹线
        or(Mode=13)and(Ka=6)and(Obj[a].D)  //台体 多面体的棱边
        or(Mode=13)and(Ka=6)and(Mode=6)
        or(Mode=13)and(Ka=4)and((Obj[a].F)and(Obj[a].S>3)or(Obj[a].S<4)) //平面的棱边
        then begin
          if Q then setSector(i,true);//设置截面
          if(Kind<>18)and Trace then begin //痕迹
            if bName then glLoadName(i);// i*200+30000 ); //为下面绘制的对象命名
            glCallList(tracList);//i*200+30000); //跟踪
            end;
          if bName then glLoadName( i ); //为下面绘制的对象命名      and(Ka in[4,6])and
          if(i>10)then begin
            if(not bMask) or (Mode in[1..12,19])and(not Mask) or bMask and(Mode=13)and(not Obj[a].Mask)then
              glCallList(mainList);// i);  // 实线
            if(Kind=18)or bMask and not bNoMask and(Mask or (Mode=13)and(Obj[a].Mask))then begin //被遮挡的
//              if(Kind=18)then glDepthFunc( GL_ALWAYS);  //标记不被其它构件遮挡
              glCallList(mainList);// i);  // 实线
//              if(Kind=18)then glDepthFunc( GL_LESS);
              end;
            end;
          if Hot or Seled or(Mode=13)and(Obj[a].Hot)
            then begin
              setEnable(Seled, GL_LINE_STIPPLE); //
              if Seled then begin
                glEnable(GL_LINE_STIPPLE);
                glLineStipple( 1, $1f1f); //设置线形
                end;
              glCallList(seleList);// i+9000);
              end;
          if(Kind=2)and bL and not bAdd and(i=hit)then PosDraw( i); //拖动时显示线长
          if Q then setSector(i,false);//取消截面
          end;
      end; //for...with Obj[i]
    end;
  procedure DrawPlane(bName,bFace, bMask,bNoMask:boolean; k:integer); // 圆 平面 ##############
    var i,sS :integer; //k=0时不考虑圆和平面的构建顺序
  begin
    For i:= 5 to m do
      with Obj[i] do begin
      if hide or (DelID>0) or (k>0)and not(Kind=k) or(k=0)and not(Kind in[3,4]) then continue;
      if not(ObjShow[Layer] or bAll or Hot)and(i>10)then continue;//显示状态
      if(i<11)and not(Hot or Seled)and not(chePlane.Checked and cheAxis.Checked)then continue;
      if(i<7)and not(Hot or Seled)and not cheAxisZ.Checked then continue;
      if Q then setSector(i,true);//设置截面
      glLoadName( 0 );
      if Trace then begin
        if bName then glLoadName(i);// i*200+30000 ); //为下面绘制的对象命名
        glCallList(tracList); //跟踪  i*200+30000
        end;
      sS:=(S Mod 100);
      if bName then glLoadName( i ); //为下面绘制的对象命名
      if(sS>7)and not(bMask and not bNoMask)then begin
        if((sS div 10)>1)then begin //填充模式
          glPolygonmode(GL_FRONT_AND_BACK, GL_FILL); //GL_LINE);//
          glEnable(GL_POLYGON_STIPPLE);
          glPolygonStipple(@nPlaneStyle[sS div 10]); //
          end;
        glCallList(mainList);   // 填充面
        glDisable(GL_POLYGON_STIPPLE);
        glDisable(GL_LIGHTING);
        end;
      if((sS<8)or F)and((not Mask) or (not bMask and bNoMask))then
        glCallList(wireList);// i+6000); //实线边框
      if((ss<8)or F)and(Mask and bMask)and(not bNoMask)then begin //虚实线边框
        glDepthFunc( GL_GREATER); //写入深度较大的值
        glCallList(stipList);     //虚线边框
        glDepthFunc( GL_LESS);    //写入深度较小的值
        glCallList(wireList);     //实线边框
        end;
      if Hot or Seled then begin
        setEnable(Seled, GL_LINE_STIPPLE); //
        if Seled then glLineStipple( 1, $1f1f); //设置线形
        glCallList(seleList);// i+9000);
        end;
      if Q then setSector(i,false);//取消截面
      glDisable( GL_LINE_STIPPLE);
      end; //for...with
    end;
  procedure DrawMask( M:integer);//遮罩
    var i:integer;
  begin
    glDrawBuffer(GL_NONE);  //屏蔽颜色缓存
    glLoadName( 0);
    For i:= 11 to M do with Obj[i] do begin
      if hide or(DelID>0)or not(ObjShow[Layer] or bAll)then continue; //显示状态
      if not Mask then continue;
      if(Kind=6)or(Kind=4)and((S div 10)<>1)then   //
          glCallList(maskList);     //比平面略小些的遮罩 i+4000
      end;//For...with...begin
    glDrawBuffer(GL_BACK);  //激活颜色缓存
  end;
  procedure DrawSolid(bName,bFace, bMask,bNoMask, bReverse :boolean); //实体 ##############
    var i,j :integer;  isFillCopy:boolean;
  begin
    For j:= 11 to m do begin //#### 多面体  ####
      i:=j; if bReverse then i:=m-(j-11);
      with Obj[i] do begin
      if hide or(DelID>0) or not(Kind=6) then continue;
      if not(ObjShow[Layer] or bAll or Hot) then continue; //显示状态
      if(bMask)and(bNoMask)and(Mask)then continue;
      if(bMask)and(not bNoMask)and(not Mask)then continue;//带遮挡虚线的
      if(Mode in[1,2,6]) or (Mode>2)and F or (Mode>6) or (Mode=4)and(S>100)then begin
        if Q then setSector(i,true);//设置截面
        glPushMatrix;  // glPushAttrib( GL_ALL_ATTRIB_BITS );
        glDepthMask(GL_TRUE);
        if bMask and Mask and(not(Mode in[3,4,5])or(Mode=4)and(S>100))then begin //球或圆台的遮挡状态
          glDepthFunc( GL_GREATER); //写入深度较大的值
          glCallList( stipList);      //虚线 i+5000
          end;
        glDepthFunc(GL_LESS);
        if(bName)then glLoadName( i); //为下面绘制的对象命名
        isFillCopy:=(Mode in[7..14,16])and(Obj[parent].Mode in[3..5])and F and D
                  or(Mode=4)and(S>100)and D;
        if(Hot or Seled)then begin
          if F then glDisable( GL_LINE_SMOOTH );
          glCallList( seleList); //选择状态 i+9000
          glEnable( GL_LINE_SMOOTH );
          end;
        if not((Mode in[3,4,5])and(not F))and(F or not Hot)then begin
          if not U and (Color.A <1)and F and(Mode=1)then begin //透明的球体
            glDrawBuffer(GL_NONE);  //屏蔽颜色缓存
            glCallList( maskList);
            glDrawBuffer(GL_Back);  //屏蔽颜色缓存
            end;
          glCallList( mainList);// 多面体
          end;
        if isFillCopy and not(Hot or Seled)then
          glCallList( wireList);//填充状态的实线边框 i+5000
        glDisable(GL_TEXTURE_2D);  // 解除纹理
        glPolygonmode(GL_FRONT_AND_BACK, GL_FILL);
        glPopMatrix; //glPopAttrib;
        if Q then setSector(i,false);//取消截面
        end;
      end; //with
      end; //for...
//    glDepthMask( GL_TRUE);
    glPolygonmode(GL_FRONT_AND_BACK, GL_FILL);
    end;
  procedure DrawFace(bName,bFace,bMask,bNoMask :boolean); //曲面 迭代 ##############
    var i :integer;
  begin
    For i:= 11 to m do
      with Obj[i] do begin
      if hide or(DelID>0) or not(Kind in[7,9,13]) then continue; //#### 曲面  ####
      if not(ObjShow[Layer] or bAll or Hot) then continue; //显示状态
      if(Kind>6)then begin
        glPushAttrib( GL_ALL_ATTRIB_BITS );
        if Q then setSector(i,true);//设置截面
        glDepthMask(GL_TRUE);
        glDepthFunc(GL_LESS);
        if(Kind in[7,9])and Trace then begin //痕迹
          if bName then glLoadName(i);// i*200+30000 ); //为下面绘制的对象命名
          glCallList(tracList); //跟踪 i*200+30000
          end;
        if(bName)then glLoadName( i ); //为下面绘制的对象命名
        if Hot or Seled then begin
          setEnable(Seled, GL_LINE_STIPPLE); //
          if Seled then glLineStipple( 1, $1f1f); //设置线形
          if F then glDisable( GL_LINE_SMOOTH );
          glCallList( seleList); //i+9000
          end;
        if F or not Hot or(Kind=13)then
          glCallList( mainList);// 多面体、曲面   F or
        glDisable(GL_TEXTURE_2D);  // 解除纹理
        glPolygonmode(GL_FRONT_AND_BACK, GL_FILL);
        if Q then setSector(i,false);//取消截面
        glPopAttrib;
        end;
      end; //for... with
//    glDepthMask( GL_TRUE);
    glPolygonmode(GL_FRONT_AND_BACK, GL_FILL);
    end; //DrawFace
  procedure DrawText(bName:boolean);//####在固定位置显示手绘 f文本、图片、计算式###########
    var i,a,b,c,y1,y2:integer; pT,pB :TcgVector;  t:single;//### 为按钮画选择边框 ########
    label isContinue;
  begin
    glPushMatrix;//glPushAttrib( GL_ALL_ATTRIB_BITS ); //
    glLoadIdentity;
    glTranslatef( 0, 0, -0.1);
    glDisable(GL_LIGHTING);   //关闭光照
    glDisable(GL_DEPTH_TEST); //关闭深度缓存
    if bFrameSel then begin   //框选
      pT:=getObjPos( 0,pt,x0, Clientheight-y0, 0);
      pB:=getObjPos( 0,pb,dx, Clientheight-dy, 0);
      glColor4F(0.5,0.5,0.5,0.2);
      glRectFv(@pT,@pB);      //选择框
      glDisable(GL_LINE_SMOOTH);
      glColor4F(1,0.5,0.5,0.3); glLineWidth(1);
      glBegin(GL_LINE_LOOP);
        glVertex2f(pT.x,pT.y);  glVertex2f(pB.x,pT.y);
        glVertex2f(pB.x,pB.y);  glVertex2f(pT.x,pB.y);
      glEnd;
        begin  y1:=y0+26;  y2:=dy+26; end;
      for i:=11 to ObjCount do with Obj[i] do begin//选择计算式 文字、按钮
        if not hide and(delID=0)and(not noSel)and(Kind in[1,10,11,14])and(bAll or ObjShow[Layer])and(not Seled)then begin
          if(Kind=1)then begin
            Hot:=(abs(y2-y1)/2 > abs((y2+y1)/2-para[4].y))
              and(abs(dx-x0)/2 > abs((dx+x0)/2-para[4].x));
            end
          else begin
            if(Kind=10)and(Mode=2)then t:=L else t:=1;
            p1.x:=p0.x+TagSize.x*t;
            p1.y:=p0.y-TagSize.y*t;
            Hot:=((abs(y2-y1)+abs(p1.y-p0.y)) > abs(y2+y1-p1.y-p0.y))
              and((abs(dx-x0)+abs(p1.x-p0.x)) > abs(dx+x0-p1.x-p0.x));
            end;
          if Hot then MarkObj:=i;
          end;
        if(Kind=11)and(Mode=2)and not(ObjShow[Layer]or bAll)then
          butID.Visible:=false;
        end;
      end;
    if not bName then
    for i:= 11 to ObjCount do with Obj[i] do begin
      if(Kind=11)and(Mode=2)and not(ObjShow[Layer] or Hot or bAll)
        then butID.Visible:=false; //参数滑竿
      if not(Kind in[10,11,14])or(delID>0)then continue;
      if not((Kind=11)and(Mode in[1,7])and(F or U))and Hide then continue;//无穷大的计算值或比值不隐藏

      if not(ObjShow[Layer] or bAll or Hot) then continue;
      if(Kind=11)and(Mode=2)and Trace and not TagShow[Layer] then continue;//参数滑竿
      glPushMatrix;
      if(Kind=10)and(Mode<3)then begin //绑定的图片或文本
        a:=Link[10];  b:=Link[1]; c:=Link[2];//a绑定对象 b隐阈对象 c显阈对象
        if(b>0)then H:=Obj[b].L;  if(c>0)then R:=Obj[c].L; //R隐阈值 H显阈值
        if(H<R)and not bAll then goto isContinue; //不能简单的用Continue，因为前有glPushMatrix
        if(a>10)and(Obj[a].Kind=1)then begin //绑定到点 因为绘制图片或文本时点还没画到屏幕上，所以必须在绘制点时计算屏幕位置
          p0.x:=p2.y+Obj[a].TagScr.x;
          p0.y:=Height-(p2.w+Obj[a].TagScr.y);
          TextAndImage(i, false, true,false,false);
          end;
        end;
      if(Kind=11)then begin //绑定的参数、度量、计算
        a:=Link[10]; //a位置 trunc(W); //
        if(a>10)and(Obj[a].Kind=1)then begin //绑定到点 因为绘制图片或文本时点还没画到屏幕上，所以必须在绘制点时计算屏幕位置
          p0.x:=p2.y+Obj[a].TagScr.x;
          p0.y:=Height-(p2.w+Obj[a].TagScr.y);
          TextAndImage(i, false, true,false,false);
          end;
        if(Mode=2)and Assigned(butID)then butID.Visible:=Trace;
        end;
      if(Kind in[11,14])or(Kind=10)and(Mode<3) then begin//参数 计算值 文本 图片
        setEnable( U, GL_DEPTH_TEST); //U 前置
        glTranslatef( TagScr.x, TagScr.y, 0); //TagScr在TextAndImage中计算
//        if bName then glLoadName(i);//命名
        if hot then glCallList(seleList);//i+9000);//被选构件画出外框
        glCallList(mainList);
        end;
    isContinue:
      glPopMatrix;
      end; //for ... do with ... do begin
    glPopMatrix;//glPopAttrib; //
    glEnable(GL_DEPTH_TEST); //打开深度缓存
  end; //DrawText
  procedure DrawPaint; //涂鸦手绘
    var i:integer;
  begin
    glPushMatrix;//glPushAttrib( GL_ALL_ATTRIB_BITS ); //
    glLoadIdentity;
    glTranslatef( 0, 0, -0.1);
    glDisable(GL_LIGHTING);   //关闭光照
    glDisable(GL_DEPTH_TEST); //关闭深度缓存
    if(PaintNum>0)or(PaintMax>0)then begin //手绘
      if(PaintMax>0)then
        for i:=1 to PaintMax do if(not PaintData[i].Del)then begin
          if bName then glLoadName(60000+i);
          glPushMatrix;
          glTranslatef( PaintData[i].dx, PaintData[i].dy, 0);
          glCallList(PaintData[i].mainList); //60000+i );//
          if PaintData[i].Hot then glCallList(PaintData[i].wireList); //61000+i);//
          glPopMatrix;
          end;
      if(PaintNum>0)then begin
        glLineWidth(PaintWidth); glColor3Fv(@PaintColor);
        glEnable(GL_LINE_STIPPLE);
        glLineStipple( 1, stLineStyle[PaintStyle]); //设置线形
        i:=0;
        while(not PaintList[i].Break)or(i<PaintNum)do begin
          glBegin(GL_LINE_STRIP);//
          repeat
            inc(i);
            glVertex2fv(@PaintList[i].Dot);
            until(PaintList[i].Break)or(i>=PaintNum);
          glEnd;
          inc(i);
          end;//while...
        glDisable(GL_LINE_STIPPLE);
        end;
      end;
    glPopMatrix;//glPopAttrib; //
    glEnable(GL_DEPTH_TEST); //打开深度缓存
    end;
  procedure MarkFlash(isFlash:boolean); //=========== 变换标记闪烁 ================
    var pa,pb,pc :TcgVector; i:integer;
    procedure DrawRect(pc:TcgVector; FlashSize:integer);
      var kx,ky, x1,x2,y1,y2 :single;  pp :TcgVector;
    begin
      pp:=getObjPos(MarkObj,pc, 0,0,0);
      kx:=2*pp.x/Width ;  x1:=-kx*(pc.x-FlashSize)+pp.x;  x2:=-kx*(pc.x+FlashSize)+pp.x;
      ky:=2*pp.y/Height;  y1:= ky*(pc.y+FlashSize)-pp.y;  y2:= ky*(pc.y-FlashSize)-pp.y;
      if Obj[0].Seled then glColor3f(1,1,1) else glColor3f(0,0,0);
      glRectf(x1,y1, x2+0.00001,y2);
      end;
  begin //
    glDisable(gl_depth_test);
    with Obj[MarkObj]do begin
      if isFlash and not Obj[0].Seled then begin
        if Obj[0].Way then dec(FlashSize,4) else inc(FlashSize,4);
        end;
      if FlashSize>6 then Obj[0].Way:=true;
      if(Kind=4)then begin
        glLineWidth(3);
        if Obj[0].Seled then glColor3f(1,1,1) else glColor3f(0,0,0);
        glBEGIN(GL_LINE_LOOP);
        for i:=0 to trunc(W)-1 do glVertex3fv(@LocaVct[MarkObj,i]);
        glEND;
        end
      else begin
        pa:=getWinPos(MarkObj,0); pa.y:=height-pa.y;//+TitleHeight-4;//从场景坐标转换为屏幕坐标
        if Kind=2 then begin
          pb:=getWinPos(MarkObj,2); pb.y:=height-pb.y;
          pc:=cgVecMid(pa,pb); pa:=cgVecMid(pa,pc); pb:=cgVecMid(pc,pb);
          end;
        glLoadIdentity;
        glPushAttrib( GL_ALL_ATTRIB_BITS );
        glTranslatef( 0, 0, -0.1);
        glPolygonMode( GL_FRONT_AND_BACK, GL_LINE);
        glLineWidth(4);
        DrawRect(pa,FlashSize);  if Obj[MarkObj].Kind=2 then DrawRect(pb,FlashSize);
        glPolygonMode( GL_FRONT_AND_BACK, GL_FILL);
        glPopAttrib;
        end;
      Obj[0].Seled:=not Obj[0].Seled;
      end; //with
    if FlashSize<5 then begin
      bFlash:=false;      timFlash.Enabled:=false;
      SetProjection(false,false,24);
      end;
    glEnable(gl_depth_test); //打开深度缓存
  end;
begin
  bName:= ModOrRender=GL_SELECT;//选择状态时以命名方式绘图
  glClear( GL_COLOR_BUFFER_BIT or GL_DEPTH_BUFFER_BIT);
  glLoadIdentity;
  DrawText(bName); //####在固定位置显示文本、图片、计算式##############
  glTranslatef( Origin.x, Origin.y, -fogL); //移动原点
  glEnable(gl_depth_test); //打开深度缓存
  glEnable(GL_LIGHTING);
  glRotatef( rY,1,0,0 );
  glRotatef( rZ,0,1,0 );
  glRotatef( rX,0,0,1 );
  glPushAttrib( GL_ALL_ATTRIB_BITS );
  M:=ObjCount;
  if bAdd and not bDotJoin then dec(M); //添加状态下最后一个构件还未完全建立，不能正确绘出(自由点除外)
  if bGrid and bAxis then begin
    glLineWidth(1);
    setEnable( false, GL_LINE_SMOOTH );
    glLoadName(0); glCallList(Obj[10].mainList); //######### 网格线 #############
    end;
  setEnable( cheSmooth.Checked, GL_LINE_SMOOTH );
  bMask:=false;
  for i:=5 to ObjCount do with Obj[i] do  // 是否有遮挡构件
    if not(i in[8..10])and(delID=0)and(Kind in[4,6])and(Mask)then bMask:=true;
  if bName then begin //选择状态下从面到线绘图
    DrawFace(bName,true,false,true);        //#### 曲面 ##############
    DrawPlane(bName,true,false,true, 4);    //#### 平面 圆  ##############
    DrawPlane(bName,true,false,true, 3);    //#### 平面 圆  ##############
    DrawSolid(bName,true,false,true,false); //#### 实体 曲面 ##############
    if bAxis then AxisDraw(false,false);    //#### 坐标轴线 ################
    DrawLine(bName,true,false,true);        //#### 直线 轨迹 #########
    DrawDot(true,true,false);               //####  点  ##############
    end
  else begin //非选择状态下
    printTag;                        //标签
    DrawDot(true,false,false);                    //####  点  ##############
    if not bMask then begin //无遮挡构件 从线到面绘图
        glDepthMask( GL_FALSE);
      if bAxis then AxisDraw(bName,false);  //#### 坐标轴线 ################
      DrawLine(false,true,false,true);      //#### 直线 轨迹 #########
      DrawPlane(false,true,false,true, 0);  //#### 平面 圆  ##############
        glDepthMask( GL_TRUE);
      DrawSolid(false,true,false,true,true);//#### 实体 ##############
      DrawFace(bName,true,false,true);      //#### 曲面 ##############
      DrawPlane(bName,true,false,true, 0);  //#### 平面 圆 ##############
      DrawSolid(false,true,false,true,false);//### 实体 ##############
      if bAxis then AxisDraw(bName,false);  //#### 坐标轴线 ################
      DrawLine(false,true,false,true);      //#### 直线 轨迹 #########
      end;
    if bMask then begin  //有遮挡构件
      //先画无遮挡属性的构件
        glDepthMask( GL_FALSE);
      DrawLine(bName,true,true,true);       //#### 直线 轨迹。若未设置遮挡，则显示实线。否则不显示
      DrawSolid(bName,true,true,true,false);//#### 实体 ##############
        glDepthMask( GL_FALSE);
      DrawFace(bName,true,true,true);       //#### 曲面 ##############
      DrawPlane(bName,true,true,true, 0);   //#### 平面 圆 ##############
        glDepthMask( GL_TRUE);
      DrawPlane(bName,true,true,true, 0);   //#### 平面 圆 ##############
      DrawMask( M );                        //#### 遮罩 ########
      //再画有遮挡属性的构件
        glDepthMask( GL_TRUE);
      DrawSolid(bName,true,true,false,false);//#### 实体 ##############
      DrawPlane(bName,true,true,false, 0);  //#### 平面 圆  ##############
      if bAxis then AxisDraw(bName,true);   //#### 坐标轴线 ##########
      DrawLine(bName,true,true,false);      //#### 直线 轨迹。若设置遮挡则显示虚线，否则显示实线 #########
      end;
    DrawDot(false,false,false);                   //####  点  ##############
    end;
  DrawPaint; //####在固定位置显示涂鸦手绘##############

  glLoadName(0);
  if bName then goto isSelect;

  if bFlash then MarkFlash(isFlash);
  if(bAdd)and(not bName)and(not bDotJoin)then //创建构件的过程中动态显示
    with Obj[ObjCount]do begin  //
    glLineWidth(1);  glPointSize(4);
    na:=Obj[Link[0]].p0; nb:=Obj[Link[1]].p0;
    case Kind of //
    1:if(Mode<3)or(Mode in[5,8,10,12])and(selNum>0)
        or(Mode in[2,7,9,11])and(bSel) //约束点 投影点 旋转点
      then Pointe(ObjCount,true,false,false);
    2:if(Mode=2)and(selNum=0)and(R<2)
        or(Mode in[1,3,5,19])and(selNum>0)
        or(Mode in[4,5])and(selNum>0)and(bSel)
        or(Mode=6)and(selNum>1)and bSel
        or(Mode=6)and(selNum=2)
        or(Mode in[8,10,12,15])and(selNum>0)//and bSel  and(selNum=0)
        or(Mode in[7,9,11])and(bSel)  //直线
        or(Mode=11)and bSel
      then Lineer(ObjCount,true,false,false);
    3:begin
      if(Mode in[2,4])and(selNum=1)then begin //三点圆 三点弧
        glBegin(GL_LINES); glVertex3fv(@na); glVertex3fv(@nb); glEnd;
        end;
      if(Mode=3)and(selNum=1)or(Mode in[2,3,4])and(selNum=2) //圆(圆弧)
        or(Mode in[1,8,10,12,15])and(selNum>0)
        or(Mode in[7,9,11])and(bSel)
        then CircleDraw(  ObjCount, true,false,false,false);
      end;
    4:begin
      if(Mode in[1,2,3,4,5,6,8,10,12,15])and(selNum>0)//平面  and bSel   or(Mode=3)
        or((Mode in[7,9,11]))and(bSel)
      then begin
        Plane(ObjCount,Mode>6,false);
        if(Mode<7)then begin
          k:=IIFi((Mode in[3,4,5]), 3, trunc(W));
          if(k=99)then k:=4; if(k>100)then k:=k-100; //长方形W=99  正n变形W=100+边数
          glBegin(GL_LINE_LOOP); //随鼠标画出多边形
          for i:=0 to k do
            if(Mode<6)or Rand then glVertex3fv( @LocaVct[ObjCount,i]) //三角形或正多边形
                    else glVertex3fv(@Obj[Link[i]].p0);     //任意多边形
          glEnd;
          end;
        end;
      end;
    5:if(Mode in[8,10,12,15])and(selNum>0)or(Mode in[7,9,11])and(bSel) //轨迹线
      then Locus(ObjCount,true,false,false,false);
    6:begin
      if(selNum>0)and((Mode in[1..4,8,10,12,15])or(Mode in[7,9])and(bSel)) //
        or(selNum>1)and(Mode=5) or(Mode=11)and(bSel)
        then Solid(ObjCount,true,false,false,false); //实体
      if(selNum=1)and(Mode=5)then begin //凸壳的第一条棱边
        glBegin(GL_LINES);  glVertex3fv(@na); glVertex3fv(@nb); glEnd;
        end;
      end;
    7,9:if(selNum>0)and((Mode in[8,10,12,15])or(Mode in[7,9,15])and(bSel))
      or(Mode=11)and(bSel)
      then Face( ObjCount,true,false,false); //曲面
   16:if(Mode in[8,10,12,15])and(selNum>0)or(Mode in[7,9,11])and(bSel) //曲线
      then FuncCurve(ObjCount,true,false,false);
   17:if(Mode=1)and((selNum>0)or bSel) //路径
      then Path(ObjCount,true,false,false);
   18:if(Mode=2)then Marker(ObjCount,true,false,false); //标注
   19:begin //圆锥曲线
      if(selNum=2)or(selNum=1)and(Obj[Link[0]].Kind=2)or(Mode=15)
        then Conic(ObjCount,true,false,false);
      end;
    end; //case Kind
    if  (Kind=1)and((Mode<3)or(Mode=5)and(SelNum>=0))
      or(Kind=2)and((Mode=1)or(Mode in[2,3,4,19])and(SelNum=0)or(Mode=6)and(selNum=2))
      or(Kind=2)and(Mode=5)and(SelNum<2)
      or(Kind=3)and((Mode in[1,2,4,8])or(Mode=3)and(SelNum=0))
      or(Kind=4)//and((Mode in[1,4,5,6])or(Mode in[2,3])and(SelNum=0))
      or(Kind=6)and(Mode<7) or(Kind in[17,19])
      or(Mode in[8,10,12,15])and(SelNum>0)
      then if not bDotJoin and not bSel then
        PosDraw(0);  //坐标线  and(Mode<5)
    end; //if...with...begin
isSelect:
  glPopAttrib;
  if(not bName)then begin
    SwapBuffers(DC); glFinish;
    if cheFlash.Checked then UpdateFPS(getTickCount); //计算刷新率
    end; // Display the scene
end;
{====================Select object===========================}
function TfrmMain.DoSelect(x,y:integer):integer;
  var i,j,k :integer;
      vp :TViewPortArray; //当前的视区边界
begin
  result:=-1;
  lastHit:=0;
  glSelectBuffer( 63, @SelectBuf);
  glRenderMode( GL_SELECT);
  glInitNames;
  glPushName(0);
  glPushMatrix;
    glGetIntegerv( GL_VIEWPORT, @vp); // 获得当前的视区边界
    glMatrixMode( GL_PROJECTION);
    glLoadIdentity;
    gluPickMatrix( x, Height-y- titleHeight, 7, 7, vp); // 拾取精度为8个象素
    gluPerspective( Pers+2, Width/Height, 0.1, 4000);
    glMatrixMode(GL_MODELVIEW);
    MainDraw( GL_SELECT, false, 'a');
  glPopMatrix;
  Hits:= glRenderMode(GL_RENDER); //鼠标所在位置的构件数目
//  Result:=IIFi( hits<=0, -1, SelectBuf[(hits-1)*4+3]);
// exit;
  if(Hits<=0)then exit;
  result:=SelectBuf[(hits-1)*4+3];  if(result>maxObj)then exit;
  j:=-1;
  for i:=0 to Hits-1 do begin //统计有效构件
    k:=SelectBuf[i*4+3];
    if(k>0)and(k<maxObj)then begin inc(j);  SelectBuf[j]:=k; end; //
    end;
  if(j=-1)then begin Hits:=0; result:=-1; exit; end;
  Hits:=j+1;
  j:=-1;
  if(Obj[SelectBuf[Hits-1]].Kind=1)then begin //是否有重叠的点
    for i:=0 to Hits-1 do if(Obj[SelectBuf[i]].Kind=1)then
      begin inc(j); SelectBuf[j]:=SelectBuf[i]; end;
    Hits:=j+1;
    end;
  k:=SelectBuf[Hits-1];
  if(Obj[k].Kind in[2,3,5,15,16,19])or(Obj[k].Kind=17)and(Obj[k].Mode=1)then begin //是否有重叠的线
    for i:=0 to Hits-1 do begin
      k:=SelectBuf[i];
      if(Obj[k].Kind in[2,3,5,15,16,19])or(Obj[k].Kind=17)and(Obj[k].Mode=1)then
        begin inc(j); SelectBuf[j]:=k; end;
      end;
    Hits:=j+1;
    end;

  if(Hits=1)then
    result:=SelectBuf[0] //唯一选择
  else begin //有重叠
    j:=-1;
    for i:=0 to Hits-1 do
      if(Obj[SelectBuf[i]].Hot)then j:=i;   //检索有否已被选择的构件
    if(j<0)then result:=SelectBuf[0]
      else result:=SelectBuf[j];
    end;
end;
//==================== 是否保存已编辑的模型 ================
function TfrmMain.checkSaved :boolean;
  var answer :integer;  ss:string;
begin
  result:=true;
  if ((BackObj.UndoID>0)or bEdit)and not bPW then begin //当编辑了UndoTime次时，bEdit=true
    ss:=SwitchS(iLanguage,'当前模型已经编辑，是否保存 ?',
                          '当前模型已經編輯，是否保存 ?',
                          'Current model has been edited, do you save?','');
    answer:= MessageDlg( ss, mtCustom, [mbYes,mbNo,mbCancel], 0);
    if answer=mrCancel then result:=false
    else if answer=mrYes then SaveFile( SgfFile);
    end;  //if
end;
//==================== 设置默认环境 ================
procedure TfrmMain.initDefault;//第一次执行程序时执行
  var i,j:integer;
begin
  frmMain.Color:=clWhite;
  bAxis:=true; bGrid:=true;  bHint:=true;
  bNail:=false; butNail.NumGlyphs:=2;
  Axis:=8;
  with Obj[8]do begin //坐标原点相当于[点]  各类构件的默认值
    Kind:=1;  Mode:=1;  Name:=8;  W:=4; S:=1; //原点
    p0:=cgVector(0,0,0);
    Tag:='o';   TagN:='Times New Roman'; TagS:=16; TagC:=255; //坐标系字体  颜色
    TagP.x:=-12; TagP.y:=-4;  TagT:='0000';
    color:= cgColorF( 1,0,0,1);     //原点色 红色
    colorB:=color;                  //选择色
    p1.x:=6;    Link[ 1]:=255;  p1.r:=1;//点径 p1.r形状
    p1.y:=2;    Link[ 2]:=16711680; //直线
    p1.z:=2;    Link[ 3]:=65280;    //圆
    p1.w:=1;    Link[ 4]:=32896;    //平面
    p2.x:=2;    Link[ 5]:=6324416;  //实体棱边宽 颜色
    p2.y:=3;    Link[ 6]:=32896;    //曲线
    p2.z:=1;    Link[ 7]:=255;      //曲面
    p2.w:=4;    Link[ 8]:=0;        //数据精度 颜色
    p5.w:=2;    Link[ 9]:=16711935; //选择线宽比率 选择色
    TagP.z:=16; Link[10]:=255;      //默认标签字号 颜色
    Link[20]:=(Screen.Width-800)div 2;
    Link[21]:=(Screen.Height-600)div 2;
    Link[22]:=800;  Link[23]:=600;
    p3.x:=0;    p3.y:=0;    p3.z:=250;  p3.w:=300;//原点坐标
    p4.x:=34;   p4.y:=29;   p4.z:=0;    p4.w:=0;  p4.r:=2.2;  //景深 透视度  Z轴下部长度p4.r
    p5.x:=0.1;  p5.y:=0.1;  p5.z:=0.1;            //坐标平面的透明度
    Vec.x:=13;  Vec.y:=10;  Vec.z:=8.4; Vec.w:=4.5; Vec.r:=3; //坐标轴长度  X轴Y轴下部长度Vec.w Vec.r

    pTR.x:=10;  pTR.y:=10;  pTR.z:=10;      //坐标平面模式
    LinkName[ 0]:=  0; LinkName[ 1]:=255;   //背景色 标签色
    LinkName[ 2]:=255; LinkName[ 3]:=32768; LinkName[ 4]:=16711680;//坐标轴色
    LinkName[ 5]:=255; LinkName[ 6]:=32768; LinkName[ 7]:=16711680;//坐标平面色
    LinkName[ 8]:=255; LinkName[ 9]:=32768; LinkName[10]:=16711680;//坐标轴字符色
    LinkName[11]:=255; LinkName[12]:=32768; LinkName[13]:=16711680;//坐标平面字符色
    info[0]:='111011111000111100000'; //22位
    info[1]:='Times New Roman';//默认标签字体
    info[2]:='AxiTag o x y z';
    for j:=0 to LayerTime do ObjShow[j]:=true;
    D:=false; Q:=false; iLanguage:=0;
    parent:=0; //最大页名
    end;
  for i:=2 to 7 do for j:=0 to LayerTime do begin
    Obj[i].ObjShow[j]:=true; Obj[i].TagShow[j]:=true;
    end;
  for i:=2 to 4 do with Obj[i] do begin  //坐标轴相当于[点斜线]
    Name:=i;  LinkName[0]:=1;   Link[0]:=1;
    Color:=cgTColorToCGColorF( LinkName[i],1);
    Kind:=2;  Mode:=2;  parent:=i;
    W:=1;  L:=8; S:=0; F:=false; U:=false; H:=2; R:=0;//R:坐标轴尾巴 H:剑头
    Vec:=cgVector(0,0,0);
    case i of 2:Vec.x:=1; 3:Vec.y:=1; 4:Vec.z:=1; end;
    case i of 2:Tag:='x'; 3:Tag:='y'; 4:Tag:='z'; end;
    case i of 3:p2.x:=halfPi; 4:p2.z:=halfPi; end;
    TagN:='Times New Roman';  TagS:=16;  TagC:=Obj[8].LinkName[i];
    end;
  for i:=5 to 7 do with Obj[i] do begin  //坐标平面相当于[平面]
    Name:=i;  LinkName[0]:=1;   Link[0]:=1;
    Color:=Obj[i-3].Color; Color.A:=0.2;  ColorB:=Color;
    Kind:=4;  Mode:=1;  parent:=i;  L:=3;
    case i of 5:Tag:='YOZ'; 6:Tag:='XOZ'; 7:Tag:='XOY'; end;
    TagN:='Times New Roman'; TagS:=16;    TagC:=Obj[8].LinkName[i-3];
    F:=Obj[8].info[0][i+14]='1';
    end;
end;
//==================== 根据环境参数设置界面 ================
procedure setWindowFrame(ObjToWindow:boolean);
begin
  with Obj[1] do
  if ObjToWindow then begin //
    if(Link[20]<0)or(Link[20]>Screen.Width -100)then Link[20]:=0;
    if(Link[21]<0)or(Link[21]>Screen.Height-100)then Link[21]:=0;
    if(Link[22]<320)or(Link[22]>Screen.Width )then Link[22]:=Screen.Width;
    if(Link[23]<256)or(Link[23]>Screen.Height)then Link[23]:=Screen.Height;
    frmMain.Left :=Link[20];    frmMain.Top:=Link[21];
    frmMain.Width:=Link[22];    frmMain.Height:=Link[23];
    frmMain.WindowState:=wsNormal;
    end
  else begin
    Link[20]:=frmMain.Left;     Link[21]:=frmMain.Top;
    Link[22]:=frmMain.Width;    Link[23]:=frmMain.Height;
    info[2]:='AxiTag '+Obj[1].Tag+' '+Obj[2].Tag+' '+Obj[3].Tag+' '+Obj[4].Tag; //坐标轴标签
    end;
end;
procedure TfrmMain.setDefault(NewPos:boolean);
  var st:string; i:integer;
begin
  with Obj[1] do begin //
    if NewPos and(info[0][17]='0')and not isUseToControler then //
      setWindowFrame(true);
    frmMain.Color:=LinkName[0];
    varScreen.Color:=LinkName[0];
    backColor:=cgTColorToCGColorF( LinkName[0], 1); //背景色
    glClearColor( BackColor.R, BackColor.G, BackColor.B, 1.0);
    rX:=p3.z; rY:=p3.w; rZ:=p3.r; //视角
    rX2:=rX;  rY2:=rY;  rZ2:=rZ;

    Deep:=p4.x; if(Deep<2)then Deep:=2;    varDeep.Caption:= FtoS( Deep,2); //景深
    Pers:=p4.y; if(Pers<0)then Pers:=0;    varPers.Caption:= FtoS( Pers,2); //透视度
    Origin.x:=p3.x; Origin.y:=p3.y; //坐标原点的屏幕位置
    Color :=cgTColorToCGColorF(LinkName[1],1); //原点色
    TagC :=LinkName[1];                        //原点标签色
    ColorB:=cgTColorToCGColorF(Link[9],1); //选择色
//  defaultProp:Array[0..7]of single; //默认属性 1点型 2线长 4线型 5角度6比例
    defaultProp[0]:=1;   defaultProp[2]:=3;//默认点型 半径
    defaultProp[3]:=0;   defaultProp[5]:=30;  defaultProp[6]:=0.3; //默认线型 旋转角度 缩放值
    defaultVec:=cgVector(1,0,0); //默认向量

    if(Vec.x<0)then Obj[2].F:=true; if(Vec.x=0)then Vec.x:=1;
    if(Vec.y<0)then Obj[3].F:=true; if(Vec.y=0)then Vec.y:=1;
    if(Vec.z<0)then Obj[4].F:=true; if(Vec.z=0)then Vec.z:=1;

    for i:=1 to 7 do Obj[i].ShowID:=i-8;
//    for i:=2 to 4 do Obj[i].W:=p1.y; //坐标轴线宽
    Obj[2].L:=abs(Vec.x); Obj[3].L:=abs(Vec.y); Obj[4].L:=abs(Vec.z); //坐标轴长度
    Obj[2].R:=abs(Vec.w); Obj[3].R:=abs(Vec.r); Obj[4].R:=abs(p4.r);  //坐标轴尾巴长度
    for i:=2 to 7 do with Obj[i] do begin
      Color:=cgTColorToCGColorF( Obj[1].LinkName[i],1);//坐标轴颜色
      TagN:=Obj[1].TagN; TagS:=Obj[1].TagS;  TagT:=Obj[1].TagT;
      end;
    Obj[5].Color.A:=p5.x; Obj[6].Color.A:=p5.y; Obj[7].Color.A:=p5.z;
    Obj[5].Tag:='YOZ';    Obj[6].Tag:='XOZ';    Obj[7].Tag:='XOY';
    for i:=5 to 7 do Obj[i].ColorB:=Obj[i].Color;
    for i:=1 to 4 do Obj[i].Tag:=getStr(info[2],i);//原点和坐标轴标签
      
    Obj[5].S:=trunc(pTR.x);   Obj[6].S:=trunc(pTR.y);   Obj[7].S:=trunc(pTR.z);   //坐标平面模式
    for i:=0 to 2 do Obj[5+i].F:=info[0,13+i]='1';  //坐标平面边框
    cmbObjKind.ItemIndex:=0;
    varObjSize.Caption:=FtS(p1.x);  varObjColor.Color:=Link[1]; //系统参数
    st:=info[0]; //场景开关变量
    end;
  cheAxis.Checked:=  st[ 1]='1'; bAxis:=cheAxis.Checked;//显示坐标系
  cheAxisZ.Checked:= st[ 2]='1';                        //显示Z轴
  cheGrid.Checked:=  st[ 3]='1'; bGrid:=cheGrid.Checked;//显示网格
  cheOrigin.Checked:=st[ 4]='1';                        //显示原点
  cheFog.Checked:=   st[ 5]='1';                        //雾效
  cheSmooth.Checked:=st[ 6]='1';                        //反锯齿
  cheFlash.Checked:= st[ 7]='1';                        //显示刷新率
  cheHint.Checked:=  st[ 8]='1';                        //显示工具提示
  cheTag.Checked:=   st[ 9]='1';                        //创建构件时显示标签
  chePlane.Checked:= st[10]='1';                        //显示坐标平面
  cheMark.Checked:=  st[11]='1';                        //显示刻度
  cheAngle.Checked:= st[12]='1';                        //X轴刻度弧度制
                  // st[13]...st[15] 坐标平面边框
  if not isUseToControler then begin bNail:= st[16]='1'; butNail.NumGlyphs:=2-ord(bNail); end;//属性框摁钉
                  // st[17] 窗口最大化(非全屏)
  Obj[1].Mask:=      st[18]='1';  butLock.Down:=Obj[1].Mask; // 锁定视角
  butList.Down:=     st[20]='1';
  butListAnchor.NumGlyphs :=1; if st[21]='1' then butListAnchor.NumGlyphs :=2;
  menList.Checked:=butList.Down;  pnlList.Visible:=butList.Down;
  if butList.Down then pnlList.Show;// setListPosision; //打开对象列表
  cheGrid.Enabled:=bAxis;   chePlane.Enabled:=bAxis;
  frmMain.ShowHint:=cheHint.Checked;
  cheAxisZ.Enabled:=cheAxis.Checked; //Z轴
  cheMark.Enabled:=cheAxis.Checked;  //刻度
  cheAngle.Enabled:=cheMark.Checked and cheAxis.Checked; //X刻度
  menMark3.Checked:=false;  menMark4.Checked:=false;  menMark5.Checked:=false;
  menMark6.Checked:=false;  menMark7.Checked:=false;
  AxisList;
end;
{=========================Start procedure==========================}
procedure TfrmMain.Start( New :boolean); // new: 打开新文件
  var i,j :integer;
begin
  if(not New)and(not bPW) then if(not checkSaved)then exit;
//  Screen.cursor:=crHourGlass;
  j:= ObjCount;   Origin:=cgOrigin;
  for i:= 0 to j do with Obj[i] do begin
    if Assigned(butID) then butID.Hide; //控制按纽 参数轴
    glDeleteTextures( 1, @texID);   texID:=0; //释放纹理内存
    glDeleteTextures( 1, @texTag);  texTag:=0; //释放纹理内存
    sImage.sData:='';    Tag:='';
    glDeleteLists( mainList, 1);  mainList:=0;//只能一个个删除而不能用glDeleteLists(2,65535);
    glDeleteLists( maskList, 1);  maskList:=0;
    glDeleteLists( wireList, 1);  wireList:=0;
    glDeleteLists( seleList, 1);  seleList:=0;
    glDeleteLists( tracList, 1);  tracList:=0;
    glDeleteLists( stipList, 1);  stipList:=0;
    setLength( LocaVct[i], 0);    setLength( LocaColor[i],0);
    setLength( FaceVct[i], 0);    setLength( FaceColor[i],0);   setLength(aLink[i],0);
    end; //for i
  ObjCount:=10;   OldCount:=0;   maxPage:=0;
  BackObj.UndoID:= 0;   BackObj.UndoMax:= 0;  BackObj.maxName:=10;
  for i:=11 to maxObj do ObjNameStack[i]:=false; //清空名称栈
  MarkObj:=0;
  leftHit:=0;
  PaintListNum:=0; PaintNum:=0; PaintMax:=0; //手绘比划数 当前手绘点数
  PaintColorIndex:=5; PaintColor:=cgTColorToCGColorF(objColor[PaintColorIndex],1);
  PaintWidth:=2;      PaintStyle:=0;   SportTime:=0;
//  if new then setMem( 63, true); //动态数组分配内存
  ClearSelRec(0); //清空选择列表
  bc:=false; bs:=false;
  SgfFile:= '';     if not New then sgfName:='';
  bAdd:= false;
  bEdit:=false;
  bSelLink:=false;
  bPause:=false;
  bSport:=false;
  barPage.Max:=0; barPage.Show;   pnlShow.Hide;   UpDwPage.Position:=0;
  Obj[1]:=Obj[8]; Obj[1].Name:=1;
  barPage.Width:=19;  pnlShow.Width:=15;
  if(HotTool.Tag>0)then HotTool.Down:=false;
  HotMenu:=menBar57; HotTool:=butArrow; butArrow.Down:=true;
  men128.Visible:=false; //自定义变换菜单
  butAll.Down:=false; butLock.Down:=false; butProp.Down:=false;

  timSpin.Enabled:=false;  butSpin.Down:=false;
  updateTitle;

  if New and FileExists( aryFile[0]) then
    ObjCount:= OpenFile( aryFile[0], true,false); //打开文件菜单中第一个文件
  setDefault(not New);   //读取默认环境
  //  frmMain.Show;
  for i:= 11 to ObjCount do Obj[i].edited:=true;
  HideAllPanel;
  CountObjNum(false,false); //设置按钮的可用性
  Screen.Cursor:=crDefault;
  reRelate(11,ObjCount,false,false,false);
  ObjListUpdate(0,false);
  if not isUseToControler then begin
    if(Obj[1].info[0][17]='1')then frmMain.WindowState:=wsMaximized; // 最大化
    if(Obj[1].info[0][19]='1')then setWindowStyle;  //全屏
    end;
  SetProjection(false,false,1);
  for i:=11 to ObjCount do
    if(Obj[i].Kind in[10,11,14])then TextAndImage(i, false,true,true,true);
end;
//======================= 打开文件 =======================
function TfrmMain.updateTexture(NewPos:boolean):string; //更新文本 纹理 按钮
  var i,j,k,w0,h0,w1,h1, Len,ID,LinkA,LinkB :integer;  t,st:AnsiString;
  function FineLink(LinkName,ObjCount:integer):integer;
    var i:integer;
    begin i:=0; result:=0;
      repeat inc(i); until(LinkName=Obj[i].Name)or(i=ObjCount);
      if i<=ObjCount then result:=i;
    end;
  function getTex(ID:integer; texName:string; var w0,h0,w1,h1:integer):Cardinal;
    var sName:string;
  begin
    result:=0;
    with Obj[ID]do begin
      if(texName>'')then begin //来自文件
        sName:=sgfPath+texName; //路径必须与模型相同
        if FileExists(sName) then //如果文件存在
          result:= myLoadTexture(ID,texID, sName, nil, w0,h0, kW,kH, (Kind<>10)or(Kind=10)and not D )//D是否透明背景
        end
      else if(sImage.sFormat>'')then //来自数据
        result:= TxtToImg(ID,texID, sImage.sData, sImage.sFormat, w0,h0, kW,kH, (Kind<>10)or(Kind=10)and not D );
    end; //with Obj[ID]
    end;
begin
  MarkObj:=0; result:='';
  setDefault(NewPos);
  for i:= 11 to ObjCount do
    with Obj[i] do if(DelID=0)then begin
    hot:=false; //edited:=true;
    case Kind of
      2:if(Mode=6)and((Obj[Link[0]].Kind>4)or(Obj[Link[1]].Kind>4))and(Obj[Link[0]].Kind<>19)
        then begin Kind:=15; Mode:=1; end;
      3:if(Obj[parent].Mode<3)or(Obj[parent].Mode>4)then begin
        if D then texID:=getTex(i, info[0], w0,h0,w1,h1);  //D贴图
        if(texID=0)then begin D:=false; result:=info[0]; end;
        end;
      4:begin
        if D then texID:=getTex(i, info[0], w0,h0,w1,h1); 
        if(Link[10]=0)and(texID=0)and(Mode<>7)then D:=false;   //Link[10]数值纹理
        if(Mode=6)then setLength(LocaVct[i],IIFi(S=0,16,S+1)); //多边形
        if(texID=0)then result:=info[0];
        end;
      6:begin
        if D then texID:=getTex(i, info[0], w0,h0,w1,h1);
        if(texID=0)and(Obj[parent].Mode<3)then D:=false;
        end;
      7:begin
        if D then texID:=getTex(i, info[0], w0,h0,w1,h1);
        if(texID=0)then D:=false;
        end;
      9:begin
        texID:=getTex(i,info[3], w0,h0,w1,h1);//载入纹理。纹理文件必须和模型文件同路径
        if(texID=0)then D:=false;
        end;
//        8: Block( i, sgfPath+info[0]);
      10:begin //文本 图片
        if(Mode=1)then begin //文本
          st:=info[1]; t:=''; len:=Length(st)div 3; //字符串的ASCII码
          for j:= 0 to len-1 do begin
            val(copy(st,(j*3)+2,3),k,ID); t:=t+chr(k);
            end;
          info[2]:=t; //用于显示的字符串
          texID:= TextToBMP(i,info[2],true);
          end;
        if(Mode=2)then begin //图片
          texID:=getTex(i, info[0], w0,h0,w1,h1);
          TagSize.x:=w0; TagSize.y:=h0;
          end;  //TextAndImage(i,true,true);
        end;
      11:if(Mode=2)then begin
        R:=L; //保存原值 TextAndImage(i,true,true);
        if maxTrace<50 then maxTrace:=100;
        createParaBar( i, NewPos);//创建参数轴
        end;
      14:createCtrl( i,true); //创建控制按纽
      15:if((Obj[Link[0]].Kind<5)and(Obj[Link[1]].Kind<5)) //圆和平面的相贯线为直线
        then begin Kind:=2; Mode:=6; end;
      end;//case
    end;//for i
    LinkA:=Obj[0].iL; LinkB:=Obj[0].iR;
    if(LinkA>0)and(LinkB>0)then begin //恢复自定义变换规则
      LinkA:=FineLink(LinkA,ObjCount);
      LinkB:=FineLink(LinkB,ObjCount);
      if(LinkA>0)and(LinkB>0)then
      men128.Caption:=SwitchS(iLanguage,'变换 ','变换 ','Transform ','')
                  +Obj[LinkA].Tag+'→'+Obj[LinkB].Tag+'& ';
      MarkTrans[8,0]:=LinkA; MarkTrans[8,1]:=LinkB;
      end;
    men128.Visible:=(LinkA>0)and(LinkB>0);
    keyPreview:=true;
  for i:=11 to ObjCount do
    with Obj[i] do if(DelID=0)then begin
    if(Kind=14)and F then begin
      F:=false; butIDMouseDown(butID,mbLeft,[],0,0);
      end;
    GetTextList( i); //标签
    end;
end;

function TfrmMain.OpenFile( FileName :string; isFile,addPage :boolean):integer; //返回构件数
//== isFile: true_打开画板文件, false_打开[块]文件
//==addPage: true_在页尾追加文件, false_从第一页打开文件
  var i,j,k, k0,w0,h0,len,ID,iID, LinkA,LinkB :integer;
      N,Pages,NowPage,OldCount :integer;
      st,t,ver,tmp :AnsiString;  temp:WideString;
      blankObj :TmyObject; isError:boolean; //空白数据
      G :TextFile; //文本文件句柄
  function stf( s:string; p,l:integer):single;
    var st:string;
    begin st:=trim(copy(s,p,l)); if st='' then result:=0 else result:= StrToFloat(st); end;
  function sti( s:string; p,l:integer):integer;
    var st:string;
    begin  //if Length(s)<(p+l-1) then result:=0 else
      st:= trim(copy(s,p,l));
      if st='' then result:=0 else result:= StrToInt(st);
    end;
begin
  result:=0;   bOpenFile:=true;
  j:=High(Obj)-1;
  for i:=1 to j do with Obj[i]do begin
    glDeleteTextures(1,@texID);  //释放纹理内存
    glDeleteTextures(1,@texTag); //释放标签纹理内存
    end;
  if isFile then begin SgfFile:= FileName; updateTitle;  end;
  isError:=false;
  cheMark.Checked:=false;  cheAngle.Checked:=false; cheAngle.Enabled:=false;
  if(not addPage)then begin
    tabPage.Tabs.Clear;  tabPage.Tabs.Add('Page1');
    end;
  if AddPage then OldCount:=tabPage.Tabs.Count else OldCount:=0;

  Pages:=1;  NowPage:=1;  barPage.Max:=0;
  temp:=ExtractFileName(FileName);
  sgfName:=temp;
  temp:=LeftStr(temp, Length(temp)-4);
  AssignFile( G, FileName); //获取SysFile的句柄
  try
  try
    ReSet( G);
    readLn( G, st);   //打开文件 读取版本号
    if(copy(st,1,8)<>'inRm3D v')then begin
      closeFile( G); ObjCount:=10; exit;
      end;
    ver:=copy(st,9,5);
//    if ver[1]='.'then ver:=RightStr(st,5); //版本号
    if(ver<'2.820')and(not AddPage)then tabPage.Tabs[0]:=temp;
    if(ver>='2.820')then begin //从v2.820版开始加入页面控件
      readLn( G, st);  Pages:=sti(st,7,4); NowPage:=sti(st,11,4); //
      end;
    for N:=0 to Pages-1 do begin
      if(ver<'2.820')and(AddPage)then tabPage.Tabs.Add(temp);
      repeat //环境变量
        readLn( G, st); Len:=Length(st); t:= LeftStr(st,6);  //标志串
        if(trim(st)='')then begin
          closeFile( G); result:=10;  ObjCount:=10; exit;
          end;
        if(t='PageNm')then begin //页标签
          i:=sti(st, 8,4);  if(maxPage<i)then maxPage:=i; //页Name
          if addPage and(i<=maxPage)then begin inc(maxPage); i:=maxPage; end;
          Obj[8].parent:=i;
          tmp:= trim(copy(st,13,60));
          if(N=0)and(not addPage)
            then tabPage.Tabs[N]:=tmp
            else tabPage.Tabs.Add(tmp);
          end;
        with Obj[1] do begin
          if t='Color 'then begin
            for i:=0 to 7 do LinkName[i]:= getInt(st, i+1);
            end;
          if t='Transp'then begin
            p5.x:=getFlo(st, 1);  p5.y:=getFlo(st, 2);  p5.z:=getFlo(st, 3);
            end;
          if t='Mode  'then begin
            Obj[5].S:=getInt(st,1);   Obj[5].Thick:=getFlo(st,2);
            Obj[6].S:=getInt(st,3);   Obj[6].Thick:=getFlo(st,4);
            Obj[7].S:=getInt(st,5);   Obj[7].Thick:=getFlo(st,6);
            end;
          if t='Origin'then begin //原点位置 视角
            p3.x:=getFlo(st,1);  p3.y:=getFlo(st,2);  p3.z:=getFlo(st,3);
            p3.w:=getFlo(st,4);  p3.r:=getFlo(st,5);
            end;
          if t='Origi 'then begin //原点大小 点形 颜色
            Obj[1].W:=getFlo(st,1);  S:=getInt(st,2);   LinkName[1]:=getInt(st,3);
            end;
          if(t='Length')then begin //坐标轴长度
            Vec.x:=getFlo(st,1);  Vec.y:=getFlo(st,2);   Vec.z:=getFlo(st,3);
            Vec.w:=getFlo(st,4);  Vec.r:=getFlo(st,5);   p4.r :=getFlo(st,6);
            end;
          if(t='Axis  ')and(ver>'2.820')then begin //坐标轴线宽 箭头
            Obj[2].W:=getFlo(st,1);      Obj[2].H:=getFlo(st,2);
            Obj[3].W:=getFlo(st,3);      Obj[3].H:=getFlo(st,4);
            Obj[4].W:=getFlo(st,5);      Obj[4].H:=getFlo(st,6);
            end;
          if(t='AxiTag')then begin //坐标轴标签
            info[2]:=st;  for i:=1 to 4 do Obj[i].Tag:=getStr(st,i);
            end;
          if t='ObjShO'then for i:=7 to len do Obj[1].ObjShow[i-7]:= st[i]='1';
          if t='ObjShX'then for i:=7 to len do Obj[2].ObjShow[i-7]:= st[i]='1';
          if t='ObjShY'then for i:=7 to len do Obj[3].ObjShow[i-7]:= st[i]='1';
          if t='ObjShZ'then for i:=7 to len do Obj[4].ObjShow[i-7]:= st[i]='1';
          if t='Mask  'then for i:=7 to len do Obj[i].Mask:= st[i]='1';
          if(t='Deep  ')then begin //景深、透视
            p4.x:=getFlo(st,1);   p4.y:=getFlo(st,2);
            end;
          if t='Scene 'then begin   //环境开关
            tmp:=copy(st,7,21); for i:=1 to 21 do info[0][i]:=tmp[i];
            end;
          if(t='Window')and(isFile)and(maxPage=0)then begin //窗口位置
            Link[20]:=getInt(st,1); Link[21]:=getInt(st,2);
            Link[22]:=getInt(st,3); Link[23]:=getInt(st,4);
            if(Link[21]>Link[23])then Link[21]:=10;
            if(isFile)and not isUseToControler then setWindowFrame(true);
            end;
          if(t='Mark  ')then begin //刻度
            cheMark.Checked:=true; cheAngle.Checked:=(st[7]='1'); cheAngle.Enabled:=cheMark.Checked;
            end;
          if t='ShowA 'then D:= sti(st,7,4)=1; //显示轴线
          if t='ShowG 'then U:= sti(st,7,4)=1; //显示网格
          if t='ShowO 'then Lock:=sti(st,7,4)=1; //显示
          if t='Spin  'then begin //自动旋转场景
            dx:=getInt(st,1); dy:=getInt(st,2);
            timSpin.Enabled:=true;  butSpin.Down:=true;
            end;
          if t='Pages 'then begin //层数
            //if isFile then barPage.Max:=sti(st,7,4) else Obj[1].S:=sti(st,7,4);
            barPage.Max:=getInt(st,1); //PagePos 在 barPageChange 事件中赋值
            Layer:=getInt(st,2);
            barPage.Width:=   barPage.Max*15+19;
            pnlShow.Width:=  (barPage.Max+1)*15;
            UpDwPage.Position:= barPage.Max;
            if(ver<'2.820')then barPage.Position:=barPage.Max
                           else barPage.Position:=Layer;
            end;
          if t='Trans8'then begin //自定义变换规则
            Obj[0].iL:=getInt(st,1);  Obj[0].iR:=getInt(st,2);
            end;
        end; //if...with
      until t='End';
      ID:=10; if(isFile)then backObj.maxName:=ID;
      repeat //构件数据
        readLn( G, st); //构件序号
        if(st='Finish')or(trim(st)='')then break;
        inc(ID);  //构件ID
        Obj[ID]:= BlankObj;
        i:=sti(st,1,3);   if ver<='2.63'then i:=i+10;
        Obj[ID].Name:=i;  ObjNameStack[i]:=true;
        //if(i>backObj.maxName)then backObj.maxName:=i;//(isFile)and
        if(i<11)then Obj[ID].delID:=maxObj;
        with Obj[ID] do begin
          TagT:='0000'; parent:=ID;
          repeat
            readLn( G, st);   t:=LeftStr(st,6); //标志串
            len:= Length(st)-6;
            if t='Kind  'then begin Kind:=getInt(st,1); Mode:=getInt(st,2); end;
            if(ver<='2.5')and(Kind=1)then
              case Mode of 3:Mode:=7; 5:Mode:=8; 6:Mode:=9; end;
            if t='Tag   'then Tag:= copy( st, 7,len);
            if t='TagPos'then begin
              TagP.x:=getFlo(st,1);   TagP.y:=getFlo(st,2);
              TagP.z:=getFlo(st,3);   TagP.w:=getFlo(st,4);   TagC:=getInt(st,5);
              end; //
            if t='TagSty'then TagT:= copy(st,7,4); //标签style
            if t='TagS  'then TagS:= getInt(st,1); //标签字体
            if t='Font  'then TagN:= copy(st,7,len); //字体
            if t='Color 'then begin              //颜色、透明度
              Color := cgTColorToCGColorF( getInt(st,1), getFlo(st,2)); 
              p4.w:=getInt(st,1); ColorB:=Color; end;
            if t='ColorB'then begin              //颜色、透明度
              ColorB:= cgTColorToCGColorF( getInt(st,1), getFlo(st,2));
              p5.w:=getInt(st,1); end;
            if t='ColorV'then begin
              ColorMode:=getInt(st,1); ColorV0:=getFlo(st,2); ColorV1:=getFlo(st,3); end;
            if t='Shape 'then begin
              L:=getFlo(st,1);  W:=getFlo(st,2);  S:=getInt(st,3);  H:=getFlo(st,4);
              if(ver<'2.846')and(Kind in[3,4])and(S>3)then S:=(S-3)*10;
              if(ver<'2.857')and(Kind=4)and(Mode in[3,4,5])and(H=0)then H:=3;
              end;
            if t='Point 'then begin p0.x:=getFlo(st,1); p0.y:=getFlo(st,2);
                                    p0.z:=getFlo(st,3); p0.w:=getFlo(st,4); end;
{            if(Kind=14)then begin //按钮位置不能超出窗口
              if(p0.x>(frmMain.Width-W-20))then p0.x:=frmMain.Width-W-20;
              if(p0.x<20)then p0.x:=20;
              if(p0.y>(frmMain.Height-H)-10)then p0.y:=frmMain.Height-H-10;
              if(p0.y<30)then p0.y:=30;
              end;}
            if t='Thick 'then Thick:=getFlo(st,1);
            if t='Block 'then info[0]:= copy(st,7,len); //[块]文件名、迭代规则
            if t='Links 'then   //链接按钮
              begin info[0]:= copy(st,7,len);  edtLink.Text:=info[0]; end;
            if t='FuncX 'then info[0]:= copy(st,7,len); //方程表达式
            if t='FuncY 'then info[1]:= copy(st,7,len); //方程表达式
            if t='FuncZ 'then info[2]:= copy(st,7,len); //方程表达式
            if t='RuleX 'then p1:= cgVector( getFlo(st,1),getFlo(st,2),getFlo(st,3));//方程式的变量范围
            if t='RuleY 'then p2:= cgVector( getFlo(st,1),getFlo(st,2),getFlo(st,3));//方程式的变量范围
            if t='RuleZ 'then p5:= cgVector( getFlo(st,1),getFlo(st,2),getFlo(st,3));//方程式的变量范围
            if t='Param 'then p3:= cgVector( getFlo(st,1),getFlo(st,2),getFlo(st,3));//方程式的参数值
            if t='Param1'then begin
              p4.x:= getFlo(st,1); p4.y:=getFlo(st,2); p4.z:= getFlo(st,3); end;//方程式的参数值
            if t='Parame'then begin//参数轴
              i:=10 + getInt(st,1);
              LinkName[i]:= getInt(st,2);
              Para[i].x:= getFlo(st,3);   Para[i].y:= getFlo(st,4);
              Para[i].z:= getFlo(st,5);   Para[i].w:= getFlo(st,6);
              end;
            if t='Spin  'then R:= stf(st,7,9); //实体 块的转角
            if t='Angle 'then R:= stf(st,7,20); //旋转构件的转角
            if(ver<'2.865')and((Kind=4)and(Mode=5)or(Kind=2)and(Mode=5))
              then Angle:=0.5; //中面中线的角分比
            if t='Angle0'then begin
              if(Kind=4)and(Mode=5)or(Kind=2)and(Mode in[4,5])or(Kind=3)and(Mode<5)
                then Angle:= stf(st,7,20)  //中面的角分比 圆(弧)的精度
                else pTR.x:= stf(st,7,20); //平行面的线面角
              end;
            if t='Angle1'then begin
              Angle:= getFlo(st,1); pTR.x:=getFlo(st,2); pTR.y:=getFlo(st,3);
              end;
            if(ver<'2.858')and(Kind=4)and(Mode<3)then R:=1;
            if(ver<'2.854')and(Kind=2)and(Mode=5)then R:=0.5;//中线
            if(ver<'2.858')and(Mode=12)then begin R:=1; D:=false; end; //向量变换
            if t='Invert'then begin D:=true;  if copy(st,7,4)='   0'then D:=false; end;//
              if(ver<'2.868')and(Kind=4)and(Mode=6)and D then begin D:=false; Rand:=true; end;//正多边形贴图
            if t='Return'then begin F:=true;  if copy(st,7,4)='   0'then F:=false; end;
            if t='Shadow'then begin U:=true;  if copy(st,7,4)='   0'then U:=false; end;
            if t='Sected'then begin Q:=true;  if copy(st,7,4)='   0'then Q:=false; end;
            if t='Locked'then Lock:=true;
            if t='Mask'then Mask:=true;
            if t='Rand'then Rand:=true;
            if t='Degree'then begin Deg:=true; if(Mode=12)and(ver<'2.859')then Deg:=false; end;
            if t='noSel 'then noSel:=true;
            if t='Trace 'then begin Trace:=true; maxTrace:=sti(st,7,4); end;
            if t='TraceN'then maxTrace:= sti(st,7,4);
            if t='Trans 'then begin
              pTR:= cgVector( getFlo(st,1),getFlo(st,2),getFlo(st,3));  //平移变换
              cgXYZtoAngle(pTR.X,pTR.Y,pTR.Z, pBL.y,pBL.z,pBL.x, true); //将pTR转换为矢量pBL
              end;
            if t='Affine'then begin //仿射变换规则
              for i:=0 to 11 do Value[i]:=getFlo(st,i+1);
              end;
            if t='Slope 'then begin
                p2.x:= getFlo(st,1); p2.z:= getFlo(st,2); p2.y:= getFlo(st,3); p2.w:= getFlo(st,4);
                if(Kind=1)and(p2.z=0)then p2.z:=1;
                end; //斜率
            if t='Linker'then begin //关联构件
              Len:=getVarNum(st);
              for i:=0 to Len do begin
                k:=getInt(st, i+1);  //     k:= sti(st, 7+i*4, 4);
                LinkName[i]:=k;
                if(ver<='2.63')and(k>0)then begin
                  if(k>248)then LinkName[i]:=k-248 else LinkName[i]:=k+10;
                  end;
                end;
              if(ver<'2.860')and(Kind=3)and(Mode=3)and(LinkName[2]>0)then begin
                LinkName[3]:=LinkName[2];  LinkName[2]:=0;
                end;
              end;
            if t='Cutter'then begin //截面
              Q:=st[7]='1'; //Q剪裁
              Len:=(len-1)div 4;
              for i:=0 to len do begin
                k:= sti(st, 8+i*4, 4);  Cutter[i,2]:=0; 
                if(k>7000)then begin Cutter[i,2]:=2; k:=k-7000; end;
                if(k>4000)then begin Cutter[i,2]:=1; k:=k-4000; end;
                Cutter[i,0]:=k; //截面名
                end;
              end;
            if t='Textur'then begin //纹理文件
              if(Kind=9)then info[3]:= copy(st,7,len)
                        else info[0]:= copy(st,7,len);
              end;
            if t='Image 'then begin //纹理数据
              sImage.sFormat:= copy(st,9,5); //格式
              readLn( G, sImage.sData ); //数据
              end;
            if(Kind=1)and(Mode=2)and(Obj[Link[1]].Kind<4)and(p2.z=0)then p2.z:=1;//约束点的终止值
            if(Kind=7)and(Mode=1)and(H<=0)then H:=6.2832; //旋转曲面的转角
            if(Kind=10)and(Mode=2)and(LinkName[0]>0)then begin p2.x:=p0.x; p2.y:=p0.y; end;
            if t='ObjSho'then for i:=0 to len do ObjShow[i]:= st[i+7]='1';
            if t='TagSho'then for i:=0 to len do TagShow[i]:= st[i+7]='1';
            if trim(TagN)='' then TagN:='Arial';
            if TagS=0 then TagS:=9;
            if t='Croses'then begin //附属交点的标签
              k:=trunc(H);  for i:=1 to k do Obj[ID+i]:=Obj[ID]; //复制附属交点
              Len:=Length(st);  tmp:=copy(st, 8, Len);
              for i:=1 to k do with Obj[ID+i]do begin
                Name:=Obj[ID].Name+i;  ObjNameStack[Name]:=true;
                //if(Name>BackObj.maxName)then BackObj.maxName:=Name;
                j:=Pos(' ',tmp); if(j=0)then j:=Len;
                Tag:= copy(tmp, 1, j-1);  tmp:=copy(tmp, j+1, Len);
                LinkName[2]:=Obj[ID].Name;
                for j:=0 to LinkTime do ObjShow[j]:=false;
                R:=0;  D:=true;
                end;
              iID:=ID;//iID用于后续设置点径
              inc(ID, trunc(H));
              end;
            if t='CroShw'then begin //附属交点的显示状态
              k:=trunc(H);
              for i:=1 to k do Obj[iID+i].ObjShow[Layer]:=false;
              len:=(Length(st)-6)div 4;
              for j:=0 to len-1 do begin
                k:= sti(st, 7+j*4, 4);
                for i:=0 to Layer do Obj[iID+k].ObjShow[i]:=true;
                for i:=0 to Layer do Obj[iID+k].TagShow[i]:=Obj[iID].TagShow[i];
                end;
              end;
            if t='Edges 'then begin
              if(Kind=6)and(Mode=4)and(S=0)then begin //凸棱台的棱边数取决于父对象
                j:=4; repeat inc(j); until(Obj[j].Name=LinkName[0]);//定位父对象
                Link[0]:=j;
                end;
              iID:=ID;//iID用于后续设置线宽
              ID:=AddingEdges(ID,ID);//添加棱边和顶点
              Len:=Length(st);  tmp:=copy(st, 8, Len);
              for i:=1 to ID-iID do with Obj[iID+i]do begin
                j:=Pos(' ',tmp); if(j=0)then j:=Len;
                Tag:= copy(tmp, 1, j-1);  tmp:=copy(tmp, j+1, Len);
                Q:= Obj[iID].Q;   Cutter:=Obj[iID].Cutter;  //剪裁
                end;
              end;
            if t='EdgesW'then begin //棱边线宽、顶点直径、棱边颜色、顶点颜色
              getEdges( iID, i,k); //j棱边数 k顶点数
              Obj[iID+1].W:= stf(st,7,4);
              Obj[iID+1].Color:= cgTColorToCGColorF( sti(st,15,9),1);
              Obj[iID+1].S:= sti(st,33,4);
              for j:=1 to i do begin
                Obj[iID+j].W:=Obj[iID+1].W;
                Obj[iID+j].Color:= Obj[iID+1].Color;
                Obj[iID+j].S:= Obj[iID+1].S;
                end;
              if(k>0)then begin
                Obj[iID+i+1].W:= stf(st,11,4);
                Obj[iID+i+1].Color:= cgTColorToCGColorF( sti(st,24,9),1);
                for j:=1 to k do begin
                  Obj[iID+i+j].W:=Obj[iID+i+1].W;
                  Obj[iID+i+j].Color:= Obj[iID+i+1].Color;
                  end;
                end;
              end;
            if t='Names 'then begin //棱边顶点的Name
              getEdges( iID, i,k);  //i棱边数 k顶点数
              for j:=1 to i+k do begin
                Obj[iID+j].Name:=sti( st, 7+(j-1)*4, 4);
                ObjNameStack[Obj[iID+j].Name]:=true;
                //if(Obj[iID+j].Name>BackObj.maxName)then BackObj.maxName:=Obj[iID+j].Name;
                end;
              end;
            if t='VctObj'then begin //棱边顶点显示状态
              getEdges( iID, i,k);  //i棱边数 k顶点数
              StrToBool(iID, i+k, copy(st,7,9), false);
              end;
            if t='VctTag'then begin //棱边顶点标签显示状态
              getEdges( iID, i,k);  //i棱边数 k顶点数
              StrToBool(iID, i+k, copy(st,7,9), true);
              end;
            until st='End';
          if(ver<'2.70')and(Kind=1)and(Mode=4)
            and((Obj[Link[0]].Kind>2)or(Obj[Link[1]].Kind>4)) //旧版模型遇到交点则不再继续
            then begin dec(ID); isError:=true; end;
          if(ver<'2.837')and(Kind=11)and(Mode=13)and(p2.z=0)then p2.z:=1;
          end; //with
        if(Obj[ID].Name<11)or(Obj[ID].Kind<1)or(Obj[ID].Mode<1)
          then dec(ID); //跳过非法对象

      until (st='Finish');
      upDateLink(ID, false); //刷新链接
      ObjCount:=ID;
      if(ver<'2.715')then begin //老版本中若有多边形或多面体则插入相应数量的顶点
        i:=11;
        repeat
          with Obj[i] do
          if(Kind=6)and(Mode in[3,4]) or (Kind=4)and(Mode=6)and(Rand) //
            then begin
              if(Kind=4)then begin k:=trunc(W); k0:=k; end;
              if(Kind=6)then k :=IIFi(Mode=3, SolidVct[S], S*2); //顶点数
              if(Kind=6)then k0:=IIFi(Mode=3,SolidEdge[S], S*3); //棱边数
              for j:=0 to ObjCount-i-k0 do
                Obj[ObjCount+k-j]:=Obj[ObjCount-j];//为顶点腾出位置
              for j:=1 to k do with Obj[i+k0+j] do begin //写入顶点
                Name:=getObjName(1); //Name:=backObj.maxName+j;
                DelID:=0;
                Tag:=Obj[i].Tag+'['+itos(k0+j);
                Kind:=1; Mode:=13; W:=6; S:=1;
                Link[0]:=i; LinkName[0]:=Obj[i].Name;
                color:=cgTColorToCGColorF( Obj[1].Link[1],1); Color.A:=1;
                for Len:=0 to 24 do ObjShow[Len]:=true;
                end;
              inc(backObj.maxName,k);
              inc(ObjCount,k);
              inc(i,k);
              end;
          inc(i);
         until(i>ObjCount);
        upDateLink(ObjCount, isFile); //刷新链接
        end; //if(ver<'2.715')
      SaveThisPage(OldCount+N, ObjCount, true,true);
      end; //for N
    finally
      closeFile( G);          //关闭文件
      result:=ID; //返回构件总数
    end; // try
  except                    //出错处理
    MyMessage( 'Can''t open file ' + sgfFile);
    result:=0;  sgfFile:=''; sgfName:='';
    updateTitle;  exit;
  end; //try
  ReadThisPage(OldCount+NowPage-1);
  tabPage.TabIndex:=OldCount+NowPage-1;
  tmp:= updateTexture(true); //建立纹理 包含setDefault
  if(tmp>'')then
    MyMessage('图像文件不存在' + chr(13)
      + 'Texture file does not exist' + chr(13)+chr(13) +sgfPath + tmp);
  menPageDelete.Enabled:= tabPage.Tabs.Count>1;
  popPageDelete.Enabled:= menPageDelete.Enabled;
  bc:=false; bs:=false;
  pnlProp.Hide;
  result:=ObjCount;   bOpenFile:=false;
end;
{======================= 保存文件 =======================}
procedure TfrmMain.SaveFile( FileName :string);
  var ID,i,j,k,N, Pages,ThisPage :integer;   st,ss :AnsiString;
      G :TextFile; //文本文件句柄
  function fts( v:single):string;
    begin if v>9999999 then v:=9999999; if v<-9999999 then v:=-9999999;
      str( v:9:4, result);  if Length(result)>9 then result:=copy(result,1,9);
      end;
  function its( v:integer):string;
    begin if v>9999 then v:=9999; if v<-999 then v:=-999; str( v:4, result); end;
  function cts( v:integer):string;
    begin str( v:9, result); end;

  function its2( v:integer):string;
    begin result:=' '+ IntToStr( v); end;//if v>99999 then v:=99999; if v<-99999 then v:=-99999;
  function fts2( v:single):string;
    var i,Len :integer;
    begin
      if EP(trunc(v)-v) then
        result:= IntToStr(trunc(v))
      else begin
        str( v:12:4, result);  if Length(result)>12 then result:=copy(result,1,12);
        i:=Length(result);     while result[i]='0' do Dec(i);
        result:= copy(result,1,i);
        end;
      result:=' '+trim(result);
      end;
  function cts2( v:integer):string;
    begin result:=' '+ IntToStr(v); end;
  function str2( s:string):string;
    begin result:=' '+ trim(s); end;
begin
//  if bPW then exit; //未注册则退出
  with Obj[1]do begin
    Vec.x:=Obj[2].L; Vec.y:=Obj[3].L; Vec.z:=Obj[4].L;
    Vec.w:=Obj[2].R; Vec.r:=Obj[3].R; p4.r:=Obj[4].R;
    p3.z:=rX;   p3.w:=rY;  p3.r:=rZ;
    p4.x:=Deep; p4.y:=Pers;
    p5.x:=Obj[5].Color.A; p5.y:=Obj[6].Color.A; p5.z:=Obj[7].Color.A;//坐标平面透明度
    if not IsZoomed(frmMain.Handle)then begin
      setWindowFrame(false);
      info[0][17]:='0'; //最大化标记
      end;
    end;
  SaveThisPage(tabPage.TabIndex, ObjCount, true,true);
  If FileName>''
    then SgfFile:= FileName
    else begin
      If SaveBox.Execute
        then SgfFile:= SaveBox.FileName
        else exit;
      sgfName:=ExtractFileName(SgfFile);
      end;
  AssignFile( G, SgfFile);
  try
    try
    ReWrite( G);            //重写文件
    WriteLn( G, Version);  //版本号
    Pages:=tabPage.Tabs.Count; //总页数
    ThisPage:=tabPage.TabIndex+1;
    WriteLn( G, 'Page  '+its(Pages)+its(ThisPage));
    for N:=0 to Pages-1 do begin //逐页面保存
      ReadThisPage(N); //读入页面数据
        ID:=10;  k:=ObjCount; //对象总数
        repeat //挤出被删除的对象
          inc(ID);
          while(ID<=ObjCount)and(Obj[ID].DelID>0)do begin
            for i:=ID to ObjCount do Obj[i]:=Obj[i+1];
            dec(ObjCount);
            end;
          until(ID>=ObjCount);
        if(ObjCount<k)then begin //若有挤出对象
          setLength(Objs[N], ObjCount+1);
          updateLink(ObjCount,TRUE); //刷新链接
          for i:=0 to ObjCount do Objs[N,i]:=Obj[i];
          end;
      WriteLn( G, 'PageNm'+ItS(N)+'  '+tabPage.Tabs[N] ); //页序号、页标签
      WriteLn( G, 'Color '+ cts2(Obj[1].LinkName[0]) +cts2(Obj[1].LinkName[1])  //场景色 坐标轴色
                          + cts2(Obj[1].LinkName[2]) +cts2(Obj[1].LinkName[3]) +cts2(Obj[1].LinkName[4])
                          + cts2(Obj[1].LinkName[5]) +cts2(Obj[1].LinkName[6]) +cts2(Obj[1].LinkName[7]));
      WriteLn( G, 'Transp' +fts2(Obj[5].Color.A) +fts2(Obj[6].Color.A) +fts2(Obj[7].Color.A)); //坐标平面透明度
      WriteLn( G, 'Mode  '+ its2(Obj[5].S)+ fts2((Obj[5].Thick))
                          + its2(Obj[6].S)+ fts2((Obj[6].Thick))
                          + its2(Obj[7].S)+ fts2((Obj[7].Thick)));
      WriteLn( G, 'Origin'+ fts2(Origin.x)+ fts2(Origin.y)+ fts2(Obj[1].p3.z)+ fts2(Obj[1].p3.w)+ fts2(Obj[1].p3.r)); //原点位置 视角
      WriteLn( G, 'Origi '+ its2(trunc(Obj[1].W))+ its2(Obj[1].S)+ cts2(cgColorFToTColor( Obj[1].Color))); //原点大小 颜色
      WriteLn( G, 'Length'+ fts2(Obj[1].Vec.x)+ fts2(Obj[1].Vec.y)+ fts2(Obj[1].Vec.z) //轴线长
                          + fts2(Obj[1].Vec.w)+ fts2(Obj[1].Vec.r)+ fts2(Obj[1].p4.r ) );
      WriteLn( G, 'Axis  '+ its2(trunc(Obj[2].W))+ its2(trunc(Obj[2].H))
                          + its2(trunc(Obj[3].W))+ its2(trunc(Obj[3].H))
                          + its2(trunc(Obj[4].W))+ its2(trunc(Obj[4].H)));
      WriteLn( G, 'AxiTag'+ str2(Obj[1].Tag)+ str2(Obj[2].Tag)+ str2(Obj[3].Tag)+ str2(Obj[4].Tag)); //坐标轴标签
        st:=''; for j:=0 to barPage.Max do st:=st+IIFs(Obj[1].ObjShow[j],'1','0');
      WriteLn( G, 'ObjShO'+ st); //原点显示状态
        st:=''; for j:=0 to barPage.Max do st:=st+IIFs(Obj[2].ObjShow[j],'1','0');
      WriteLn( G, 'ObjShX'+ st); //x轴显示状态
        st:=''; for j:=0 to barPage.Max do st:=st+IIFs(Obj[3].ObjShow[j],'1','0');
      WriteLn( G, 'ObjShY'+ st); //y轴显示状态
        st:=''; for j:=0 to barPage.Max do st:=st+IIFs(Obj[4].ObjShow[j],'1','0');
      WriteLn( G, 'ObjShZ'+ st); //z轴显示状态
        st:=''; for j:=2 to 7 do st:=st+IIFs(Obj[j].Mask, '1','0');
      WriteLn( G, 'Mask  '+ st);
      if cheMark.Checked then
        WriteLn( G, 'Mark  '+ IIFs(cheAngle.Checked,'1','0') );
      WriteLn( G, 'Deep  '+ fts2(Deep) +fts2(Pers)); //景深 透视
      with Obj[1]do begin
        if IsZoomed(frmMain.Handle)and tlbMain.Visible then info[0][17]:='1' else info[0][17]:='0';//最大化
        if not tlbMain.Visible then info[0][19]:='1' else info[0][19]:='0'; //全屏
        if butLock.Down then info[0][18]:='1' else info[0][18]:='0';        //锁定视角
        if butList.Down then info[0][20]:='1' else info[0][20]:='0';     //对象列表
        if butListAnchor.NumGlyphs=1 then info[0][21]:='0' else info[0][21]:='1';
        for i:=0 to 2 do if Obj[5+i].F then info[0][13+i]:='1' else info[0][13+i]:='0'; //坐标平面边框
        WriteLn( G, 'Scene '+info[0]);
        if(N=0)then with frmMain do  //窗口位置
          WriteLn( G, 'Window'+its2(Left) +its2(Top) +its2(Width) +its2(Height));
        end;
      WriteLn( G, 'Pages '+its2(barPage.Max) +its2(barPage.Position) ); //层数、当前层号
      if timSpin.Enabled then
        WriteLn(G,'Spin  '+ its2(dx)+ its2(dy)); //场景旋转
      if(men128.Visible)and(Obj[MarkTrans[8,0]].DelID=0)and(Obj[MarkTrans[8,1]].DelID=0 )then //自定义变换规则
        WriteLn(G,'Trans8'+its2(Obj[MarkTrans[8,0]].Name)+its2(Obj[MarkTrans[8,1]].Name));
      WriteLn( G, 'End' );
      ID:=11;
      while(ID>10)and(Obj[ID].Name>0)and(ID<=ObjCount)do begin
        with Obj[ID] do begin
        if(DelID>0)or(Name<1)or(Kind<1)or(Mode<1)
          or(Kind=1)and(Mode=4)and D  //附属交点
          or(Kind in[1,2])and(Mode=13)then begin inc(ID); continue; end; //附属棱边、顶点

        WriteLn( G, IntToStr(Name) );//构件ID
        WriteLn( G, 'Kind  '+its2( Kind)+its2( Mode) ); //Kind, Mode
        WriteLn( G, 'Tag   '+Tag );
        WriteLn( G, 'TagPos'+ fts2(TagP.x)+fts2(TagP.y)+fts2(TagP.z)+ fts2(TagP.w)+ its2(TagC));//标签位置 颜色
        if not(TagT='0000')and(TagT>'')then WriteLn( G, 'TagSty'+ TagT);
        if(TagS>0) then WriteLn( G, 'TagS  '+ its(TagS) ); //标签字号
        if(TagN>'')then WriteLn( G, 'Font  '+ TagN);  //标签字体
        if(Kind<>11)or (Kind=11)and(Mode=2)then
          WriteLn( G, 'Color '+cts2(cgColorFToTColor( Color))+ fts2(Color.A) );//颜色索引和透明度
        if(Kind in[3,4,6,7,9])or(Kind=11)and(Mode=2)then
          WriteLn( G, 'ColorB'+cts2(cgColorFToTColor( ColorB))+ fts2(ColorB.A) );
        if(Link[6]>0)then
          WriteLn( G, 'ColorV'+its2(ColorMode) +fts2(ColorV0) +fts2(ColorV1) ); //着色模式
        WriteLn( G, 'Shape '+fts2(L) +fts2( W) +its2( S) +fts2( H));
        if(Kind=1)and(Mode=1)or(Kind in[10,11,14])then //自由点、文字、计算式、控制纽
          WriteLn( G, 'Point '+fts2(p0.x)+fts2(p0.y)+fts2(p0.z)+fts2(p0.w) );
        if(Thick<>0)then
          WriteLn( G, 'Thick '+fts2(Thick));
        if(Mode=11)then //平移变换
          WriteLn( G, 'Trans '+fts2(pTR.x)+fts2(pTR.y)+fts2(pTR.z) );
        if(Mode=16)and(Kind<>11)then begin //仿射变换规则
          ss:='';  for j:=0 to 11 do ss:=ss+fts2(Value[j]);
          WriteLn( G, 'Affine'+ ss );
          end;
        if(R<>0)then WriteLn( G, 'Angle '+fts2(R) );
        if(Kind=4)and(Mode=3)and(pTR.x<>0)then //平行面的线面角
          WriteLn( G, 'Angle0'+fts2(pTR.x) );
        if(Kind=2)and((Mode=4)or(Mode=5))or(Kind=3)and(Mode<5)or(Kind=4)and(Mode=5)then //两点之中垂线之间比 中面的角分比
          WriteLn( G, 'Angle0'+fts2(Angle) );
        if(Kind=6)and(Mode<3)then //球体台体的弧角 平面凸壳厚度
          WriteLn( G, 'Angle1'+fts2(Angle)+fts2(pTR.x)+fts2(pTR.y) );
        if((Kind=4)and(Mode=6)and not Rand or (Kind=11)and(Mode=2)) and not EP(Angle) then // 平面凸壳厚度
          WriteLn( G, 'Angle1'+fts2(Angle) );
        if(Kind=19)and(Mode=1)and not EP(Angle)then
          WriteLn( G, 'Angle1'+fts2(Angle) );
        ss:=''; k:=-1;
        for j:=0 to LinkTime do if(LinkName[j]>0)then k:=j; //链接数
        if(k>=0)then begin
          for j:=0 to k do ss:=ss + its2(LinkName[j]);
          WriteLn( G, 'Linker'+ ss ); //链接构件
          end;
        if(Kind in[2,10,11])or(Kind=1)and(Mode=2)then
          WriteLn( G, 'Slope '+fts2(p2.x)+fts2(p2.z) +fts2(p2.y)+fts2(p2.w));//注意 y,z 必须是颠倒存放的 为了兼容老版本
        if(Kind=9)or(Kind=16)then begin  //函数曲面 曲线
          WriteLn( G, 'FuncX '+ trim( info[0]) );    //X表达式
          WriteLn( G, 'FuncY '+ trim( info[1]) );    //Y表达式
          WriteLn( G, 'FuncZ '+ trim( info[2]) );    //Z表达式
          WriteLn( G, 'RuleX '+ fts2(p1.x)+fts2(p1.y)+fts2(p1.z)); //x变量范围
          WriteLn( G, 'RuleY '+ fts2(p2.x)+fts2(p2.y)+fts2(p2.z)); //y变量范围
          WriteLn( G, 'RuleZ '+ fts2(p5.x)+fts2(p5.y)+fts2(p5.z)); //z变量范围
          WriteLn( G, 'Param '+ fts2(p3.x)+fts2(p3.y)+fts2(p3.z)); //常量参数a,b,c
          WriteLn( G, 'Param1'+ fts2(p4.x)+fts2(p4.y)+fts2(p4.z)); //常量参数d,e,f
          end;
        if(Kind=10)and(Mode=1)then //文字
          WriteLn( G, 'FuncY '+trim(info[1]));
        if(info[3]>'')and(Kind=9)then
          WriteLn( G, 'Textur'+ trim( info[3]) ); //函数曲面纹理
        if(info[0]>'0')and((Kind=10)and(Mode=2)or (Kind in[3,4,6,7,9])and D )then //图片纹理
          WriteLn( G, 'Textur'+ trim( info[0]) );
        if(info[0]='')and(sImage.sData>'')and((Kind in[3,4,6,7])and D or(Kind=10)and(Mode=2))
          or(info[3]='')and(Kind=9)and D then begin  //纹理
            WriteLn( G, 'Image '+'  '+ sImage.sFormat); //格式
            WriteLn( G, sImage.sData);                  //数据
            end;

        if(Kind=11)then begin //[计算]
          WriteLn( G, 'FuncX '+ trim( info[0]));  //[计算]表达式
          WriteLn( G, 'FuncY '+ trim( info[1]));  //变换后的[计算]表达式
          end;
        if(Kind=14)and(Mode=6)then //链接按钮
          WriteLn( G, 'Links '+ trim( info[0]));
        if(Kind=11)and(Mode=2)then begin //参数
          for j:=11 to LinkTime do if(Link[j]>0)then
            WriteLn( G, 'Parame'+ its2(j-10)+ its2(LinkName[j])
              + fts2(Para[j].x)+ fts2(Para[j].y) + fts2(Para[j].z)+ fts2(Para[j].w) );
          if Assigned(butID)then butID.Hide;
          end;
        if Lock then WriteLn( G, 'Locked'); //锁定
        if Mask then WriteLn( G, 'Mask'); //遮挡
        if Rand then WriteLn( G, 'Rand'); //约束点 正多边形 随机动画
        if D then WriteLn( G, 'Invert');
        if F then WriteLn( G, 'Return');
        if U and not((Kind=11)and(Mode=2))then WriteLn( G, 'Shadow'); //不记录参数的动画状态
        if Q then WriteLn( G, 'Sected');
        if(Cutter[0,1]>0)then begin //截面
          ss:='0'; if Q then ss:='1';
          for i:=0 to 5 do begin
            k:=Cutter[i,1];  j:=Obj[k].Name;
            if(Cutter[i,2]=1)then j:=j+4000;//Secter[i,2] 截面取反
            if(Cutter[i,2]=2)then j:=j+7000;
            if(k>0)and(Obj[k].DelID=0)and(Obj[k].Kind=4)then ss:=ss+its(j);
            end;
          if(ss>'')then WriteLn( G, 'Cutter'+ss);
          end;
        if Deg then WriteLn( G, 'Degree');
        if noSel then WriteLn( G,'noSel ');
        if Trace or(Kind=14)and(Mode=2)then
          WriteLn( G, 'Trace '+its2(maxTrace) );//
        if(Kind=18)and not Trace or(Kind=14)and(Mode=6)and(maxTrace>0)then
          WriteLn( G, 'TraceN'+its(maxTrace));
        st:=''; for j:=0 to barPage.Max do st:=st+IIFs(ObjShow[j],'1','0');
          WriteLn( G, 'ObjSho'+ st);
        st:=''; for j:=0 to barPage.Max do st:=st+IIFs(TagShow[j],'1','0');
          WriteLn( G, 'TagSho'+ st);
        if(Kind=1)and(Mode=4)and not D then begin //交点
          ss:=''; for j:=1 to trunc(H) do ss:=ss+' '+Obj[ID+j].Tag;//附属交点只保存有效交点标签
          WriteLn( G, 'Croses'+ ss);
          ss:=''; for j:=1 to trunc(R)+1 do if(Obj[ID+j].ObjShow[Layer])and(not Hide)then ss:=ss+its(j);
          if(ss>'')then WriteLn( G, 'CroShw'+ ss); //显示交点
          end;

        if(Kind=6)and((Mode in[3,5])or(Mode=4)and(S<100))
          or(Kind=4)and(Mode=6)and(W<100)then begin //附属棱边顶点
          getEdges( ID, i,k); //j棱边数 k顶点数
          ss:=''; for j:=1 to i+k do ss:=ss+' '+Obj[ID+j].Tag; //标签
          WriteLn( G, 'Edges '+ ss);
          WriteLn( G, 'EdgesW'+ its(trunc(Obj[ID+1].W))+its(trunc(Obj[ID+i+1].W))
            +cts(cgColorFToTColor( Obj[ID+1].Color)) +cts(cgColorFToTColor( Obj[ID+i+2].Color))
            +its(Obj[ID+1].S) );
          ss:=''; for j:=1 to i+k do ss:=ss+its(Obj[ID+j].Name); //对象名
          WriteLn( G, 'Names '+ ss);

          WriteLn( G, 'VctObj'+ BoolToStr(ID,i+k, false)); //显示顶点
          WriteLn( G, 'VctTag'+ BoolToStr(ID,i+k, true)); //显示顶点标签
          end;
        WriteLn( G, 'End');
        end; //with Obj[i]...
        inc(ID);
        end; //while ...
      WriteLn( G, 'Finish');
      end; //for N
      WriteLn( G, 'Termination');
    finally
      closeFile( G);        //关闭文件
    end; // try
  except                  //出错处理
    MyMessage( 'Can not save file.' + sgfFile);
  end; //try
  ReadThisPage(ThisPage-1);
  UpdateTexture(false);
  updateTitle;
  setPopMenu( true, SgfFile);
  BackObj.UndoID:= 0;   BackObj.UndoMax:= 0;
  bEdit:=false;
  reRelate(11,ObjCount,false,false,false);
  SetProjection(false,false,0);
end;
//======================== 多面体或平面填充 =========================
procedure TfrmMain.OpenPicture( ID:integer; isPicture, bDraw:boolean);
  var sName:string; w0,h0:integer;
begin
  with Obj[ID] do begin
  OpenBox.InitialDir :=sgfPath;
  if(Kind=9)then OpenBox.FileName:= info[3] //函数曲面
            else OpenBox.FileName:= info[0];//平面或几何曲面
  OpenBox.Filter:='All (*.bmp; *.jpg; *.gif; *.png)|*.bmp;*.jpg;*.gif;*.png|Bitmaps (*.bmp)|*.bmp|JPEG Image File (*.jpg)|*.jpg|GIF Image File (*.gif)|*.gif|PNG Image File (*.png)|*.png';
  if OpenBox.Execute then begin //打开图象文件框
    texID:=0;
    sName:= OpenBox.FileName;
    if FileExists(sName) then begin
      sImage.sFormat:='';//UpperCase( ExtractFileExt(sName));
      sImage.sData:='';// ImgToTxt(ID, sName, sImage.sFormat);

      texID:= myLoadTexture(ID,texID, sName, nil, TagSize.x,TagSize.y, kW,kH, not((Kind=10)and D) );//图片可以选择不透明
      if texID>0 then sName:=ExtractFileName(sName) else sName:='';//不保存路径
      if(Kind=10)and(Mode=2)then begin p0.z:=w0; p0.w:=h0; end; //图片路径必须与模型相同
      info[0]:='';  info[3]:='';  Hide:=false;
      if(Kind=9)then info[3]:=sName else info[0]:=sName;
      if(Kind<>10)then D:= texID>0;
      cheMask.Checked:=D;
      if(Kind=4)then begin Link[10]:=0; LinkName[10]:=0; end;
      end;
    if bDraw then reRelate(MarkObj,MarkObj,false,true,false);
    end;
  end;//with
end;
procedure getStaticText(var Dest :TStaticText; var Sour :TStaticText);
begin
  Dest.Caption:=Sour.Caption;   Dest.Visible:=Sour.Visible;
  Dest.Font:=Sour.Font;         Dest.Hint:=Sour.Hint;
  Dest.Color:=Sour.Color;
  Dest.Left:=Sour.Left;         Dest.Top:=Sour.Top;
end;
//======================== 删除对象 =====================
procedure TfrmMain.DeleteObj(ID:integer; bb:boolean); //bb 是否保存删除数据
  var i :integer;
  label OnlyDelPaint;
  procedure DelLinkObj(ID, iID :integer);  //删除关联构件
    var i,j :integer;
    begin
    for i:= 11 to ObjCount do with Obj[i] do if(DelID=0)then begin
      for j:=0 to LinkTime do if(Obj[Link[j]].DelID in[ID,iID])
        then DelID:=iID;
      if((Kind=14)or(Kind=11)and(Mode=2))and(DelID>0)then butID.Hide;
      if(Kind=13)then Iterate(i,true,true);
      end;
    end; //procedure
begin
  if((ID<10)or(ID>999))then
    if(PaintListNum=0)then exit else goto OnlyDelPaint;
  with Obj[ID] do if(Kind=14)and F //按下的按钮
    then exit;
  for i:=11 to ObjCount do
    with Obj[i] do if hot then begin
      if(Kind<3)and(Mode=13)then //棱边
        begin hot:=false; Obj[Link[0]].Hot:=true; if(i=ID)then ID:=Link[0]; end;
      if(Kind=1)and(Mode=4)and D then  //如是共轭交点则删除主交点
        begin hot:=false; Obj[Link[2]].Hot:=true; if(i=ID)then ID:=Link[2]; end;
      end; //with
  Obj[ID].hot:=true; //不能没有，Undo/Redo所必须
  if bb then Save(2,ID,1,true,false);       //保存UnDo数据
  for i:=11 to ObjCount do
    with Obj[i] do if hot or Seled then begin
    if(Trace)and not(Kind in[6,10,11,14,18])then begin  //删除构件的跟踪痕迹
      Trace:=false; cheTrace.Checked:=false;
      glDeleteLists( tracList, 200);// i*200+30000+1, maxTrace);//
      reRelate(ID,ID,false,false,false);
      continue;
      end
    else begin
      glDeleteLists( mainList, 1);  glDeleteLists( maskList, 1);
      glDeleteLists( seleList, 1);  gldeleteLists( wireList, 1);
      end;
    setLength(LocaVct[i],0);
    setLength(FaceVct[i],0);
    setLength(aLink[i], 0);
    DelID:=ID;       //设置删除标记   hot:=false;
    if i<ObjCount then DelLinkObj(i, ID); //删除被关联构件
    case Kind of
      13: pnlControl.Hide;              //迭代规则
      11: if(Mode=2)then butID.Hide; //滑块
      14: butID.Hide;                //按钮
      end;//case Kind
    end;//for...with...if...begin
  ObjListUpdate(0,false);
  MarkObj:=0; pnlShow.Visible:=false;
  pnlProp.Visible:=bNail; pnlProp.Height:=44;
OnlyDelPaint:
  if(PaintListNum>0)then PaintDel; //删除手绘线
  SetProjection(true,false,2);
  ClearSelRec(0);
  CountObjNum(false,true);
end;
{===================== 撤消/恢复  Undo =======================}
procedure TfrmMain.Save( workCode,ID,Num :integer; bSave,bAlone :boolean);
  var i,j,k :integer;   //workCode= 0_编辑 1_添加 2_删除 3_合并 4_分离
  procedure PushData(Num,Code:integer; var undoID:integer);
    var i,j,n :integer;
  begin
    j:=backObj.undoData[undoID].undoObjID[0];
    if(backObj.undoData[0].undoCode=0)then begin
      n:=backObj.undoData[0].undoNum;
      for i:=0 to undoTime-n do
        backObj.undoObj[i]:=backObj.undoObj[i+n];
      for i:=0 to undoID do
        if(backObj.undoData[i].undoCode=0)then begin
          j:=backObj.undoData[i].undoObjID[0];
          dec(j, n);
          backObj.undoData[i].undoObjID[0]:=j;
          end;
      end;
    for i:=0 to undoID do backObj.undoData[i]:=backObj.undoData[i+1];
    dec(undoID);
    if(Code=0)and((j + Num) > undoTime)
      then PushData(Num,workCode, undoID); //递归
  end;
begin
  with backObj do begin
    case workCode of
    0:begin //编辑
      if bSave then begin
        inc( UndoID);  UndoMax:= UndoID;
        end
      else begin
        undoData[undoID].undoCode:=workCode;
        j:=0;
        case Obj[ID].Kind of
        1:begin
          if bAlone then begin
             j:=1; undoData[undoID].undoObjID[1]:=ID;
            end
          else for i:=11 to ObjCount do if(j<LinkTime)then with Obj[i] do
            if((Kind=1)and(Mode=1)or(Kind=1)and(Mode=2)and(i=ID))and Hot and not Lock then begin
              inc(j); undoData[undoID].undoObjID[j]:=i;
              end;
          end;
        2,3,4,6,17:begin //直线 圆 平面 实体 路径
          if bS or(bC and bS)or bAlone then begin
            j:=1; undoData[undoID].undoObjID[1]:=ID;
            end
          else
            for i:=0 to 47 do if(Obj[ID].Link[i]>10)then
              with Obj[Obj[ID].Link[i]] do
              if(Kind=1)and(Mode=1)and not Lock then begin
                inc(j); undoData[undoID].undoObjID[j]:=Obj[ID].Link[i];
                end;
          end;
        9,13,16,18:begin //函数曲线、曲面、迭代 标记 
            j:=1; undoData[undoID].undoObjID[1]:=ID;
          end;
        10,11,14:begin //文字 参数 按钮 
          for i:=11 to ObjCount do if(j<LinkTime)then with Obj[i] do
            if(Kind in[10,11,14])and not Lock then begin
              inc(j); undoData[undoID].undoObjID[j]:=i;
              end;
          end;
        end;// case Kind
        undoData[undoID].undoNum:=j;
        if(undoID>undoTime)or((undoData[undoID].undoObjID[0]+j)>undoTime)
          then PushData(j,workCode, undoID); //压缩Undo数组
        for i:=1 to j do begin
          k:=undoData[undoID].undoObjID[i];
          undoObj[undoData[undoID].undoObjID[0]+i-1]:=Obj[k];
          undoObj[undoData[undoID].undoObjID[0]+i-1].Hot:=false;
          end;
        undoData[undoID+1].undoObjID[0]:=undoData[undoID].undoObjID[0]+j;
        end;
      end;
    1:begin //添加 必然是连续对象，只保存添加对象的个数和对象的Name
      if(undoID>undoTime)then PushData(1,workCode, undoID); //压缩Undo数组
      undoData[undoID].undoCode:=workCode; //workCode=1
      undoData[undoID].undoNum:=Num;                     //添加的对象数目
//      undoData[undoID].undoObjID[1]:=ID;
      for i:=1 to Num do
        undoData[undoID].undoObjID[i]:=Obj[ID-i+1].Name; //添加的对象名,Redo时必须先要转换成ID
      if(undoID=0)then j:=0 else j:=undoData[undoID].undoObjID[0];
      inc( UndoID);  UndoMax:= UndoID;
      undoData[undoID].undoObjID[0]:=j;//Undu对象数组指针
      end;
    2:begin //删除 只保存被删对象的Name号
      if(undoID>undoTime)then PushData(1,workCode, undoID); //压缩Undo数组
      undoData[undoID].undoCode:=workCode; //workCode=2
      j:=0;
      for i:=11 to ObjCount do with Obj[i]do
        if(delID=0)and Hot then begin
        inc(j);
        undoData[undoID].undoObjID[j]:=Name;//Undu对象的Name,Redo时必须先转换成ID
        end;
      undoData[undoID].undoNum:=j; //删除的对象个数
      if(undoID=0)then j:=0 else j:=undoData[undoID].undoObjID[0];
      inc( UndoID);  UndoMax:= UndoID;
      undoData[undoID].undoObjID[0]:=j; //Undu对象数组指针
      end;
    3:if bSave then begin //合并
        inc( UndoID);  UndoMax:= UndoID;
        end
      else begin
        undoData[undoID].undoCode:=workCode; //workCode=3
        j:=0;
        for i:=11 to ObjCount do with Obj[i] do
          if Hot then begin
              inc(j); undoData[undoID].undoObjID[j]:=i;
              end;
        undoData[undoID].undoNum:=j;
        if(undoID>undoTime)or((undoData[undoID].undoObjID[0]+j)>undoTime)
          then PushData(j,workCode, undoID); //压缩Undo数组
        for i:=1 to j do begin
          k:=undoData[undoID].undoObjID[i];
          undoObj[undoData[undoID].undoObjID[0]+i-1]:=Obj[k];
          undoObj[undoData[undoID].undoObjID[0]+i-1].Hot:=false;
          end;
        undoData[undoID+1].undoObjID[0]:=undoData[undoID].undoObjID[0]+j;
      end;
    end;//case n
    if UndoMax=UndoTime then bEdit:=true; //当前已保存的场景数
    end; //with backObj
end;
{==============================================}
procedure TfrmMain.UnDo( isUndo:boolean); //isUndo: true as Undo, false as Redo
  var i,n, workCode, LastID, workID :integer;  tmpObj:TmyObject;
  function getObjID(ObjName:integer):integer;
    var i :integer; isSame :boolean;
    begin //
      result:=ObjName; if(ObjName<11)then exit;
      i:=10; repeat inc(i); isSame:=(Obj[i].Name=ObjName); until isSame or(i=ObjCount);
      result:=0; if isSame then result:=i;
    end;
  procedure updateObj(ID :integer; var LastID :integer);  //恢复被删除的构件
    var i :integer;
    begin LastID:=maxObj;
      for i:= 11 to ObjCount do
        with Obj[i] do if(DelID=ID)then begin
          if i<LastID then LastID:=i; DelID:=0; iT:=0;
          end; //iT 参数是否被修改过
    end; //procedure
begin
  if isUndo and(PaintListNum>0)and(bAdd and(nK=18)or(BackObj.UndoID=0))then begin
    dec(PaintListNum);  PaintMax:=PaintListNum;
    SetProjection(true,false,3);
    exit;
    end; //删除手绘线 只能Undo
  if bAdd then exit;

  with backObj do begin
    if isUndo and(undoID=0)or not isUndo and(undoID=undoMax)then exit;
    if isUndo then dec(undoID); //Undo
    workCode:= undoData[undoID].undoCode;  //workCode 操作模式: 0_编辑, 1_添加, 2_删除
    n:= undoData[undoID].undoNum;
    case workCode of
    0:begin //编辑
      LastID:= undoData[undoID].undoObjID[0]; //undo对象数组ID
      for i:= 1 to n do begin
        tmpObj:= undoObj[LastID+i-1];
        workID:= getObjID(tmpObj.Name);
        undoObj[LastID+i-1]:= Obj[workID];
        Obj[workID]:=tmpObj; //恢复原数据
        Obj[workID].Edited:=true;
        Obj[workID].Hot:=false;
        if(Obj[workID].Kind=10)and(Obj[workID].Mode=1)then //恢复文字纹理
          Obj[workID].texID:= TextToBMP(workID,Obj[workID].info[2], true);
        end;
      end;
    1:begin //添加构件
      for i:= 1 to n do begin
        workID:=getObjID(undoData[undoID].undoObjID[i]);
        if isUndo then deleteObj(workID, false)
                  else updateObj(workID,LastID);
        Obj[workID].Hot:=false;
        if not isUndo then Obj[workID].edited:=true;
        end;
      end;
    2:begin //删除构件
      for i:= 1 to n do begin
        workID:=getObjID(undoData[undoID].undoObjID[i]);
        if isUndo then updateObj(workID,LastID) else deleteObj(workID, false);
        if isUndo then Obj[workID].edited:=true;
        Obj[workID].Hot:=false;
        end;
      end;
    3:begin //合并
      LastID:= undoData[undoID].undoObjID[0]; //undo对象数组ID
      for i:= 1 to n do begin
        tmpObj:= undoObj[LastID+i-1];
        workID:= undoData[undoID].undoObjID[i]; //对象数组ID
        undoObj[LastID+i-1]:= Obj[workID];
        Obj[workID]:=tmpObj; //恢复原数据
        Obj[workID].Edited:=true;
        Obj[workID].Hot:=false;
        end;
      end;
    end;
    if not isUndo then inc(undoID); //Redo
    end;
  upDateLink(ObjCount, true); //更新链接
  ObjListUpdate(0,false);
  reRelate(11,ObjCount,false,false,false);
  SetProjection(false,false,3);
  ClearSelRec(0);
  MarkObj:=0;
  pnlProp.Hide;
end;
//############ 获得点构件的屏幕坐标 ################
function TfrmMain.GetDotPos( pp:TcgVector; calc:boolean) :TcgVector;
  var wx,wy,wz :glDouble;
begin
  if calc then begin
    glGetIntegerv(GL_VIEWPORT, @viewP);
    glGetDoublev( GL_Modelview_Matrix, @modeM);
    glGetDoublev(GL_Projection_Matrix, @projM);
    end;
  gluProject( pp.x, pp.y, pp.z, modeM,projM,viewP, @wx,@wy,@wz);
  result:= cgVector( wx,wy,wz);
end;
function TfrmMain.GetWinPos( ID,k :integer) :TcgVector;
  var wx,wy,wz :glDouble; pp:TcgVector; viewP :TviewPortArray; // 屏幕坐标
begin
    glGetIntegerv(GL_VIEWPORT, @viewP);
    glGetDoublev( GL_Modelview_Matrix, @modeM);
    glGetDoublev(GL_Projection_Matrix, @projM);
  with Obj[ID] do begin
  case Kind of
    2: case k of 0,1:pp:=p4; 2:pp:=p5; 3:pp:=p2; end;
    1,3,18: case k of 0,1:pp:=p0; 2:pp:=p1; 3:pp:=p2; end; //case
    4:case k of 0:pp:=LocaVct[ID,0]; 1:pp:=LocaVct[ID,1]; 2,3:pp:=LocaVct[ID,2]; end;
    else pp:=p0;
    end; //case Kind
  end; //with
  gluProject( pp.x, pp.y, pp.z, modeM,projM,viewP, @wx,@wy,@wz);
  result:= cgVector( wx,wy,wz);
end;
//############ 将屏幕坐标转换为空间坐标 ################
function TfrmMain.GetObjPos( ID:integer; p:TcgVector; x,y,z :single) :TcgVector;
  var px,py,pz :glDouble; pp:TcgVector;  // 对象坐标
begin
  result:=Obj[ID].p0;
  if(ID=1)and(Obj[ID].Kind=1)then exit; //原点不可拖动
    glGetIntegerv(GL_VIEWPORT, @viewP);
    glGetDoublev( GL_Modelview_Matrix, @modeM);
    glGetDoublev(GL_Projection_Matrix, @projM);
  gluUnProject( x,y,z, modeM,projM,viewP, @px,@py,@pz);
  if(ID=0)or(Obj[ID].Kind in[10,11,14])then //文字
    begin result:=cgVector(px,py,pz);  exit; end;
//  if keyZ then pp:= cgVector( obj[ID].p0.x, obj[ID].p0.y, pz)
//          else pp:= cgVector( px, py, obj[ID].p0.z);  exit;
  if(bFlash)then //闪烁标记
    begin result:=cgVector(px,py,pz);  exit; end;
  if(ry>315)or(ry<45)or(ry>135)and(ry<225)then begin//XOY平面
    if bC then pp:= cgVector( p.x, p.y, pz)
          else pp:= cgVector( px, py, p.z); end
  else begin
    if(rx>315)or(rx<45)or(rx>135)and(rx<225)then begin//XOZ平面
      if bC then pp:= cgVector( p.x, py, p.z)
            else pp:= cgVector( px, p.y,  pz); end
    else                                       //YOZ平面
      if bC then pp:= cgVector( px, p.y, p.z)
            else pp:= cgVector( p.x, py, pz);
    end;
  if bS then result:=cgVector(round(pp.x),round(pp.y),round(pp.z)) // 粘附网格
        else result:=pp;
end;
{======================= 移动构件 =======================}
procedure TfrmMain.MoveObj(ID, x,y,dx,dy :integer);
  var k1, xL,xH,vL,vH, t :single;
      a,b,i,j,N, minID, iID :integer;  bb,tempSeled :boolean;
      pa,pb,pc,pv, na,nb, pp, px,py,pz :TcgVector;    //直线两端点的屏幕坐标及屏幕距离
  const dm=0.001;  dc=0.01;
  function Footer2D( x0,y0:integer; p1,p2 :TcgVector):TcgVector; //点p0在直线p1-p2上的垂足
    var c1,c2, tx,ty,t :single;
    begin
    tx:=p2.x-p1.x;  ty:=p2.y-p1.y;
    if EP(tx)and EP(ty) then begin result:=cgVector(x0,y0,0); exit;end;
    if EP(tx) then begin result:=cgVector(p1.x, y0, 0); exit; end; //垂直直线
    if EP(ty) then begin result:=cgVector(x0, p1.y, 0); exit; end; //平行直线
    c1:=ty*p1.x-tx*p1.y;  c2:=tx*x0  +ty*y0;
    t:=sqr(tx)+sqr(ty);// Determinant2D(ty,tx,-tx,ty);
    result.x:=cgDeterminant2D(c1,-tx,c2,ty)/t;
    result.y:=cgDeterminant2D(ty, c1,tx,c2)/t;
    end;
  procedure DotAtFace(b,x,y:integer; var L,R:single); //曲面上的点
    var i,j,M,N:integer; t,k:single; pp:TcgVector;
  begin
    L:=0; R:=0;
    N:=high(FaceVct[b]); M:=high(FaceVct[b,0])-1;  if(N=0)or(M=0)then exit;
    pp:=getDotPos(FaceVct[b,0,0], true);
    t:=(pp.x-x)*(pp.x-x) + (pp.y-y)*(pp.y-y);
    for j:=0 to N do for i:=0 to M do begin
      pp:= getDotPos(FaceVct[b,j,i], false);
      k:=(pp.x-x)*(pp.x-x) + (pp.y-y)*(pp.y-y);
      if(k<t)then begin t:=k; L:=j/N; R:=i/M; end;
      end;
    end;
  function DotAtCurve(b,x,y:integer; var pp:TcgVector; bVec:boolean):single; //bVec仅计算距鼠标最近的点
    var aa,i,N:integer;   k1,vL,xL :single;  isFooter:boolean;
        pa,pb,pF :TcgVector;
  begin result:=0;
    vL:=1000;
    N:=high(LocaVct[b]);//曲线的点数
    if not(Obj[b].Kind in[1,13])and((N=0)or(LocaVct[b,N].w=0))then exit; //等分点和迭代点集 不计算点集间距
    pb:=getDotPos(LocaVct[b,0],true); //轨迹点之屏幕坐标
    if bVec then begin //仅计算距离鼠标最近的点
      for i:=0 to N do begin //计算距离鼠标最近的轨迹点
        pa:=pb;
        xL:=cgDistance2D(x,y, pa);//鼠标至轨迹点的距离
        if xL<vL then begin vL:=xL; aa:=i; end;
        if(i<N)then pb:=getDotPos(LocaVct[b,i+1],false);//轨迹点之屏幕坐标
        end;
      result:=aa; exit;
      end; //仅计算距离鼠标最近的点
    for i:=0 to N do begin //计算距离鼠标最近的轨迹点
      pa:=pb;
      xL:=cgDistance2D(x,y, pa);//鼠标至轨迹点的距离
      if xL<vL then begin vL:=xL; aa:=i; isFooter:=false; end;
      if(i<N)then begin
        pb:=getDotPos(LocaVct[b,i+1],false);//轨迹点之屏幕坐标
        pp:=Footer2D(x,y,pa,pb);//视觉上的垂点Z
        if cgDotInLine2D(pp,pa,pb)then begin //如果垂点位于直线内
          xL:=cgDistance2D(x,y, pp);//鼠标至垂点的距离
          if xL<vL then begin vL:=xL; aa:=i; pF:=pp; isFooter:=true; end;
          end;
        end;
      end;
    if isFooter then begin //如果鼠标距离垂足最近
      pa:=getDotPos(LocaVct[b,aa  ],false);
      pb:=getDotPos(LocaVct[b,aa+1],false);//两轨迹点之屏幕坐标
      if abs(pb.y-pa.y)>abs(pb.x-pa.x)
        then k1:=(pF.y-pa.y)/(pb.y-pa.y)
        else k1:=(pF.x-pa.x)/(pb.x-pa.x);
      pp:=cgVecAddMult(LocaVct[b,aa],cgVecSub(LocaVct[b,aa+1],LocaVct[b,aa]), k1);
      xL:=cgDistance(pp,LocaVct[b,aa]);
      end
    else
      pp:=LocaVct[b,aa];
    result:=(IIFf(isFooter,xL,0)+LocaVct[b,aa].w)/LocaVct[b,N].w;
    end;
  procedure MovePoint(ID, x,y, dx,dy :integer; var iID:integer); //移动一个点
    var i,b :integer;  tx,ty :single;  pp:TcgVector;
  begin
    with Obj[ID] do if(Kind=1)and not Lock then begin
    Edited:=(Mode=1)or(Mode=2);
    if(Mode=1)then begin //移动自由点
      if(iID>0)and(ID>10)then begin
        p0:= cgVecAdd( p0, cgVecSub(Obj[iID].p0, Obj[iID].p5) );
        exit;
        end;
      p5:=p0;
      p0:= GetObjPos(ID, p0, iL+x-DownX, iR+y-DownY, GetWinPos(ID,0).z);//将构件移动到新的位置
      if(iID=0)and not cgVecComp(p0,p5) then iID:=ID;
      end //1
    else if(Mode=2)then begin //移动约束点
      b:=Link[1];
      case Obj[b].Kind of
        2:begin //沿直线的点
          winPos[0]:= GetDotPos(Obj[b].p4,true);
          winPos[1]:= GetDotPos(Obj[b].p5,true);  //约束直线端点的屏幕坐标
          DotInPlane( ID,L,L, iL+x-DownX,iR+y-DownY,true);
          if D then L:=L*cgDistance(Obj[b].p4, Obj[b].p5);  //从定比转为定长  vL:=IIFf(D, Obj[b].L,1);
          if U<>bS then Limit(L, p2.x,p2.x, p2.z,p2.z); //U 限制
          end;//2
        3:begin  //沿圆周的点
          L:=DotAtCurve(b,iL+x-DownX,iR+y-DownY,pp,false); //pp 离鼠标最近的点
          case Obj[b].Mode of
            1:begin //点法圆上的点
              if(Obj[b].H=0)then begin //正圆上的点
                L:=L*towPi; if Deg then L:=L*oneArc;
                if bC or bS then begin //圆整到5度倍数
                  if Deg then k1:=5 else k1:=0.08727;//Pi/36;
                  L:=trunc(L/k1)*k1;
                  end;
                end
              else begin //椭圆上的点
                with Obj[10] do begin
                  Kind:=2; Mode:=1; p0:=Obj[b].p0; p1:=LocaVct[b,0];
                  Vec:=cgNormalVec(p0,p1);
                  end;
                pp:=Footer(pp,10,false);
                xL:=cgDistance(pp,Obj[b].p0);
                vL:=L; k1:=arcCos(xL/Obj[b].L);  L:=k1;
                if(vL>0.25)and(vL<=0.5)then L:=Pi-k1
                else if(vL>0.5)and(vL<=0.75)then L:=Pi+k1
                else if(vL>0.75)and(vL<1)then L:=towPi-k1;
                if Deg then L:=L*oneArc;
                end;
              end;
            2:begin //三点圆上的点
              L:=towPi-L*towPi; if Deg then L:=L*oneArc;
              if bC or bS then begin //圆整到5度倍数
                if Deg then k1:=5 else k1:=0.08727;//Pi/36;
                L:=trunc(L/k1)*k1;
                end;
              end;
            3,4:if D then L:=L*Obj[b].H*IIFf(Obj[b].D,1,Obj[b].L);
  //          8,9,10,11:L:=L*towPi;
            15:if(Obj[b].L<999)then L:=L*towPi; //反演圆上
            end;
          if(bS)and((Obj[b].Mode=1)and(Obj[b].H=0)or(Obj[b].Mode=2))then begin //粘附5度倍数
            K1:=Pi/36; if Deg then K1:=5;
            L:=trunc(L/k1)*k1;
            end;
          if Mask then begin //圆内部的点
            pa:=getDotPos(Obj[b].p0,false); //圆心的屏幕坐标
            pb:=getDotPos(pp,false); //圆周上距鼠标最近的点的屏幕坐标
            xL:=cgDistance2D(x,y, pa)/cgDistance2D(trunc(pa.x),trunc(pa.y), pb);//鼠标与两点的比例
            if U and(xL>1)then xL:=1; //限制在圆周内
            R:=Obj[b].L *xL;
            end
          else //圆周上的点
            if(U<>bS)and((L<p2.x)or(L>p2.z))then begin
              t:=(towPi-p2.z+p2.x)/2;
              if(p2.x<t)then L:=IIFf((L>p2.z)and(L<p2.z+t), p2.z, p2.x)
                        else L:=IIFf((L<p2.x)and(L>p2.x-t), p2.x, p2.z);
              end;
          end;//3
        4:begin  //平面上的点。必须先在MouseDown过程里获得平面三个顶点的屏幕坐标
          for i:= 0 to 2 do winPos[i]:= GetWinPos(b,i); //平面的三个顶点屏幕坐标
          if Mask then begin //边界上的点
            k1:=DotAtCurve(b,iL+x-DownX,iR+y-DownY,pp,false);  if(k1<=1)then L:=k1;
            if U then Limit( L, p2.x,p2.x, p2.z,p2.z);
            end
          else begin //平面上的点
            DotInPlane( ID,xL,xH,iL+x-DownX,iR+y-DownY,false);
            px:=LocaVct[b,0]; py:=LocaVct[b,1]; pz:=LocaVct[b,2]; pc:=Obj[b].p5;
            vH:=xL*pc.w; //pc.w: px至垂足的距离
            vL:=xH* cgDistance(py,pz);
            pa:=cgVecSub(pc, py);  pb:=cgVecSub(pz,py);
            k1:=Obj[b].p1.w;//px的垂足至py的距离
            if cgVecSgn(pa,pb)then vL:=vL+ xL*k1 else vL:=vL- xL*k1;
            if U then begin //限制在平面的可视范围以内
              na:=cgNormalVec(pz, py); //后两点形成的直线
              nb:=cgNormalVec(px, pc); //第一点至直线的垂线向量
              pc:=cgVecAddMult(py, na, vL);
              pp:=cgVecAddMult(pc, nb, vH);
              N:=trunc(Obj[b].W); if(N=99)then N:=4; if(N>100)then N:=N-100;//W>100 正n边形
              bb:=cgDotInPolygon(pp, LocaVct[b], N);
              end;
            if not U or bb then begin
              L:=vL; R:=vH;
              end //平面范围内
            else begin //限制情况下鼠标位于平面范围之外
              DotAtCurve(b,iL+x-DownX,iR+y-DownY, pp,false);//pp是边界上的点
              cgFooterAtLine(pp, pz,py, pa, false);//pa是垂点
              L:=cgDistance(pa,py);
              R:=cgDistance(pp,pa);
              end;
            end;
          end;//4
        5,15,16,17,19:begin //轨迹线上的点
          k1:=DotAtCurve(b,iL+x-DownX,iR+y-DownY,pp,false);  if(k1<=1)then L:=k1;
          if U then Limit( L, p2.x,p2.x, p2.z,p2.z);
          end;
        7,9:if Mask then begin //曲面上的点 Mask边缘
            k1:=DotAtCurve(b,iL+x-DownX,iR+y-DownY,pp,false);  if(k1<=1)then L:=k1;
            end
          else begin
            DotAtFace(b, x,y, L,R);
            end;
        6:case Obj[b].Mode of // 球面或圆台面上的点
          1,6,15:begin // 球面上的点
            R:=R-dx*dc; Limit(R,-halfPi,-halfPi, halfPi,halfPi); //经度
            L:=L-dy*dc; Limit(L, 0,towPi, towPi,0);//纬度
            end;
          2:begin    // 圆台面上的点
            R:=R-dx*dc; Limit(R, 0,0, 1,1);        //高度
            L:=L-dy*dc; Limit(L, 0,towPi, towPi,0);//纬度
            end;
          end; //6
        1:if(Obj[b].Mode=6)then L:= DotAtCurve(b,iL+x-DownX,iR+y-DownY,pp,true); //等分点上的点
        13:L:= DotAtCurve(b,iL+x-DownX,iR+y-DownY,pp,true); //迭代像上的点
        end;//case Obj[b].Kind
      end;//if(Mode=2)then ...
    end;//with Obj[ID]...
    end;//MovePoint
begin
  y:= ClientHeight-y;
  if bR and(ID in[2..4])then exit;
  if bR then with Obj[ID] do begin //按右键拖动标签
    if not bC then begin//未按下[Ctrl]键
      if(Kind=11)and(Mode=2)and(butID.Visible)then begin //
        x0:=trunc(p0.x);  p0.x:=x-p3.x;
        y0:=trunc(p0.y);  p0.y:=Height-y-p3.y-27-(titleHeight-29);
        TagP.x:=TagP.x-(p0.x-x0); //滑杆相对移动
        TagP.y:=TagP.y-(p0.y-y0);
        TextAndImage(ID,false,true,false,false);
        end
      else begin
        TagP.x:=TagP.x-dy;  TagP.y:=TagP.y-dx;
        end;
      end
    else case Kind of    //按下[Ctrl]键
      2:begin //直线的标签
        winPos[0]:= getDotPos(p0,true);   winPos[1]:= getDotPos(p1,true);
        DotInPlane( ID,TagP.z,TagP.z, x,y,true);
        Limit(TagP.z, 0,0, 1,1);
        end;
      3:begin //圆周的标签
        setPlane(10, p0, ID, L);  //虚拟一个平面
        for i:= 0 to 2 do winPos[i]:= GetWinPos(10,i); //平面的三个顶点屏幕坐标
        DotInPlane( ID,xL,xL, x,y,true); //xL 圆周角
        if Mode in[3,4] then begin
          vL:=R;  //圆弧基点的角度
          if U and(Mode=3)
            then begin TagP.z:=vL-xL; if xL>vL then TagP.z:=towPi+TagP.z; end
            else begin TagP.z:=xL-vL; if xL<vL then TagP.z:=towPi+TagP.z; end;
          k1:=H/IIFf(D, L, 1);
          TagP.z:=TagP.z/k1;
          if(TagP.z>(1+towPi/k1)/2)then TagP.z:=0;
          if(TagP.z>1)then TagP.z:=1;
          end
         else TagP.z:=xL;
        end;
      4:begin //平面的标签
        for i:= 0 to 2 do winPos[i]:= GetWinPos(ID,i);
        DotInPlane( ID,xL,xH,x,y,true);
        if(xL<=1)and(xL>=0)then TagP.w:=xL* p5.w; //pc.w: px至垂足的距离
        if(xH<=1)and(xH>=0)then TagP.z:=-xH* cgDistance(p1,p2);
        end;
      5,15,16,17,19:begin //轨迹线的标签
        TagP.z:=DotAtCurve(ID,x,y,pp,false);   //TagP.z:=TagP.z-(dx+dy)*dc; Limit(TagP.z, 0,0, 1,1);
        N:=high(LocaVct[ID]);
        p0:= LocaVct[ID][trunc(N*TagP.z)];
        end;
      end;
    exit;
    end; // if bR
  if(Obj[ID].Kind<>11)and(Obj[ID].Mode=13)then ID:=Obj[ID].Link[0]; //拖动棱边或顶点相当于拖动多面体或多边形
  minID:=ID;
  with Obj[ID] do begin
  if Lock then exit;
  if not bMultiSel and not bS and(SelRec[0]>1)then begin //取消所有选择
    ClearSelRec(ID); //清除选择队列
    MarkObj:=ObjSelected(ID, bS,bC,bL,bR); //重新选择ID
    end;
  a:=Link[0];   b:=Link[1];   iID:=0;
  if not((Kind=2)and(Mode=4)and(Obj[b].Kind=3))and Lock then exit; //锁定
  if(Mode<7)or(Kind=11)or(Kind=2)and(Mode=19)then
    case Kind of
    1:if(Mode<7)then begin
      if bMultiSel then begin
        for i:=11 to ObjCount do with Obj[i]do //  and(i<>ID)
        if(delID=0)and(Kind=1)and Hot and not Lock then begin //自由点 未锁定
          if i<minID then minID:=i;
          MovePoint(i, x,y,dx,dy, iID);
          end;
        end
      else if(Mode=2)and(Obj[b].Kind=1)and(Obj[b].Mode<>6)then begin //拖动约束点
        if b<minID then minID:=b;
        MovePoint(b, x,y,dx,dy, iID);
        end
      else if(Mode=5)and not Lock then begin //中点
        MovePoint(a, x,y,dx,dy, iID);  MovePoint(b, x,y,dx,dy, iID);
        end
      else
        MovePoint(ID, x,y,dx,dy, iID);
      end;//1
    2:begin //直线
      if(Mode<7)or(Mode in[12,19])then begin
        if not(Obj[a].Lock or bS)and((Mode=2)and not bC and(trunc(R)<2)
          or(Mode<>2)and(Obj[a].Mode in[1,2,12]))then begin //基点
          if(Obj[a].Mode=12)then begin //线段起点为向量变换点
            MovePoint(Obj[a].Link[0], x,y,dx,dy, iID);
            minID:=Obj[a].Link[0];
            end
          else begin
            MovePoint(a, x,y,dx,dy, iID);
            p0:=Obj[a].p0;  minID:=a;
            end;
          end;
        if not(Obj[b].Lock or bS)and(Mode in[1,4,5])and(Obj[b].Mode in[1,2,12])then begin //两点式直线之第二点
          if(Obj[b].Mode=12)then begin //线段起点为向量变换点
            MovePoint(Obj[b].Link[0], x,y,dx,dy, iID);
            minID:=Obj[b].Link[0];
            end
          else begin
            MovePoint(b, x,y,dx,dy, iID);
            p1:=Obj[b].p0;  if(b<minID)then minID:=b;
            end;
          end;
        if(bS<>bC)and(Mode=2)and(ID>10)and(trunc(R)=1)then begin //向量偏移量
          if bS then begin p2.x:= p2.x-dy/20;  p2.y:= p2.y-dx/20;  end;
          if bC then p2.z:=p2.z-dx/20;
          end
        else if((not bS and bC)or(bS and bC))and(Mode=2)and(ID>10)and(trunc(R)=0)then begin   //角向量 调节方向角
          K1:=dc; if Deg then K1:=1;    //Deg 角度制
          pBL.z:=pBL.z-dx*K1;   pBL.x:=pBL.x+dy*K1;
          p2:=pBL;
          if(bS and bC)then begin //圆整到5度倍数
            K1:=Pi/36; if Deg then K1:=5;
            p2.z:=trunc(p2.z/k1)*k1;
            p2.x:=trunc(p2.x/k1)*k1;
            end;
          end //改变与X轴和Y轴的夹角
        else if not bS and bC and(ID<5)then begin //坐标轴负轴长度
          t:= L;
          DotInPlane( ID,xL,xL, x,y, false); //鼠标移动后的位置
          L:=(1-xL+p3.x)*p3.z;
          R:=R-(t-L); if(R<0)then begin R:=0; L:=t; end; //
          end
        else if bS and not bC and(not((Mode in[1,4,19])and not(D or F))or(Mode=5))then begin //
          DotInPlane( ID,xL,xL, x,y, false); //鼠标移动后的位置
           L:=(1+xL-p3.x)*p3.z; //p3.x p3.z 在MouseDown中计算
          if(ID<5)and(L<(R+0.5))then L:=R+0.5;  //坐标轴不短于负轴长
          end; //case
        end;
      if L<=0 then L:=0.00001;
      end;
    3:if(not bS)then begin
        if(Mode<5)then
          for i:=0 to 2 do begin
            a:=Link[i];
            if(a>10)and(Obj[a].Mode<3)and(not Obj[a].Lock)then begin //基点
              MovePoint(a, x,y,dx,dy, iID);
              p0:=Obj[a].p0;  if(a<minID)then minID:=a;
              end;
            end;
        end
      else if(Mode in[1,3,9,10,15])then begin //点法圆 点法弧
        setPlane(10, p0, ID, L);  //虚拟一个平面
        for i:= 0 to 2 do winPos[i]:= GetWinPos(10,i); //平面的三个顶点屏幕坐标
        case mode of
          1:if bC then begin H:=H-(dx*dc+dy*dm); Limit(H, 0,0, 1,1); end //椭圆度
            else DotInPlane( ID,L,L,x,y,false); //圆 改变半径
          3:begin  //点法弧 改变弧长
            DotInPlane( ID,xL,xL,x,y,false); //圆弧 改变弧长
            if U then begin H:=R-xL; if xL>R then H:=towPi+H; end
                 else begin H:=xL-R; if xL<R then H:=towPi+H; end;
            if D then H:=H*L;
            end; //p3.z是拖动前的弧长(弧度), 在MouseDown中赋值
          15:begin R:=R-dy*dc; Limit(R, 0,0, 10,10); end; //反演圆
          end; //case
        end;
    4:begin //拖动平面
      if not bS then begin
        if(Mode=6)then N:=trunc(W)-1 else N:=2;
        if(N=98)then N:=3;  if(N>100)then N:=N-100; //矩形W=99 正n多边形W>100
        if(Mode<7)then
          for i:=0 to N do begin
            a:=Link[i]; if(i=0)then j:=a;
            if(a>10)and(Obj[a].Kind=1)and(Obj[a].Mode<3)and(not Obj[a].Lock)then begin//基点
              MovePoint(a, x,y,dx,dy, iID);
              p0:=Obj[a].p0;  if(a<minID)then minID:=a;
              end;
          end;
        end
      else begin
        case Mode of //平面
          1,2:begin R:=R-(dx+dy)/200; if R<0.1 then R:=0.1; end;
          3,4,5:begin L:=L-dy/30; H:=H-dx/30; end; //平行面 垂面
          6:begin L:=L-dy/30; if trunc(W)=99 then H:=H-dx/30; end; //正多边形
          end; //case Mode
        end;
      end;
    5:if(Obj[a].Mode=2)then MovePoint( a, x,y, dx,dy, iID);
    6:if not bS then begin //直接拖动
        if(Mode=5)then N:=trunc(W)-1 else N:=9;
        if(Mode<7)then
          for i:=0 to N do begin
            a:=Link[i];
            if(a>10)and(Obj[a].Kind=1)and(Obj[a].Mode<3)and(not Obj[a].Lock)then begin//基点
              MovePoint(a, x,y,dx,dy, iID);
              p0:=Obj[a].p0;  if(a<minID)then minID:=a;
              end;
            end;
        end
      else begin //Shift拖动
        case Mode of  //标准实体
        1,6:begin L:=L-(dx+dy)*dc; if L<0 then L:=0; end; //球体
        3:begin //正多面体
          if(S=6)then begin if bC then H:=H-dx*dc else W:=W-dx*dc; end; //S=6长方体
          if not bC then begin L:=L-(dy)*dc; if L<0 then L:=0; end;
          end;
        2,4:begin
          if bC then begin W:=W-(dx+dy)*dc; Limit(W,0,0,99,99); end   //锥体
                else begin L:=L-dy*dc;  H:=H-dx*dc; if L<0 then L:=0; end;
          end;
    //    6:begin H:=H-dx*dc; W:=W-dy*dc; Limit(W,0,0,1,1); end;
        15:begin R:=R-dy*dc; Limit(R, 0,0, 10,10); end; //反演球
        end;
      end;
    10:begin //文字 图像
      if bMultiSel then //同时移动框选对象
        for i:=11 to ObjCount do with Obj[i]do
          if(i<>ID)and(delID=0)and(Kind in[10,11,14])and Hot and not Lock then begin
          p0.x:=p0.x-Obj[ID].p0.x + x-Obj[ID].p3.x;
          p0.y:=p0.y-Obj[ID].p0.y + Height-y-Obj[ID].p3.y-27-(titleHeight-29);
          if(Kind=14)then begin //按钮
            butID.left:=trunc(p0.x);
            butID.Top:=trunc(Obj[i].p0.y-Obj[i].H-27-(titleHeight-29));
            end;
          TextAndImage(i,false,true,(Mode=2)and bS, false);
          end;
      a:=Link[10];//绑定构件
      if not(bC or bS)then begin
        if(a=0)then begin p0.x:=x-p3.x; p0.y:=Height-y-p3.y-27-(titleHeight-29); end
               else begin p2.y:=x-p3.x-Obj[a].TagScr.x; p2.w:=y+p3.y-Obj[a].TagScr.y+titleHeight; end;
        if(p0.x<20)then p0.x:=20;   if(p0.x> Width-20)then p0.x:= Width-20;
        if(p0.y<70)then p0.y:=70;   if(p0.y>Height-10)then p0.y:=Height-10;
        end;
      if(Mode=2)and bS then L:=L-(dx+dy)*dm; //图像比例
      TextAndImage(ID,false,true,(Mode=2)and bS, false);
      end;
    11:begin //参数 计算
      if bMultiSel and not bR then begin //同时移动框选对象
        for i:=11 to ObjCount do with Obj[i]do
          if(i<>ID)and(delID=0)and(Kind in[10,11,14])and Hot and not Lock then begin
          p0.x:=p0.x-Obj[ID].p0.x + x-Obj[ID].p3.x;
          p0.y:=p0.y-Obj[ID].p0.y + Height-y-Obj[ID].p3.y-27-(titleHeight-29);
          if(Kind=14)then begin //按钮
            butID.left:=trunc(p0.x);
            butID.Top:=trunc(Obj[i].p0.y-Obj[i].H-27-(titleHeight-29));
            end;
          if(Mode=2)and(butID.Visible)then begin
            butID.Left:=trunc(p0.x +TagP.X); //
            butID.Top :=trunc(p0.y +TagP.Y) -butID.height-TitleHeight+12; //-26;//
            butID.Refresh;
            end;
          TextAndImage(i,false,true,(Mode=2)and bS, false);
          end;
        end;
      a:=Link[10]; //绑定构件
      if(a<11)then begin p0.x:=x-p3.x; p0.y:=Height-y-p3.y-27-(titleHeight-29); end
              else begin p2.y:=x-p3.x-Obj[a].TagScr.x; p2.w:=y+p3.y-Obj[a].TagScr.y+titleHeight; end;
      if(Mode=2)and(butID.Visible)and bL then begin // setBarTrack(MarkObj);  //参数轴
  //      butID.Visible:=false;   butID.Top:=-10; //拖动参数时，隐藏滑块
        butID.Left:=trunc(p0.x +TagP.X); //
        butID.Top :=trunc(p0.y +TagP.Y) -(Height-ClientHeight); //-26;//
        butID.Refresh;
        end;
      TextAndImage(ID,false,true,false, false);
      end;
    16:begin //函数曲线
      if bS and not bC then p1.y:=p1.y-(dx+dy)/10; //右域值
      if bC and not bS then p1.x:=p1.x-(dx+dy)/10; //左域值
      end;
    17:if(Mode=1)then begin //路径
        N:=0; for i:=0 to LinkTime do if(Link[i] in[1..ID-1])then inc(N);
        for i:=0 to N do begin
          a:=Link[i];
          if(a>10)and(Obj[a].Kind=1)and(Obj[a].Mode<3)and not(Obj[a].Lock)then begin//基点
            MovePoint(a, x,y,dx,dy, iID);
            p0:=Obj[a].p0;  if(a<minID)then minID:=a;
            end;
          end;
        end
      else begin  //三视图
        R:=R-(dx+dy)*0.02;  Limit(R, -1,-1, 1,1);
        end;
    18:if Mode=1 then begin //线标记
        if bS then begin
          if bC then Thick:=Thick-(dx+dy)*0.02 else R:=R-(dx+dy)*0.02; //Thick锥度 R半径
          end
        else case Obj[b].Kind of
          2:begin //直线标注
            DotInPlane( ID,L,L, x,y,true);    Limit( L, 0,0, 1,1); //将位置限制在直线内
            end;
          3,5,15,16,17,19:begin //曲线标注
            k1:=DotAtCurve(b,x,y,pp,false);   if(k1<=1)then L:=k1;
            end;
          end;//case
        end
      else begin //角标记
        if bS and not bC then begin R:=R-(dx+dy)*0.02; if(R<0.1)then R:=0.1; end; //半径
        if bC and not bS then DotInPlane( ID,TagP.z,TagP.z, x,y,true); //位置
        end;
    19:begin //圆锥曲面
      if bS and (R>=0) then begin
        L:=L-(dx+dy)/10; if L<1 then L:=1; //抛物线/双曲线 改变长度
        end
      else
        for i:=0 to 2 do begin
          a:=Link[i];
          if(a>10)and(Obj[a].Kind=1)and(Obj[a].Mode<3)and(not Obj[a].Lock)then begin//基点
            MovePoint(a, x,y,dx,dy, iID);
            p0:=Obj[a].p0;  if(a<minID)then minID:=a;
            end;
          end;
      end;
    end //case Kind
  else
    case Mode of //变换
      9:begin  //旋转
        if(Link[3]>10)then exit;
        r0:=r0-dy*IIFf( Deg,1,dc);
        R:=r0;
        if bC or bS then begin //圆整到5度倍数
          if Deg then K1:=5 else K1:=0.08727; //Pi/36=0.08727;
          R:=trunc(r0/k1)*k1;
          end;
        end;
      7,10,15:begin //7投影 10缩放 15反演
        if(Link[3]>10)then exit;
        r0:=r0-dy*dc;
        R:=r0;
        if(Mode in[7,10])and not(bC or bS)then Limit(R, 0,0, 1,1);
        if(Mode in[7,10])and bC then R:=trunc(r0*10)*0.1; //粘附 0.1
        if(Mode=7)and(Kind=4)then Limit(R, 0,0, 1,1); //平面的投影
        end;
     11:begin //平移
        pp:= GetObjPos(ID, p0, iL+x-DownX, iR+y-DownY, GetWinPos(ID,0).z);//iL,iR在MouseDown中赋值
        if(Kind=7)then itos(0);  //见鬼，若无这句，平移的曲面一拖就消失
        if(Kind=4)and(Mode=11)then p0:=LocaVct[ID,0];
        pTR:=cgVecAdd(pTR, cgVecSub( pp, p0));
        if bS then begin
          pTR.x:=trunc(pTR.x);  pTR.y:=trunc(pTR.y);  pTR.z:=trunc(pTR.z);
          end;
        if U then begin //矢量平移 将直角坐标pTR转换为球坐标pBL
          cgXYZtoAngle(pTR.X,pTR.Y,pTR.Z, pBL.y,pBL.z,pBL.x, true);
          end;
        end;
     12:begin  //向量变换
        if bS then
          R:=R-(dx+dy)*dc
        else begin
          i:=IIFi(Obj[a].Kind=1, 0, 2);
          if not Obj[Link[i]].Lock then MovePoint(Link[i], x,y,dx,dy, iID);
          end;
        end;
    end; //case Mode
  if butProp.Down then begin //更新属性框
    ShowProp( MarkObj,true);  pnlProp.Refresh;
    end;
  if(Kind in[1..9,15..19])or(Mode>6)and(Kind<>11)then begin //
    if(ID<11)then AxisList; //
    if not(bC or bS or(Kind=17)and(Mode=2))then //
      for i:=0 to 47 do begin //
        a:=Link[i];
        if(a>10)and(a<minID)and(not Obj[a].Lock)then minID:=a;
        end;
    ReRelate( minID,ObjCount,false,false,false );  // 重建关联构件
    end;
  SetProjection( true,false,12);
  end; //with Obj[ Obj]
end;
//====================== 动态数组内存分配 ========================
procedure TfrmMain.setMem( n :integer; bb:boolean); //bb:强制分配
  var n0 :integer;
begin
  if not bb then begin
    n0:=High(Obj);  if n0<0 then n0:=0;
    if n<n0 then exit else inc(n ,32);
    end;

  setLength( LocaVct, n+1); //曲线顶点
  setLength( FaceVct, n+1); //曲面顶点
  setLength( LocaColor,n+1);
  setLength( FaceColor,n+1);
  setLength( aLink,   n+1); //相贯线相邻线段的链接状态
  if n=-1 then exit;
  setLength( Obj,     n+1); //caption :=caption+' # '+itos(High(Obj));
end;
{======================= 设置雾效 =======================}
procedure TfrmMain.setFog;
begin
  fogL:= Deep*40/(Pers+2); //雾气起点
  setEnable( cheFog.Checked, GL_FOG);
  glFogfv(GL_FOG_COLOR, @BackColor);
  glFogi (GL_FOG_MODE, GL_LINEAR);
  glHint (GL_FOG_HINT, GL_DONT_CARE);
  glFogf (GL_FOG_START, fogL);
  glFogf (GL_FOG_END, fogL+1.5*axis);
end;
{======================= 初始化灯光和材质 =======================}
procedure TfrmMain.InitLights;
  const Ambient0 :gl4f=( 0.2, 0.2, 0.2, 0.0 ); //环境光色
        Diffuse0 :gl4f=( 0.5, 0.5, 0.5, 0.0 ); //散射光色
        Specular0:gl4f=( 0.55, 0.55, 0.55, 0.0 ); //镜面光色
        Position0:gl4f=( 8.0, 4.0, 4.0, 0.0 ); //光源位置
        Ambient1 :gl4f=( 0.2, 0.2, 0.2, 0.0 );
        Diffuse1 :gl4f=( 0.5, 0.5, 0.5, 0.0 );
        Specular1:gl4f=( 0.3, 0.3, 0.3, 0.0 );
        Position1:gl4f=(-8.0,-4.0,-4.0, 0.0 );
       mAmbient0 :gl4f=( 1.0, 1.0, 1.0, 0.0 ); //材料环境色
       mDiffuse0 :gl4f=( 1.0, 1.0, 1.0, 0.0 ); //材料散射色
       mSpecular0:gl4f=( 0.55, 0.55, 0.55, 0.0 ); //材料镜面色
       mShinine0 :single= 30.0;                //此值越大，反光面越小
       mAmbient1 :gl4f=( 1.0, 1.0, 1.0, 0.0 );
       mDiffuse1 :gl4f=( 1.0, 1.0, 1.0, 0.0 );
       mSpecular1:gl4f=( 0.6, 0.6, 0.6, 0.0 );
       mShinine1 :single= 30.0;
  var bufs, samples :integer;
begin
{
  glutInitDisplayMode( GLUT_MULTISAMPLE);  //多重采样 glut单元
  glGetIntegerv(GL_SAMPLE_BUFFERS, &bufs);
  glGetIntegerv(GL_SAMPLES, &samples);
  glEnable(GL_MULTISAMPLE);
}
  if(Height=0)then Height:=1; // 防止被零除
  glClearColor(1,1,1,1); //在MainDraw过程中将重新定义环境背景

  glHint( GL_POINT_SMOOTH_HINT, GL_NICEST);
  glHint(  GL_LINE_SMOOTH_HINT, GL_NICEST);
//  glHint(GL_POLYGON_SMOOTH_HINT, GL_NICEST);
  glBlendFunc( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); //控制混合方式
  glEnable( GL_BLEND);        //打开混合(透明)
  glEnable( GL_LINE_SMOOTH);  //直线反走样模式使能
  glEnable( GL_POINT_SMOOTH); //点反走样模式使能
//  glEnable( GL_POLYGON_SMOOTH); //直线反走样模式使能

  glEnable( GL_DEPTH_TEST);   //激活深度缓存  glEnable(GL_CULL_FACE);
  glEnable( GL_NORMALIZE);    //法线向量归一化 glDepthFunc( GL_LESS);
    glShadeModel(GL_smooth);
    glLightfv(GL_LIGHT0, GL_AMBIENT, @ambient0);
    glLightfv(GL_LIGHT0, GL_DiFFUSE, @diffuse0);
    glLightfv(GL_LIGHT0, GL_POSITION, @position0);
    glLightfv(GL_LIGHT0, GL_SPECULAR, @specular0);

    glLightfv(GL_LIGHT1, GL_POSITION, @position1);
    glLightfv(GL_LIGHT1, GL_AMBIENT, @ambient1);
    glLightfv(GL_LIGHT1, GL_DiFFUSE, @diffuse1);
    glLightfv(GL_LIGHT1, GL_SPECULAR, @specular1);

    glMaterialfv(GL_FRONT, GL_AMBIENT, @mAmbient0);
    glMaterialfv(GL_FRONT, GL_DIFFUSE, @mDiffuse0);
    glMaterialfv(GL_FRONT, GL_SPECULAR, @mSpecular0);
    glMaterialfv(GL_FRONT, GL_SHININESS, @mShinine0);
    glMaterialfv(GL_BACK, GL_AMBIENT, @mAmbient1);
    glMaterialfv(GL_BACK, GL_DIFFUSE, @mDiffuse1);
    glMaterialfv(GL_BACK, GL_SPECULAR, @mSpecular1);
    glMaterialfv(GL_BACK, GL_SHININESS, @mShinine1);
    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);   glEnable(GL_LIGHT1);
    glEnable(GL_COLOR_MATERIAL);
    glColorMaterial( GL_FRONT_AND_BACK, GL_DIFFUSE and GL_AMBIENT); //
end;
{================ Resize and Refresh window =================}
procedure TfrmMain.SetProjection( Draw,isFlash:boolean; func:integer);
begin
  glMatrixMode( GL_PROJECTION);
  glLoadIdentity;
  gluPerspective( Pers+2, rView, 0.1, 4000); // rView:= Width/Height;
  glViewport( 0, 0, Width, Height);
  glMatrixMode( GL_MODELVIEW);
  InvalidateRect( Handle, nil, False);
  if Draw then MainDraw( GL_RENDER, isFlash, 'd');
end;
procedure TfrmMain.SetDCPixelFormat;
var
  pfd: TPixelFormatDescriptor;
  nPixelFormat: Integer;
begin
  DC := GetDC(Handle);
  FillChar(pfd, SizeOf(pfd), 0);
  with pfd do begin
    nSize     := sizeof(pfd);
    nVersion  := 1;
    dwFlags   := PFD_DRAW_TO_WINDOW or PFD_SUPPORT_OPENGL or PFD_DOUBLEBUFFER;
    iPixelType:= PFD_TYPE_RGBA;
    cColorBits:= 16;
    cDepthBits:= 16;
    cStencilBits := 1;                     // Stencil buffer, too.
    cAccumBits:= 64;
    iLayerType:= PFD_MAIN_PLANE;
  end;
  nPixelFormat := ChoosePixelFormat(DC, @pfd);
  SetPixelFormat(DC, nPixelFormat, @pfd);
  rc := wglCreateContext(DC);
  wglMakeCurrent(DC, rc);
end;
procedure TfrmMain.set2Dstyle; // 设置2D状态
begin
  with Obj[1]do begin
    is2D:=not(menZ.Checked and menLock.Checked);  //是否2D状态
    if is2D then begin rX:=0; rY:=0; rZ:=0; end //z视角
            else begin rX:=p3.z; rY:=p3.w; rZ:=p3.r; end;
    rX2:=rX;  rY2:=rY;  rZ2:=rZ;
    Mask:=is2D;
    if is2D then info[0][18]:='1' else info[0][18]:='0';
    end;
  cheAxisZ.Checked:=not is2D; //隐藏Z轴
  menZ.Checked:=is2D;  menLock.Checked:=is2D;  butLock.Down:=is2D; // 锁定Z视角
  AxisList;
  SetProjection(false,false,9);
end;

procedure TfrmMain.WhenHint(Sender: TObject);
begin
  stbBar.caption :=Application.Hint;
end;
{==================== Start work application ====================}
procedure TfrmMain.FormCreate(Sender: TObject);
  var i,j :integer; st,t,tmp, vFile, vFileVar :string;
      tempPath: Array[1..127]of Char;
      isEnd,isFromFile :boolean;
      G :TextFile; //文本文件句柄
      lab :array[1..22]of TLabel;
      itmColor :TMenuItem;
      popChar :TPopupMenu;
      itmChar :array[0..23]of TMenuItem;
  const txtChar :WideString='∠°π△⊙∥～≈≡≠≥≤÷－±·∞∫∑→∵∴℃‰αβγΔδεθφ';
  function stf( s:string; p,l:integer):single;
    var st:string;
    begin st:=trim(copy(s,p,l)); if st='' then result:=0 else result:= StrToFloat(st); end;
  function sti( s:string; p,l:integer):integer;
    var st:string;
    begin st:=trim(copy(s,p,l)); if st='' then result:=0 else result:= StrToInt(st); end;
begin
  labHint.Top:=-20;   edtTemp.Top:=-20;// edtTemp的唯一用处是接受focus
  vFile:= Trim( ParamStr(1) ); //如果用"命令行+文件名"的形式或从资源管理器中直接打开“.sgf”文件
  i:=Pos('||',vFile); //"||"后跟参数串
  if(i>0)then begin
    j:=Length(vFile);
    vFileVar:= Copy(vFile, i+2, j-i); //画板文件名
    vFile:= Copy(vFile, 1, i-1);      //参数字串
    end;
  if(vFileVar>'')then begin //用于控件时隐藏窗口边框
    if(Pos('c',vFileVar)>0)then isUseToControler:=true;       //用于控件，隐藏任务栏图标，禁止全屏
    if(Pos('r',vFileVar)>0)then isReadOnly:=true;             //只读，不允许保存文件
    if(Pos('f',vFileVar)>0)then frmMain.BorderStyle:=bsNone;  //隐藏边框
    end;
  st:= format('%d.%d' ,[Win32MajorVersion, Win32MinorVersion]); //Syetem Verson
  isWin7or8:=st>='6.1';
//  menWin7.Visible:=isWin7;
//  if isWin7 then //取消Win7中的Aero效果
//  WinExec('command.com /C net stop uxsms',SW_Hide);
  for I := 0 to ComponentCount - 1 do //设置菜单项的热键下划线
    if Components[I] is TMenuItem then
      TMenuItem(Components[I]).OnAdvancedDrawItem := MenuItemAdvancedDrawItem
    else if Components[I] is TMenu then
      TMenu(Components[I]).OwnerDraw := True;
  DragAcceptFiles(Handle,True); //允许图片拖入窗体
  frmMain.Icon.Handle := LoadIcon(hInstance, 'HPOINT');
  Application.OnHint:=WhenHint; //捕捉鼠标信息并显示于状态条
  SetDCPixelFormat;
//  Quadric:= gluNewQuadric;  gluQuadricDrawStyle(Quadric, GLU_FILL);
  InitLights; //材质和光线 创建字体
  SelectObject(DC, Font.Handle); //Font当前窗口的字体
  fontBase := 700; // 为每个字符制作显示列表
  wglUseFontBitmaps (DC, 0, 255, fontBase);
  glListBase(fontBase); // 设置字符串显示列表的基值
//属性控件数组
  pnlArray[ 0]:=pnl0;   pnlArray[ 1]:=pnl1;   pnlArray[ 2]:=pnl2;
  pnlArray[ 3]:=pnl3;   pnlArray[ 4]:=pnl4;   pnlArray[ 5]:=pnl5;
  pnlArray[ 6]:=pnl6;   pnlArray[ 7]:=pnl7;   pnlArray[ 8]:=pnl8;
  pnlArray[ 9]:=pnl9;   pnlArray[10]:=pnl20;  pnlArray[11]:=pnl21;
  pnlArray[12]:=pnl19;  pnlArray[13]:=pnl16;  pnlArray[14]:=pnl10;
  pnlArray[15]:=pnl11;  pnlArray[16]:=pnl12;  pnlArray[17]:=pnl13;
  pnlArray[18]:=pnl14;  pnlArray[19]:=pnl15;  pnlArray[20]:=pnl23;
  pnlArray[21]:=pnl26;  pnlArray[22]:=pnl25;  pnlArray[23]:=pnl00;
  pnlArray[24]:=pnl47;  pnlArray[25]:=pnl27;  pnlArray[26]:=pnl28;
  pnlArray[27]:=pnl22;  pnlArray[28]:=pnl24;  pnlArray[29]:=pnl29;
  pnlArray[30]:=pnl48;  pnlArray[31]:=pnl18;

  selFunc[0]:=selFunc0; selFunc[1]:=selFunc1; selFunc[2]:=selFunc2;
  FuncCtrl[0]:=edtX;    FuncCtrl[1]:=edtY;    FuncCtrl[2]:=edtZ;
  HotTool:=butArrow;    HotMenu:=menBar57;      MenuCount:=7;
  setMem( maxObj, false); //动态数组分配内存
  for i:= 0 to 8 do for j:=0 to 21 do begin //迭代窗口中的映射控件
    txtArray[i,j]:=TEdit.Create(Self);
    with txtArray[i,j] do begin
      Parent:=pnlIterate;   Tag:=i*21+j;  Text:='?';  ReadOnly:=i<8; //不接受键盘，必须从右键菜单选择对象或从屏幕点击对象
      Left:=j*36+IIFi(j=0, 4,18);  Top:= i*22+18; Width:=30;  Height:=18;
      Color:=clBtnFace;   Ctl3D:=false;   imeMode:=imSAlpha;  //imSAlpha 半角状态 即自动切换至英文
      Font.Name:='Aril';  Font.Size:=9;   Font.Style:=[fsBold];//
      PopupMenu:= popObj;
      OnEnter:=frmMain.txtDepthEnter;
      OnMouseDown:=frmMain.txtDepth0MouseDown;
      SetWindowLong(Handle,GWL_STYLE,GetWindowLong(Handle,GWL_STYLE) or Es_Center); //内容居中
      end;
    end;
  for i:= 1 to 19 do begin //迭代窗口中的映像序号
    lab[i]:=TLabel.Create(self);
    with lab[i] do begin
      Parent:=pnlIterate;  AutoSize:=false;
      if iLanguage>1 then font.Name:='Aril' else font.Name:='宋体';
      font.Size:=9;   font.Style:=LabSour.Font.Style;
      Width:=16;  Height:=12; Left:=i*36+64; top:=4;
      Caption:=itos(i+1);
      end;
    end;
  for i:= 0 to 2 do for j:=0 to 3 do begin //仿射变换规则
    with txtArray[8,i*4+j] do begin //控件已在前面与迭代规则控件一起创建
      Parent:=tabAffine;   Tag:=i*4+j;  Text:='0';   Color:=clWhite;//clBtnFace;//
      Left:=j*64+46;  Top:=i*26+6;  Width:=42;  Height:=14;
      OnExit:=frmMain.txtDepthExit;
      OnKeyPress:=frmMain.posEdit1KeyPress;
      SetWindowLong(Handle,GWL_STYLE,GetWindowLong(Handle,GWL_STYLE) or Es_right); //内容靠右
      end;
    end;

  for i:= 0 to 9 do itmOpen[i]:= TMenuItem.Create(self);  //创建[Open]菜单选项
  for i:= 0 to LayerTime do begin
    aObjShow[i]:= TPanel.Create(Self); //创建对象显示状态控件
    with aObjShow[i] do begin
      Parent:=pnlShow;  OnClick:= ObjShowClick;  Cursor:= crHandPoint;
      Height:=14;  Width:= 13;  Left:= 2+ i*15;  Top:=0;
      Tag:= i; caption:=IntToStr(i+1);
    end; //with
    aTagShow[i]:= TPanel.Create(Self); //创建标签显示状态控件
    with aTagShow[i] do begin
      Parent:=pnlShow;  OnClick:= TagShowClick;  Cursor:= crHandPoint;
      Height:= 7;  Width:= 13;  Left:= 2+ i*15;  Top:=14; Tag:= i;
    end; //with
    end; //for i:=
  pnlColorPad.Height:=68;  //调色板
  for i:= 0 to 18 do begin
    pnlColor[i]:= TPanel.Create(self); //创建调色板
    with pnlColor[i] do begin
      Parent:=pnlColorPad;  OnClick:=pnlColorClick;   Cursor:= crHandPoint;
      Height:=12;   Width:=IIFi(i=18,38,18);   Font.Size:=6;
      Left:=2+(i Mod 4)*20;   Top:= 2+(i div 4)*13;
      Tag:=i;   if(i<17)then Color:= ObjColor[i];
      if(i=17)then caption:='···';
      if(i=18)then caption:='R.G.B';
      if(i=18)then Hint:=SwitchS(iLanguage,'参数...','參數...','Parametric...','');
      end;
    end; //for i:=
  for i:= 0 to 18 do begin //创建颜色菜单
    itmColor:=TMenuItem.Create(self);
    with itmColor do begin
      Tag:=i;
      case i of
        0..16:begin
          OnDrawItem:=butPaintColorEDrawItem; //绘制颜色菜单
          OnMeasureItem:=butPaintColorEMeasureItem;
          end;
        17:itmColor.Caption:=SwitchS(iLanguage,'其它 (&O)...','其它 (&O)...','&Other...','');
        18:itmColor.Caption:=SwitchS(iLanguage,'参数 (&P)...& ','參數 (&P)...','&Parametric...','');
        end;
      OnClick:=butPaintColorFClick; //点击颜色菜单
      menColor.Add(itmColor);
      end;
    end;
  for i:=0 to 17 do cmbFontC.Items.Insert(i,'a'); //创建字体颜色下拉列表
  tagFont:=TFont.Create(); //标签或文本字体
  pnlFont.Left:=300;  pnlFont.Top:=24;
  cmbFontN.Items.AddStrings(Screen.Fonts);  //创建字体列表
//  hotLabel:=TLabel.Create(self);
  popChar:=TpopupMenu.Create(self); //创建弹出式菜单
  popChar.AutoHotkeys:=maManual; //不考虑热键
  memText.PopupMenu:=popChar;  //链接到文本输入框
  for i:=0 to 32 do begin //文本框右键菜单
    itmColor:=TMenuItem.Create(self); //创建菜单项
    itmColor.Caption:=txtChar[i+1];   //读入字符
    if(i in[8,16,24])then itmColor.Break:=mbBreak;
    itmColor.OnClick:=N27Click;       //链接处理过程
    popChar.Items.Add( itmColor);     //添加到菜单
    end;
//  setLength(BackObj, UndoTime+1);
  hotEdit:=edtZ;      hotID:=0;
  pnlProp.Top:=24;    pnlProp.Height:=44;
  edtZmin.EditLabel.Caption:='z=';
  pnlShow.Left:=tlbMain.Left+ barPage.Left+2;   pnlShow.top:= 1;
  pnlControl.Left:=28;      pnlControl.Top:= 60;
  butZoom.Left:=2; butZoom.Top:=2;//  butZoom.Left:=ClientWidth-20;   butZoom.Top:=ClientHeight-20; //
  pnlList.Top:=26; pnlList.Left:=26; pnlList.Width:=80; pnlList.Height:=80;//对象列表
    With imgList.Picture.Bitmap do begin
      Width:=imgList.Width; Height:=imgList.Height;
      canvas.Font.Name:='宋体'; canvas.Font.Size:=9;
      end;

  menMax.ShortCut:=   ShortCut(27,[ssShift]); //全屏 Shift+Q 8219;
  menSelDad.ShortCut:=ShortCut(38,[ssAlt]);   //父对象 Alt+Up 32806;
  menSelSon.ShortCut:=ShortCut(40,[ssAlt]);   //子对象 Alt+Dn 32808;
  menTraceDel.ShortCut:=27; //Esc
  menLabel.ShortCut:=32879; //标签Alt+/
  menFont.ShortCut:=ShortCut(84,[ssCtrl,ssShift]);//字体 Ctrl+Shift+T
  men112.ShortCut:=ShortCut(80,[ssCtrl,ssShift]); //新建参数 Ctrl+Shift+P
  men111.ShortCut:=ShortCut(187,[ssAlt]); //计算 Alt+=
  initDefault;  //#######第一次运行程序时用的系统默认环境数据##########

  menHelp.Enabled:= FileExists( 'inRm3D Help.chm'); //是否存在帮助文件
  exePath:= ExtractFilePath( Application.ExeName); //应用程序所在目录
  OpenBox.InitialDir:= exePath; //文件框的默认路径
  initFile:=exePath+'inRm3D.ini';
  if not FileExists(initFile)then begin
    GetTempPath(127, @tempPath); //系统Temp目录
    initFile:= trim(tempPath) + 'inRm3D.ini';
    end;
  isFromFile:=(vFile>'');
  FileCount:=-1;
  if FileExists(initFile) then begin
    AssignFile( G, initFile);  //获取SysFile的句柄
    try
      try
        ReSet( G);              //打开SysFile (只读)
        repeat
          readLn( G, st);        //从文件G中读取一行文本s
          isEnd:=(st='End')or EOF(G);
          if FileExists(st)and not isEnd then begin //如果文件s存在
            Inc( FileCount);
            aryFile[ FileCount]:= st;
            end;
        until isEnd;
        with Obj[8] do
        repeat
          readLn( G, st); t:=copy(st,1,6);  // showmessage(st);
          if t='Point 'then begin p1.x:=stf(st,7, 5); Link[1]:=sti(st,12,10); p1.r:=sti(st,22,3); end; //点径、颜色
          if t='Line  'then begin p1.y:=stf(st,7, 5); Link[2]:=sti(st,12,10); end; //线径、颜色
          if t='Circle'then begin p1.z:=stf(st,7, 5); Link[3]:=sti(st,12,10); end; //线径、颜色
          if t='Plane 'then begin p1.w:=stf(st,7, 5); Link[4]:=sti(st,12,10); end; //框径、颜色
          if t='Solid 'then begin p2.x:=stf(st,7, 5); Link[5]:=sti(st,12,10); end; //实体棱径、颜色
          if t='Curve 'then begin p2.y:=stf(st,7, 5); Link[6]:=sti(st,12,10); end; //曲线线径、颜色
          if t='Face  'then begin p2.z:=stf(st,7, 5); Link[7]:=sti(st,12,10); end; //曲面颜色
          if t='Accura'then begin p2.w:=stf(st,7, 5); Link[8]:=sti(st,12,10); end; //计算小数 颜色
          if t='Select'then begin p5.w:=stf(st,7, 5); Link[9]:=sti(st,12,10); end; //坐标轴经 选择色
          if t='TagSiz'then begin TagP.z:=trunc(stf(st,7, 5)); Link[10]:=sti(st,12,10); end; //标签字号 颜色
          if t='TagNam'then info[1]:=copy(st,7, 20); //标签字体
          if t='TagSty'then begin TagT:=copy(st,7, 4);TagS:=sti(st,11,5); end; //标签Style
          if t='TagN  'then TagN:=copy(st,7,20); //坐标轴字体
          if t='Axis  'then begin Vec.x:=stf(st,7,6);  Vec.y:=stf(st,13,6); Vec.z:=stf(st,19,6); W:=stf(st,25,6);
                                  Vec.w:=stf(st,31,6); Vec.r:=stf(st,37,6); p4.r:=stf(st,43,6); end;
          if t='AxiTag'then begin //坐标轴标签
            info[2]:=st;   if Length(info[2])<1 then info[2]:='AxiTag o x y z';
            for i:= 2 to 5 do Obj[i].Tag:=getStr(info[2], i); // copy(st,5+i*2, 2);//
            end;
          if t='Color 'then begin LinkName[0]:=sti(st,7,10);  LinkName[1]:=sti(st,17,10);
                                  LinkName[2]:=sti(st,27,10); LinkName[3]:=sti(st,37,10); LinkName[4]:=sti(st,47,10);
                                  LinkName[5]:=sti(st,57,10); LinkName[6]:=sti(st,67,10); LinkName[7]:=sti(st,77,10); end;
          if t='Transp'then begin p5.x:=stf(st,7,5);  p5.y:=stf(st,12,5);   p5.z:=stf(st,17,5); end; //坐标平面透明度
          if t='Mode  'then begin pTR.x:=sti(st,7,4); pTR.y:=sti(st,11,4);  pTR.z:=sti(st,15,4); end;//坐标平面模式

          if t='Origin'then begin p3.x:=stf(st,7,5);  p3.y:=stf(st,12,5);      //坐标原点
                                  p3.z:=stf(st,17,5); p3.w:=stf(st,22,5); p3.r:=stf(st,27,5);  end; //视角
          if(t='Window')then begin
            Link[20]:=sti(st,7,4); Link[21]:=sti(st,11,4); Link[22]:=sti(st,15,4); Link[23]:=sti(st,19,4);
            end;
          if t='Deep  'then begin
            p4.x:=stf(st,7,5);  p4.y:=stf(st,12,5); //景深 透视
            i:=sti(st,17,4);  if(i< 0)then i:=30;  pnlList.Left:=i;    //对象列表位置
            i:=sti(st,21,4);  if(i< 0)then i:=30;  pnlList.Top:=i;     //对象列表位置
            i:=sti(st,25,4);  if(i<60)then i:=60;  pnlList.Width:=i;   //对象列表宽
            i:=sti(st,29,4);  if(i<80)then i:=80;  pnlList.Height:=i;  //对象列表高
            i:=sti(st,33,4);  if(i< 0)then i:=30;  pnlProp.Left:=i;    //属性框位置
            i:=sti(st,37,4);  if(i< 0)then i:=30;  pnlProp.Top:=i;     //属性框位置
            end; //景深 透湿度
          if t='Englis'then iLanguage:=2;
          if t='Taiwan'then iLanguage:=1;
          if t='Scene 'then begin
            tmp:=copy(st,7,22); for i:=1 to 21 do info[0][i]:=tmp[i];
            end;
        until (st='Finish')or EOF(G); //
      finally
        closeFile( G);          //关闭文件
      end; // try
    except                    //出错处理
      MyMessage( 'Can''t open file ' + initFile);
    end; //try
    OpenBox.InitialDir:= aryFile[0];
    if isFromFile then setPopMenu( false, vFile)  //如果用"命令行+文件名"的形式或从资源管理器中直接打开“.sgf”文件
            else if FileCount>-1 then setPopMenu( false, aryFile[0] );  //设置文件名列表
    end
  else begin
    if isFromFile then setPopMenu( true, vFile );
    end;
  setLanguage(iLanguage);
  case iLanguage of 0:stMode:=stModeC; 1:stMode:=stModeT; 2:stMode:=stModeE; end; //构件名称
  case iLanguage of 0:stAxis:=stAxisC; 1:stAxis:=stAxisT; 2:stMode:=stModeE; end;
  case iLanguage of 0,1:mNum:=mNumC; 2:mNum:=mNumE; end;
  for i:= 1 to 26 do screen.Cursors[i]:= LoadCursor( HInstance, mNum[i]); //鼠标文件详见资源文件Hand.res
  frmMain.Show; //必须先Show，否则下面的TitleHeight就读不到
  if isUseToControler then begin //如果用于控件
    ShowWindow(Application.Handle, SW_HIDE); //隐藏任务栏里的程序图标
    menNew.Enabled:=not isReadOnly;
    menSave.Enabled:=not isReadOnly;
    menSaveAs.Enabled:=not isReadOnly;
    bNail:=false;   butNail.NumGlyphs:=2;   //属性框钉子

    if(vFileVar>'')then begin
      if(Pos('m',vFileVar)>0)then begin tlbMain.Visible:=false;  tlbMenu.Visible:=false; end; //隐藏菜单
      if(Pos('s',vFileVar)>0)then setTimer( 91, false);  //隐藏状态栏
      if(Pos('t',vFileVar)>0)then setTimer( 92, false);  //隐藏工具条
      if(Pos('p',vFileVar)>0)then setTimer( 93, false);  //隐藏页面栏
      if(Pos('b',vFileVar)>0)then setTimer( 94, false);  //菜单位于底部
      end;
    end;
  butMax.Visible:=not isUseToControler;
  stbBar.Top:=Height-47-TitleHeight +29;//
  tlbShort.Height:=frmMain.Height;
  frmMain.Width:=800;    frmMain.Height:=600;
  Start( isFromFile); //初始化画板 打开画板文件(参数False将显示空画板)
  if not isUseToControler and(Obj[1].info[0][17]='1')then
    frmMain.WindowState :=  wsMaximized;//窗体最大化
  if(not isFromFile)then SaveThisPage(0,ObjCount, false,true);
  ClipBoard:=TClipBoard.Create; //打开剪贴板
  if not isFromFile then   sgfName:='New.sgf';
end;

procedure TfrmMain.FormDestroy(Sender: TObject);
begin
    DragAcceptFiles(Handle,   False);
    ClipBoard.Free;
end;
//============ 右击重叠构件时，从弹出菜单中选择构件
procedure TfrmMain.SelObjFromMultMenu(Sender:TObject);
  var t :integer;
begin
  t:=(Sender as TMenuItem).Tag;
  if(t=0)then begin
    butProp.Down:=true;
    ShowObjProp(MarkObj, 0,0, false,true);  //显示构件属性框
    end
  else begin
    MarkObj:=t;
    Obj[MarkObj].Hot:=not Obj[MarkObj].Hot ;
    SetProjection(false,false, 30);
    end;
end;
{====================  End application work ====================}
Function TfrmMain.ObjSelected(ID:integer; bS,bC,bL,bR:boolean):integer; //选择了一个构件
  var i,pos,iID :integer;
begin
  iID:=ID;
  if(iID>0)and bL then begin //SelRec[] 已选择的构件 0总数 1点数 2直线数 3圆数... 21开始被选择的构件ID
    if(lastHit>0)then begin //从选择列表中删除一个
      pos:=20;
      repeat inc(pos); until(SelRec[pos]=iID)or(pos>63);
      for i:=0 to SelRec[0]-1 do SelRec[pos+i]:=SelRec[pos+i+1];
      dec(SelRec[0]); dec(SelRec[Obj[lastHit].Kind]);
      Obj[lastHit].Hot:=false;
      Obj[lastHit].Seled:=false;
      end;
    with Obj[iID] do begin
      if(Hot)then begin //从选择列表中删除一个
        pos:=20;
        repeat inc(pos); until(SelRec[pos]=iID)or(pos>63);
        for i:=0 to SelRec[0]-1 do SelRec[pos+i]:=SelRec[pos+i+1];
        if(SelRec[0]>0)then dec(SelRec[0]);
        if(SelRec[Kind]>0)then dec(SelRec[Kind]);
        end
      else begin //加入选择列表
        inc(SelRec[0]); inc(SelRec[Kind]);
        SelRec[SelRec[0]+20]:=iID;
        end;
      Hot:=not Hot;  Seled:=false;
      end;//with
    end;
  result:=SelRec[20+SelRec[0]];
  if(result>10)then
  for i:=0 to LayerTime do with Obj[result]do begin
    setBevel( not ObjShow[i], aObjShow[i], nil );  //对象显示状态
    setBevel( not TagShow[i], aTagShow[i], nil );  //标签显示状态
    end; // for i
//  if(SelRec[0]=1)then cmbTag.ItemIndex:=Obj[result].ShowID
  //               else cmbTag.ItemIndex:=0;
  pnlShow.Visible:=(SelRec[0]>0)and(SelRec[21]>0)and(tlbMain.Visible);
  if pnlShow.Visible then pnlShow.Refresh;
//  grdTagDraw(MarkObj, Obj[ID].ListID, false); //刷新对象列表
  CountObjNum(false,false);
end;

function TfrmMain.BreackAdd:boolean; //终止添加
  var i:integer;
begin //
  result:=false;
  if(PaintNum>0)then begin //正在手绘
    setPaintList(true);
    exit;
    end;
  bAdd:=false;      //Obj[MarkObj].hot:=false;
  with Obj[MarkObj] do begin //添加多边形时等于确认添加
    if(nK=4)and(nM=6)and(not D)and(selNum>2)then begin //多边形
      if(trunc(W)=3)then begin Mode:=1; L:=0; end;
      Link[trunc(W)]:=0; result:=true;
      exit;
      end; // goto addPlane; end;
    if(nK=6)and(nM=5)and(selNum>1)then begin //凸壳
      W:=W-1; result:=true; exit;
      end;//goto addPlane; end;
    if(nK=6)and(nM=6)and(selNum>1)//凸棱台
      then begin S:=S-1; result:=true; exit; end;//goto addPlane; end;
    if(nK=17)and(nM=1)and((selNum>1)or(Obj[Link[0]].Kind=4))then //路径
      begin result:=true; exit; end;
    end;
  if pnlControl.Visible and tabPath.TabVisible and Assigned(Obj[ObjCount].butID)then begin
    Obj[ObjCount].butID.Visible:=false;
    Obj[ObjCount].DelID:=ObjCount;
    end;
  HideAllPanel; //不能放在 dec( ObjCount,CancelNum);后面
  if bDotJoin then with Obj[MarkObj] do  //自由点寻找约束构件状态
    begin Mode:=1; for i:=0 to 2 do begin Link[i]:=0; LinkName[i]:=0;end;
    end
  else begin
    dec( ObjCount,CancelNum); //取消添加
    for i:=1 to CancelNum do Obj[ObjCount+i].Tag:='';
    end;
  nK:=0; nM:=0; hit:=-1;  //MarkObj:=0;
  MarkObj:=ObjCount;
  Cursor:=crDefault;
  labHint.Top:=-20;
  HotTool.Down:=false; HotTool:=butArrow; butArrow.Down:=true; // HotMenu:=menBar57; 
  butPaintRect.Visible:=false;
  butPaintCircle.Visible:=false;
  butPaintDel.Visible:=false;
  SetProjection(true,false,6);
end;
procedure TfrmMain.PaintDel;
  var i:integer;
begin
  for i:=1 to PaintMax do if PaintData[i].Hot then begin
    PaintData[i].Hot:=false;
    PaintData[i].Del:=true;
    glDeleteLists(PaintData[i].mainList,1);// 60000+PaintHot
    if(i=PaintMax)then begin
      repeat dec(PaintMax);
      until(PaintMax=0)or(not PaintData[PaintMax].Del);
      PaintListNum:=PaintMax;
      end;
    end;
  PaintHot:=0;
end;

procedure TfrmMain.SelLinkObj(hit:integer);  //选择关联构件
  var i,j, aK,aM :integer;
begin
  aK:=Obj[MarkObj].Kind;  aM:=Obj[MarkObj].Mode;
  Obj[hit].Seled:=false;
  if(cheCutter.Visible)and(cheCutter.Count<6)then begin   //添加剪切面
    i:=cheCutter.Count;
    for j:=0 to i-1 do
      if(Obj[MarkObj].Cutter[j,1]=hit)then exit;;//判断是否相同截面
    Obj[MarkObj].Cutter[i,0]:=Obj[hit].Name;
    Obj[MarkObj].Cutter[i,1]:=hit;
    Obj[MarkObj].Cutter[i,2]:=1;    //正面为1
    cheCutter.AddItem(Obj[hit].Tag,nil);
    cheCutter.Height:=cheCutter.Count * cheCutter.ItemHeight+2;
    cheCutter.Left:=2;
    cheCutter.Width:=tab0.Width-4;
    if(aK=6)and((aM=3)or(nM=4)and(Obj[MarkObj].S<100))then begin
      getEdges( MarkObj, i,j); //j棱边数 k顶点数
      for j:=1 to i do Obj[MarkObj+j].Cutter:=Obj[MarkObj].Cutter;//为棱边设置截面
      end;
    end
//    else if(aK in[11])and(Obj[hit].Kind=1)then //绑定位置   10,
//    setObjLink(MarkObj,hit, IDtoItem(hit))
  else begin
    if(aK=14) or (aK=17)then begin
      setObjLink(MarkObj,hit, IDtoItem(hit)); //插入路径
      lstPath.ItemIndex:=lstPath.Count-1;
      butPathU.Enabled:=true;   butPathD.Enabled:=false;
      butPathDel.Enabled:=true; butPathResume.Enabled:=false;
      end
    else
      setObjLink(MarkObj,hit, Obj[hit].Tag);
    if(MarkObj<hit)and(aK<>14)then begin //关联件移到编辑件之前
      ChangeObjID(MarkObj,hit);
      rerelate(11,ObjCount,true,false,false);
      SetProjection(true,false,8);
      end;
    if(aK=17)then bSelLink:=true;
    end;
end;
{======================= Mouse Down =======================}
procedure TfrmMain.FormMouseDown(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
  var a,b,c, i,j,k, N,len, Ka,Kb,Ma,Mb, kEdge,kVct:integer;
    pa,pb,pc,na,nb, pp,px,py,pz :TcgVector;    tmpObj:TmyObject;
    vL,xL,xH, tX,tY:single;   bo,bb :bool;  ss:string;
    itm :TMenuItem;
  label addPlane;
  procedure hintShow(st:string);
    begin if cheHint.Checked then //显示纹理文件名  if bHint then top:=0;
      with labHint do begin Caption:=st; top:=25;  end;
    end;
  function its( v:integer):string;  begin str( v:3, result); end;
  function DotAtLine(hit,x,y :integer):single;    //直线上的约束点
    var i:integer;
    begin
      for i:= 0 to 1 do winPos[i]:= GetWinPos(hit,i+1);
      if abs(winPos[0].y-winPos[1].y)>abs(winPos[0].x-winPos[1].x) //直线斜率>1
        then result:=(y-winPos[0].y)/(winPos[1].y-winPos[0].y)
        else result:=(x-winPos[0].x)/(winPos[1].x-winPos[0].x);
    end;
//==================== 计算鼠标在曲线上的位置 ======================
  function getPosOfCurveByMouse(hit, x,y :integer):single; //曲线上的约束点
    var k,N :integer; tX,tY:single;  bb:boolean;  pMax,pMin :TcgVector;
    function Mid(a,Min,Max:single):boolean;
      begin result:=(a>=Min)and(a<=Max); end;
  begin
    N:=high(LocaVct[hit]); //轨迹点数
    k:=0;   winPos[0]:=getDotPos(LocaVct[hit,k],true);
    repeat
      winPos[1]:=getDotPos(LocaVct[hit,k+1],false);
      pMax:=cgMax(winPos[0],winPos[1]);
      pMin:=cgMin(winPos[0],winPos[1]);
      if abs(pMax.x-pMin.x)<6 then
        begin pMax.x:=pMax.x+5; pMin.x:=pMin.x-5; end;
      if abs(pMax.y-pMin.y)<6 then
        begin pMax.y:=pMax.y+5; pMin.y:=pMin.y-5; end;
      bb:= Mid(x, pMin.x, pMax.x)and Mid(y, pMin.y, pMax.y);
      winPos[0]:=winPos[1];
      inc(k);
    until(k>=N)or bb;
    winPos[1]:=winPos[0];
    winPos[0]:=getDotPos(LocaVct[hit,k-1],false);
    tX:=abs(winPos[0].x-winPos[1].x);
    tY:=abs(winPos[0].y-winPos[1].y);
    if tY>tX then result:=(y-winPos[0].y)/tY  //直线斜率>1
             else result:=(x-winPos[0].x)/tX;
    result:=result*(LocaVct[hit,k].w-LocaVct[hit,k-1].w);
    result:=abs(result)+LocaVct[hit,k-1].w;
    result:=result/LocaVct[hit,N].w; //比例值
  end;
  procedure BindDotToCurve(ID,hit, x,y :integer); //将点约束到线上
    var i,b, N :integer;
        vL,xL,xH :single;
        pa,pb,pc, px,py,pz :TcgVector;
  begin
    with Obj[ID] do begin
    case Obj[hit].Kind of
      2:L:=DotAtLine(hit,x,y); //直线上的点
      4:begin //平面上的点
        b:=Link[1];
        if(hit<8)and bAxisTagSeled then begin //坐标轴标签相当于坐标平面
          L:=Random(trunc(Obj[IIFi(hit=5,3,2)].L)*100)/100;
          R:=Random(trunc(Obj[IIFi(hit=7,3,4)].L)*100)/100;
          end
        else begin
          for i:= 0 to 2 do winPos[i]:= GetWinPos(hit,i); //平面的三个顶点屏幕坐标
          DotInPlane( MarkObj,xL,xH,x,y,false);
          px:=LocaVct[b,0]; py:=LocaVct[b,1]; pz:=LocaVct[b,2]; pc:=Obj[b].p5;
          R:=xL*pc.w; L:=xH*cgDistance(py,pz);
          pa:=cgVecSub(pc, py);  pb:=cgVecSub(pz,py);
          vL:=Obj[b].p1.w;//cgDistance(pc, py); //
          if cgVecSgn(pa,pb)then L:=L+ xL*vL else L:=L- xL*vL;
          end;
        end;
      3,5,15,16,17,19:begin //曲线上的点
        if(Obj[hit].Kind=3)then if(Obj[hit].Mode<3)then p2.z:=towPi else p2.z:=1;
        b:=Link[1];
        L:=getPosOfCurveByMouse(hit, x,y);
        if(Obj[b].Kind=3)and(Obj[b].Mode<7)then begin//圆周上的点
          if(Obj[b].Mode=2)then L:=towPi-L*towPi
            else if(Obj[Obj[b].parent].Mode in[1,2,15])then L:=L*towPi; //圆周角
          if(Obj[b].Mode in[3,4])and(D)then L:=L*Obj[b].H;
          end;
        end;
      1,13:begin //迭代像上的点
        N:=high(LocaVct[hit]); //可视点数
        vL:=1000;
        pb:=getDotPos(LocaVct[hit,0],true); //可视点之屏幕坐标
        for i:=0 to N-1 do begin //计算距离鼠标最近的可视点
          pa:=pb;
          xL:=cgDistance2D(x,y, pa);//鼠标至可视点的距离
          if xL<vL then begin vL:=xL; b:=i; end;
          pb:=getDotPos(LocaVct[hit,i+1],false);//可视点之屏幕坐标
          end;
          L:=b;
        bAdd:=false; //迭代终像
        end; //仅计算距离鼠标最近的点
    end;//case
    end;//with
  end;
  procedure setMultyObjMenu; //右键重叠构件 设置弹出弹出菜单
    var i,j,k :integer; bb:boolean;
  begin
    popMultObj.Items.Clear;
    for i:=0 to Hits do begin
      itm:= TMenuItem.Create(frmMain);
      if(i=0)then begin
        itm.Tag:=0; itm.Enabled:=false;
        itm.Caption:=SwitchS(iLanguage,'属性...','屬性...','Property...','');
        end
      else begin
        itm.Tag:= SelectBuf[i-1];   //构件ID +'& '
        itm.Caption:= IDtoItem( itm.Tag );
        if(Obj[itm.Tag].Hot)then itm.Checked:=true;//已选择标记打钩
        if itm.Checked then with popMultObj.Items[0]do begin
          if Enabled and not Checked then AutoCheck:=true;//AutoCheck仅用作临时标记
          Enabled:=not AutoCheck and not Enabled;
          end;
        end;
      itm.OnClick:= SelObjFromMultMenu;
      j:=1; k:=0; bb:=false;
      if(i>1)then //按作图顺序排序
        repeat
          bb:=(Obj[itm.Tag].ShowID < Obj[popMultObj.Items[j].Tag].ShowID);
          if bb then k:=j; inc(j);
          until bb or(j>=i);
      if bb then popMultObj.Items.Insert(k,itm)
            else popMultObj.Items.Add(itm);
      end;//for i
    hit:=-1; lastHit:=-1; Hits:=0;
  end;
begin
  if bFlash or bDouble then exit; // bDouble 双击状态
  bo:=(hit>0); // hit值(构件索引)于MouseMove事件中获得
  if(PaintHot>0)and(butPaintDel.Down)then //删除手绘
    begin PaintDel; exit; end;
  bL:= button=mbLeft;  //按下左键
  bR:= button=mbRight; //按下右键
  bM:= button=mbMiddle; //按下中键
  if bM then Cursor:=crHandPoint;  //移动坐标系
  bFrameSel:=bS and not bC and bL and not bAdd and not bo; //框选状态
  if bFrameSel then //Shift+MouseDown
    for i:=11 to ObjCount do with Obj[i]do
      if(DelID=0)and Hot then Seled:=true; //标记Seled，则已选择的对象与框选无关
  bMultiSel:=bL and(hit>0)and(hit<maxObj)and(SelRec[0]>1)
    and(Obj[hit].Kind in[1,10,11,14])and Obj[hit].Hot; //多对象拖动

  if bS and bL and bo and(lastHit>0) then hit:=lastHit;
  if bR then popMultObj.Items.Clear;
  if bR and not bAdd and(Hits>1)then begin //右键重叠构件 设置弹出弹出菜单
    setMultyObjMenu;
    exit;
    end;
  bAdded:=bAdd; //用于FormMouseDown中，在添加状态中，不能移动构件
  pnlColorPad.Hide;
  x0:=x; y0:=y;  dx:=0; dy:=0;  MoveX:=0; MoveY:=0;
  if(not bo)then posEdit.Hide; //点击背景则隐藏posEdit
  if bAdd and bR then begin //添加状态时，相当于按下[Esc]
    if(hit>0)then with Obj[MarkObj]do
      if(nK=17)and(Obj[hit].Kind<6)then begin
      Link[selNum]:=hit; LinkName[selNum]:=Obj[hit].Name;
      end;
    if BreackAdd then goto addPlane;
    exit;    //************ 退出 **************
    end; //begin  and(nK=18)and(PaintListNum>0)
  if bAdd then begin
    for i:=1 to ObjCount do Obj[i].Hot:=false;
    for i:=1 to PaintListNum do PaintData[i].Hot:=false;
    end;
  if bAdd and(nK=10)then with Obj[MarkObj]do begin //********添加文本/图片*******
    p0.x:=x; p0.y:=y+TitleHeight;
    if(nM=1)and(hit>10)then //显示/隐藏标签
      Obj[hit].TagShow[Layer]:=not Obj[hit].TagShow[Layer];
    if(nM=1)and(hit<1)then with pnlControl do begin  //文本
      Left:=x; Top:=y; tlbMain.Enabled:=false;
      ShowControlBox( MarkObj,10, tabText);
      end;
    if nM=2 then begin //图片
      OpenPicture( MarkObj,true,true); bAdd:=false; bL:=false;
      tlbMain.Enabled:=true;  //but110.Down:=false;
      Save( 1,MarkObj,1,true,false);
      ObjListUpdate(MarkObj,true);
      end;
    bSel:=false;
    end;
  if(not bo)and bR then begin  //右击背景 已有选择时取消选择，无选择时显示环境属性
    if(PaintListNum>0)then
      for i:=1 to PaintListNum do PaintData[i].Hot:=false;
    HideAllPanel; // menSpinClick(nil);
    if(MarkObj>1)then begin
      MarkObj:=0;
      if bPause then setTimer(101,false);
      if bSport then setTimer(102,true);
      end
    else begin //右击背景
      timSpin.Enabled:=false;   butSpin.Down:=false;
      popObj.Items.Clear;  // ShowObjProp(0,0,0, false,true);
      tabProp.TabIndex:=0;
      end;
    butProp.Down:=false;
    bC:=false; bS:=false; bA:=false;
    ClearSelRec(0); //清除选择队列
    MarkObj:=ObjSelected(0, bS,bC,false,true);
    end;
  if bAdd and bL and(hit<1)then with Obj[ObjCount] do //添加自由点 按下左键则确定位置
    if(Kind=1)and(Mode<3)then begin
      if(Mode=2)and(hit<1)then Mode:=1;
      bAdd:=false;  bSel:=false;
      Pointe( ObjCount,true,true,false); // 点
      ClearSelRec(0); //清空选择队列
      MarkObj:=ObjSelected(ObjCount, false,false,true,false);
      Save( 1,MarkObj,1,true,false);
      ObjListUpdate(MarkObj,true);
      butProp.Down:=bNail;
      ShowObjProp(MarkObj,x,ClientHeight-y, false,true);  //显示构件属性框
      if(HotTool.Tag>0)then but10Click(HotTool);//从工具启动的添加
      exit;  //************ 退出 **************
      end;
  if not bSelLink then edtTemp.Tag:=-1;
  if(bo)and(bSelLink)and(MarkObj>10)then begin //选择关联构件
    Save( 0,MarkObj,1,false,true);
    SelLinkObj(hit);
    posEdit.Tag:=0;
    exit;
    end;
  if(bo)and not bAdd then begin //###非添加状态选中了一个构件######
    if(hit>60000)then begin
      with PaintData[hit-60000]do begin //选中手绘
        Moved:=not Hot;   Hot:=true;
        end;
      SetProjection(true,false,8);
      exit;
      end;
    if(hit>30000)then hit:=(hit-30000)div 200; //选中痕迹等于选中父构件   or(bL and bNail)
    with Obj[hit]do if(Kind in[10,11])then
      begin p3.x:=x-p0.x; p3.y:=y-p0.y; end;  //鼠标的相对位置 用于拖动
    if(bR)and(lastHit<=0)and not(bS or bC)    //右键选择对象
      or bC and not bS and(Obj[hit].Mode=13)then begin //Ctrl+点击棱边
      if not bL then ClearSelRec(0); //清空选择队列
      with Obj[hit]do if bC and not bS and(Mode=13)then begin //选择棱边的父构件
        MarkObj:=Link[0]; hit:=MarkObj;
        end;
      if(hit=MarkObj)and(not bNail)then butProp.Down:=not butProp.Down
        else butProp.Down:=true;
      MarkObj:=ObjSelected(hit,  false,false,true,false);

//      Obj[MarkObj].Hot:=true;
      if bR or not Obj[hit].noSel then //
        ShowObjProp(MarkObj, x,ClientHeight-y, bL,bR);  //显示构件属性框
      exit;
      end;
    if(hit<>MarkObj)then begin
      butProp.Down:=bNail;  pnlProp.Visible:=bNail;  // pnlProp.Height:=44;
      end;
    if(hit<1)or(hit>maxObj)then exit;
    if bL and(Obj[hit].noSel)then begin //若击中的对象“不可选”则忽略
      hit:=-1; MarkObj:=0; exit;
      end;
    lastHot:=Obj[hit].Hot; //对象的选择状态
    if not lastHot // 在未被选择的对象上按下鼠标则加入选择集
      then MarkObj:=ObjSelected(hit, bS,bC,bL,bR);
    if(Obj[hit].Kind in[2,3,4,6])then MarkObj:=hit;
    for i:=11 to ObjCount do with Obj[i]do
      if(Kind=1)then begin //保存各点的屏幕坐标
        pp:= GetWinPos(i,0);  iL:=trunc(pp.x); iR:=trunc(pp.y);
        end;
    with Obj[hit] do if(Mode=11)then begin //平移变换时保存屏幕坐标
      pp:= GetWinPos(hit,0);  iL:=trunc(pp.x); iR:=trunc(pp.y);
      end;
    with Obj[hit]do begin
      if(Kind=2)and(Mode=2)then pBL:=p2;//角向量 拖动方位角时用于粘附计算
      if(Kind=1)and(Mode=2)or(Mode=10)then r0:=L; //约束值 缩放值
      if(Mode in[7,9,10])then r0:=R; //投影率、旋转角 用于粘附计算
      end;
    KeyPreview:=true;
    end;
   y:= ClientHeight-y;  DownX:=x; DownY:=y;
//非添加状态选中了一个构件
  if bo and not bAdd and(MarkObj>0)then begin
    with Obj[MarkObj]do begin
      a:=Link[0]; b:=Link[1]; c:=Link[2];
      for i:=0 to LayerTime do begin
        setBevel( not ObjShow[i], aObjShow[i], nil );  //对象显示状态
        setBevel( not TagShow[i], aTagShow[i], nil );  //标签显示状态
        end; // for i
      Save( 0, IIFi(Mode=13, a, MarkObj),1, false,false);//Undo
      pnlControl.Visible:=false;
      if Mode=16 then
        hintShow(SwitchS(iLanguage,' 双击以编辑仿射规则 ',' 雙擊以編輯仿射規則 ','Double click to edit Affine rule ',' '))
      else case Kind of    //选择了一个对象 获取对象基点的屏幕坐标
        2:begin  //直线
          if(Mode=13)then begin
            for i:= 0 to 4 do with Obj[a] do
              if(Link[i]>10)and(Obj[Link[i]].Mode=1)then winPos[i]:= GetWinPos(Link[i],1);
            end
          else if(Mode in[2,5])then begin //向量线 中线
            winPos[0]:= GetWinPos(a,1); winPos[1]:= GetWinPos(MarkObj,2);
            end
          else begin
            if(Mode in[1,5])then winPos[0]:= GetWinPos(a,1) //两点线 相贯线
                            else winPos[0]:= GetWinPos(MarkObj,1);
            if(Mode in[1,5])then winPos[1]:= GetWinPos(b,1)
                            else winPos[1]:= GetWinPos(MarkObj,2);
            end;
          DotInPlane( MarkObj, p3.x,p3.x, x,y, true);
          p3.z:=L;
          end;
        4:if D then hintShow(' '+ Obj[ MarkObj].info[0]+' ');  //纹理
        6:if(Mode in[1,2,6])and D and(info[0]>'')then hintShow(' '+ info[0]+' ');  //纹理
        7:if D and(info[0]>'')then hintShow(' '+ info[0]+' '); //纹理
        9,16:if bL and(Mode in[1..6,13])and not pnlControl.Visible then
            hintShow(SwitchS(iLanguage,' 双击以编辑函数式 ',' 雙擊以編輯函数式 ','Double click to edit expression ',' '));
       10:if bL then begin
          if(Mode=1)and not pnlControl.Visible then
            hintShow(SwitchS(iLanguage,' 双击以编辑文本 ',' 雙擊以編輯文本 ','Double click to edit text ',''));
          if(Mode=2)and(info[0]>'')then
            hintShow(SwitchS(iLanguage,' 双击以选择图片 ',' 雙擊以選擇图片 ','Double click to select a image ',''));
          end;
       11:if bL then begin
          if(Mode=1)then hintShow(SwitchS(iLanguage,' 双击以编辑表达式 ',' 雙擊以編輯表達式 ','Double click to edit expression ',''));
          if(Mode=2)then iT:=0; //参数值是否被修改
          end;
       13:if bL and not(pnlControl.Visible and tabIterate.Visible)then
            hintShow(SwitchS(iLanguage,' 双击以编辑迭代规则 ',' 雙擊以編輯疊代規則 ','Double click to edit Iterative rule ',''));
       17:if bL and not pnlControl.Visible then begin
          if(Mode=1)then begin
            N:=0; for i:=0 to LinkTime do if(Link[i] in[1..MarkObj-1])then inc(N);
            for i:=0 to N do begin
              a:=Link[i];
              if(a>10)and(a<MarkObj)and(Obj[a].Kind=1)and(Obj[a].Mode=1)
                then winPos[i]:= GetWinPos(Link[i],1);
              end;
              hintShow(SwitchS(iLanguage,' 双击以编辑路径 ',' 雙擊以編輯路經 ','Double click to edit path ',''));
            end;
          if(Mode=2)then
              hintShow(SwitchS(iLanguage,' 双击以编辑三视图 ',' 雙擊以編輯三視圖 ','Double click to edit 3-View',''));
          end;
       18:for i:=0 to 1 do winPos[i]:= GetWinPos(hit,i+1); //标记
       19:if(Mode<>2)then for i:=0 to 2 do //圆锥曲线 椭圆除外
            if(Link[i]>10)and(Obj[Link[i]].Mode=1)then winPos[i]:= GetWinPos(Link[i],1);
        end; //case
      end; //with
    end;
  if bo then bDown:= true; //bDown 用于移动构件时画坐标指示线
//在对象上添加点
  if bAdd and((not bSel)or bSel and(Obj[hit].Kind in[2..5,15,16,17,19]))
    then with Obj[MarkObj]do
      if(nK=2)and((nM=1) or (nM=2)and(trunc(R)<2) or (nM=3)and(selNum=0) ) //两点线 向量 平行线的第一点
      or(nK=1)and(nM=5)and not bSel //中点
      or(nK=2)and(nM=4)and(selNum=0)and(not bSel)  //垂线
      or(nK=2)and(nM=19)and(selNum=0)and(not bSel or(Obj[hit].Kind<>3)) //切线
      or(nK=3)and((nM in[2,4])or(nM>1)and(selNum=0)or not bSel)and not bC //三点圆 或者其它圆的第一点
      or(nK=3)and(nM=1)and(rY=0)and(butLock.Down)and(selNum=2)
      or(nK=3)and(nM=3)and(selNum=0) //点法弧
      or(nK=4)and not(bSel) // (nM in[2..6]) or
      or(nK=6)and((nM in[1,2,3,5,6]) or(nM=4)and(S>0))and(not bSel or(selNum=0))
      or(nK=6)and(nM=5)
      or(nK=17)and(bSel and(Obj[hit].Kind=1)or not bSel )
      or(nK=19)and((nM=1) or(nM=2)and(selNum=1) )//圆锥曲线一
      or(nM in[8,10,12,15])and(not bSel)and(selNum>0)
      then begin
        Tag:='';
        Obj[MarkObj+1]:=Obj[MarkObj];
        with Obj[MarkObj]do begin
          Kind:=1;  W:=Obj[1].p1.x;  S:=trunc(Obj[1].p1.r);  U:=false; D:=False;  F:=false;
          edited:=true; Trace:=false;
          color:=cgTColorToCGColorF( Obj[1].Link[1],1);
          texTag:=0;
          mainList:=glGenLists(1);
          seleList:=glGenLists(1);
          Tag:=getTag(MarkObj);
          CleanLink(MarkObj,0); // for i:=0 to LinkTime do begin Link[i]:=0; LinkName[i]:=0; end;
          for i:=0 to LayerTime do begin ObjShow[i]:=true; TagShow[i]:=cheTag.Checked and(Kind=1); end;
          if not bSel then //添加一个自由点 and(SelNum=0)
            Mode:=1
          else //添加一个约束点
            if(Obj[hit].Kind in[5,15,16,17,19])
              or(Obj[hit].Kind in[2,3,4])and((nK=2)and(nM=1) //两点直线
              or(nK=3)and(nM in[2,3,4]) //三点圆 三点弧
              or(nK=4)
              or(nK=6)and(nM=5) //凸壳
              or(nK=19)and((nM=1) or(nM=2)and(SelNum=0))
              or(SelNum=0))
            then begin
            Mode:=2;   U:=false;   D:=false;   H:=0;
            p2.x:=0;   p2.z:=1; if(Obj[hit].Kind=3)then p2.z:=towPi;
            Link[1]:=hit; LinkName[1]:=Obj[hit].Name;
            BindDotToCurve(MarkObj, hit, x,y);
            bSel:=false;
            end;
          p0:=Obj[0].p0;   if(rY=0)and(butLock.Down)then p0.z:=0;
          Name:=getObjName(1);
          end; //with Obj[MarkObj]
        inc(ObjCount); inc(CancelNum); MarkObj:=ObjCount;
        with Obj[MarkObj]do begin
          i:=selNum;
          if(Kind=2)and(Mode=6)and(selNum=2)then i:=3;
          if(Kind=6)and(Mode=6)and(selNum=2)then i:=4; //三点球
          
          Link[i]:=MarkObj-1;   LinkName[i]:=Obj[MarkObj-1].Name;
          Tag:=getTag(MarkObj);
          if(nK=3)and(nM=1)and(rY=0)and(butLock.Down)and(selNum=0)then begin  //点向圆 2D状态时法线为z轴
            Link[1]:=4; LinkName[1]:=Obj[Link[1]].Name; inc(selNum);
            end;
          if(nK=4)and(nM=6)and(rY=0)and(butLock.Down)and(selNum=0)and Rand then begin //
            Link[1]:=4; LinkName[1]:=Obj[Link[1]].Name;   bAdd:=false;
            end;
          inc(selNum);
          Ka:=Obj[Link[0]].Kind;  Kb:=Obj[Link[1]].Kind;
          if(Kind=4)and(Mode=6)and not Rand then W:=selNum; //多边形
          if(Kind=4)and(Mode=2)and(Ka=1)and(Kb=1)and(selNum=2)then Mode:=1;
          if(Kind=6)and(Mode=5)then W:=selNum+1;  //凸壳
          labHint.Caption:=SetHint(Kind,Mode,selNum);

          if(Kind=2)and( (Mode=2)and(selNum=1)or(Mode=1)and(selNum=2)or(Mode=6)and(selNum=3) )

          or(Kind=3)and(Mode=1)and(rY=0)and(butLock.Down)and(selNum=3) //点向圆 2D状态
          or(Kind=3)and(Mode=1)and(rY<>0)and(selNum=2)
          or(Kind=3)and( (Mode in[8,10])and(selNum=2)or(Mode in[2,4])and(selNum=3))
          or(Kind=3)and(Mode=3)and(rY=0)and(butLock.Down)and(selNum=2) //点法弧
          or(Kind=3)and(Mode=3)and(selNum=3) //点法弧

          or(Kind=4)and((Ka=2)or(Kb=2))and(selNum=2) //两线面
          or(Kind=4)and( (Mode in[1,3])and(selNum=3)or((Mode=2)or(Mode=6)and Rand)and(selNum=2))
          or(Kind=4)and(Mode=5)and(Ka=4)and(Kb=4)and(selNum=3)//两面中面
          or(Kind=4)and(Mode=5)and(selNum>1)  //两点中面
          or(Kind=4)and(Mode=4)and(selNum>1)  //两点定义的垂面
          or((Mode in[8,10])or(Kind=1)and(Mode=5))and(selNum=2)
          or(Kind=6)and(Mode in[1,2,3,4])and(selNum=2)
          or(Kind=6)and(Mode=6)and(selNum=3)  //三点球
          or(Kind=6)and(Mode=5)and(selNum>=32)
          or(Mode=12)and(selNum=3) or(Kind=17)and(selNum>=32)
          or(Kind=19)and((selNum=3)or(Mode=2)and(selNum=2))//圆锥曲线
          or(Mode=15)and(selNum>0) //反演
          then begin
            bAdd:=false;
            if(Kind=3)and(Mode=3)and(selNum=2)and(rY=0)and(butLock.Down)then begin Link[2]:=4; H:=2; end;//圆弧 二维状态
            if(Kind=3)and(Mode=3)and(selNum=3)then Link[3]:=Link[2];//三点构造的点法弧
            if(Kind=4)and(Ka=2)and(Kb=1)then SwapI(Link[0],Link[1]);//点线面
            if(Kind=6)and(Mode=5)then W:=W-1;
            if(Kind=19)and(Mode=2)and(Ka=1)and(Kb=2)then SwapI(Link[0],Link[1]);//圆锥曲线
            end;
          if not bAdd and(Kind=3)then Angle:=0;
          reRelate(MarkObj-CancelNum+1,MarkObj,false,false,false);
          if not bAdd then goto addPlane;
          end;//with
      end;//if bAdd...with...
  if bSel and(hit>0)and(hit<maxObj)then begin  // 添加对象时选择构件，bSel状态在MouseMove事件中获得
    with Obj[ ObjCount] do begin
    if(hit>0)then Obj[hit].seled:= true;
    case selNum of
    0:begin //选择第一个对象
      if(nK=1)and(nM in[1,2,6])or(nK in[13,14,18])then k:=1 else k:=0;
      if not bDotJoin then begin Link[k]:=hit; LinkName[k]:=Obj[hit].Name; end;
      case nK of
        1:case nM of  // 点
          1,2:begin //约束点
            if nM=1 then begin nM:=2; Mode:=2; end;
            L:=1; H:=0; D:=false; F:=false; U:=false; bAdd:=false;
            p2.x:=0; p2.z:=1;  //起始值、终止值
            Link[0]:=0;
            case Obj[hit].Kind of
              1:if(Obj[hit].Mode=6)then BindDotToCurve(MarkObj, hit, x,y)
                else Link[1]:=hit;  //合并
              2,3,4,5,13,15,16,17,19: BindDotToCurve(MarkObj, hit, x,y);
              6:begin
                end;
              end;
            end;
          3,4:begin inc(selNum);  end;//最近点 交点
          5:begin  //中点
            inc(selNum); if Obj[hit].Kind in[2,3,4] then bAdd:=false; //2中点 3圆心 4形心
            end;
          6:begin L:=5;
            bAdd:=false;  //等分点
            end;
          end;
        2:begin //直线
          if(Mode=1)then begin //线段
            Obj[MarkObj].p0:=Obj[hit].p0;   inc(selNum);
            end 
          else if(Mode=2)then begin //向量
            if trunc(Obj[MarkObj].R)<2 then begin
              p2.x:=6; p2.z:=0;   bAdd:=false;
              end
            else begin //向量运算
              Link[0]:=0;   LinkName[0]:=0;
              Link[3]:=hit; LinkName[3]:=Obj[hit].Name;
              inc(selNum);  
              end;
            end
          else if(Mode=6)and(Obj[hit].Kind=19)then //交惯线 渐近线/准线
            bAdd:=false
          else
            inc(selNum);  //两点式、平行线、垂直线、交惯线
          end; //case Mode
        3:if(Mode=1)and(rY=0)and(butLock.Down)then  //点向圆 2D状态时法线为z轴
            begin Link[1]:=4; inc(selNum,2); end
          else inc(selNum);
        4:begin //平面
          p0:=Obj[hit].p0;
          if(Mode=2)and(Obj[hit].Kind=2)then p1:=Obj[hit].p1;
          if(nM=6)and(rY=0)and(butLock.Down)and Rand  //正多边形 2D状态
            then begin Link[1]:=4;   bAdd:=false; end
            else inc(selNum);
          if(Mode=6)and not Rand then W:=selNum; //任意多边形
          end; //
        5,7:inc(selNum); //平面 轨迹 曲面 块
        6:begin
          inc(selNum); //实体
          if(nM=5)then begin W:=selNum; if(W>1)and(W<32)then W:=W+1; end; //凸壳
          if(nM=4)and(S=0)then begin bAdd:=false; end; //凸棱台
          end;
        8:begin //合并/分离
          if(Obj[hit].Mode>1)then begin bAdd:=false; PointJoin(hit,0); exit; end
            else begin MarkObj:=hit;   inc(selNum); end;
          end;
       11:if(nM in[5,6,7,9])  //距离 角度 比值 斜率
            or(nM=6)and not(Obj[Link[0]].Mode in[3,4]) //角度（不包括圆弧角）
            or(nM=13)and( bC or bS or not((Obj[Link[0]].Kind=1)and(Obj[Link[0]].Mode=2)))//点的值（非约束点,或按下Ctrl）
            or(nM=16)and(Obj[Link[0]].Kind=1) //向量(第一个为点)
            or(nM=17)then inc(selNum) //向量运算
          else begin
            if(nM=13)and not bC then begin Link[1]:=Obj[hit].Link[1];  LinkName[1]:=Obj[Link[1]].Name;  end;
            appendExpr(MarkObj); bAdd:=false;
            end;
       12:begin //变换
          if bC and(Obj[hit].Mode=13)then hit:=Obj[hit].Link[0];
          Obj[MarkObj]:=Obj[hit];  Obj[MarkObj].Name:=getObjName(1); //Obj[MarkObj].Name:=backObj.maxName;
          CleanLink(ObjCount,0);// for i:=0 to LinkTime do begin Link[i]:=0; LinkName[i]:=0; end;
          for i:=0 to LayerTime do ObjShow[i]:=true;
          for i:=0 to 6 do begin Cutter[i,0]:=0; Cutter[i,1]:=0; Cutter[i,2]:=0; end;
          Mode:=nM;  U:=false; Q:=false;  Lock:=false;
          Link[0]:=hit; LinkName[0]:=Obj[hit].Name;
          mainList:=0;  maskList:=0; wireList:=0; seleList:=0; tracList:=0;
          texTag:=0;  Tag:=Tag+'''';
          inc(selNum);
          case nM of
            7:R:=0; //投影率
            9:begin R:=30; D:=false; Deg:=true; end;  //旋转
           10:R:=0.6; //缩放率
           11:begin pTR.x:=1; p4.x:=2; p4.y:=0; p4.z:=0; bAdd:=false; end; //平移
           12:begin Deg:=false; R:=1; end; //向量变换
           14:begin //自定义变换
              dec(ObjCount); SelRec[0]:=1; SelRec[21]:=hit;  bAdd:=false;
              menTransClick(men128);
              end;
           15:begin //反演
              R:=3; //默认反演值
              if(Obj[hit].Kind=2)then begin Kind:=3; Mode:=15; end;//直线反演为圆
              if(Obj[hit].Kind=4)then
                begin Kind:=6; Mode:=15; S:=32; Color.A:=1; end;//平面反演为球
              end;
           16:begin //仿射
              bAdd:=false;
              for k:=0 to 2 do for j:=0 to 3 do
                Obj[MarkObj].Value[k*4+j]:=IIFi((k=j)or(j=3), 1, 0);
              ShowControlBox(MarkObj,40,tabAffine);
              end;
           end;
          if(Kind=2)and(Obj[parent].Mode in[3,4])or(Kind=6)
            then W:=Obj[1].p2.x;//棱边线宽
          end;
       17,19:inc(selNum); //路径 圆锥曲线
       18:begin //标记
          if(Obj[hit].Kind=2)then L:=DotAtLine(hit, x,y); //直线标记
          if(Obj[hit].Kind in[3,5,15,16,17,19])then L:=getPosOfCurveByMouse(hit, x,y); //曲线标记
          R:=0.3; S:=3; H:=0.2; W:=1; maxTrace:=2; F:=true; //bAdd:=false;
          color:=cgTColorToCGColorF( Obj[1].Link[2],1); color.A:=0.3;
          inc(selNum);
          end;
        end; //case Kind
      end; //begin
    1:begin //选择第二个对象
      if(nK=13)then k:=2 else k:=1; //nK=13迭代
      if(nK<>8)and(not bDotJoin)then begin Link[k]:=hit; LinkName[k]:=Obj[hit].Name; end;
      if(nK=1)and(nM=4)and(Obj[Link[0]].Kind>Obj[Link[1]].Kind)  //交点
        then begin SwapI(Link[0],Link[1]); SwapI(LinkName[0],LinkName[1]); end;
      a:=Link[0]; Ka:=Obj[a].Kind; Ma:=Obj[a].Mode; pa:=Obj[a].p0;
      b:=Link[1]; Kb:=Obj[b].Kind; Mb:=Obj[b].Mode; pb:=Obj[b].p0;
      case nK of
        1:bAdd:=false;
        2:case Mode of //直线
          2:begin //矢量
            if(trunc(Obj[MarkObj].R)>1)then begin //矢量运算
              Link[1]:=0;   LinkName[1]:=0;
              Link[4]:=hit; LinkName[4]:=Obj[hit].Name;
              end;
            if(Obj[hit].Kind=2)then bAdd:=false;
            end;
          4:begin //垂线
            if(Ka=1)and(Ma=2)and(Kb=2)and(Obj[a].Link[1]=Obj[b].Link[1]) //基点在椭圆上
              then inc(selNum)
              else bAdd:=false; //如果基点不在直线上
            end;
          5:begin //中线
            if(Ka=1)and(Kb=1)then inc(selNum)else bAdd:=false;
            end;
          6:begin //相贯线
            if(Ka in[6,7,9])or(Kb in[6,7,9])then
              begin Kind:=15; Mode:=1; parent:=15; W:=Obj[8].p2.z; end //
            else if(Ka in[3,4])or(Kb in[3,4])or(Ka=19)then
              begin Kind:=2; Mode:=6; parent:=2; end;
            bAdd:=false;
            end;
         19:bAdd:=false; //切线
         12:inc(selNum);//向量复制
          else bAdd:=false;
         end;
        3:begin //圆 圆弧
          if(Mode in[2,4])or(Mode=3)and bC //(Kb=1)
          then inc(selNum)
          else bAdd:=false;
          end;
        4:begin  //平面
          case Mode of
//            1:p1:=Obj[hit].p0; //三点面之第二点
            2:if(Ka=1)and(Kb=1)then Mode:=1 //转化为三点面
              else begin
                if(Ka=2)and(Kb=1)then SwapI(Link[0],Link[1]);
                bAdd:=false; //点线面
                end;
            3:bAdd:=false; //平行面
            4:if(Kb<3)then bAdd:=false; //垂面
            5:bAdd:=false; //中面  if not((Ka=4)and(Kb=4))then
            6:if Rand then bAdd:=false else W:=selNum; // 正多边形/多边形
            end;
          inc(selNum);
          end;
        5:bAdd:=false;//轨迹
        6:begin //实体
          if(nM=5)then begin inc(selNum); W:=selNum; if(W>1)and(W<32)then W:=W+1; end //凸壳
          else if(nM=6)then inc(selNum)  //三点球
          else bAdd:=false;
          end;
        7:begin //曲面
          if(Mode=2)then S:=16;   //直纹曲面
          if(Mode=1)then H:=towPi;//旋转曲面
          bAdd:=false;
          end;
        8:begin bAdd:=false; PointJoin(MarkObj, hit); exit; end;//合并/分离
       11:begin  //度量
          if(Mode in[6,7])and(Obj[Link[0]].Kind=1) //第一个对象为点时的角度、比值
            then inc(selNum)
            else begin
              bAdd:=false; appendExpr(MarkObj); 
              if(Mode=5)then Tag:=Obj[Link[0]].Tag + Obj[Link[1]].Tag;  //两点距离的标签为两点标签之和
            end;
          end;
       12:if(nM=12)and(Kb=1) //nM=12向量变换
            then inc(selNum) else bAdd:=false;//变换
       17:inc(selNum); //路径
       19:if(nM=2)then bAdd:=false else inc(selNum); //圆锥曲线
        end; //case nK
      end; //begin
    2:begin //选择第三个对象
      Link[2]:=hit; LinkName[2]:=Obj[hit].Name;
      inc(selNum);
      case nK of
        1,12,19:bAdd:=false; // 向量变换 圆锥曲线
        2:begin Link[3]:=hit; LinkName[3]:=Obj[hit].Name;
          Link[2]:=0; LinkName[2]:=0;  L:=5; bAdd:=false;
          end; //中线 垂线 相贯线
        3:begin //三点圆(弧)
          if(nM=3)and(Obj[Link[2]].Kind=1)then begin Link[3]:=hit; LinkName[3]:=Obj[hit].Name; end;//三点式点法弧
          bAdd:=false;
          end;
        4:begin
          if(Mode=6)and(not D)then W:=selNum else bAdd:=false; //多边形
          end;
        6:begin
          if(Mode=5)then begin W:=selNum; if(W>1)and(W<32)then W:=W+1; end;//凸壳
          if(Mode=6)then begin  //三点球
            Link[2]:=0;   LinkName[2]:=0;
            Link[4]:=hit; LinkName[4]:=Obj[hit].Name;
            bAdd:=false;
            end;
          end;
       11:begin bAdd:=false; appendExpr(MarkObj); end;
//       17:inc(selNum); //路径 无需作什么
        end; //case nK
      end;
    else begin
      if(nK=4)and(nM=6)and(not Rand)or(nK=6)and(nM in[5])or(nK=17)then begin //多边形 凸壳 路径 逐点选择顶点
        Link[selNum]:=hit; LinkName[selNum]:=Obj[hit].Name;
        inc(selNum);
        if(nK=6)and(nM=5)then begin W:=selNum; if(W>1)and(W<32)then W:=W+1; end;
        if(nK=4)then W:=selNum; //  ,17
        if selNum>=32 then begin bAdd:=false; end;
        end;
      end;
    end; //case selNum
addPlane:
    if bAdd then begin
      Obj[hit].Hot:= true;
      if bDotJoin then labHint.Caption:=SetHint(8,1,selNum)
                  else labHint.Caption:=SetHint(Kind,Mode,selNum);
      end
    else begin //
      tlbMain.Enabled:=true;  labHint.Top:=-20;
      with Obj[MarkObj] do begin  //自动生成棱边
        if(Kind=1)and(Mode=4)then //添加交点
          ObjCount:=AddingCross(MarkObj,ObjCount);
        if(Kind=6)and((Mode in[3,5])or(Mode=4)and(S<100)) //多面体或棱台 正n棱台S>100
          or(Kind=4)and(Mode=6)and(W<100)then //多边形 正n边形W>100
          ObjCount:=AddingEdges(MarkObj,ObjCount);
        end; //with
      save( 1, MarkObj, cancelNum, true,false);
      ReRelate(MarkObj, ObjCount, false,false,false );
      if(HotTool.Tag=0)or(bNail)then begin
        butProp.Down:=true;
        ShowObjProp(MarkObj,x,ClientHeight-y, true,true);  //显示构件属性框
        end;
      ObjListUpdate(MarkObj,true); //if(HotTool<>nil)then HotTool.Down:=false;
      k:=MarkObj;  ClearSelRec(0); //清空选择队列 清空时MarkObj将归零
      MarkObj:=ObjSelected( k, false,false,true,false);
      selNum:=0;
      end;// else begin
    end; //with
    if(nK<>18)then begin //非添加标注
      bR:=false; bL:=false;
      if(HotTool.Tag>0)and(not bAdd)then but10Click(HotTool);//从工具启动的添加
//      if(HotMenu.Tag>0)and(not bAdd)then but10Click(HotMenu);//从工具启动的添加
      end;
  end; //if bSel
end;
//================== 建立手绘曲线显示列表 ===================
procedure TfrmMain.setPaintList(setHot:boolean);
  var i:integer;
begin
    if(PaintListNum<PaintListCount)then inc(PaintListNum);
    if(PaintListNum>PaintMax)then PaintMax:=PaintListNum;
    if(PaintListNum=PaintListCount)then PaintListNum:=1;
    PaintData[PaintListNum]:=PaintList[0];
    with PaintData[PaintListNum]do begin
      Del:=false;   Hot:=setHot;
      if mainList=0 then mainList:=glGenLists(1);
      if wireList=0 then wireList:=glGenLists(1);
      end;
    glNewList( PaintData[PaintListNum].mainList, GL_COMPILE); //手绘显示列表 从60000开始
      glLineWidth(PaintWidth); glColor3Fv(@PaintColor);
      glEnable(GL_LINE_STIPPLE);
      glLineStipple( 1, stLineStyle[PaintStyle]); //设置线形
      i:=0;
      while(not PaintList[i].Break)or(i<PaintNum)do begin
        glBegin(GL_LINE_STRIP);//
        repeat
          inc(i);  glVertex2fv(@PaintList[i].Dot);
          until(PaintList[i].Break)or(i>=PaintNum);
        glEnd;
        inc(i);
        end;//while...
      glDisable(GL_LINE_STIPPLE);
    glEndList;

    glNewList( PaintData[PaintListNum].wireList, GL_COMPILE); //被选择时的外框 从61000开始
      glLineWidth(1); glColor3fv(@Obj[1].ColorB);
      glBegin(GL_LINE_LOOP);
      with PaintList[0].Dot do begin
        glVertex2f(x,y); glVertex2f(z,y); glVertex2f(z,w); glVertex2f(x,w);
        end;
      glEnd;
    glEndList;

    PaintNum:=0;
    SetProjection(false,false,8);
end;
procedure setPaintEllips(x0,y0, x1,y1 :single);
  var i :integer; R,t,dig, cx,cy :single;
begin
  R:=abs(x1-x0)/2;  t:=abs(y1-y0)/R/2; //半径 椭圆度
  cx:=x0+(x1-x0)/2; cy:=y0+(y1-y0)/2; //圆心
  for i:=1 to 31 do begin
    dig:=(i-1)*pi/15;
    PaintList[i].dot.X:=(cx+R*cos(dig));
    PaintList[i].dot.Y:=(cy+t*R*sin(dig));
    PaintList[i].Break:=false;
    end;
  PaintNum:=31;
end;
{======================= Mouse move =======================}
 procedure TfrmMain.FormMouseMove(Sender: TObject; Shift: TShiftState; X,Y: Integer);
  var i,j,k,m,jk,jm :integer; BacCol,ScrCol :TColor; //屏幕颜色
      t,kx,ky :single;  bb:bool;  pc,pp,pt :TcgVector;
  procedure setCursor(hit,Kind,Mode:integer; bAdd,bSel:boolean);
  begin //设置光标。光标值与构件类型一致(光标常数在Create中定义)
    if bSel or (not bAdd)and(hit>0) then   //非选择状态时忽略坐标轴
      case Kind of
       9: Cursor:=7;
      10:case Mode of 1:Cursor:=10; 2:Cursor:=18; end;
      11:case Mode of 1:Cursor:=11; 2:Cursor:=9; else Cursor:=12; end;
      15: Cursor:=2;
      16,19: Cursor:=15;
      17: Cursor:=IIFi(Mode=2, 26,16); //2三视图 else路径
      18: Cursor:=17;
      else Cursor:=Kind;
      end;
    if bAdd and not bSel or(hit<=0)then Cursor:= 25;
    end;
  label onlyView, noSelect, selText;
begin
  if EP(X-downX)and EP(Y-downY)then exit;
  if(y<24)or(bFlash)then exit;
  if bL or bR or bM then begin
    dx:=x-x0; if(dx>MoveX)then MoveX:=dx;
    dy:=y-y0; if(dy>MoveY)then MoveY:=dy;
    if bS then begin if abs(dx)>abs(dy) then dy:=0 else dx:=0; end;
    end;
  if bFrameSel then begin //框选参数、按钮等 在MouseUp事件中处理
    dx:=x; dy:=y;
    SetProjection(false,false,7);
    exit;
    end;
  if bL and(hit>60000)and not bAdd then begin //拖动手绘
    glPushMatrix;//glPushAttrib( GL_ALL_ATTRIB_BITS ); //
    glLoadIdentity;
    glTranslatef( 0, 0, -0.1);
    with PaintData[hit-60000]do begin
      pc:=getObjPos( 0,pp,cX, Clientheight-cY, 0);
      pp:=getObjPos( 0,pp,cX+x-x0, Clientheight-cY-y+y0, 0);
      dx:=dx+pp.x-pc.x;  dy:=dy+pp.y-pc.y;
      Moved:=true;
      end;//with
    glPopMatrix;
    for i:=1 to PaintListNum do PaintData[i].Hot:=(i=hit-60000);
    goto OnlyView;
    exit;
    end;   //
  if bM or bA and bL and(hit<0)or(hit=1)and(bL)and(not Obj[1].Lock)then begin //移动坐标原点 fogL:= Deep*40/(Pers+2); //雾气起点
    Origin.x:=Origin.x+dx/(sqr(Pers*0.1)+20);   Obj[1].p3.x:=Origin.x;
    Origin.y:=Origin.y-dy/(sqr(Pers*0.1)+20);   Obj[1].p3.y:=Origin.y;
    SetProjection(false,false, 7);
    x0:=x; y0:=y;
    exit;
    end;
  if bAdd and(nK=18)and(butPaintDel.Down)then begin //标记 橡皮
    Cursor:=21;
{####}if(selNum=0)then hit:= DoSelect( X,Y); {##############################}
    if(hit<=0)and(PaintHot>0)then begin
      PaintData[PaintHot].Hot:=false;
      PaintHot:=0;
      end;
    if(hit>60000)then begin
      PaintHot:=hit-60000; PaintData[PaintHot].Hot:=true;
      end;
    goto onlyView;
    end;
  if bAdd and(nK=18)and bL and not butPaintDel.Down then begin //标记 手绘
{####}if(selNum=1)then hit:= DoSelect( X, Y); {##############################}
    if(hit>0)and(hit<maxObj)then with Obj[MarkObj] do begin
      if(Link[1]<>hit)and(Obj[hit].Kind in[2,4])
        then begin Mode:=2; Link[2]:=hit; LinkName[2]:=Obj[hit].Name; end
        else begin Mode:=1; Link[2]:=0;   LinkName[2]:=0; end;
      end;
    if((hit<=0)or(hit>1024)or not(Obj[hit].Kind in[2..5,15,16,19]))and(SelNum<1)then begin //手绘
      glPushMatrix;//glPushAttrib( GL_ALL_ATTRIB_BITS ); //
      glLoadIdentity;
      glTranslatef( 0, 0, -0.1);
      if(PaintNum=0)then with PaintList[0]do
        begin tX:=x0;tY:=y0; bX:=x0;bY:=y0; end; //选择框左上角 右下角
      with PaintList[0]do begin
        if butPaintCircle.Down or butPaintRect.Down then begin
          bX:=X;  bY:=Y;
          end
        else begin
          if(X<tX)then tX:=X; if(Y>tY)then tY:=Y;
          if(X>bX)then bX:=X; if(Y<bY)then bY:=Y;
          cX:=tX; cY:=tY; //选择框左上角
          end;
        Dot:=getObjPos( 0,pp, tX, Clientheight-tY, 0); //方框左上角
         pt:=getObjPos( 0,pp, bX, Clientheight-bY, 0);
        Dot.z:=pt.x; Dot.w:=pt.y;                      //方框右下角
        end;
      if butPaintCircle.Down then begin //手绘椭圆
        with PaintList[0].Dot do setPaintEllips(x,y, z,w);
        end
      else if butPaintRect.Down then begin //手绘框
        PaintNum:=5;
        with PaintList[0].Dot do begin
          PaintList[1].Dot.x:=x;  PaintList[1].Dot.Y:=y;  PaintList[1].Break:=false;
          PaintList[2].Dot.X:=z;  PaintList[2].Dot.Y:=y;  PaintList[2].Break:=false;
          PaintList[3].Dot.X:=z;  PaintList[3].Dot.Y:=w;  PaintList[3].Break:=false;
          PaintList[4].Dot.X:=x;  PaintList[4].Dot.Y:=w;  PaintList[4].Break:=false;
          PaintList[5].Dot.X:=x;  PaintList[5].Dot.Y:=y;  PaintList[5].Break:=false;
          end;
        end
      else begin                      //手绘
        if(PaintNum>=PaintPointCount)then begin
          setPaintList(true);
          with PaintList[0]do begin tX:=x;tY:=y; bX:=x;bY:=y; end;
          end;
        inc(PaintNum);
        PaintList[PaintNum].Dot:=getObjPos( 0,pp, X, Clientheight-Y, 0); //获得构件的场景坐标
        PaintList[PaintNum].Break:=false;
        end;
      glPopMatrix;//glPopAttrib; //
      end;
    goto onlyView;
    end;
  If(bL or bR)and(nK<>18)then begin    //鼠标左键或右键按下
    if bL and(not bAdd)and(not bS)and(hit<=0)and(not Obj[1].Mask)or(bSelLink)then begin //拖动空白处，改变场景视角
      if bC then begin
        rZ:=rZ+dy/2+dx/2; Limit(rZ, 0,rZ+360, 360,rZ-360);  Obj[1].p3.r:=rZ;
        end
      else begin
        rX:=rX+dx/2;      Limit(rX, 0,rX+360, 360,rX-360);  Obj[1].p3.z:=rX;
        rY:=rY+dy/2;      Limit(rY, 0,rY+360, 360,rY-360);  Obj[1].p3.w:=rY;
        end;
      if(bR)and(MarkObj>0)then winPos[0]:= GetWinPos(MarkObj,0);
      x0:=x; y0:=y;
      end
    else if not bAdded and(hit>0)and(hit<maxObj)then begin // 拖动构件
      if(dx<>0)or(dy<>0)then bMove:=true; //用于Undo
      if bR or(bMove)and bL and(not(Obj[hit].Kind in[7,9,12,15])
        or(Obj[hit].Mode in[7,9,10,11,12,15]))//
        then MoveObj( hit, x,y, dy,-dx); //============= 拖动构件 ==============
      end;
    end
  else begin  //鼠标自由移动
    bSel:=false; willAdd:=false; //构件是否允许选择
    if(bAdd and not bDotJoin)then with Obj[ObjCount] do
      if(Kind in[1..8,15,17,19])then begin //添加[自由点]或[文字]时[点]随鼠标移动
      if(Kind=4)and(Mode=6)or(Kind=6)and(Mode in[5,6])or(Kind in[17,19])or(Mode=15)then  //多边形 凸壳 路径
        Obj[0].p0:= GetObjPos(ObjCount, Obj[0].p0, x, Clientheight-y, GetDotPos(Obj[0].p0,true).z)
      else
        case selNum of
        0:begin
          if(Kind=10)then p0:=cgVector(x,y,0)
          else p0:= GetObjPos(ObjCount, p0, x, Clientheight-y, GetDotPos(p0,true).z);
          Obj[0].p0:=p0;
          end;
        1:begin
          if(Kind=1)and(Mode=5)or(Kind=2)and(Mode in[1,5])or(Kind in[3,6,8]) //中点/两点式直线/圆
            or(Kind=4)and(Mode in[1,2,4,5]) //三点面 垂面 中面
            or(Mode in[8,9,10,12])then //复制构件
            Obj[0].p0:= GetObjPos(ObjCount, Obj[0].p0, x, Clientheight-y, GetDotPos(Obj[0].p0,true).z);
          if(Kind=4)and(Mode=2)and(Obj[Link[0]].Kind=2)
            then Obj[0].p2:=Obj[0].p0
            else Obj[0].p1:=Obj[0].p0;
          end;
        2:if(Kind=3)and(Mode in[2,3,4])
            or(Kind in[2,3,4])
            or(Mode=12)then  //三点面/三点圆/三点弧
            Obj[0].p0:= GetObjPos(ObjCount, Obj[0].p0, x, Clientheight-y, GetDotPos(Obj[0].p0,true).z);
        end; //case selNum
      Link[selNum]:=0;
      willAdd:=true;
      end;
    if bAdd and(y>20) then with Obj[MarkObj]do
      if(pnlControl.Visible)and(Kind in[14,17])and tabPath.TabVisible //按钮 路径
        then goto OnlyView;
    if(not bSelLink)then begin //选择关联构件时，posEdit将显现
      if posEdit.Visible then goto noSelect;
  {    if not isWin7or8 then begin //非Win7/Win8系统
        BacCol:= cgColorFToTColor(BackColor); bb:=false; //背景色
        for j:=-3 to 3 do for i:=-3 to 3 do begin
          ScrCol:= frmMain.Canvas.Pixels[x+i,y+j];  //获取屏幕像素颜色
          if ScrCol<>BacCol then bb:=true;     // 检测像素色是否不同于背景色
          end;
        if not bb then begin   //如为背景色
          hit:=-1; Hits:=-1; lastHit:=-1; bSel:=false;
          if willAdd then goto onlyView else goto noSelect; //在屏幕背景上移动鼠标时什么都不做
          end;
        end; }
      end;
    bAxisTagSeled:=false;
{############### 选择对象 #############################################}
  hit:= DoSelect( X, Y); {#############################################}
{######################################################################}
    if(hit>60000)then goto OnlyView;
    if(hit>0)and(Obj[hit].Kind=4)and(cheCutter.Visible)then goto noSelect; //选择剪裁平面
    if(bSelLink)and(hit<>hotID)then begin //选择关联构件 (not bAdd)and  in[10,11]
      if(hit>0)and((hit>=MarkObj)or(Obj[hit].Kind<>1))and(Obj[MarkObj].Kind=11)and(posEdit.Visible)and(posEdit.Tag=3)
        then hit:=-1; //文本“绑定”到点
      if(hit>10)and(Obj[hit].Edited)then hit:=-1; //Edited 子对象标记,在VarAMouseDown中设置
      if(hotID>0)then Obj[hotID].Seled:=false;
      if(hit>0)and(Obj[MarkObj].Kind<>13)and(not(cheCutter.Visible) or(cheCutter.Visible)and(Obj[hit].Kind=4))
        then Obj[hit].Seled:=true;
      if(hit>1)and(Obj[MarkObj].Kind=13)then begin
        if(Obj[hit].Kind=1)then Obj[hit].Seled:=true
                           else hit:=-1;
        end;
      if(hit>10)and(Obj[hit].Kind=17)and(Obj[hit].Mode=2)then hit:=-1; //三视图不能关联
      if(hit>10)and(Obj[hit].Kind=7)then hit:=-1;
      hotID:=hit;
      end;
    if (hit<1)then //  添加对象时可以选择对象标签 not(bSelLink)and
    for i:=1 to ObjCount do with Obj[i] do //选择标签
      if(delID=0)and not(Kind in[10,11,14])and(bAll or ObjShow[Layer])then begin //标签
        if(x>=TagPos.x)and(x<=TagPos.x+TagSize.x)and(Height-titleHeight-y>=TagPos.y)
            and(Height-titleHeight-y<=TagPos.y+TagSize.y)
          then begin
            hit:=i;
            if bSelLink and ObjIsParent(MarkObj, i)then hit:=-1;
            if(hit in[2..4])then begin inc(hit,3); bAxisTagSeled:=true; end; //遇到坐标轴的标签相当于遇到坐标平面
            if bAdd and(Obj[hit].Kind in[10,14])then goto selText;
            end;// if(nK<>5)then goto selText; //
        end;
    if(hit<1)and not(cheCutter.Visible)then // 添加轨迹线时可以选择参数
      for i:=11 to ObjCount do with Obj[i] do //选择计算式 文字
        if(delID=0)and((Kind=11)or(Kind=10)and(Mode=1))and(bAll or ObjShow[Layer])then begin
          if(Kind=10)and(Mode=2)then t:=L else t:=1;
          if(x>=p0.x)and(x<=p0.x+TagSize.x*t)and(y>=p0.y-TagSize.y*t-24-(titleHeight-29))and(y<=p0.y-24-(titleHeight-29))
            then begin
              hit:=i;
              if bSelLink and ObjIsParent(MarkObj, i)then hit:=-1;
              if(bSelLink)and(i>0)then bSel:=true;
              if(nK<>5)and(nK<>7)then goto selText;
              end;//
          end;
    if not(bSelLink)and(hit<1)and not bAdd and not(cheCutter.Visible)then begin //
      Hits:=0;
      for i:=11 to ObjCount do with Obj[i] do begin //选择图片
        if(delID=0)and(Kind=10)and(Mode=2)and(bAll or ObjShow[Layer])then begin
          if(Kind=10)and(Mode=2)then t:=L else t:=1;
          if(x>=p0.x)and(x<=p0.x+TagSize.x*t)and(y>=p0.y-TagSize.y*t-24-(titleHeight-29))and(y<=p0.y-24-(titleHeight-29))
            then begin
              hit:=i;  inc(Hits);
              SelectBuf[Hits-1]:=i;
              if bSelLink and ObjIsParent(MarkObj, i)then hit:=-1;
              if(bSelLink)and(i>0)then bSel:=true;
              end;//
          end;
        end;
      if(Hits>0)then begin
        if(Hits=1)then
          hit:=SelectBuf[0] //唯一选择
        else begin //有重叠
          j:=-1;
          for i:=0 to Hits-1 do
            if(Obj[SelectBuf[i]].Hot)then j:=i;   //检索有否已被选择的构件
          if(j<0)then hit:=SelectBuf[0]
            else hit:=SelectBuf[j];
          end;
        end;
      if(nK<>5)and(nK<>7)and(Hits>0)then goto selText;
      end;
    if(nK=10)and(nM=1)and(hit>10)then begin //显示/隐藏标签
      bSel:=true;  goto selText;
      end;
    with Obj[hit] do begin
    if bAdd and(hit>0)and(hit<maxObj)then begin  //添加构件时选择对象
      k:=Kind; m:=Mode; j:=Obj[MarkObj].Link[0]; jK:=Obj[j].Kind; jM:=Obj[j].Mode;
      case selNum of
      0:case nK of  //选择第一个对象
        1:case nM of   // 点
          1,2:bSel:=(hit<MarkObj)and((k in[2,3,5,9,13,15,16,17,19]) //约束点，选择直线、圆、平面、球体或圆台体
            or(k=1)and(m=6) //拾取等分点
            or(k=6)and(m in[1,2,6,8..12,15])
            or(k=4)and((hit>10)or(hit in[5,6,7])))
            or(k=19)and(m=3); //双曲线的渐近线
          3:bSel:=(k=1);  //最近点
          4:bSel:=(k in[2..7,9,15,16,17,19]); //交点，选择直线、圆或轨迹线
          5:bSel:=(k in[1,2,4])or(k=3)and(m>1);  //中点 圆弧的圆心
          6:bSel:=(k in[2,3,4,5,6,15,16,17,19]);  //等分点
          end;
        2:case nM of
          1,3: bSel:=(k in[1..5,15,16,17,19]); //线段、点向线、平行线 第一点
          2:if trunc(Obj[MarkObj].R)<2 then //向量
              bSel:=k in[1..5,15,16,17,19]
            else
              bSel:=k<3;
          4:bSel:=(k<5);      //垂线、共垂线
          5:bSel:=(k<3);      //中线
          6:bSel:=(k in[3,4,6,7,9]) //交惯线
                or(k=19)and((m=1)and(Obj[hit].Angle>0.5)or(m=2)and(R>1)); //渐近线/准线
         19:bSel:=(k in[1,3]);//切线
          end;
        3:bSel:= k in[1..5,15,16,17,19];  //圆、圆弧，选择点
        4:case nM of      //平面
          1,3,4:bSel:= k=1;  //三点式
          2:bSel:= k in[1,2]; //点线式、线线式
          5:bSel:= k in[1,2,3,4];  //中面
          6:bSel:= k in[1..5,15,16,17,19];  //多边形
          end;
        5:bSel:= k=1; //轨迹: 选择轨迹点
        6:bSel:=(nM in[1,2,3,5,6])and(k in[1,2,3,5,13,15,16,17,19])
              or(nM=4)and(Obj[ObjCount].S>0)and(k in[1..5,15,16,17,19])  //棱台: 选择基点
              or(nM=4)and(Obj[ObjCount].S=0)and(k=4); //凸棱台: 选择多边形 and(hit>10)
        7:if(hit>0)then //and not((k=2)and(m=6))
          case nM of   //曲面
          1:bSel:=(k in[2,3,4,5,15,16,17,19])and not((k=4)and(m=6)and not D);//旋转曲面的母线，选择直线、圆、轨迹线、平面(凸壳除外)
          2:bSel:=(k in[1,2,3,4,5,15,16,17,19]); //直纹曲面，选择第一条边际线
//          3:bSel:=(k=5); //复合曲面的第一条轨迹，选择轨迹线 and(m<5)
          4:bSel:=(k in[1,2,3,4,5,16,17,19]); //轨迹面，选择直线、圆、轨迹
          end;
        8:bSel:=(k=1); //合并/分离，选择自由点或约束点
       11:case nM of //度量
          3:bSel:=(k in[3,4,6,7]);//面积
          4:bSel:=(k=6)and((m<>5) or (m=5)and(W=4)); //体积 四面体凸壳
          5:bSel:=(k in[1,2]);    //距离
          6:bSel:=(k in[1,2,3,4]);//角度
          7:bSel:=(k in[1,2,3]);  //比值
          8:bSel:=(k in[2,3,4,5,15,16,17,19]);//长度
          9:bSel:=(k=2);          //斜率
          10,11,12,15:bSel:=(k=1);//坐标
          13:bSel:=(k=1);         //约束值
          14:bSel:=(k=3)or(k=6);  //直径
          16:bSel:=(k in[1,2,3,4]);               //向量
          17:bSel:=(k in[2,3,4])or(k=11)and(m=16);//向量运算
          19:bSel:=(k in[2,4])or(k=3)and EP(Obj[parent].H); //方程
          end;
       12:begin //变换
          if(nM=15)then bSel:=(k in[1..4,5,7,9,15,16,19])or(k=17)and(m=1)or(k=6)and(m=1) //反演
            else bSel:=(hit>10)and(k in[1..7,9,15,16,19])or(k=17)and(m=1)or(hit in[1..4]); //复制构件的父构件
          if nM=11 then begin //平移
            Obj[MarkObj]:=Obj[hit];
            with Obj[MarkObj]do begin
              Name:=getObjName(1);   p4.x:=2;  // Name:=backObj.maxName;
              CleanLink(MarkObj,0); // for i:=0 to LinkTime do begin Link[i]:=0; LinkName[i]:=0; end;
              Kind:=Obj[hit].Kind; Mode:=nM;  U:=false;
              Link[0]:=hit; LinkName[0]:=Obj[hit].Name;
              end;
            end;
          end;
       14:bSel:=(k=1)and(m=2); //控制按纽
       17:if(nM=1)then bSel:=(k in[1,2,3,5,15,16,19]) or (k=4)and(hit>10) or (k=17)and(m=1)//路径
                  else bSel:=(k in[1..7,15,16,19]) or (k=17)and(m=1); //nM=2 三视图
       18:bSel:=(k in[2..5,15,16,17,19]); //标记
       19:bSel:=(nM=1)and(k=1)or(nM=2)and(k=2);// in[1..5,15,16,17,19]); //圆锥曲线
        end;
      1:if(hit<>j)or(nK=3)and(nM=1)or(nK=5)or(nK=12)then //已选择的第一个构件不能再次被选择
        case nK of //选择第二个对象
        1:case nM of  //点
          3:bSel:=k in[2,3,4,5,15,16,17,19]; //最近点
          4:case jK of //交点
            2,3,5,15,16,17,19 :bSel:=(k in[2..7,9,15,16,17,19]); //第一个构件已选择了线
            4,6,7,9 :bSel:=(k in[2,3,5,15,16,17,19]); //第一个构件已选择了面
            end;
          5:if Obj[j].Kind=1 then bSel:=(k in[1,2,3,4])and(hit<>MarkObj)  //中点 选择第二点或直线
                             else bSel:=(k=2)and(hit<>MarkObj); //选择直线
          6:if W<1 then with Obj[MarkObj] do info[0]:=info[0]+' '+IntToStr(hit)
                   else bSel:=k in[2,4];
          end;//case nM
        2:case nM of  //直线
          1:bSel:= k in[1..5,15,16,17,19];  //两点式，选择第二点
          2:bSel:=(Obj[Obj[MarkObj].Link[3]].Kind = k); //向量运算  (jk=1)and(k=1)or(jk=2)and
          3:bSel:= k in[2,3,4];  //平行线，选择平行直线
          4:bSel:=(jk=1)and(k in[1,2,4])  //垂线
                or(jk=2)and(k in[2,3,4]);
          5:bSel:=(jk=1)and(k in[1,2])or(jk=2)and(k in[2,4]); //中线
          6:bSel:=(k in[3,4,6,7,9]); //交惯线
         19:bSel:=(jk=1)and(k in[3,5,15,16,17,19])//切线 构造之后转为垂线
                or(jk=3)and(k=3)
                or(jk in[5,15,16,17,19])and(k=1);
          end;
        3:case nM of  //圆
          1:bSel:=(jK>1)and(k=1)or(jK=1)and(k in[1,2,3,4,19]); //点径圆，选择法线
          2,4:bSel:=(k=1);  //三点圆,三点弧, 选择第二点
          3:bSel:=(k<4);    //点法弧，选择法线
          end;//case nM
        4:case nM of  //平面
          1:bSel:=k in[1..5,15,16,17,19]; //三点式，选择第二点    (jK=1)and(k=2)or(jK=2)and
          2:bSel:=(k<3); //点线式，选择直线或第二点
          3:bSel:= k in[2,3,4]; //平行面
          4:bSel:= k in[1,2,3,4]; //垂面
          5:if jk=4 then bSel:=(k in[1,3,4])and(hit<>MarkObj)   //中面，选择第二点
                    else bSel:=(k<5)and(hit<>MarkObj);
          6:begin //多边形
            if Obj[MarkObj].Rand then bSel:=(k in[1,2,4])and(hit<>MarkObj) //正多边形
                 else bSel:=(k=1); //任意多边形
            end;
          end;//case nM
        5:bSel:=(k in[1,11])and(m=2)and(hit<j)and ObjIsParent(hit,j)
                or(k=1)and(m=2)and(hit=j); //轨迹
        6:if(nM=5)then bSel:=(k in[1,2,3,5,13,15,16,17,19])
                  else bSel:=(k<5); //实体，选择法线
        7:begin
          case nM of  //曲面
          1:bSel:=(k=2)and(m<>6); //旋转曲面的轴线，选择直线
          2:bSel:=(k in[3,4,5,15,16,17,19])or(k=2)and(m<>6); //直纹曲面，选择第二条边际线
          3:bSel:=(k in[5,15,16,17,19]); //复合曲面的第二条轨迹，选择轨迹线
          4:bSel:=(k in[1,11])and(m=2)and(jK>1)and(Obj[Obj[hit].Link[1]].Kind<>4)and ObjIsParent(hit,j) //轨迹面，选择限制点
                or(k=1)and(m=2)and(jK=1)and(Obj[Obj[hit].Link[1]].Kind=4)and ObjIsParent(hit,j);
          end;//case nM
          end;
        8:bSel:=(k in[1..5,15..17,19])and(hit<MarkObj); //合并，选择线状构件
       11:case nM of
          5:bSel:=(k in[1,2,4]);//距离
          6:if jk=1 then bSel:=k=1 else bSel:=(k in[2,3,4]);//角度
          7:if jk=1 then bSel:=k=1 else bSel:=(k in[2,3]);//比值
          9:bSel:=k in[3,4]; //斜率
          13:bSel:=k in[2..5,15..17,19];//点值的线状构件
          16:bSel:=(k=1);                          //向量
          17:bSel:=(k in[2,3,4])or(k=11)and(m=16); //向量运算
          end;
       12:case nM of //变换
          7:case jk of //投影
            1,2:bSel:= (k in[2,3,4]); //点、线的投影
            6:  bSel:= (k<5);//球体
            else bSel:=(k in[2,4]);//圆、平面、轨迹的投影
            end;
          8:bSel:=(k in[1..4])and(hit<>MarkObj);  //对称变换
          9:bSel:=(k in[1,2,3,4]);  //旋转变换
         10:bSel:=(k=1);  //缩放变换
         12:bSel:=(k in[1,2]);  //向量变换
         14:bSel:=(m in[7..12]); //自定义变换
         15:bSel:=(k in[1,3]); //反演
          end;
//       13:bSel:=(k=1); //迭代
       17:if(nM=1)then bSel:=(k in[1,2,3,5,15,16,19]) or (k=4)and(hit>10) or (k=17)and(m=1)//路径
                  else bSel:=(k in[1..7,15,16,19]) or (k=17)and(m=1); //nM=2 三视图
       19:bSel:=(k=1); //圓錐曲線
        end; // case nK
      else if(hit<>j)and(hit<>Obj[MarkObj].Link[1])or(nK=17)or(nK=12)then begin //选择第三个对象
        if(nK=2)and(nM=4)then bSel:=(k in[2,3,4]) //垂线  or(k=4)and(hit>10)
        else if(nK=2)and(nM=2)then bSel:=(k=1) //矢量运算
        else if(nK=2)and(nM=5)then bSel:=(k=1) //中线 第三点
        else if(nK=3)and(nM=3)then bSel:=(k=1) //点法弧
        else if(nK=4)and(nM=3)then bSel:=(k<3) //平行面
        else if(nK=4)and(nM=4)then bSel:=(k<5) //垂面
        else if(nK=17)then begin
          if(nM=1)then bSel:=(k in[1,2,3,5,15,16,19]) or (k=4)and(hit>10) or (k=17)and(m=1)//路径
                  else bSel:=(k in[1..7,15,16,19]) or (k=17)and(m=1); //nM=2 三视图
          end
        else if(nM=9)then bSel:=(k in[2,3,4,6])//旋转变换
        else bSel:=k in[1..5,15,16,17,19]; //三点圆(弧)、三点球、多边形、仿射复制、度量角度、度量比值
        end;
      end; // case selNum  or(SelNum>0)
      if bSel and(not bDotJoin)
        and((Obj[hit].Kind=1)
          or(Obj[hit].Kind in[2,3,4])and(SelNum>0)
          and(not( (nK=2)and(nM=1) or (nK=3)and(nM in[2,4]) or (nK=6)and(nM in[5,6]) )))
      then begin
        Obj[ObjCount].Link[selNum]:=hit;
        Obj[0].p0:=Obj[hit].p0;
        end;
      end; //if bAdd and(hit>0)
      if(hotID<>hit)then begin
        if bAdd and(hotID>0)then Obj[hotID].Seled:=false;
        if(bSel)then Obj[hit].Seled:=true;
        hotID:=hit;
        end;
SelText:
      end; // with... if...
    end; // else begin 鼠标自由移动
onlyView:
  SetProjection(false,false,7);
noSelect:  //在屏幕背景上移动鼠标时什么都不做
  if(cheCutter.Visible)then begin //关联剪裁面，仅选择平面
    bSel:=(hit>4)and(Obj[hit].Kind=4);
    if not bSel then hit:=-1;
    end;
  leftHit:=hit;
  if(hit>10)and(Hit<maxObj)and(Obj[hit].noSel)and not bAdd then leftHit:=-1;
  if(leftHit>0)and(leftHit<maxObj)and(not butPen.Down)then  //设置光标。光标值与构件类型一致(光标常数在Create中定义)
    setCursor(leftHit,Obj[leftHit].Kind,Obj[leftHit].Mode, bAdd,bSel)
  else begin
    if(leftHit>60000)and not butPen.Down then Cursor:=22 //手绘
    else if butPen.Down and not butPaintDel.Down then Cursor:=19 //手绘笔
    else if butPen.Down and butPaintDel.Down then Cursor:=21 //橡皮擦
    else if bAdd and not butPen.Down then Cursor:=25//添加构件
    else if(leftHit<1)then Cursor:= 24 //默认箭头
    end;
  if(bL or bR)and(not bAdd)then begin x0:=x;  y0:=y; end;
end;

procedure TfrmMain.SelMultyObj(var MarkObj, hit, Hits, x,y:integer);
  var i:integer;
begin
  lastSel:=MarkObj;
  if(Hits>1)then begin
    i:=0;repeat inc(i); until Obj[SelectBuf[i-1]].Hot or(i=Hits);
    if not(pnlControl.Visible)and not bDouble//
      then MarkObj:=ObjSelected(hit, bS,bC,bL,bR);
    if(i<Hits)then inc(i) else i:=1;
    hit:=SelectBuf[i-1];
    if not(pnlControl.Visible)and not bDouble//
      then MarkObj:=ObjSelected(hit, bS,bC,bL,bR);
    end
  else
    if not(pnlControl.Visible)and not bDouble//
      then MarkObj:=ObjSelected(hit, bS,bC,bL,bR);
end;
{======================= Mouse Up =======================}
procedure TfrmMain.FormMouseUp(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
  var i:integer;  pp:TcgVector;
begin
  if bFrameSel then  begin //框选状态 bFrameSel在MouseDown事件中赋值
    for i:=11 to ObjCount do with Obj[i]do
      if not Seled and Hot then begin
        inc(SelRec[0]); SelRec[20+SelRec[0]]:=i; inc(SelRec[Kind]);
        end;
    bFrameSel:=false;
    if(SelRec[0]>0)then begin
      menCopyObj.Enabled:=true;   menObjDel.Enabled:=true;
      menObjHide.Enabled:=true;   menTagHide.Enabled:=true;
      CountObjNum(false,false);
      end;
    end;
  if not bAdd and bR and(Hits>1)then begin bR:=false; exit; end; //右键点击重叠构件
  if bAdd and(nK=18)and(SelNum>0)then  //添加标注
    with Obj[MarkObj] do begin
    Obj[Link[1]].Seled:=false; Obj[Link[1]].Hot:=false; //
    Link[0]:=0; LinkName[0]:=0;
    if(hit>1)and((Mode=2)or(Mode=1)and(Obj[Link[1]].Kind<>4))then begin
      if(Mode=2)then begin TagP.z:=0; R:=0.5; end;
      bAdd:=false;
      ReRelate(MarkObj, ObjCount, false,false,false );
      SetProjection(true,false,7);
      ObjListUpdate(MarkObj,true);
      save(1,MarkObj,1,true,false);
      AppendObj(181, 0);
      end;
    if(hit<1)then begin //空白处抬起鼠标
      Mode:=1;
      Link[1]:=0; LinkName[1]:=0;
      Link[2]:=0; LinkName[2]:=0;
      end;
    bL:=false; bR:=false; SelNum:=0;
    exit;
    end;
  if bAdd and(nK=18)and(SelNum=0)and(PaintNum>0)then begin  //手绘时松开鼠标
    PaintList[PaintNum].Break:=true;
    if(butPaintCircle.Down)or(butPaintRect.Down)then setPaintList(true);
    end;
  if(hit>60000)then //拖动手绘
    with PaintData[hit-60000] do begin
      Hot:=Moved;  Moved:=false; menObjDel.Enabled:=false;
      for i:=1 to PaintListNum do if PaintData[i].Hot then menObjDel.Enabled:=true;
    end;
//###非添加状态选中了一个构件######
  if not bDouble and not bAdd and lastHot and(hit>0)and(hit<maxObj)and(leftHit>0)and(MoveX=0)and(MoveY=0)then begin
    lastSel:=MarkObj;
    SelMultyObj(MarkObj,hit,hits,x,y);
    if not bR and(SelRec[0]=0)then begin
      butProp.Down:=false; pnlProp.Visible:=bNail; pnlProp.Height:=44;
      end;
    end;
  if bDouble then begin
    if(lastSel>0)then begin SelRec[0]:=1;   SelRec[21]:=lastSel; end
                 else begin SelRec[0]:=0;   SelRec[21]:=0; end;
    end;
  bL:=false; bR:=false; bDouble:=false;  bM:=false;  Cursor:=0;
  if(MarkObj>0)and bNail then
    ShowObjProp(MarkObj, x,ClientHeight-y, bL,bR);  //显示构件属性框
  if not bAdd and(leftHit>0)then with Obj[MarkObj] do begin
    i:=IIFi((Kind in[1,3,6,18])or(Kind=2)and(Mode<>13), MarkObj, Link[0]);
    if not bAdd and bMove and(MarkObj>10) and(Kind in[1,2,3,4,6,10,11,17,18]) //移动对象
      then Save(0, i, 1, true,false); //备份
    end;
  bDown:= false; bMove:= false;
  if not bAdd then begin
    labHint.Top:=-20;
    if(hit>10)and(pnlProp.Visible)then ShowProp(MarkObj,false);
    bAdded:=false;
    end;
  if not(pnlControl.Visible)then edtTemp.SetFocus;
  if(dx=0)and(dy=0)then MainDraw( GL_RENDER, false,'e')
    else menXYZ.Checked:=false;
end;
{======================= Mouse DblClick =======================}
procedure TfrmMain.FormDblClick(Sender: TObject);
begin
  bDouble:=true; //双击状态
  if(hit<1)and(bC or bA or bS) then begin //原点归位
    Origin:=cgOrigin; Obj[1].p3.x:=0; Obj[1].p3.y:=0;  SetProjection(true,false,0);
    end;//if(hit<1)...
  if(hit>0)and(hit<maxObj)and(not bAdd)then with Obj[hit]do begin
    MarkObj:=hit;   Obj[hit].Hot:=lastHot;
    if Mode=16 then //仿射变换
      ShowControlBox(MarkObj,40,tabAffine)
    else case Kind of
    1,2,3,4:begin //标记中心/轴/平面
      if(lastSel>0)then MarkObj:=lastSel;
      FlashSize:=5;   Obj[0].Way:=false;
      bFlash:=true;   timFlash.Enabled:=true;
      MarkTrans[3,0]:=MarkObj;  menMark3.Checked:=true;
      MarkTrans[4,0]:=MarkObj;  menMark4.Checked:=true;
      end; //变换标记闪烁   if Hot then Hot:=false;
    6:if(bS or bC)and(Mode in[2,4])then begin //圆台 棱台
        if W<>trunc(W)then W:=ord(bC) else W:=1-W;
        reRelate(hit,ObjCount,false,false,false);
        end;
    9,16:begin //函数图像
      if(Mode in[1..6,13])then ShowControlBox(hit, Kind,tabFunc);// pnlFuncShow; //显示方程式
      end;
    10:case Mode of
      1:begin //文本
        memText.text:=info[2];
        pnlControl.Left:=trunc(p0.x); pnlControl.Top:=trunc(p0.y-TitleHeight);
        tlbMain.Enabled:=false;       tlbMenu.Enabled:=false;
        ShowControlBox(hit,10, tabText);
        end;
      2:begin //图片
        OpenPicture(hit,true,true);    hit:=0;   Cursor:= crArrow;
        end;
      end;
    11:case Mode of
      1:begin ShowControlBox(MarkObj, 11, tabCalc ); end;  //计算框
      2:begin L:=R; //参数 恢复原值
          reRelate(hit,ObjCount,false,false,false);
          MarkObj:=hit; Obj[MarkObj].Hot:=true;
        //  cmbTag.ItemIndex:=Obj[hit].ShowID;
          end;
      end;
    13:ShowControlBox( MarkObj,13, tabIterate);// pnlIterateShow(false); //显示迭代规则
    17:ShowControlBox( MarkObj,17, tabPath);  //路径 三视图
    18:if(Mode=2)then begin //角度标记
      TagP.z:=0; 
      ReRelate(MarkObj, MarkObj, false,false,false );
      SetProjection(true,false,21);
      end;
    end;//case Kind
    end;//if(hit>0)...
end;
{======================= MouseWheel =======================}
procedure TfrmMain.FormMouseWheel(Sender: TObject; Shift: TShiftState; WheelDelta: Integer; MousePos: TPoint; var Handled: Boolean);
  var i:integer;
begin
  if not bC then exit;
  Deep:=Deep+IIFf(WheelDelta>0,0.5,-0.5);    if Deep<2 then Deep:=2;
  varDeep.Caption:=ftos(Deep,2);  Obj[1].p4.x:=Deep;
  setFog;
  for i:=1 to ObjCount do with Obj[i] do
    if(Kind=2)and(H>0)then Lineer( i,true,true,false); //重画直线箭头
  SetProjection(false,false,22);
end;
//======================== 改变屏幕尺寸 ===========================
procedure TfrmMain.FormResize(Sender: TObject);
  var i:integer;
begin
  rView:= Width/Height;
  titleHeight:= Height-ClientHeight+2;
  tlbMain.Width:=frmMain.ClientWidth-tlbMenu.Width+2;
  stbBar.Width:=frmMain.ClientWidth+2;
  if not bNail then begin pnlProp.Hide; butProp.Down:=false; end;
  for i:=11 to ObjCount do with Obj[i]do if(Kind=14)then begin //控制按钮位置
    if((p0.x+W)>Width)then
      begin p0.x:=Width-butID.Width; butID.Left:=trunc(p0.x); end;
    if(p0.y>ClientHeight)then
      begin p0.y:=ClientHeight-1; butID.Top:=ClientHeight-TitleHeight-trunc(H); end;
    end;
  SetProjection(false,false,12);
  for i:=11 to ObjCount do
    if(Obj[i].Kind in[10,11,14])then TextAndImage(i, false,true,true,false);
//  MainDraw( GL_RENDER, false, 'd');
end;
procedure TfrmMain.FormPaint(Sender: TObject);
begin
  if frmMain.Enabled then MainDraw( GL_RENDER, false, 'c');
end;
//============ 关闭窗口前检查是否保存已经编辑的模型 ================
procedure TfrmMain.FormCloseQuery(Sender: TObject; var CanClose: Boolean);
begin
  if bPW then CanClose:=true
         else CanClose:=isReadOnly or checkSaved; //未注册则直接结束
end;
//======================== 关闭程序 ===============================
procedure TfrmMain.FormClose(Sender: TObject; var Action: TCloseAction);
  var i :integer; G :TextFile;  st:string; //文本文件句柄
  function FtS( v :single; Len,Dot :integer) :string;   //将浮点数转换为格式文本
    begin str( v:Len:Dot, result); end;
  function its( v:integer):string;
    begin if v>9999 then v:=9999; if v<-999 then v:=-999; str( v:4, result); end;
begin
  AssignFile( G, initFile);//获取UseFile的句柄
  try
    try
      ReWrite( G);          //打开UseFile
      for i:= 0 to FileCount do WriteLn( G, aryFile[i]); //写入文本最近打开的文件名
      WriteLn( G, 'End');
      with Obj[8]do begin   //记录环境变量
        WriteLn( G, 'Point ' +fts(p1.x,5,2) +fts(Link[1],10,0)+ fts(Obj[1].p1.r,3,0)); //点径 颜色
        WriteLn( G, 'Line  ' +fts(p1.y,5,2) +fts(Link[2],10,0)); //线径 颜色
        WriteLn( G, 'Circle' +fts(p1.z,5,2) +fts(Link[3],10,0)); //圆线径 颜色
        WriteLn( G, 'Plane ' +fts(p1.w,5,2) +fts(Link[4],10,0)); //平面边径 颜色
        WriteLn( G, 'Solid ' +fts(p2.x,5,2) +fts(Link[5],10,0)); //实体棱径 颜色
        WriteLn( G, 'Curve ' +fts(p2.y,5,2) +fts(Link[6],10,0)); //曲线线径 颜色
        WriteLn( G, 'Face  ' +fts(p2.z,5,2) +fts(Link[7],10,0)); //曲面 颜色
        WriteLn( G, 'Accura' +fts(p2.w,5,2) +fts(Link[8],10,0)); //计算小数 颜色
        WriteLn( G, 'Select' +fts(p5.w,5,2) +fts(Link[9],10,0)); //坐标轴经 选择色
        WriteLn( G, 'TagSiz' +fts(TagP.z,5,2) +fts(Link[10],10,0));//标签字号 颜色
        WriteLn( G, 'TagNam' +info[1]); //标签字体

        WriteLn( G, 'TagSty' +Obj[1].TagT+ fts(TagS,5,0)); //原点字号
        WriteLn( G, 'TagN  ' +Obj[1].TagN); //原点字体
        WriteLn( G, 'Color ' +fts(LinkName[0],10,0) +fts(LinkName[1],10,0)  //背景色 原点色
                             +fts(LinkName[2],10,0) +fts(LinkName[3],10,0) +fts(LinkName[4],10,0)   //坐标轴色
                             +fts(LinkName[5],10,0) +fts(LinkName[6],10,0) +fts(LinkName[7],10,0)); //坐标平面色

        WriteLn( G, 'Transp' +fts(p5.x,5,2)  +fts(p5.y,5,2)  +fts(p5.z,5,2)); //坐标平面透明度
        WriteLn( G, 'Mode  ' +fts(pTR.x,4,0) +fts(pTR.y,4,0) +fts(pTR.z,4,0)
                         +' '+fts(pBL.x,1,0) +fts(pBL.y,1,0) +fts(pBL.z,1,0)); //坐标平面模式

        WriteLn( G, 'Origin' +fts(p3.x,5,1)  +fts(p3.y,5,1)  +fts(p3.z,5,1) +fts(p3.w,5,1) +fts(p3.r,5,1));//坐标原点位置 视角
        WriteLn( G, 'Axis  ' +fts(Vec.x,6,1) +fts(Vec.y,6,1) +fts(Vec.z,6,1) +fts(W,6,1) //轴线长度 原点大小
                             +fts(Vec.w,6,1) +fts(Vec.r,6,1) +fts(p4.r ,6,1));//轴线尾
        WriteLn( G, info[2] ); //坐标轴标签 字串中已包含'AxiTag'
        WriteLn( G, 'Window' +its(Link[20]) +its(Link[21]) +its(Link[22]) +its(Link[23]));
        WriteLn( G, 'Deep  ' +fts(p4.x,5,2) +fts(p4.y, 5,2) //景深 透湿度
          +its(pnlList.Left) +its(pnlList.Top) +its(pnlList.Width) +its(pnlList.Height) //对象列表位置大小
          +its(pnlProp.Left) +its(pnlProp.Top)); //属性框位置

        if iLanguage=1 then WriteLn( G, 'Taiwan ');
        if iLanguage=2 then WriteLn( G, 'English');
        WriteLn( G, 'Scene ' +info[0]);
        WriteLn( G, 'Finish');
        end;
    finally
      closeFile( G);        //关闭文件
    end; // try
  except                  //出错处理
    MyMessage( 'Can''t open file ' + initFile);
  end; //try
  glDeleteLists( 1, 65000);
  for i:=11 to maxObj do with Obj[i] do begin
    glDeleteTextures(1,@texID); //释放纹理内存
    glDeleteTextures(1,@texTag); //释放纹理内存
    if Assigned( timID)then timID.Enabled:=false;
    end;
  setMem(-1,true);
//  setLength(backObj, 0);//Undo备份
  for i:=0 to PageTime do setLength( Objs[i], 0);//页面
//  for i:=0 to PageTime do setLength( BackObjs,0);//Undo页面备份
  Application.Terminate;
end;
//======================== 响应菜单或工具 =====================
procedure TfrmMain.ToolResponse(t:integer); //响应菜单或工具
  var i,j,hit :integer;  ch:Char;  Key:word;
begin  //caption :=itos(ObjCount)+' '+itos(HotTool.Tag);
  HideAllPanel;
  timAuto.Enabled:=false;   CancelNum:=0;
  case t of
    1:if not isReadOnly then with tabPage do begin
      Tabs.Clear;  Tabs.Add('Page1');  TabIndex:=0;
      Start( false);      //不打开画板文件，仅初始化画板
      end;
    2:if not isReadOnly then SaveFile( sgfFile); //Save
    3:if not isReadOnly then SaveFile( '');      //Save as...
    4:close;
    5:if((MarkObj>10)or(PaintListNum>0))and(not bAdd)then DeleteObj(MarkObj, true); //Delete
    6:Undo( true);        //Undo
    7:Undo( false);       //Redo
    8:begin ch:='A'; FormKeyPress(nil, ch); end; //显示全部
    9: Shellexecute(0,nil,'inRm3D Help.chm',nil,nil, SW_SHOWDEFAULT);
    10:frmDrag.Show; //Save as Image

    11..132,161,171,181,191..194: AppendObj( t, 0);   // 添加构件  frmMain.Enabled:=false;
    141..146:begin //添加控制按纽
      hit:=MarkObj; inc(ObjCount); MarkObj:=ObjCount;
      with Obj[MarkObj] do begin                       //  ↑↓
        Name:=getObjName(1);  //inc(backObj.maxName); Name:=backObj.maxName;
        Kind:=14; Mode:=t-140;     delID:=0;
        p0.x:=40; p0.y:=100; W:=70; H:=24;   S:=50;   R:=0.1;//S触发频率 R移动步长
        maxTrace:=10;   nTrace:=0; U:=Mode=6; D:=false; Q:=false;
        TagN:='Arial';  TagS:=9;   TagT:='0000';  TagC:=0;
        TagSize.X:=70;  TagSize.Y:=24;
        case Mode of
          1: Tag:=SwitchS(iLanguage,'动画','動畫','Animation...','');
          2: Tag:=SwitchS(iLanguage,'移动','移動','Move...','');
          3: Tag:=SwitchS(iLanguage,'隐藏','隱藏','Hide','');
          4: Tag:=SwitchS(iLanguage,'系列...','系列...','Presentation...','');
          6: Tag:=SwitchS(iLanguage,'链接...','鏈接...','Link...','');
          end;
        tabPath.Caption:=Tag;
        for i:=0 to LayerTime do ObjShow[i]:=true;
        if(Mode<4)then for i:=0 to SelRec[0]-1 do begin
          Link[i]:=SelRec[21+i]; LinkName[i]:=Obj[Link[i]].Name;
          if(Mode=1)and(Obj[Link[i]].Kind=1)and(Obj[Link[i]].Mode=2)and EP(Obj[Link[i]].H)
            then Obj[Link[i]].H:=0.01; //H约束点的步长
          end;
        if(Mode=4)then begin //系列按钮
          j:=0;
          for i:=0 to SelRec[0]-1 do
            if(Obj[SelRec[21+i]].Kind=14)then begin
              Link[j]:=SelRec[21+i]; LinkName[j]:=Obj[Link[j]].Name;
              inc(j);
              end;
          end;
        appendExpr(MarkObj);
      //  cmbTagUpdate(MarkObj,true);
      //  ClearSelRec;  Obj[MarkObj].Hot:=true;
        i:=ObjListID[0].ID+1;  ObjListID[i].ID:=MarkObj;  Obj[MarkObj].ShowID:=i;
//        cmbTag.AddItem( IDtoItem(MarkObj), nil);
        ObjListUpdate(i,false);// (MarkObj,i,IDtoItem(MarkObj),true,false);
        if(Mode=6)then ShowControlBox(MarkObj,t,tabLink) //链接
        else MarkObj:=SelRec[20+SelRec[0]];
        end; //with
      end;
    200:with pnlProp do begin //属性框
        if MarkObj>10 then ShowObjProp(MarkObj,0,0, true,true)
                      else ShowObjProp(0,0,0, false,true);
        end;
    201:begin //语言转换
        HideAllPanel;
        inc(iLanguage); if(iLanguage>2)then iLanguage:=0;
        setLanguage(iLanguage); //parsglb单元
        case iLanguage of 0:stMode:=stModeC; 1:stMode:=stModeT; 2:stMode:=stModeE; end; //构件名称
        case iLanguage of 0:stAxis:=stAxisC; 1:stAxis:=stAxisT; 2:stAxis:=stAxisE; end;
        if iLanguage>1 then mNum:=mNumE else mNum:=mNumC;
        for i:= 1 to 26 do screen.Cursors[i]:= LoadCursor( Hinstance, mNum[i]); //鼠标文件详见资源文件Hand.res
        ClearSelRec(0); //清除选择队列
        end;
    202:ShellExecute(handle,nil, 'http://www.inrm3d.cn/index.php',nil,nil,sw_ShowNormal); //打开帮助文件
    203:begin frmMain.Enabled:=false; //关于...
        frmSplash.Show;
        frmSplash.Left:= Left+ (Width-frmSplash.Width)div 2;
        frmSplash.Top := Top + (Height-frmSplash.Height)div 2;
        end;    //About...
    204:begin //对象列表
        butList.Down:= not butList.Down;
        menList.Checked:= butList.Down;
        pnlList.Visible:= butList.Down;
        end;
    205:begin //场景锁定
        Obj[1].Mask:=not Obj[1].Mask;
        butLock.Down:=Obj[1].Mask;  butAll.Down:=bAll;
        end;
    206:begin //2D/3D状态
        Key:=115;   FormKeyDown(nil, Key, []);
        end;
    207..209:begin //207全选 208选择父对象 209选择子对象
        case t of 207:Key:=65; 208:Key:=38; 209:Key:=40; end;
        if(t=207)then bC:=true else bA:=true;
        FormKeyDown(nil, Key,[ssCtrl]);
        bC:=false; bA:=false;
        end;
    210:begin
        DeleteFile(initFile);
        FormCreate(nil);
        end;
    end; //case
  if(t>207)or(t<304)then begin
    menCopyObj.Enabled:=true;
    menObjDel.Enabled:=true;
    SetProjection(false,false,7);
    end;
end;
//======================== 中断添加构件过程 =====================
procedure TfrmMain.BreckAdding;
  var i,j,k :integer;
begin
  if bAdd and not bDotJoin then with Obj[ObjCount]do begin
    if(Kind=4)and(Mode=6)and(not Rand)and(selNum>2)then begin //任意多边形
      k:=trunc(W);
      for i:=1 to k do with Obj[ObjCount+i] do begin //边框属性
        W:=2;  D:=false;  F:=false; color:=Obj[ObjCount].Color; //ObjShow[]:=true;
        for j:=0 to LayerTime do begin ObjShow[j]:=true; TagShow[j]:=false; end;
        end;
      save(1,ObjCount,1,true,false);
      ObjCount:=ObjCount+k;
      ReRelate(MarkObj, ObjCount, false,false,false );
      ObjListUpdate(0,false);
      end
    else
      dec( ObjCount, CancelNum);
    Cursor:= crDefault;
    bAdd:=false; nK:=0; nM:=0; hit:=-1;
    MarkObj:=ObjCount;
    end;
end;
//======================== 菜单选项 =====================
procedure TfrmMain.but10Click(Sender: TObject);
  var isMenu,isTool :boolean;  i,t,t0 :integer;
begin
  t:=TComponent(Sender).Tag;
  isMenu:=(Sender is TMenuItem);  //来自菜单
  isTool:=(Sender is TToolButton);//来自工具
  AppObjProc:=but10Click;

  if isMenu then t0:=HotMenu.Tag;
  if isTool then t0:=HotTool.Tag;
  if(t=0)or(t=181)then begin //中断手绘
    if(PaintNum>0)then setPaintList(true)
      else for i:=1 to PaintListNum do PaintData[i].Hot:=false;
    end;
  if(t=t0)and bAdd and(t>0)then //添加状态下点击相同工具或菜单
    begin if isTool then HotTool.Down:=true; exit; end;
  if(bAdd)then BreckAdding; //中断添加过程
  labHint.Top:=-20;
  if isMenu then begin //来自菜单
    if(t=5)then begin ToolResponse( t); exit; end; //删除构件
    if bAdd  or not(t in[81,200,203,141..146,208,209,211])and(t<>501)//208 209 选择父子对象
      then ClearSelRec(0);
    if(t=200)then butProp.Down:=not butProp.Down
             else HotTool.Down:=false;
    HotTool:=butArrow;
    HotMenu:=(Sender as TMenuItem);
    end;
  if isTool then begin //来自工具
//    HotMenu:=menBar57; //空项
    if(t<>t0)then HotTool.Down:=false;
    HotTool:=(Sender as TToolButton);
    butArrow.Down:=(t=0);
    if(t=0)or(t=181)then ClearSelRec(0);
    end;
  if isMenu or isTool and((t=8)or(t=300)) then butArrow.Down:=not bAdd;

  ToolResponse( t);
end;
//===================== 设置文件菜单 =======================
procedure TfrmMain.setPopMenu( bOpen :boolean; name :string); // bOpen:是否打开文件
  var i,n :integer;
begin

  SgfFile:= name;
    sgfName:=ExtractFileName(sgfFile);
    sgfPath:=ExtractFilePath(sgfFile);
  if(name=aryFile[0])and bOpen then exit; //如所选文件已在菜单顶部, 则仅打开文件
  i:=-1;
  repeat inc(i); until(UpperCase(name)=UpperCase(aryFile[i]))or(i>FileCount);//浏览文件名数组
  if (i>FileCount) then inc( FileCount); //如果不在菜单内则增加菜单选项数
  if i>9 then i:=9; if FileCount>9 then FileCount:=9; //菜单选项数不大于9。注意：第一个选项为0
  for n:= i downto 1 do aryFile[n]:= aryFile[n-1];
  aryFile[0]:= name;//将选择的文件名放到菜单顶
  for i:= 0 to FileCount do begin  //更新lstOpen
    itmOpen[i].Caption:= aryFile[i]+'& ';
    itmOpen[i].Tag:= i;
    itmOpen[i].OnClick:= itmOpenClick;
    end;

  Application.ProcessMessages;
  for i:= MenuCount downto 10 do menMain.Items[0].Delete(i); //删除菜单项
  for i:= 0 to FileCount do menMain.Items[0].Add(itmOpen[i]);//添加菜单项

  MenuCount:=FileCount+10;
end;
//================== 从文件框选择文件名 ===================
procedure TfrmMain.butOpenClick(Sender: TObject);
  var i :integer;
begin
  for i:=11 to maxObj do if Assigned(Obj[i].timID)then Obj[i].timID.Enabled:=false;
//   timAnimate.Enabled:=false;
//  tlbSys.Hide;
  if MarkObj>0 then Obj[MarkObj].hot:=false;
  if isReadOnly or not checkSaved then exit; //是否保存已经编辑的模型
  OpenBox.InitialDir :=sgfPath;
  OpenBox.FileName:= sgfName;
  OpenBox.Filter:='Solid geometry files (*.sgf)|*.sgf';
  If OpenBox.Execute then begin
    SgfFile:= OpenBox.FileName;
    sgfName:=ExtractFileName(sgfFile);
    sgfPath:=ExtractFilePath(sgfFile);
    end
  else Exit;
  setPopMenu( true, SgfFile);
  Start(true);
end;
//===================== 点击文件列表 ======================
procedure TfrmMain.itmOpenClick(Sender: TObject);
  var i :integer;
begin
  for i:=11 to maxObj do if Assigned(Obj[i].timID)then Obj[i].timID.Enabled:=false;
  if MarkObj>0 then Obj[MarkObj].hot:=false;
  bEdit:=false;
  if not isReadOnly and not checkSaved then exit; //是否保存已经编辑的模型
  setPopMenu( true, aryFile[TComponent(Sender).Tag] );
  Start(true);
end;
//==================== 构件显示控制 ==========================
procedure TfrmMain.ObjShowClick(Sender: TObject);
  var i,j, t,t0,t1 :integer;
begin
  t:=TComponent(Sender).Tag;   t0:=t; t1:=t;
  with Obj[MarkObj]do ObjShow[t]:= not ObjShow[t];
  if bS and(t<>Layer)then begin
    if(t<Layer)then t1:=Layer-1;  if(t>Layer)then t0:=Layer+1;
    end;
  for j:=1 to ObjCount do with Obj[j] do
    if Hot then for i:=t0 to t1 do begin
      ObjShow[i]:= Obj[MarkObj].ObjShow[t]; //not ObjShow[i];//
      setBevel( not ObjShow[i], aObjShow[i], nil );  //对象显示状态
      if(Kind=14)or(Kind=11)and(Mode=2)then butID.Visible:= ObjShow[Layer];
//      if(t1=PagePos)and not ObjShow[i] then Hot:=false;
      end;//with
  if(MarkObj in[2,3])then GridList;
  cheShow.Checked:=Obj[MarkObj].ObjShow[Layer];
  MainDraw(GL_RENDER, false, 'g');
  edtTemp.SetFocus;
  keyPreview:=true;
end;
//==================== 标签显示控制 ==========================
procedure TfrmMain.TagShowClick(Sender: TObject);
  var i,j, t,t0,t1 :integer;
begin
  t:=TComponent(Sender).Tag;   t0:=t; t1:=t;
  with Obj[MarkObj]do TagShow[t]:= not TagShow[t];
  if bS and(t<>Layer)then begin
    if(t<Layer)then t1:=Layer-1;  if(t>Layer)then t0:=Layer+1;
    end;
  for j:=11 to ObjCount do with Obj[j] do
    if Hot then for i:=t0 to t1 do begin
      TagShow[i]:= Obj[MarkObj].TagShow[t];
      setBevel( not TagShow[i], aTagShow[i], nil );  //对象显示状态
      end;//with
  MainDraw(GL_RENDER, false,'h');
end;
//============================ 改变线形 ============================
procedure TfrmMain.selWay1MouseUp(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
  var Len,step,t :single;  cc :bool;  b,c,N :integer;  pa,pb:TcgVector;
  label isCopy;
begin
  if hit>0 then exit;
  step:=0;  cheCutter.Hide;
  with Obj[ MarkObj] do begin
  b:=Link[1]; c:=Link[2];
  if(Mode=9) or (Mode=12)
    or(Kind=2)and(Mode in[2,3,4,5])
    or(Kind=3)and(Mode=1)
    or(Kind=4)and(Mode=6)and((S<20)and Rand or(W=99))//正多边形
    or(Kind=4)and(M3 or M4 or M5)
    or(Kind=6)and(Mode in[1..4,6])
    or(Kind=7)and(Mode=1)
    or(Kind=18)and(Mode=2) //角度标注
    or(Kind=10)
    or(Kind=11)and(Mode in[1,2,6]) //參數 度量角度
    or(Obj[b].Kind=3)and(Obj[b].Mode<3)
  then begin
    cc:=Deg;  Deg:=selWay1.Checked; if Deg=cc then exit; //角度制式
    end
  else begin
    cc:=D;    D:=selWay1.Checked;  if D=cc then exit;// 定长/定比(定角)
    end;

  if(Mode=12)then begin //向量变换
    if(Obj[b].Kind=1)then begin pa:=Obj[b].p0; pb:=Obj[c].p0; end
                     else begin pa:=Obj[b].p4; pb:=Obj[b].p5; end;
    len:=cgDistance(pa,pb); //直线的长度
    if Deg then R:=R*len //从定比转为定长
           else if(len<>0)then R:=R/len; //从定长转为定比
    varR.Caption:=ftos(R,4);
    labR.Caption:=SwitchS(iLanguage,IIFs(D,'距离','比例'),IIFs(Deg,'距離','比例'),IIFs(Deg,'Distance','Ratio'), '');
    end
  else if(Link[3]=0)and((Mode>6)
      or(Kind=2)and(Mode in[3,4,5])
      or(Kind=3)and(Mode=1)
      or(Kind=4)and(Mode=6)and Rand and(Link[3]=0)
      or(Kind=4)and(M3 or M4 or M5)
      or(Kind=6)and(Mode in[1..4,6]) ) then begin //角度制式变换
      if Deg then R:=R*oneArc else R:=R/oneArc;
      varR.Caption:=FtoS(R,4);
      if(Kind=6)and(Mode<3)then begin //球体 台体
        if Deg then Angle:=Angle*oneArc else Angle:=Angle/oneArc;
        posZ.Caption:=Ftos(Angle,4);
        end;
    end
  else case Kind of
    1:begin //直线或圆弧上的约束点
      if H>0 then step:=L/H; //移动步数
      if(Obj[b].Kind=2)or(Obj[b].Kind=3)and(Obj[b].Mode in[3,4])then begin //直线或圆弧上的点
        if D then labL.Caption:=SwitchS(iLanguage,'距离','距離','Disdance','')
             else labL.Caption:=SwitchS(iLanguage,'比例','比例','Ratio','');
        case Obj[b].Kind of
          2:len:=cgDistance(Obj[b].p4, Obj[b].p5); //直线的长度
          3:with Obj[b] do begin
              len:=H*L; if(Mode=3)and D then len:=H;//H:圆弧的弧度
              end;
          end;
        if D then begin //从定比转为定长  /
                  L:=L*len; p2.x:=p2.x*len; p2.z:=p2.z*len; end
             else if(len<>0)then begin //从定长转为定比
                  L:=L/len; p2.x:=p2.x/len; p2.z:=p2.z/len; end;
        end;
      if(Obj[b].Kind=3)and(Obj[b].Mode<3)then begin //圆周上的点
        if Deg then labL.Caption:=SwitchS(iLanguage,'角度','角度','Angle','')
               else labL.Caption:=SwitchS(iLanguage,'弧度','弧度','Arc','');
        if Deg then t:=oneArc else t:=1/oneArc;
        L:=L*t;   p2.x:=p2.x*t; p2.z:=p2.z*t;  H:=H*t;
        end;
      if(H>0)and(step>0)and not(Obj[b].Kind=4)
        then H:=L/step; //步长
      if c=0 then varL.Caption:=FtoS(L,4);
      varT.Caption:=FtoS(H,4);
      varS.Caption:=FtoS(p2.x,4); varR.Caption:=FtoS(p2.z,4);
      end; // if
    2:if(Mode=2)then begin //点斜式直线
      if Deg then p2.x:=p2.x*oneArc else p2.x:=p2.x/oneArc;
      if Deg then p2.z:=p2.z*oneArc else p2.z:=p2.z/oneArc;
      varS.Caption:=ftos(p2.x,4);
      varR.Caption:=ftos(p2.z,4);
      end;
    3:if(Mode=3)then begin //圆弧
      labH.Caption:=SwitchS(iLanguage,IIFs(D,'弧长','弧角'),IIFs(D,'弧長','弧角'), IIFs(D,'Arc Length','Arc Angle'),'');
      if(Link[3]=0)then begin
        len:= L; //基圆半径
        if D then H:= H*len  //从定角转为定长
             else H:= IIFf((Mode=3)and(c>0), Obj[c].H, H)/len; //从定长转为定角
        if c=0 then varH.Caption:=FtoS(H,4);
        end;
      end;
    7:if(Mode=1)then begin //旋转曲面
      if Deg then t:=oneArc else t:=1/oneArc;
      H:=H*t; varH.Caption:=FtoS(H,4);
      R:=R*t; varR.Caption:=FtoS(R,4);
      end;
    10:begin //文本 图片
      if Deg then t:=oneArc else t:=1/oneArc;
      Angle:=Angle*t;  varR.Caption:=FtoS(Angle,4);
      end;
    11,18:begin //角度标注
      labL.Caption:=SwitchS(iLanguage,IIFs(Deg,'角度','弧度'),IIFs(Deg,'角度','弧度'),IIFs(Deg,'Angle','Radian'),'');
      if(Kind=18)and Lock then GetTextList(MarkObj);
      end;
    end;//case
  if(Kind=4)and(Mode=3)and(Link[2]=0)then begin //平行面的线面角
    if Deg then pTR.x:=pTR.x*oneArc else pTR.x:=pTR.x/oneArc;
    varH.Caption:=FtoS(pTR.x,4);
    end
  end;// with
//  Save(0,MarkObj,1,true);
  edtTemp.SetFocus;
  keyPreview:=true;
  rerelate(MarkObj,ObjCount,false,false,false);
  if(Obj[MarkObj].Kind=3)and(Obj[MarkObj].Mode=2)then varL.Caption:=FtoS(Obj[MarkObj].L,4); //三点圆内外切转换
  MainDraw(GL_RENDER, false, 'h');
end;
//######## 关联构件菜单选项 ##############
procedure TfrmMain.popObjClick(Sender: TObject);
begin
  setObjLink(MarkObj,(Sender as TMenuItem).Tag, (Sender as TMenuItem).Caption );
end;

procedure TfrmMain.setObjLink( ID,i :integer; st:string); //设置关联
  var j,k,t,et, a,b,c,dd,e,ff,g,hh,ii,jj, lei :integer;   len :single;
      itm:TMenuItem;
  label DadOrSon;
  function getValue(ID, dd,Lin,j:integer; v,t:single; var Ctl:Tlabel):single;
  begin with Obj[ID]do begin
    if(Kind=4)and(Mode=6)and not Rand then begin //平面凸壳厚度
      len:= IIFf(EP(Angle), Thick, Obj[trunc(Angle)].L);
      Angle:=j;
      result:= IIFf(j=0, len, Thick);
      Ctl.Caption:= IIFs(Angle=0, FtoS(result,4), IDtoS(trunc(Angle)) );
      end
    else begin
      len:= IIFf(dd=0, v, t); //Obj[dd].L
      Obj[ID].Link[Lin]:= j;
      result:= IIFf(j=0, len, v);
      Ctl.Caption:= IIFs(j=0, FtoS(result,4), IDtoS(j) );
      end;
    end
  end;
begin
  j:=i;
  if(posEdit.Tag=100)then goto DadOrSon; //父/子构件弹出菜单选项
  with Obj[MarkObj] do begin
  if(Kind=11)and(Mode=1)and(tabCalc.TabVisible)then posEdit.Tag:=0;//计算框
  a:=Link[0]; b:=Link[1];   c:=Link[2]; dd:=Link[3];
  e:=Link[4]; ff:=Link[5];  g:=Link[6]; hh:=Link[7]; ii:=Link[8]; jj:=Link[9];
  if(posEdit.Tag=0)and cheCutter.Visible then begin //来自截面菜单
    if(i=0)then begin
      if(cheCutter.ItemIndex>=0)then begin //删除截面
        for i:=cheCutter.ItemIndex to cheCutter.Count-1 do
          Obj[MarkObj].Cutter[i]:=Obj[MarkObj].Cutter[i+1];
        cheCutter.DeleteSelected;
        if cheCutter.Count<1 then begin
          cheSec.Checked:=false;  Obj[MarkObj].Q:=false;  cheCutter.Hide;
          end;
        end
      end
    else if(cheCutter.Count<6)then begin
      k:=cheCutter.Count;
      Obj[MarkObj].Cutter[k,0]:=Obj[i].Name;
      Obj[MarkObj].Cutter[k,1]:=i;
      Obj[MarkObj].Cutter[k,2]:=1;    //正面为1
      cheCutter.AddItem(Obj[i].Tag,nil);
      cheCutter.State[cheCutter.Count-1]:=cbChecked;
      cheCutter.Height:=cheCutter.Count*16;
      cheSec.Checked:=true;   Q:=true;
      goto DadOrSon;
      end;
    end;
  if(posEdit.Tag=0)and tabAffine.Visible then begin //仿射变换
    t:=hotText.Tag;
    if(i=0)then begin //取消关联
      Value[t]:= getLinkVar( Link[t+16], p0);
      txtArray[8,t].Text:= fTrim(Value[t]);
      Link[t+16]:=0;
      end
    else begin
      Value[t]:= getLinkVar( Link[t+16], p0);
      txtArray[8,t].Text:= Obj[i].Tag;
      Link[t+16]:=i;
      end;
    end;
  if(posEdit.Tag=0)and(not tabAffine.Visible)then
    case Kind of
    9,16:begin  //函数曲线、曲面方程式的常量参数关联
      et:=hotEdit.Tag;
      if j>0 then Len:= Obj[Link[et]].L
      else case et of
        0:Len:=p3.x; 1:Len:=p3.y; 2:Len:=p3.z;
        3:Len:=p4.x; 4:Len:=p4.y; 5:Len:=p4.z;
        7:len:=p1.x; 8:Len:=p1.y; 9:Len:=p2.x; 10:Len:=p2.y;
        end;
      Link[et]:=j;   LinkName[et]:=Obj[j].Name;
      if(j=0)then L:=Len
      else begin  L:= Obj[j].L;
        case et of 0:p3.x:=L; 1:p3.y:=L; 2:p3.z:=L;
                   3:p4.x:=L; 4:p4.y:=L; 5:p4.z:=L;
                   7:p1.x:=L; 8:p1.y:=L; 9:p2.x:=L; 10:p2.y:=L; end;
        end;
      hotEdit.Text:=IIFs(j=0, FtoS(L,4), IDtoS(j));
      exit;
      end;
    11:begin //计算
      memExpr.Text:=insExpr( Obj[i].Tag, memExpr.Text, memExpr.SelStart,j);
      memExpr.SelStart:=j-1;
      exit;
      end;
    13:begin //迭代
      t:=HotText.Tag;
      if t=101 then begin //次数
        if(j=0)then lei:=S else lei:=trunc(Obj[j].L);
        S:=lei; //次数
        HotText.Text:= IIFs(j=0, IntToStr(lei), IDtoS(j) );
        butDieDaiAdd.Enabled:=(j=0)and(S<19);
        butDieDaiSub.Enabled:=(j=0)and(S>1);
        Link[0]:=j;  LinkName[0]:=Obj[j].Name; //连接构件
        end
      else begin //原像/映像  itos(MarkObj)+' '+
        HotText.Text:=IDtoS(j);
        ii:=t div 21;  jj:=t mod 21;
        objArray[ii, jj]:=j;
        inc(jj);
        if(jj>trunc(W))then begin
          jj:=0; inc(ii); if(ii>trunc(H))then ii:=0;
          end;
        txtArray[ii,jj].SetFocus;
        txtDepth0MouseDown(txtArray[ii,jj],mbLeft,[],0,0);
        end;
      exit;
      end;
    14:if(Mode<6)then begin //控制按纽
      j:=lstPath.Count-1;
      if i=0 then begin //删除对象
        et:=lstPath.ItemIndex; if et<0 then exit;
        lstPath.DeleteSelected;
        if et<j then for k:=et to j-1 do Link[k]:=Link[k+1];
        Link[j]:=0;
        end
      else begin //添加对象
        lstPath.AddItem(st, nil);
        Link[j+1]:=i;
        end;
      butOK.Enabled:=true;
      end; //case 14
    17:if(ID<>i)then begin //路径 三视图
      if(Mode=1)then begin //路径
        j:=lstPath.Count-1;   et:=lstPath.ItemIndex;
        if i=0 then begin //删除路径
          if et<0 then exit;
          lstPath.DeleteSelected;
          if et<j then for k:=et to j-1 do Link[k]:=Link[k+1];
          Link[j]:=0;
          end
        else begin //添加路径
          if(et<0)then begin lstPath.AddItem(st,nil); et:=j+1; end //增加
                  else lstPath.Items.Insert(et, st);//插入
          Link[j+1]:=i;
          for k:=j downto et do SwapI(Link[k],Link[k+1]);
          lstPath.ItemIndex:=et;
          end;
        butPathResume.Enabled:=true;
        end
      else begin //三视图
        j:=lstPath.Count;  et:=lstPath.ItemIndex+1;
        if i=0 then begin //在三视图中一个删除对象
          if et<0 then exit;
          lstPath.DeleteSelected;
          if et<j then for k:=et to j-1 do Link[k]:=Link[k+1];
          Link[j]:=0;
          end
        else begin //在三视图中添加对象(不能再添加三视图)
          lstPath.AddItem(st,nil);
          Link[j+1]:=i;
          end;
        lstPath.ItemIndex:= lstPath.Count-1;
        end;
      butOK.Enabled:=true;
      end; //case 17
    end; //case Kind
  if(posEdit.tag<>0)then
    case posEdit.Tag of
    -1:begin //varC 颜色关联
      len:=IIFf(j=0, p4.w, (Obj[g].L-trunc(Obj[g].L))*200);
      Link[6]:= j; //连接构件
      if j>0 then varC.Color:=clWindow
             else begin color:=cgTColorToCGColorF( trunc(len), StrToFloat( varA.Caption));
                        varC.Color:=cgColorFToTColor(color);
                        end;
      varC.Caption:= IIFs(j=0, '', IDtoS(j));
      varC1.Caption:=varC.Caption;
      end;
    1:case Mode of //posX  X偏移量
      10:R:=getValue(MarkObj, c, 2, j, Obj[j].L, Obj[c].L, posX); //缩放复制
      11:p4.x:=getValue(MarkObj, b, 1, j, Obj[j].L, Obj[b].L, posX); //平移复制
      else case Kind of
        1:p0.x:=getValue(MarkObj, a, 0, j, Obj[j].L, Obj[a].L, posX);  //自由点的X坐标
        2:p2.x:=getValue(MarkObj, b, 1, j, Obj[j].L, Obj[b].L, posX);  //点斜式直线的水平转角
        3:   H:=getValue(MarkObj,dd, 3, j, Obj[j].L, Obj[dd].L, posX); //圆的扁度
        6:if(Mode in[1,6])then //球 上截率
         pTR.x:=getValue(MarkObj,Link[9], 9, j, Obj[j].L, Obj[Link[9]].L, posX); //
        7:   R:=getValue(MarkObj, c, 2, j, Obj[j].L, Obj[c].L, posX);  //旋转曲面的初角
        end;//case Kind
      end;//case Mode
    2:case Mode of //posY
      11:p4.y:=getValue(MarkObj, c, 2, j, Obj[j].L, Obj[c].L, posY);//平移复制
      else case Kind of
        1:p0.y:=getValue(MarkObj, b, 1, j, Obj[j].L, Obj[b].L, posY);//自由点的Y坐标
        6:if(Mode in[1,6])then //posY 球体 下截率
          ptR.y:=getValue(MarkObj, Link[11], 11, j, Obj[j].L, Obj[Link[11]].L, posY);
        end;//case Kind
      end;//case Mode
    3:if(Kind<>11)and(Mode=11)then //posZ
        p4.z:=getValue(MarkObj, dd, 3, j, Obj[j].L, Obj[dd].L, posZ) //平移变换
      else case Kind of
        1:p0.z:=getValue(MarkObj, c, 2, j, Obj[j].L, Obj[c].L, posZ); //自由点的Z坐标
        2:p2.z:=getValue(MarkObj, dd, IIFi(Obj[MarkObj].Kind=3,4,3), j, Obj[j].L,Obj[dd].L, posZ); //点斜式直线的垂直转角
        3:R:=getValue(MarkObj, dd, 4, j, Obj[j].L, Obj[dd].L, posZ); //点法圆的转角
        6:Angle:=getValue(MarkObj, Link[10], 10, j, Obj[j].L, Obj[Link[10]].L, posZ); //
        7:H:=getValue(MarkObj, dd, 3, j, Obj[j].L, Obj[dd].L, posZ); //旋转曲面的转角
        10,11:if(j=0)or(Obj[j].Kind=1)then begin //绑定到点
            Link[10]:=j;
            posX.Caption:=IIFs(j=0,FtoS(p0.x,4),FtoS(p2.y,0));
            posY.Caption:=IIFs(j=0,FtoS(p0.y,4),FtoS(p2.w,0));
            posZ.Caption:=IIFs(j=0,'',IDtoS(j));
            p2.y:=0; p2.w:=0; //屏幕坐标偏移量
            end;
        end;//case Kind
    4:begin  //varW
      if(Kind=6)then
        W:=getValue(MarkObj, ff, 5, j, Obj[j].L,Obj[ff].L, varW)
      else if(Kind=4)and(Mode=6)and Rand then //正多边形边长
        H:=getValue(MarkObj, e, 4, j, Obj[j].H, Obj[e].L, varW)
      else if(Kind=4)and(Mode in[3,4,5]) then //平面宽度
        W:=getValue(MarkObj, e, 4, j, Obj[j].R, Obj[e].L, varW);
      if(Kind=6)and(Mode=3)and(S<6) or (Kind=4)and(Mode=6)and Rand and(W<99)then begin
        Link[2]:=0;   varL.Enabled:=(e=0);//正多面体或正多边形的半径不能同时有关联
        end;
      end;
    5:begin //varL
      if M11 then  //平移构件
        p4.x:=getValue(MarkObj, b, 1, j,Obj[j].L, Obj[b].L, varL) // dX
      else if K4 and(M3 or M4 or M5)then // 平面
        L:=getValue(MarkObj,dd, 3, j,Obj[j].L, Obj[dd].L, varL)
      else if K6 and M6 then
        L:=getValue(MarkObj, c, 2, j,Obj[j].L, L, varL)
      else if not K19 then
        L:=getValue(MarkObj, c, 2, j,Obj[j].L, Obj[ c].L, varL);
      if(Kind=6)and(Mode=3)and(S<6)then begin
        if(Link[5]>0)then Link[5]:=0; //正多面体棱边不能同时有关联
        varW.Enabled:=Link[5]=0;
        end;
      end;
    6:begin //varS
      if(K1 and M2)or(K11 and(M2 or M13))then //约束点起始值
        p2.x:=getValue(MarkObj, dd,3,j, Obj[j].L, Obj[dd].L, varS);
      if K2 and M2 then //角向量水平角、位向量x偏量
        p2.x:=getValue(MarkObj, dd,3,j, Obj[j].L, Obj[dd].L, varS);
      if K4 and M6 and(W>100)then begin //正n边形边数
        W:=getValue(MarkObj, Link[11],11,j, Obj[j].L, trunc(Obj[Link[11]].L), varS);
        if(W<3)then W:=3; if(W>99)then W:=99;   W:=W+100;
        end;
      if K6 and M4 and(S>100)then begin //正n棱台棱数
        S:=trunc(getValue(MarkObj, ii,8,j, Obj[j].L, trunc(Obj[ii].L), varS));
        if(S<3)then S:=3; if(S>99)then S:=99;   S:=S+100;
        end;
      if K7 and M1 then //旋转曲面的圆度
        S:=trunc(getValue(MarkObj, e,4,j, Obj[j].L, trunc(Obj[e].L), varS));
      if K10 then //图片隐藏阈值
        R:=getValue(MarkObj, c, 2, j, Obj[j].L, Obj[c].L, varS);
      if K13 then //迭代次数
        S:=trunc(getValue(MarkObj, a, 0, j, Obj[j].L, trunc(Obj[a].L), varS));
      if M11 then  //平移构件 dY
        p4.y:=getValue(MarkObj, c, 2, j,Obj[j].L,Obj[c].L, varS);
      end;
    7:if not(K11 or K13 or K14 or K17 or K20)then begin //varA 透明度
      Link[12]:=j;
      if(j>0)then Color.A:= Obj[j].L; //
      varA.Caption:=IIFs(j=0, FtoS(Color.A, 4) , Obj[Link[12]].Tag);
      end;
    8:begin //varT
      if M7 then begin //投影变换的光线
        Link[2]:=j; varT.Caption:=IIFs(j=0, '', Obj[Link[2]].Tag);
        cheWay.Enabled:=Obj[Link[2]].Kind=2;
        end
      else if K6 and(M2 or M4 or M6 or M3 and(S=6))then begin
        Link[9]:=j; varT.Caption:=IIFs(j=0, '', Obj[Link[9]].Tag);
        end
      else if K1 and M2 then
        H:=getValue(MarkObj, a, 0, j, Obj[j].H, Obj[a].L, varT)
      else if K3 or K4 then //圆、平面厚度
        Thick:=getValue(MarkObj, ff, 5, j, Obj[j].Thick, Obj[ff].L, varT)
      else if K10 then //文字绑定
        H:=getValue(MarkObj, c, 2, j, Obj[j].H, Obj[c].L, varT);
      end;
    9:begin //varH
      if K1 and(M2 or M6)then
        H:=getValue(MarkObj, a, 0, j, Obj[j].H,Obj[a].L, varH);
      if K2 and M2 and(trunc(R)=1)then //位向量y偏量
        p2.y:=getValue(MarkObj, e,4,j, Obj[j].L,Obj[e].L, varH);
      if K3 and M3 then with Obj[dd] do begin //圆弧 and(j>0)
        if(Kind=3)and(Mode=3)then Obj[MarkObj].D:=D; //链接构件为圆弧
        if(j=0)and(Obj[dd].Kind=1)and(Obj[dd].Mode<>2)then
          Obj[MarkObj].H:=getValue(MarkObj, dd, 3, j, Obj[MarkObj].H, Obj[MarkObj].H, varH)
        else begin
          Obj[MarkObj].D:=false; selWay0.Checked:=true;
          Obj[MarkObj].H:=getValue(MarkObj, dd, 3, j, Obj[j].L, Obj[dd].L, varH);
          end;
        end; // with Obj[c]
      if K3 and M1 then //圆的扁度
        H:=getValue(MarkObj,dd, 3, j, Obj[j].L, Obj[dd].L, varH);
      if K4 and M3 then //平行面的线面角
        pTR.x:=getValue(MarkObj,c, 2, j, Obj[j].L, Obj[c].L, varH); //
      if K6 or K4 and not(M1 or M2 or M3 or M5) or M11 then
        H:=getValue(MarkObj, e, 4, j, Obj[j].H, Obj[MarkObj].H, varH);
      if K7 then H:=getValue(MarkObj, c, 2, j, Obj[j].H, Obj[c].L, varH);
      if K10 then //图片显示阈值
        H:=getValue(MarkObj, b, 1, j, Obj[MarkObj].H, Obj[b].L, varH);
      end; //posEdit.Tag=9
   10:begin  //varR
      if(K1 and M2)and(Obj[b].Kind<>4)or(K11 and(M2 or M13))then //约束点终止值
        p2.z:=getValue(MarkObj, e,4,j, Obj[j].L, Obj[e].L, varR);
      if K1 and M2 and(Obj[b].Kind in[4,6])then
        R:=getValue(MarkObj, ff,5,j, Obj[j].L, Obj[ff].L, varR);
      if K2 and M2 then  //角向量仰角、位向量z偏量
        p2.z:=getValue(MarkObj,ff, 5, j,Obj[j].L, Obj[ff].L, varR);
      if K2 and(M3 or M4)then  //垂线转角
        R:=getValue(MarkObj,dd, 3, j,Obj[j].L, Obj[dd].L, varR);
      if K2 and M5 then  //中线角分比
        R:=getValue(MarkObj,e, 4, j,Obj[j].L, Obj[e].L, varR);
      if(K3 and M1)then
        R:=getValue(MarkObj, e,4,j, Obj[j].L, Obj[e].L, varR);
      if(K4 and M6)or K6 or K7 or K8 or M7 or M9 or M10 or M11 then //M10 缩放变换
        R:=getValue(MarkObj,dd,3,j, Obj[j].L, Obj[dd].L, varR);
      if K4 and(M1 or M2 or M3 or M4 or M5)then
        R:=getValue(MarkObj,Link[9],9,j, Obj[j].R, Obj[Link[9]].L, varR);
      if K10 then  //图片/文字转角
        Angle:=getValue(MarkObj, dd,3,j, Obj[j].R, Obj[dd].L, varR);
      if K17 and M2 then //三视图
        R:=getValue(MarkObj, a,0,j, Obj[j].R, Obj[0].L, varR);
      if K19 and M2 then //圆锥曲线离心率
        R:=getValue(MarkObj, dd,3,j, Obj[j].R, Obj[dd].L, varR);
      if M10 or M12 then  //缩放变换 向量变换
        R:=getValue(MarkObj,dd,3,j, Obj[j].R, Obj[dd].L, varR);
      if M15 then
        R:=getValue(MarkObj, c,2,j, Obj[j].R, Obj[c].L, varR);
      if(M7 or M10)and(dd=0)then begin Link[4]:=0; Link[5]:=0; end;
      if M7 or M9 or M10 then
        if Link[3]=0 then begin Link[4]:=0; Link[5]:=0; end;
      end;
    end;//case posEdit.Tag
  for i:=0 to LinkTime do
    if Link[i]=0 then LinkName[i]:=0 else LinkName[i]:=Obj[Link[i]].Name;
  reRelate(MarkObj,ObjCount,false,false,false);
  posEdit.Visible:=false;  if not pnlControl.Visible then bSelLink:=false;
  end;//with Obj[MarkObj]
DadOrSon:
  if posEdit.Tag=100 then begin //父/子构件弹出菜单选项
    ClearSelRec(0); //清除选择队列
    MarkObj:=ObjSelected( j,  false,false,true,false);
    ShowObjProp(MarkObj, 0,0, true,false);
    end;
  SetProjection(false,false,10);
end;
//================= 创建父构件或子构件菜单 ===================
procedure TfrmMain.butDadMouseDown(Sender: TObject; Button: TMouseButton;Shift: TShiftState; X, Y: Integer);
  var i,j :integer;  isEdge,isVct:boolean;  
begin
  Application.ProcessMessages;
  popObj.Items.Clear;   isEdge:=false;   isVct:=false;
  case TComponent(Sender).Tag of
  0:for i:= 0 to LinkTime do //父构件
      with Obj[MarkObj]do begin
      if(Link[i]>0)and not((Kind=14)and(Link[i]<11))
        then AddItem( Link[i],0,false,false,false);
      end;
  1:for i:= MarkObj+1 to ObjCount do //子构件
      with Obj[i] do begin
      if(DelID=0)and not((Kind=1)and(Mode=4)and(hide))then begin
        for j:=0 to LinkTime do begin
          if(Obj[MarkObj].Kind<>6)and(Link[j]=MarkObj)then
            begin AddItem( i,0,false,false,false);  break; end;
          if(Obj[MarkObj].Kind=6)and(Kind=2)and(not isEdge)then begin
            AddItem( i,0,false,false,false); isEdge:=true; break;
            end;
          if(Obj[MarkObj].Kind=6)and(Kind=1)and(not isVct)then begin
            AddItem( i,0,false,false,false); isVct:=true; break;
            end;
          end;
        end;
      end;
  2:OpenPicture(MarkObj,true,true);//贴图
  3:begin //截面
    i:=cheCutter.Count; if(i=0)then i:=1;
    cheCutter.Top:=pnl23.Top+15; cheCutter.Height:=i*16;
    cheCutter.Visible:=not cheCutter.Visible;
    bSelLink:=cheCutter.Visible;
    end;
  end;
  posEdit.Tag:=100;
end;

procedure TfrmMain.posEditValueChange(Sender:TObject; Key:Word);
  function VarToCtrl( v,Min,Max :single; ctrl :TLabel; Len:integer) :single;
    var st:string;
    begin  if v<Min then v:=Min; if v>Max then v:=Max;
      result:=v;  st:=FtoS(v,Len);
      if Length(st)>9 then st:=copy(st,1,9);
      ctrl.caption:=st;   ctrl.Refresh;
      end;
  var v :single; i,t,iID :integer;  st: string;
begin
  v:=0;  iID:=MarkObj;
  t:= TComponent(Sender).Tag;  //posEdit.Tag值在edtTagDblClick事件中设置
  if Key=VK_RETURN then begin //
    st:= trim( posEdit.Text);
    try
      if t>0 then v:= StrToFloat( st);  //edtTag控件除外
    except
      on E:Exception do begin
        messageDlg(E.Message,mtError,[mbOk],0);
        v:=0;
        end;
    end;
    with Obj[ MarkObj] do begin
      case t of
      0:begin //标签 HotTag为自动生成标签所用(用Ctrl+Shift+LeftMouse点击构件)
        Tag:=LeftStr(st,32);   varTag.Caption:=Tag;
        if(Kind=14)then CreateCtrl(MarkObj,false); //控制按纽
        end;
      1:begin //posX
        if K1 and M1 then  p0.x:=VarToCtrl( v,-999,9999, posX,4)
        else if K6 and(M1 or M2)then begin
          if Deg then pTR.x:=VarToCtrl( v, 0,  360, posX,4)
                 else pTR.x:=VarToCtrl( v, 0,towPi, posX,4);
          end
        else if K14 then butID.Left:=trunc(p0.x +TagP.X) //按钮
        else if(K10)then p0.x:=VarToCtrl( v,0,ClientWidth, posX,0) //图片and(Link[0]>0)
        else if K11 then begin //参数、计算值
          p0.x:=VarToCtrl( v,0,ClientWidth, posX,0);
          if M2 then butID.Left:=trunc(p0.x +TagP.X);
          end
        else p0.x:=VarToCtrl( v,0,999, posX,4);
        end;
      2:begin //posY
        if K1 and M1 then p0.y:=VarToCtrl( v,-999,9999, posY,4)
        else if K6 and(M1 or M2)then begin
          if Deg then pTR.y:=VarToCtrl( v, 0,  360, posY,4)
                 else pTR.y:=VarToCtrl( v, 0,towPi, posY,4);
          end
        else if K14 then butID.Top:=trunc(p0.y-H) //按钮   //+TagP.Y
        else if(K10)then p0.y:=VarToCtrl( v,0,ClientHeight, posY,0) //and(Link[0]>0
        else if K11 then begin //参数、计算值
          p0.y:=VarToCtrl( v,0,ClientHeight, posY,0);
          if M2 then butID.Top:=trunc(p0.y) -butID.height-TitleHeight+12;
          end
        else p0.y:=VarToCtrl( v,0,ClientHeight, posY,4);
        end;
      3:begin //posZ
        if K1 and M1 then p0.z:=VarToCtrl( v,-999,9999, posZ,4)
        else if K6 and(M1 or M2)then begin
          if Deg then Angle:=VarToCtrl( v, 0,  360, posZ,4)
                 else Angle:=VarToCtrl( v, 0,towPi, posZ,4);
          end
        else p0.z:=VarToCtrl( v,-999,9999, posZ,4);
        end;
      4:begin //varW
        if K1 and not(M4 or M13)then begin
          W:= VarToCtrl( v,1,40, varW,4); Obj[1].p1.x:=W; //点径
          end
        else if K2 and not M13 then begin
          W:= VarToCtrl( v,0.5,99, varW,4); Obj[1].p1.y:=W; //线宽
          end
        else if K4 and(Mode<6)then H:= VarToCtrl( v,0.5,99, varW,4) //垂面、平行面 高度
        else if K4 and M6 and Rand then begin //正多边形边长
          H:= VarToCtrl( v,0.1,99, varW,4); //棱长
          if(trunc(W)<>99)then begin //非长方形则计算边长
            v:=W; if(v>100)then v:=v-100; //v>100 正n边形
            L:=H/sin(Pi/v)/2;   varL.Caption:=ftos(L,4);  varL.Refresh;
            end;
          end
        else if K14 then begin //按钮宽度
          W:= VarToCtrl( v,0,999, varW,0); hotBut.Width:=trunc(W);
          end
        else if K6 and M3 and(S<6) then begin //正多面体边长
          W:= VarToCtrl( v,0.1,99, varW,4); //棱长
          L:= EdgeToRadius(W,S);   varL.Caption:=ftos(L,4);  varL.Refresh;
          end
        else if K6 and M4 then //棱台锥度
          W:= VarToCtrl( v, 0, 99, varW,4)
        else if K1 and(M4 or M13) or(K2 and M13)then begin //交点、多边形棱边或顶点
          iID:=Link[0];  t:=Kind;
          for i:=iID+1 to ObjCount do with Obj[i]do
            if(Link[0]=iID)and(Kind=t)and((Mode=4)or(Mode=13))then
              W:= VarToCtrl( v,1,40, varW,4)
          end
        else begin
          W:= VarToCtrl( v,0,99, varW,4);  if K3 then Obj[1].p1.z:=W; if K5 then Obj[1].p2.y:=W;
          end;
       end;
      5:begin //varL
        if(K11 and M2)then begin
          L:=VarToCtrl( v,p2.x,p2.z, varL,4); //参数值
          if Trace then setBarTrack(MarkObj); //参数轴
          end
        else if M11 and not K11 then begin    // 平移变换
          if U then pBL.x:= VarToCtrl( v,0,99, varL,4)      //dL 矢量平移
               else pTR.x:= VarToCtrl( v,-999,9999, varL,4);//dX
          if U then cgAngleToXYZ(pBL.x,pBL.y,pBL.z, pTR.X,pTR.Y,pTR.Z, true);
          defaultVec:=pTR;
          end
        else if K2 then begin
          L:= VarToCtrl( v,0.00001,9999, varL,4);//varL 直线长度, 实体的长宽比
          if(iID<5)and(L<(R+0.5))then L:=R+0.5; //坐标轴不短于负轴长
          end
        else if K14 or K19 then
          L:=VarToCtrl( v,0,9999999, varL,0) //控制计算的次数
        else if K1 and M2 and(Obj[Link[1]].Kind in[1,13])then  //等分点或迭代上的点
          L:=VarToCtrl( v,0,High(LocaVct[Link[1]]), varL,0)
        else if K1 and M6 then
          L:=VarToCtrl( v,2,360, varL,0)
        else if K6 and(M1 or M6)then begin
          if M1 and(Link[1]>0)and(Obj[Link[1]].Kind=1)and(Link[2]=0) then begin //两点球之半径
            if(v<0)then begin Rand:=false; L:=VarToCtrl( L,0,9999, varL,4); end
                   else begin Rand:=true;  L:=VarToCtrl( v,0,9999, varL,4); end;
            end;
          if M1 and((Link[1]=0)or(Link[1]>0)and(Obj[Link[1]].Kind>1))then
            L:=VarToCtrl( v,0,9999, varL,4);
          if M6 and(Link[5]=0)then begin
            if(v<0)then begin Rand:=false; L:=VarToCtrl( L,0,9999, varL,4); end
                   else begin Rand:=true;  L:=VarToCtrl( v,0,9999, varL,4); end;
            end;
          end
        else begin
          L:=VarToCtrl( v,-999,9999, varL,4);
          DefaultProp[2]:=L;  
          end;
        if K4 and M6 and Rand and(trunc(W)<99)then begin //正多边形边长
          H:=2*L*sin(Pi/W);   varW.Caption:=ftos(H,4); varW.Refresh;
          end;
        if(iID<9)then //坐标轴长度
          case iID of 2:Obj[1].Vec.x:=L; 3:Obj[1].Vec.y:=L; 4:Obj[1].Vec.z:=L; end;
        end;
      6:begin  //varS
        if M11 and not K11 then begin
          if U then pBL.y:= VarToCtrl( v,0,towPi, varS,4)      //dL 矢量平移
               else pTR.y:= VarToCtrl( v,-999,9999, varS,4); // 平移变换dY
          if U then cgAngleToXYZ(pBL.x,pBL.y,pBL.z, pTR.X,pTR.Y,pTR.Z, true);
          defaultVec:=pTR;
          end
        else if(K1 and M2)then begin //约束点起值、
            if(Obj[Link[1]].Kind=4)and(Obj[Link[1]].Mask)
              then p2.x:=VarToCtrl( v,0,1, varS,4) //平面上的约束点
              else p2.x:=VarToCtrl( v,-99,99, varS,4);
            end
        else if(K2)and(M2)then begin //向量
          if(trunc(R)=0)then p2.x:=VarToCtrl( v,-360,360, varS,4); //角向量的水平转角
          if(trunc(R)=1)then p2.x:=VarToCtrl( v,-99,99, varS,4); //向量的x偏量
          end
        else if K3 then begin
          Angle:= trunc(VarToCtrl( v, 0,999,varS,0)); //圆(弧)精度
          if Angle<3 then Angle:=0;
          end
        else if K4 and M6 and(W>100)then
          begin v:=VarToCtrl( v, 3,99, varS,0); W:=100+trunc(v); end //正n边形
        else if(K6)then begin //正n棱台
          if M4 and(S>100)then begin v:=VarToCtrl( v, 3,98, varS,0); S:=100+trunc(v); end
            else begin v:=VarToCtrl( v,2, 15, varS,4); S:=trunc(v); end;
          end
        else if(K7)then begin v:=VarToCtrl( v,3,128, varS,0); S:=trunc(v); end //精度
        else if(K10)then R:= VarToCtrl( v, -20,20,varS,4)  //图片/文本 隐阈
        else if(K11 and( M2 or M13))then begin
          p2.x:=VarToCtrl( v,-999,9999, varS,4);
          if p2.x>p2.z then p2.x:=p2.z;
          if(L<p2.x)then L:=p2.x; //参数起值
          if M2 and Trace then setBarTrack(MarkObj); //参数轴
          end
        else if(K13 or K14)then S:= trunc(VarToCtrl( v, 1,9999,varS,0))//移动按钮频率
        else if(K18)then S:= trunc(VarToCtrl( v, 2,6, varS,0))
        else p3.x:= VarToCtrl( v,-999,9999, varS,4);  //平面上的点距离平面第一点的距离
        end;
      7:if(K11 and M2) //参数动画频率
        then   Angle:= VarToCtrl( v, 0,1000, varA,0) //
        else Color.a:= VarToCtrl( IIFf(v>1,1,v), 0,1, varA,4); //varA 对象透明度
      8:begin //varT
        if K1 then begin H:= VarToCtrl( v,-5,5, varT,4); menSport.Enabled:=H>0; end; //步长
        if K3 or K4 then Thick:=VarToCtrl( v,-99,99, varT,4);
        if K10 then S:= trunc(VarToCtrl( v, 0,20, varT,0));
        if K11 then H:= VarToCtrl( v,-99,99, varT,4);
        if K18 then begin
          if M1 then Thick:=VarToCtrl( v,-1,1, varT,4) //标注锥度
                else Thick:=VarToCtrl( v,-99,99, varT,4);
          end;
        end;
      9:begin //varH
        if K1 and M6 then H:=VarToCtrl( v,2,trunc(L), varH,4) //等分点
        else if K3 and M1 then begin
          H:=VarToCtrl( v,0,1, varH,4); //椭圆度
          butSize19.Visible:=EP(H);
          end
        else if K2 and M2 then begin //向量
          if(trunc(R)=1)then p2.y:=VarToCtrl( v,-99,99, varH,4); //向量的y偏量
          end
        else if K2 and(M4 or M5)then Angle:=VarToCtrl( v, 0, 1, varH,4)//两点之中垂线 间比
        else if(K4 and M3)then begin //平行面的线面角
          if Deg then pTR.x:=VarToCtrl( v,-360,360, varH,4) //
                 else pTR.x:=VarToCtrl( v,-towPi,towPi, varH,4);
          end
        else if(K4 and M5)then Angle:=VarToCtrl( v, 0, 1, varH,4) //中面的角分比
        else if K10 then H:=VarToCtrl( v,-20,20, varH,4) //图片/文本 显阈
        else if(Kind in[5,15,16])then H:=VarToCtrl( v,0.1,16, varH,4) //阈值
        else if(K7 and M1)then begin //旋转曲面转角
          if Deg then H:=VarToCtrl( v,-360,360, varH,4)
                 else H:=VarToCtrl( v,-towPi,towPi, varH,4);
          end
        else if K14 then begin //按钮高度
          H:=VarToCtrl( v,20,ClientHeight,varH,0);  hotBut.Height:=trunc(H);
          end
        else if K17 then H:=VarToCtrl( v,1,99, varH,0) //
        else if K18 then H:=VarToCtrl( v,0.1,0.5,varH,4) //标记间隔
        else if K19 then H:=VarToCtrl( v,8,1024, varH,0) //圆锥曲线密度
        else H:=VarToCtrl( v,-999,9999, varH,4);
        end;
     10:begin //varR
        if M11 and not K11 then begin
          if U then pBL.z:= VarToCtrl( v,-halfPi,halfPi, varR,4)      //rZ 矢量平移
               else pTR.z:= VarToCtrl( v,-999,9999, varR,4); // 平移变换dZ
          if U then cgAngleToXYZ(pBL.x,pBL.y,pBL.z, pTR.X,pTR.Y,pTR.Z, true);
          defaultVec:=pTR;
          end
        else if K1 and M2 and not(Obj[Link[1]].Kind=4)then
          p2.z:=VarToCtrl( v,-999,9999, varR,4)
        else if K1 and M2 and(Obj[Link[1]].Kind=4)then begin
          if(not Mask)then R:=VarToCtrl( v,-999,9999, varR,4) //平面上的约束点
               else p2.z:=VarToCtrl( v,-999,9999, varR,4);
          end
        else if(K2)and(M4 or M5)then
          R:=VarToCtrl( v, IIFf(Deg,-360,-towPi), IIFf(Deg,360,towPi), varR,4)//中垂线
        else if(K2)and M2 then begin
          if(MarkObj<5)then begin
            L:=L-R;
            R:=VarToCtrl( v, 0, 99, varR,4);
            L:=L+R;  varL.Caption:=ftos(L,4);
            end
          else p2.z:= VarToCtrl( v,-999,9999, varR,4); //约束点终值、点斜线的仰角
          end
        else if K4 and(M1 or M2)then R:=VarToCtrl( v,0.1,9, varR,4) //
        else if K4 and(M3 or M4 or M5)then R:=VarToCtrl( v,-9999,9999, varR,4)
        else if(K11 and( M2 or M13))then begin  //参数终值
          p2.z:= VarToCtrl( v,-9999999,9999999, varR,4);
          if p2.z<p2.x then p2.z:=p2.x;
          if(L>p2.z)then L:=p2.z;
          if M2 and Trace then setBarTrack(MarkObj); //参数轴
          end
        else if(K14 and M2)then R:=VarToCtrl( v,0,10, varR,4) //移动控制步长
        else if K10 then Angle:=VarToCtrl( Angle,-towPi,towPi, varR,4) //图片/文本 角度
        else if M14 then R:=VarToCtrl( v, 2,99, varR,0) //自定义变换
        else if M15 then R:=VarToCtrl( v, 0,99, varR,4) //反演变换
        else if K17 and M2 then R:=VarToCtrl( v, -1,1, varR,4) //三视图
        else if K18 then R:=VarToCtrl( v,0.1,2, varR,4) //标注半径
        else if K19 then R:=VarToCtrl( v, 0,9999, varR,4) //渐近线离心率
        else if M9 then begin //旋转变换
          if Deg then R:=VarToCtrl( v,-360,360, varR,4) //角度制
                 else R:=VarToCtrl( v,-towPi,towPi, varR,4); //弧度制
          defaultProp[5]:=R; //保存旋转角度用于反复创建变换
          end
        else if M7 or M10 or M12 then begin //投影率、缩放率
          R:=VarToCtrl( v,-999,9999, varR,4);
          if M7 and(Kind=4)then R:=VarToCtrl( v,0,1, varR,4); //平面投影率
          if M10 then defaultProp[6]:=R; //保存缩放值用于反复创建变换
          end
        else if(K7 and M1)then begin //旋转曲面初角
          if Deg then R:=VarToCtrl( v,-360,360, varR,4)
                 else R:=VarToCtrl( v,-towPi,towPi, varR,4);
          end
        else if(K2 and(M3 or M4))or K3 or K6 or K8 or(K4 and(M3 or M4 or M5 or M6 and Rand))then begin
          if Deg then R:=VarToCtrl( v,-360,360, varR,4) //角度制
                 else R:=VarToCtrl( v,-towPi,towPi, varR,4);
          end;
        if(iID<9)then //坐标轴长度
          case iID of 2:Obj[1].Vec.w:=R; 3:Obj[1].Vec.r:=R; 4:Obj[1].p4.r:=R; end;
        end;
     11:if(K11 and M2)then begin //varTrace
          maxTrace:= trunc(VarToCtrl( v,50,500, varTrace,0));//参数轨长
          setBarTrack(MarkObj);
          end
        else begin
          maxTrace:= trunc(VarToCtrl( v,0,200, varTrace,0));//痕迹数
          if maxTrace=0 then begin Trace:=false; cheTrace.Checked:=false; end;
          if K18 then maxTrace:=trunc(VarToCtrl( v,1,6, varTrace,0));//标记片数
          end;
     12:begin Deep:= VarToCtrl( v,2,300, varDeep,2); Obj[1].p4.x:=Deep; end; //Deep景深
     14:begin Pers:= VarToCtrl( v,0,64, varPers,2); Obj[1].p4.y:=Pers; end; //Pers透视
     24:with Obj[1]do begin
        case cmbObjKind.ItemIndex of
          0:p1.x:=v; 1:p1.y:=v; 2:p1.z:=v; 3:p1.w:=v;
          4:p2.x:=v; 5:p2.y:=v; 6:p2.z:=v; 7:p2.w:=v; 8:p5.w:=v;
          9:TagS:=trunc(v);
          end;
        varObjSize.Caption:=FtS(v);
        end;
      end; //case
      if(K10)and(M1)then TextToBMP(MarkObj,info[2], false);
      end; //with
    posEdit.Hide; posEdit.Tag:=0; bSelLink:=false;
    frmMain.KeyPreview:=true;
    if(t=0)then ObjListUpdate(MarkObj,true); //同时更新标签
    if(t in[12..24])or(MarkObj<11)then AxisList;
    if(t<12)then reRelate(iID,ObjCount,false,false,false);
    SetProjection(false,false, 11);
    if(t=14)then for i:=11 to ObjCount do
      if(Obj[i].Kind in[10,11,14])then TextAndImage(i, false,true,true,false);
    end;
end;

procedure TfrmMain.posEdit1KeyDown(Sender: TObject; var Key: Word; Shift: TShiftState);
begin
  hotKey:=Key;
  if(Key=VK_RETURN)or(Key=VK_ESCAPE)then
    posEdit.Visible:=false; //自动失去focus并激活posEditExit
end;

procedure TfrmMain.posEditExit(Sender: TObject);
  var st:string;  i,t,Len:integer;  isCode:boolean;
begin
  KeyPreview:=true;
  bSelLink:=false;
  st:=trim(posEdit.Text);
  if(hotKey=VK_ESCAPE)then exit; // or(st='')
  t:=(Sender as TComponent).Tag;
  if(t>0)then begin
    isCode:=(st='-');
    if not isCode and(st>'')then begin
      Len:=length(st); i:=0;
      repeat inc(i); isCode:=not(st[i] in[#48..#57, '-','.']);
      until(isCode)or(i>=Len);
      end;
    if(isCode)then exit;
    end;
  if(st<>edtTemp.Text)then begin
    if(t>0)and(MarkObj>10)and not((Obj[MarkObj].Kind=14)or(Obj[MarkObj].Kind=17)and(t=4))then //Kind=17 路径
      setObjLink(MarkObj, 0, st );
    if(st>'')then
      posEditValueChange(Sender, VK_RETURN);
    with Obj[MarkObj] do if(Kind=11)and(Mode=2)then R:=L;//回车改变参数初值
    save(0,MarkObj,1,true,true);
    end;
end;
//================ 数值录入控件 按键限制 =====================
procedure TfrmMain.posEdit1KeyPress(Sender: TObject; var Key: Char);
  var e:TEdit;  s:string;  i,p:integer; b:boolean;
begin 
  e:= (Sender as TEdit);
  if(e.tag=0)and(posEdit.Visible) then exit; //标签录入不作限制
  s:=trim(e.Text); p:=e.SelStart; //p光标位置
  case Key of
  '-':begin // '-'
    b:=s[1]='-';
    if e.SelLength<>length(s) then begin
      if b then e.Text:=copy(s,2,length(s)) else e.Text:='-'+s;
      if b then dec(p) else inc(p);
      e.SelStart:=p;
      key:=#0;
      end;
    end;
  '.':begin
    i:=pos( '.',s);
    if(i>0)then begin
      if(i>p)then s:=copy(s,1,p)
             else s:=copy(s,1,i-1)+ copy(s,i+1,p-i);
      e.Text:=s;
      e.SelStart:=p;
      end;
    end;
  else //#48..#57数字键 #8回车
    if(p=0)and(s[1]='-')then begin s:=''; e.Text:=''; end;
    if not(key in [#48..#57, #8])then key:=#0; //#0忽略按键
  end;
end;
//======================== 拖动鼠标改变对象的属性 =======================
procedure setObjFont(ID :integer; bFontToObj:boolean); //设置字体
  var i:integer;
begin //

end;

procedure TfrmMain.varAMouseDown(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
  var i,j,t,k,iID:integer;  bb:boolean;   tmpColor:TColor;
  function ItoS( i:integer):string; begin str( i:3, result); end;
  procedure apendItem(labelTag :integer);
    var i:integer;  bBreak,isSolid:boolean;
  begin
    if(Obj[MarkObj].Mode=7)then begin //投影变换
      for i:=11 to MarkObj-1 do with Obj[i] do
        if(Kind in[1,2,4,11])then addItem(i,0,false,false,false);
        end
    else if(Obj[MarkObj].Kind in[10,11])then begin //文本 图像
      if(labelTag=3)then begin //绑定到点
        for i:=11 to MarkObj-1 do
          if(Obj[i].Kind=1)then addItem(i,0,false,false,false);
        end
      else //阈值 显示
        for i:=11 to MarkObj-1 do
          if(Obj[i].Kind in[1,2,3,11])then addItem(i,0,false,false,false); //
      end
    else begin
      for i:=11 to MarkObj-1 do with Obj[i] do
        if(Kind=1)and((Mode<>4)or(Mode=4)and(not hide))
          then addItem(i,0,false,false,false);
      bBreak:=true;
      for i:=11 to MarkObj-1 do with Obj[i] do
        if(Kind=2)and(Mode<13)then
          begin addItem(i,0,false,false,bBreak); bBreak:=false; end;
      for i:=11 to MarkObj-1 do with Obj[i] do begin
        if(Kind=6)or(Kind=4)and(Mode=6)then isSolid:=true;
        if isSolid and(Kind=2)and(Mode=13)then //棱边
          begin isSolid:=false; addItem(i,0,false,false,false); end;
        end;
      bBreak:=true;
      for i:=11 to MarkObj-1 do with Obj[i] do
        if(Kind in[3,5,6,15,16])then
          begin addItem(i,0,false,false,bBreak); bBreak:=false; end;
      bBreak:=true;
      for i:=11 to MarkObj-1 do with Obj[i] do
        if(Kind=11)or(Kind=18)and(Mode=2)then
          begin addItem(i,0,false,false,bBreak); bBreak:=false; end;
      end;
  end;
begin
  Save( 0,MarkObj,1,false,true);
  x0:=x; y0:=y;

  t:= TComponent(Sender).Tag;   hotLabel:=Sender as TLabel;
  edtTemp.Text:=hotLabel.Caption;   edtTemp.Tag:=t;   edtTemp.SetFocus;
  posEdit.Tag:=t;
  addItem(0,0, true,true,false);  //'无关联'
  cheCutter.Hide; bSelLink:=false;
  with Obj[MarkObj] do begin
  k1:=Kind=1; k2:=Kind=2; k3:=Kind=3; k4:=Kind=4; k5:=Kind=5;
  k6:=Kind=6; k7:=Kind=7; k8:=Kind=8; k9:=Kind=9; k11:=Kind=11;
  k12:=Kind=12; k13:=Kind=13; k14:=Kind=14; k15:=Kind=15;
  m1:=Mode=1; m2:=Mode=2; m3:=Mode=3; m4:=Mode=4; m5:=Mode=5;
  m6:=Mode=6; m7:=Mode=7; m8:=Mode=8; m9:=Mode=9; m10:=Mode=10;
  m11:=Mode=11; m12:=Mode=12; m13:=Mode=13; m14:=Mode=14; m15:=Mode=15;
  case t of
   -1,-2:begin //varC 构件颜色
      if(MarkObj>10)then Save(0,MarkObj,1,false,true);
      if(K7 or K9)and((W>0)or U)then begin //曲面 眩彩或色随线
        W:=0; U:=false;  cheColor.Checked:=false;
        if K7 then Face( MarkObj, true,true, true);
        if K9 then FuncFace( MarkObj,true,true,true);
        setBevel( false, pnlColorH, imgColorH);
        setBevel( false, pnlColorV, imgColorV);
        exit;
        end;
      if((K5 or K17)and U)then begin //轨迹线 色随点
        U:=false; cheColor.Checked:=false; exit;
        end;
      if K13 and not U then begin //迭代
        U:=true;  cheWay.Checked:=false; //U 统一着色
        Iterate( MarkObj, true,true); 
        SetProjection(false,false,8);
        exit;
        end;
      pnlColorPad.Top:=90;
      pnlColorPad.Visible:=(ssLeft in Shift);
      pnlColor[18].Visible:=not( (K4 and M6 and not Rand) or K5 or(K6 and M5)or K7 or K17 ); //参数颜色
      exit;
      end;//-1,-2
    1,2,3:if(K1 and M1) or (K2 and M2) or (K3 and M1)
        or K6 or K7 or K8 or K10 or K11 or M10 or M11
      then apendItem(t);//[球] [块]的转角
    4,7:if K4 or K13 or K6 then apendItem(t); //varW
    5,6,8:if(K1 and M2)or(K3 and M1)or K4 and(M3 or M4 or M5 or M6) //varL varS varT
           or K2 or K6 or K8 or K10 or K11 or(K18 and M1) or M11 or M7
      then apendItem(t);
    9:if K1 and M2 or K2 and M4 or K3 and(M1 or M3)
        or(K4 and M6 and Rand) or K6 or K7 //varH
        then apendItem(t);
   10:if(K1 and M2) or (K2 and M2) or (K3 and M1) //varR
      or(K4 and(M1 or M2 or M3 or M4 or M5 or M6))  
      or K6 or K7 or K8 or K10 or K11 or K19
      or M7 or M9 or M10 or M11 or M12 or M15
      then apendItem(t);
   15,25:begin //15背景色 25默认标签字体
      ClearSelRec(0); //清除选择队列
      MarkObj:=ObjSelected(0, bS,bC,false,true);

      pnlFont.Visible:= (t=25)and(cmbObjKind.ItemIndex=9); //字体工具
      menFont.Checked:= pnlFont.Visible; //字体菜单
      pnlColorPad.Visible:=true;//调色板
      pnlColorPad.Top := IIFi(t=15,60,236);
      pnlColor[18].Visible:=false;
      if(t=25)and(cmbObjKind.ItemIndex=9)then begin
        pnlFont.Tag:=-3; //判断是否设置默认标签字体
        setFont( 0, true, false);//默认标签字体
        end;
      exit;
      end;
   26:begin //标签字体 字号 颜色 if Kind<>11 then
      menFont.Checked:=true;  pnlFont.Show;  pnlColorPad.Hide;
      pnlFont.Tag:=MarkObj;
      setFont( MarkObj, true, false);
      end;
    end; //case t
  end;  //with Obj[MarkObj]
  bb:=false;
  if(bC or bS)then exit;
  if(ssLeft in shift)and(t<>26)then with posEdit do begin
    Text:=TLabel(Sender).Caption;
    Top:= TLabel(Sender).Parent.Top+ 47;
    bSelLink:=(t<>4)or(t=4)and(K4 or K13 or K6); //点径、线宽不能关联
    Visible:=true;    SetFocus;
    for i:=0 to ObjCount do Obj[i].Edited:=(i=MarkObj);
    if(MarkObj>10)and(MarkObj<ObjCount)then
    for i:=MarkObj+1 to ObjCount do with Obj[i]do //为子对象作标记
      for j:=0 to LinkTime do
        if(Link[j]>10)and(Obj[Link[j]].Edited)then Edited:=true;
    frmMain.KeyPreview:=false;
    end; //with posEdit
end;

procedure TfrmMain.varAMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
  var i,t,dv,bK,bM,iID :integer;  b0,b1,b2,b3,b4,b5 :boolean;
      tmp:single;
  const dm=0.001; dc=0.01;
  function VarToCtrl( v, a,b :single; ctrl :TLabel; Len:integer) :single;
    var c: single;
    begin c:= v; if c<a then c:= a; if c>b then c:=b;
          result:=c; ctrl.caption:= FtoS(c,Len); ctrl.Refresh;
    end;
  function IntToCtrl( v, a,b :integer; ctrl :TLabel) :integer;
    var c: integer;
    begin c:= v; if c<a then c:= a; if c>b then c:=b;
          result:=c; ctrl.caption:= ItoS(c); ctrl.Refresh;
    end;
begin
  if not(bC or bS)then exit;
  if not( ssLeft in shift) then exit;
  dv:=x-x0- (y-y0)*5;
  t:= TComponent(Sender).Tag;   iID:=MarkObj;
  with Obj[ MarkObj] do begin
  b0:=Link[0]=0; b1:=Link[1]=0; b2:=Link[2]=0;
  b3:=Link[3]=0; b4:=Link[4]=0; b5:=Link[5]=0;
  bK:=Obj[Link[1]].Kind;  bM:=Obj[Link[1]].Mode;
  case t of
    1:case Kind of //posX
      1:if b0 then p0.x:= VarToCtrl( p0.x+ dv*dm,-20,20, posX,4);//p0.x
      6:if(Mode=1)and(Link[9]=0)then pTR.x:= VarToCtrl( pTR.x+ dv*dm, 0, 1-pTR.y, posX,4);
     10:if b0 then p0.x:=VarToCtrl( p0.x+ dv, 0,ClientWidth, posX,0)
              else p2.x:=VarToCtrl( p2.x+ dv,-400,200, posX,0);
     11:begin //参数 计算值
        p0.x:=VarToCtrl( p0.x+ dv, 0,ClientWidth, posX,0);
        if(Mode=2)and Trace then setBarTrack(MarkObj); //参数
        end;
     14:begin //控制按钮
        p0.x:=VarToCtrl(p0.x+dv, 0,999,posX,0);
        butID.Left:=trunc(p0.x);
        end;
      end;
    2:case Kind of //posY
      1:if b1 then p0.y:= VarToCtrl( p0.y+ dv*dm,-20,20, posY,4); //p0.y
      6:if(Mode=1)and(Link[11]=0)then pTR.y:= VarToCtrl( pTR.y+ dv*dm, 0, 1-pTR.x, posY,4);
     10:if b0 then p0.y:=VarToCtrl( p0.y+ dv, 0,ClientHeight, posY,0)
              else p2.y:=VarToCtrl( p2.y+ dv,-200,100, posY,0);
     11:begin  //参数 计算值
        p0.y:=VarToCtrl( p0.y+ dv, 0,ClientHeight, posY,0);
        if(Mode=2)and Trace then setBarTrack(MarkObj); //参数
        end;
     14:begin //控制按钮
        p0.y:=VarToCtrl(p0.y+dv, 50,ClientHeight,posY,0);
        butID.Top:=trunc(p0.y-H);
        end;
      end;
    3:case Kind of  //posZ
      1:if b2 then p0.z:= VarToCtrl( p0.z+ dv*dm,-20,20, posZ,4); //p0.z
      2:if b3 then p2.z:= VarToCtrl( p2.z+ dv*dm,-20,20, posZ,4);//点斜式直线的垂直转角
      3:if b4 then R:=VarToCtrl( R+ dv*dm,-10, 10, posZ,4);//点法圆的转角(扁度H>0时)
      6:if(Link[10]=0)then begin
        if Deg then Angle:=VarToCtrl( Angle+ dv, 0, 360, posZ,4)//
               else Angle:=VarToCtrl( Angle+ dv*dm, 0, towPi, posZ,4)
        end;
      7:if b3 then H:=VarToCtrl( H+ dv*dm, 0, 6.832, posZ,4);//旋转曲面的转角
      end;
    4:begin //varW
      if K1 and not M13 or K3 then begin
        W:=VarToCtrl( W+dv*dc, 0.5,20, varW,4);  //点径
        if K1 then Obj[1].p1.x:=W;  if K3 then Obj[1].p1.z:=W;  
        end
      else if M13 then begin
        iID:=Link[0];  t:=Kind;
        for i:=iID+1 to ObjCount do with Obj[i]do
          if(Link[0]=iID)and(Kind=t)and(Mode=13)then
            W:= VarToCtrl( W+dv*dc,1,40, varW,4) //多边形顶点
        end
      else if K2 and not M13 then begin
        W:=VarToCtrl( W+dv*dc, 0.5,40, varW,4); Obj[1].p1.y:=W; //直线宽
        end
      else if K4 and not M6 and b4 then H:=VarToCtrl( H+dv*dm, 0.01, 10, varW,4) //平面
      else if K4 and M6 and Rand and b2 and b4 then begin //正多边形
        H:=VarToCtrl( H+dv*dm, 0.01, 99, varW,4);
        if(W<>99)then begin //非长方形则计算半径
          t:=trunc(W); if(t>100)then t:=t-100;
          L:=H/sin(Pi/t)/2;   varL.Caption:=ftos(L,4);  varL.Refresh;
          end;
        end
      else if K6 and b5 then begin
        if M3 and(S=6)then
          W:=VarToCtrl(W+dv*dm, 0,20, varW,4) // 长方体
        else if M3 and(S<6)then begin //正多面体棱边
          W:= VarToCtrl( W+dv*dm, 0.1, 99, varW,4); //棱长
          L:= EdgeToRadius(W,S);
          varL.Caption:=ftos(L,4);  varL.Refresh;
          end
        else if(Obj[parent].Mode in[3,4])and(Mode in[7..15])then
          W:=VarToCtrl(W+dv*dm, 0,10, varW,4)
        else
          W:=VarToCtrl(W+dv*dm, 0,99, varW,4); //圆台、棱台的锥度
        end
      else if K14 then begin
        W:=VarToCtrl( W+dv, 60,999, varW,4);
        butID.Width:=trunc(W);
        end
      else if Kind in[5,7,9,15,16,17,18,19]then begin
        W:=VarToCtrl( W+dv*dc, 0.5,20, varW,4);
        if K5 then Obj[1].p2.y:=W; //线宽
        end;
      end;
    5:begin //varL
      if M11 then begin //平移变换
        if b1 then begin
          if U then begin //矢量平移 dL
            pBL.x:= VarToCtrl( pBL.x+ dv*dc, 0, 99, varL,4); // dL
            cgAngleToXYZ( pBL.x,pBL.y,pBL.z, pTR.x,pTR.y,pTR.z, true);
            end
          else
            pTR.x:= VarToCtrl( pTR.x+ dv*dc, -20, 20, varL,4); //平移变换 dX
          end;
        end
      else case Kind of
        1:if M6 then //等分点
            L:=VarToCtrl( L+dv, 2, 360, varL,0)
          else begin //约束点
            if(bK=1)and(bM=6)or(bK=13)then //等分点上、迭代像上的点
              L:= VarToCtrl( L+dv*0.3, 0, High(LocaVct[Link[1]]), varL,0)
            else if b2 then begin
              if(bK=2)or(bK=3)or(bK=4)and not Mask //约束点的约束距离
                then L:=VarToCtrl( L+dv*dc,-999,999, varL,4)
              else if(bK=6)
                then L:=VarToCtrl( L+dv*dc, 0,towPi, varL,4)
              else L:=VarToCtrl( L+dv*dm, 0,1, varL,4);
              end;
            end;
        3:if b2 and(M1)then begin
          L:= VarToCtrl( L+dv*dm,-10, 10, varL,4);  defaultProp[2]:=L;
          end;
        4:begin
          if b3 and(M3 or M4 or m5)then L:= VarToCtrl( L+dv*dm, 0.01, 20, varL,4);
          if b2 and b4 and M6 and Rand then begin //正多边形
            L:= VarToCtrl( L+dv*dm, 0.01, 20, varL,4);
            if(trunc(W)<99)then begin //非长方形则计算边长
              H:=2*L*sin(Pi/W); varW.Caption:=ftos(H,4); varW.Refresh;
              end;
            end;
          end;
        6:if b2 then L:= VarToCtrl( L+dv*dm, 0, 20, varL,4); //实体的半径
        7:if M1 then L:= VarToCtrl( L+ dv, 1, 64, varL,0)   //旋转曲面的精度
          else if M2 then S:= IntToCtrl( S+ dv, 2, 64, varS)
          else L:= VarToCtrl( L+ dv, 8, 64, varL,4);  //一般曲面
        8:if b2 then L:= VarToCtrl( L+dv*dm,-4, 4, varL,4);
       11:if b2 then begin
          L:=VarToCtrl( L+dv*dm,-999,999, varL,4);  //参数值
          if(L<p2.x)then L:=p2.x;   if(L>p2.z)then L:=p2.z;
          end;
        else
          if not((Link[2]>0)and(Kind<3))then begin
             L:= VarToCtrl( L+ dv*dm, 0.00001, 20, varL,4);//线长、半径、约束点的约束距离
             if(MarkObj<5)and(L<(R+0.5))then L:=R+0.5;
             end;
        end; //else case Kind
      end;
    6:begin //varS
      if b3 and K1 and M2 then begin // 约束点的起始值
        if(bK=2)or(bK=4)and(not Mask)then  //被直线或平面约束的点距
          p2.x:=VarToCtrl( p2.x+dv*dc, -999, 999, varS,4)
        else if(bK=3)and not Mask then
          p2.x:=VarToCtrl( p2.x+dv*dc, -towPi, towPi, varS,4)
        else
          p2.x:=VarToCtrl( p2.x+dv*dm, 0,1, varS,4);
        end;
      if K3 then Angle:=VarToCtrl( Angle+dv, 3,999, varS,0);
      if K4 and M6 and(W>100)then begin //正n边形的边数为W-100
        i:=trunc(W-100);
        i:= IntToCtrl( i+x-x0,3,99,varS);
        W:=i+100;
        end;
      if b3 and K2 and M2 then begin //向量
        if trunc(R)=0 then
          p2.x:=VarToCtrl( p2.x+dv*dm, -360, 360, varS,4); //角向量的平角
        if trunc(R)=1 then
          p2.x:=VarToCtrl( p2.x+dv*dm, -99, 99, varS,4); //向量的X偏量
        end;
      if K6 and(M1 or M2 or M6 or M15)then S:= IntToCtrl( S+x-x0, 2, 15, varS); //圆度
      if(Link[8]=0)and K6 and M4 and(S>100)then begin //正n棱台
        S:=S+x-x0; if(S<103)then S:=103; if(S>198)then S:=198;
        varS.Caption:=ItoS(S-100);   varS.Refresh;
        end;
      if b2 and M11 then begin //平移变换
          if U then begin //矢量平移 
            pBL.y:= VarToCtrl( pBL.y+ dv*dc, 0, towPi, varS,4); //  平角rX
            cgAngleToXYZ( pBL.x,pBL.y,pBL.z, pTR.x,pTR.y,pTR.z, true);
            end
          else
            pTR.y:= VarToCtrl( pTR.y+ dv*dc, -20, 20, varS,4); //平移变换 dY
        end;
      if K7 and(M1 or M2)then S:= IntToCtrl( S+dv, 3, 128, varS); //旋转曲面的边数
      if(K10 and b2)then R:=VarToCtrl( R+dv*dm, -20,20, varS,4); //文本 图像 隐阈
      if K11 and(M2 or M13) then begin        // 参数的起始值
          p2.x:=VarToCtrl( p2.x+dv*dc, -999, 999, varS,4);
          if(L<p2.x)then L:=p2.x;
          end;
      if K14 then S:= IntToCtrl( S+(x-x0)*10,1,1000,varS);
      if K18 then S:= IntToCtrl( S+dv, 2, 12, varS); //直线标记用的多边形边数
      end;
    7:if(K11 and M2)then begin
        Angle:= VarToCtrl( Angle+ (X-X0), 0, 1000, varA,0); //
        end
      else begin
        if(Link[12]=0)then begin //透明度
        tmp:=VarToCtrl( Color.A + dv*dm, 0.02, 1, varA,4);
        for i:=1 to SelRec[0] do with Obj[SelRec[20+i]] do
          if(Kind in[1..10, 15..19])and Hot or Seled then begin
            Color.A:=tmp;   Edited:=true;   if i<iID then iID:=i;
            end;
        end;
      end;
    8:begin //varT
      if(K1)and b0 then
        H:= VarToCtrl( H+ dv*IIFf(D,dm,dm/10), -1, 1, varT,4); //约束点的步长 圆的扁度
      if(K11 and b0)then //参数的增量
        H:= VarToCtrl( H+ dv*dm/10, -10, 10, varT,4);
      cheWay.Enabled:=H>0;
      if K10 and M1 then begin //文字行距
        S:= IntToCtrl( S+ dv, 0, 20, varT); 
        TextToBMP(MarkObj,info[2], false);
        end;
      if(K3 or K4 and not(M6 and(not D)))and b5 //厚度
        or K4 and M6 and not D and EP(Angle)
        then Thick:=VarToCtrl( Thick+dv*dm, -99, 99, varT,4); 
      if K18 then //直线标注的锥度
        Thick:= VarToCtrl( Thick+ dv*dm, -1,1, varT,4);
      end;
    9:case Kind of //varH
      1:if M6 and b0 then H:=VarToCtrl( H+dv*0.3, 0,trunc(L-1), varH,0); //等分点
      2:begin
        if M2 and b4 and(trunc(R)=1)then//向量
          p2.y:=VarToCtrl( p2.y+dv*dm, -99, 99, varH,4);
        if(M4 or M5)then //两点之中线/垂线
          Angle:=VarToCtrl( Angle+dv*dm, 0,1, varH,4); //间比
        end;
      3:if b3 then case Mode of
        1:begin H:=VarToCtrl( H+dv*dm, 0,IIFf(Kind=3,1,10), varH,4); //点法圆的扁度
          butSize19.Visible:=EP(H);
          end;
        3:H:=VarToCtrl( H+dv*dm, 0,30, varH,4); //圆弧长度
        9,10:R:=VarToCtrl( R+dv*dm,-999,999, varH,4); //旋转复制的转角
        end;
      4:begin
        if M3 and b2 then begin //平行面之线面角
          if Deg then pTR.x :=VarToCtrl( pTR.x +dv,-360,360, varH,4)
                 else pTR.x :=VarToCtrl( pTR.x +dv*dm,-towPi,towPi, varH,4);
          end;
        if M5 then begin //中面之角分比
          Angle:= VarToCtrl( Angle +dv*dm, 0, 1, varH,4)
          end;
        end;
      5,15,16:H:=VarToCtrl( H+dv*dc, 0.1,16, varH,4); //阈值
      6:if b3 and(Mode in[9,10])
          then R:=VarToCtrl( R+dv*dm, -999, 999, varH,4)   //复制球体的转角
          else if b4 then H:=VarToCtrl( H+dv*dm, -20, 20, varH,4); //实体的高度
      7:if M1 and b2 then begin //旋转曲面转角
        if Deg then H:=VarToCtrl( H+dv, 0,360, varH,4)
               else H:=VarToCtrl( H+dv*dm,-towPi,towPi, varH,4);
        end;
     10:if(b1)then H:=VarToCtrl( H+dv*dm, -20,20, varH,4); //文本/图像 隐阈
     14:begin H:=VarToCtrl(H+dv, 20,ClientHeight,varH,4);
        butID.Height:=trunc(H);
        butID.Top:=trunc(p0.y-H);
        end; //控制按钮
     17:H:=VarToCtrl( H+x-x0, 1,10, varH, 0); //路径密度
     19:H:=VarToCtrl( H+x-x0, 8,1024, varH, 0); //圆锥曲线密度
     18:H:=VarToCtrl( H+dv*dm, 0, 1, varH,4); //标记用多边形的间隔
      end;
   10:begin //varR
      if b4 and K1 and M2 then begin //约束点的终止值
        if(bK=4)and not Mask then //平面内部的点
          R:=VarToCtrl( R+ dv*dc, -999,999, varR,4)
        else if(bK=9)then //函数曲线上的点
          R:=VarToCtrl( R+ dv*dm, 0,1, varR,4)
        else if(bK=3)and Mask then //被圆内部约束的点角度
          R:=VarToCtrl( R+ dv*dc, 0,towPi, varR,4)
        else if(bK=3)and(not Mask)then //被圆约束的点终值
          p2.z:=VarToCtrl( p2.z+dv*dc, 0, 360, varR,4)
        else if(bK=2)then  //被直线约束的点终值
          p2.z:=VarToCtrl( p2.z+dv*dc, -999, 999, varR,4)
        else //终值
          p2.z:=VarToCtrl( p2.z+dv*dm, 0,1, varR,4);
        end;
      if b5 and K1 and M2 and(bK=6)then begin
        if(bM=1)then R:= VarToCtrl( R+dv*dm, 0, towPi, varR,4) //球体上的约束点
                else R:= VarToCtrl( R+dv*dm, -20, 20, varR,4); //台体高度
        end;
      if b3 and M11 then begin
          if U then begin //矢量平移 仰角
            pBL.z:= VarToCtrl( pBL.z+ dv*dc, -halfPi, halfPi, varR,4); //rZ
            cgAngleToXYZ( pBL.x,pBL.y,pBL.z, pTR.x,pTR.y,pTR.z, true);
            end
          else
            pTR.z:= VarToCtrl( pTR.z+ dv*dc,-20,20, varR,4); //平移变换dZ
        end;
      if b5 and K2 and M2 and(MarkObj>10)then begin //向量
        if(trunc(R)=0)then p2.z:=VarToCtrl( p2.z+dv*dm, -360, 360, varR,4); //角向量的仰角
        if(trunc(R)=1)then p2.z:=VarToCtrl( p2.z+dv*dm, -99, 99, varR,4);   //向量的z偏移量
        end;
      if K2 and(MarkObj<5)then begin // 坐标轴负轴长
        L:=L-R;
        R:=VarToCtrl( R+ dv*dc, 0,99, varR,4);
        L:=L+R;  varL.Caption:=ftos(L,4); varL.Refresh;
        end;
      if K2 and(M4 or M5)then begin 
        if M4 or(Obj[Link[0]].Kind=1)and(Obj[Link[1]].Kind=1)and(Link[3]=0) //两点之中线
          then R:=VarToCtrl( R+ dv*IIFf(Deg,1,dc), IIFf(Deg,-360,-towPi),IIFf(Deg,360,towPi), varR,4)   //两点之中线的角度
          else R:=VarToCtrl( R+ dv*dc, 0,1, varR,4);  //中线的角度比
        end;
      if b3 and(K8 or(K6 or K4)and(Mode<7))then begin //球 圆台转角
        if Deg then R:=VarToCtrl( R+dv,-360,360, varR,4)
               else R:=VarToCtrl( R+dv*dm, -towPi, towPi, varR,4);
        end;
      if(K10 and b3)then begin //文本 图像
        if Deg then Angle:=VarToCtrl( Angle+dv, -360,360, varR,4)
               else Angle:=VarToCtrl( Angle+dv*dm, -towPi,towPi, varR,4);
        end;
      if K11 and(M2 or M13)then begin      //参数的终止值
        p2.z:=VarToCtrl( p2.z+dv*dm, -990, 990, varR,4);
        if(L>p2.z)then L:=p2.z;
        end;
      if K14 then R:=VarToCtrl( R+dv*dm, 0, 10, varR,4); //
      if K17 and M2 then R:=VarToCtrl( R+dv*dm, -1, 1, varR,4); //三视图
      if K18 then R:=VarToCtrl( R+dv*dm, 0.1, 2, varR,4); //标记用多边形的半径
      if K19 and M2 and b3 then R:=VarToCtrl( R+dv*dm, 0, 9999, varR,4); //圆锥曲线离心率
      if(b4 and K3 and(Mode<7)) or(M7 and(Kind<>4))or M10 or M12
        then R:=VarToCtrl( R+dv*dm, -999, 999, varR,4); //转角、缩放值、向量变换值
      if M7 and(Kind=4)then R:=VarToCtrl( R+dv*dm, 0, 1, varR,4);
      if b3 and(M9 or K7 and M1 or K2 and(M3 or M4))then begin //旋转变换 旋转曲面
        if Deg then R:=VarToCtrl( R+dv,-360,360, varR,4)
               else R:=VarToCtrl( R+dv*dm,-towPi,towPi, varR,4);
        end;
      if M14 then R:=VarToCtrl( R+dv*0.1, 2, 20, varR,0); //自定义变换
      if M15 then R:=VarToCtrl( R+dv*dm, 0, 20, varR,4); //反演变换
      end;
   11:if K18 then
        maxTrace:= IntToCtrl( maxTrace+(x-x0), 1, 6, varTrace) //标记用多边形的片数
      else if K11 and M2 and Trace then begin //参数轨长
        maxTrace:= IntToCtrl( maxTrace+dv, 50, 500, varTrace); //
        butID.Width:=maxTrace+8;
        imgID.Width:=maxTrace+8;
        DrawParaBar(MarkObj, 0, false,false);
        end
      else begin
        maxTrace:= IntToCtrl( maxTrace+dv, 0, 200, varTrace); //varTrace 痕迹长度
        if maxTrace=0 then begin Trace:=false; cheTrace.Checked:=false; end;
        end;
   12:begin Deep:= VarToCtrl( Deep +dv/10, 2,300, varDeep,2);//Deep景深
        Obj[1].p4.x:=Deep; end;
   14:begin Pers:= VarToCtrl( Pers +dv/10, 0, 64, varPers,2);//Pers透视
        Obj[1].p4.y:=Pers; end; //
   24:with Obj[1] do  //默认构件属性
      case cmbObjKind.ItemIndex of
      0:p1.x:=VarToCtrl(p1.x+dv*dc,0.5,10, varObjSize,2);
      1:p1.y:=VarToCtrl(p1.y+dv*dc,0.5,10, varObjSize,2);
      2:p1.z:=VarToCtrl(p1.z+dv*dc,0.5,10, varObjSize,2);
      3:p1.w:=VarToCtrl(p1.w+dv*dc,0.5,10, varObjSize,2);
      4:p2.x:=VarToCtrl(p2.x+dv*dc,0.5,10, varObjSize,2);
      5:p2.y:=VarToCtrl(p2.y+dv*dc,0.5,10, varObjSize,2);
      7:p2.x:=VarToCtrl(p2.z+dv*dc,0.5,10, varObjSize,2);
      end;
    end; //case
  x0:=x; y0:=y;
  if(t in[12..20])or(iID<11)then AxisList;
  if(t<12)then reRelate(iID,ObjCount,false,false,false );
  if not(K11 and M2 and Trace and(t=11))then
    SetProjection(true,false,8);
  if(t=14)then //Pers透视
    for i:=11 to ObjCount do
      if(Obj[i].Kind in[10,11,14])then TextAndImage(i, false,true,true,false);
  end; //with
end;//varAMouseMove
procedure TfrmMain.varTMouseUp(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
  if TComponent(Sender).Tag=8 then CountObjNum(false,false);
  if(MarkObj>0)and(edtTemp.Text<>hotLabel.Caption)and(posEdit.Visible=false)then
    Save( 0,MarkObj,1,true,true);
  if not posEdit.Visible then
    frmMain.KeyPreview:=true;
end;
//====================== ↑编辑数值属性↑ ========================
procedure TfrmMain.cheSolidMouseUp(Sender: TObject; Button: TMouseButton;Shift: TShiftState; X, Y: Integer);
  var i,k,t,p, w0,h0:integer;  st:string;  dx,dy,dz,dr:single;   Key:char;
begin
  t:= TComponent(Sender).Tag;
  cheCutter.Hide;
  with Obj[ MarkObj] do begin
  case t of
    10:noSel:=not cheSel.Checked;//不可选择
    11:begin // cheColor 颜色随顶点  圆弧反向延伸
        if(Kind<>13)then U:=cheColor.Checked;
        if(Kind=6)and(Mode=3)and not U and not F then begin
          D:=true; cheMask.Checked:=true; cheMask.Enabled:=false;
          end;
        if(Kind=1)and(Mode=2)and(Obj[Link[1]].Kind=4)then begin
          cheMask.Enabled:=U; if not U then Mask:=false; cheMask.Checked:=false;
          end;//约束点起止值
        if(Kind=2)and(Mode=4)then varC.Visible:=true;
//        if(Kind in[2,3,7,8,9])or(Kind=4)and(Mode<5)then varA.Enabled:=not U; //透明度
        if(Kind=2)and(Mode=4)then varA.Enabled:=true;
        if(Kind=7)and U then begin
          Obj[MarkObj].W:= 0;
          setBevel( false, pnlColorH, imgColorH);
          setBevel( false, pnlColorV, imgColorV);
          end;
        if(Kind=11)and(Mode=2)then begin //參數動畫 頻率
          imgParaMouseDown( Obj[MarkObj].imgID, mbLeft,[],-1,2);
          bDown:=false;
          if not Assigned(timID) then begin
            timID:=TTimer.Create(self);
            timID.Tag:=MarkObj;
            timID.OnTimer:=timVarTimer;  //參數动画
            end;
          timID.Interval:=trunc(1000/Angle);
          timID.Enabled:=U;
          end;
        if(Kind=13)then begin //迭代 随机
          Rand:=cheColor.Checked;  cheRand.Checked:=Rand;
          end;
        if(Kind=14)and(Mode=3)and U then begin //控制按钮 总是隐藏
          sT:=Tag;  Q:=false;   cheSec.Checked:=false;
          if iLanguage=2 then sT:=StringReplace(sT,'Show','Hide',[rfIgnoreCase])// AFromText, AToText, [rfReplaceAll, rfIgnoreCase]);
                         else sT:=StringReplace(sT,'显示','隐藏',[rfIgnoreCase]);//
          Tag:=sT;  butID.Caption:=sT;
          end;
        if(Kind=18)and(Mode=2)then begin //标注角度
          Rand:=cheColor.Checked;
          cheSec.Enabled:=not Rand;   cheBlock.Enabled:=not Rand;
          end;
        if(Mode=9)then begin varC.Visible:=true; varC.Enabled:=true; end;
        end;
    12:begin //cheSolid 填充
        if(Kind=1)and(Mode=2)then   //约束点双向移动
          begin way:=false; Q:=false; cheSec.Checked:=false; end;//F双向 Q反向
        if(Kind=2)and(M1 or (Obj[Link[0]].Kind=19))then Rand:=cheSolid.Checked //线段反向 双曲线的渐近线
          else F:= cheSolid.Checked;
//        if(Kind in[6,7,9])then varA.Enabled:=F; //透明度
        if(Kind=4)and(Mode=6)then cheMask.Enabled:=F;
        if(Kind=6)then begin
          Mask:=false; cheBlock.Checked:=false; //遮挡
          if not F and(Mode<>9)then
            if(Obj[parent].Mode>2)then D:=true;
          cheMask.Checked:=D;//贴图 棱边
          cheMask.Enabled:=F or(Mode=4)and(S<100);
          end;
        if(Kind=7)then begin Lock:=false; cheLock.Checked:=false; end; //Lock 线族
        if(Kind in[7,9])then cheWay.Enabled:=F;
        if(Kind=11)then begin
          info[2]:=FtoS(L,4); if not F then info[2]:=Tag+' ='+info[2];// if F then info[2]:=FtoS(L,4) else info[2]:=Tag+' ='+FtoS(L,4);
          end;
        if(Kind=13)then cheDot.Checked:=F; //迭代含点
        end;
    13:begin // cheMask
        if(Kind=1)and(Mode=2)then begin
          if(Obj[Link[1]].Kind=3)then begin //圆上的点
            Mask:=not cheMask.Checked;//为与老版本兼容 Mask=false 是为边缘点
            but51.Visible:=not Mask; //允许作轨迹线
            if Mask then R:=Obj[Link[1]].L; //圆内部的点
            end;
          if(Obj[Link[1]].Kind in[4,9])then begin //平面上的点  函数曲面上的点
            Mask:=cheMask.Checked; //为与老版本兼容 Mask=false 是为内部点
            but51.Visible:=Mask; //允许作轨迹线
            end;
          ShowObjProp(MarkObj,0,0, true,true);
          end;

        if(Kind=11)then //缩写
          Mask:=cheMask.Checked
        else
          if(Kind>1)then begin
            D:=cheMask.Checked; //贴图、轨迹线、轨迹面 跟随主动点
            if not D and(Kind=4)then LinkName[10]:=0; 
            end;
        if(Kind=2)and(Mode in[1,4,19])then begin  //是否为射线
          //varL.Enabled:=D or(Obj[Link[0]].Link[1]=Link[1]);
          if D then begin
            if F then L:=L/2 else L:=20;
            varL.Caption:=ftos(L,4);
            F:=false; cheWay.Checked:=false;
            end;
          if D=false then Link[2]:=0;
          end;
        if(Kind=4)and(Mode=6)then cheSolid.Enabled:= Rand; //多边形的边框
        if( (Kind=4)and not((Mode=6)and not Rand) or(Kind=6)and(Mode<3)  //Rand正多边形
          or(Kind=7)or(Kind=9) )
          and(texID=0)and D then //平面球体台体曲面是否贴图
          OpenPicture(MarkObj,true,true);
        if(Kind=10)and(Mode=2)then begin //图片显示图片背景
          if(info[0]>'')then
            texID:= myLoadTexture(MarkObj,texID, sgfPath+info[0], nil, w0,h0, kw,kh, not D);
          if(sImage.sFormat>'')then
            texID:= TxtToImg(MarkObj,texID, sImage.sData, sImage.sFormat, w0,h0, kw,kh, not D );
          p0.z:=w0; p0.w:=h0;
          end;
        if(Kind=13)then cheLast.Checked:=Mask; //迭代终象
        end;
    14:begin // cheWay
       if(Mode=7)then D:=cheWay.Checked  //投影变换 投影线
       else if(Mode=11)then begin //平移变换
          U:=cheWay.Checked; //矢量平移
          dx:=pTR.x; dy:=pTR.y; dz:=pTR.z;
          if U then begin  //矢量平移 将直角坐标转换为球坐标
            cgXYZtoAngle(pTR.X,pTR.Y,pTR.Z, pBL.y,pBL.z,pBL.x, true);
            labL.Caption:='dL';  labS.Caption:='rX';  labR.Caption:='rZ';
            dx:=pBL.x; dy:=pBL.y; dz:=pBL.z; //pBL 平移矢量
            end
          else begin
            labL.Caption:='dX';  labS.Caption:='dY';  labR.Caption:='dZ';
            end;
          varL.Caption:=IIFs(Link[1]>0, Obj[Link[1]].Tag, FtoS(dx,4));
          varS.Caption:=IIFs(Link[2]>0, Obj[Link[2]].Tag, FtoS(dy,4));
          varR.Caption:=IIFs(Link[3]>0, Obj[Link[3]].Tag, FtoS(dz,4));
          end
       else case Kind of
        2:begin
          F:=cheWay.Checked;  //varL.Enabled:=F or(Mode in[2,3,5,6]); //是否为直线
          if F then begin
            if(MarkObj<8)or(Mode in[1,4,19])and D
              then L:=L*2 else L:=40;
            if(Mode in[1,4,19])then begin D:=false; cheMask.Checked:=D; end;//线段、垂线、切线
            end
          else
            L:=L/2;
          varL.Caption:=ftos(L,4);
          end; //基点为直线中点
        3:if(Mode<>7)then begin if(S>99)then S:=S-100 else S:=S+100; end; //扇形 Mode=7投影
        6:begin Trace:= cheWay.Checked; //正多面体的中点移到底面
          if(Mode=1)and(Obj[Link[1]].Kind=1)then begin
            varL.Enabled:=not Trace;  if Trace then Link[2]:=0;
            varH.Enabled:=not Trace;  if Trace then Link[4]:=0; H:=0;
            end;
          end;
        7:if(Mode=4)then Mask:=cheWay.Checked; //跟随轨迹线
        9,18,19: U:= cheWay.Checked; //曲面法线取反
        11:if Mode=2 then Q:=cheWay.Checked else U:= cheWay.Checked; //Q参数动画按钮 U度量角度的补角
        13: U:=not cheWay.Checked; //迭代 原象色
        14: Q:= cheWay.Checked; //控制按钮 单次
        17: D:= cheWay.Checked; //圆滑路径
         end;
       end;
    15:begin Q:=cheSec.Checked; //cheSec 剪裁  显示计算式
        if(Kind=1)and(Mode=2)then //约束点反向运动
          begin way:=false; F:=false; cheSolid.Checked:=false; end; //Q反向 F双向
        if(Kind=4)then begin
          if(Mode=6)then for i:=1 to trunc(W) do Obj[MarkObj+i].Q:= Q;//边框剪裁
          end;
        if(Kind=6)and(Mode in[3,4])then begin //棱边剪裁
          k:=IIFi(mode=3, SolidEdge[S], S*3);
          for i:=1 to k do begin
            Obj[MarkObj+i].Q:= Q;
            Obj[MarkObj+i].Cutter:= Cutter;
            end;
          end;
        if(Kind=14)and(Mode=3)and Q then begin //控制按钮 总是显示
          sT:=Tag;  U:=false;   cheColor.Checked:=false;
          if iLanguage=2 then sT:=StringReplace(sT,'Hide','Show',[rfIgnoreCase])
                         else sT:=StringReplace(sT,'隐藏','显示',[rfIgnoreCase]);
          Tag:=sT; butID.Caption:=sT;
          end;
        if(Obj[parent].Kind in[2,3,4,5,6,7,9,13,15,16,17,19])then begin
          if(cheCutter.Count=0)and Q then begin
            cheCutter.Top:=pnl23.Top+15; cheCutter.Show;
            end
          else
            cheCutter.Hide;
          bSelLink:=cheCutter.Visible;
          end;
        end;
    16:begin //cheLock 锁定
        Lock:=cheLock.Checked;
        if(Kind=7)and(Mode=4)then begin F:=false; cheSolid.Checked:=false; end; //轨迹曲面线族
        end;
    17:begin //cheMask
        if(Kind in[1,11])and(Mode=2) //随机约束点或参数
          then begin Rand:=cheBlock.Checked; varT.Enabled:=not Rand; labT.Enabled:=not Rand; end   //约束点 随机动画
          else Mask:=cheBlock.Checked;  //遮挡
        if(Kind=6)then begin
          if Mask then begin F:=false; cheSolid.Checked:=false; end; //F 填充
          D:=(Obj[parent].Mode in[3,4,5,6]); //D 边框
          cheMask.Checked:=D; cheMask.Enabled:=false;
          end;
        if(Kind=14)then nTrace:=0; //控制按钮 手动控制
        end;
    18:begin //痕迹  参数轴
        if(Kind=6)and(Obj[parent].Mode=3)
          then Rand:=cheTrace.Checked //分色
          else begin
            Trace:=cheTrace.Checked;  varTrace.Enabled:=Trace and not K6;
            end;
        if(Kind=11)and(Mode=2)then begin //参数轴
          butID.Visible:=Trace;  if Trace then setBarTrack(MarkObj); //end;  cheColor.Checked:=true;
          end
        else if(K18 and M2)then begin //角度标注
          texTag:= TagToBMP(MarkObj,true);    TagShow[Layer]:=true;
          end
        else if not(K6 or K14)then begin //痕迹
          if Trace and(maxTrace=0)then begin
            maxTrace:=10;   varTrace.Caption:=itos(maxTrace);
            end;
          if not Trace then glDeleteLists( tracList, 200);
          end;
        end;
    19:D:=cheRound.Checked; //函数曲线首尾相连
    20:begin  //底边式 以底边两个端点作正多面体
        S:=S mod 10;
        S:=ord( cheBottom.Checked)*10+S;
        end;
    24:begin //cheSmooth 反锯齿
        setEnable( cheSmooth.Checked, GL_LINE_SMOOTH );
        setEnable( cheSmooth.Checked, GL_POINT_SMOOTH );
        glShadeModel( IIFc( cheSmooth.Checked, GL_SMOOTH, GL_FLAT));
        end;
    25:bGrid:=cheGrid.Checked;  //cheGrid 网格线
    26:if not cheFlash.Checked then pnlFPS.Caption:=SwitchS(iLanguage,' 属性',' 屬性',' Propertis','');
    27:frmMain.ShowHint:=cheHint.Checked; //cheHint 工具提示
    28:begin bAxis:=cheAxis.Checked;//轴线
        if bAxis then for i:= 2 to 4 do Obj[i].ObjShow[Layer]:=true;
        for i:=2 to 4 do Obj[i].Hot:=false;
        chePlane.Enabled:=bAxis;
        cheGrid.Enabled:=bAxis;   cheAxisZ.Enabled:=bAxis;
        cheMark.Enabled:=bAxis;   cheAngle.Enabled:=bAxis and cheMark.Checked;
       end;
    29:setEnable( cheFog.Checked, GL_FOG);  //雾效
    30,31:begin cheAngle.Enabled:=cheMark.Checked;   AxisList; end;//坐标轴刻度
    32,33:AxisList; //坐标平面
    47:begin //显示
        Key:='H';
        if(SelRec[0]>1)then
          FormKeyPress(nil, Key)
        else begin
          p:=barPage.Position;
          Obj[MarkObj].ObjShow[p]:=not Obj[MarkObj].ObjShow[p];
            setBevel(not Obj[MarkObj].ObjShow[p], aObjShow[p],nil);
          Obj[MarkObj].Hot:=Obj[MarkObj].ObjShow[p];
          if(Obj[MarkObj].Kind=14)and Assigned(Obj[MarkObj].butID)then
            Obj[MarkObj].butID.Visible:=Obj[MarkObj].ObjShow[p];
          end;
        end;
    end; //case t

  if t>22 then begin
    st:=Obj[1].info[0];
    if cheAxis.Checked    then st[ 1]:='1' else st[ 1]:='0';
    if cheAxisZ.Checked   then st[ 2]:='1' else st[ 2]:='0';
    if cheGrid.Checked    then st[ 3]:='1' else st[ 3]:='0';
    if cheOrigin.Checked  then st[ 4]:='1' else st[ 4]:='0';
    if cheFog.Checked     then st[ 5]:='1' else st[ 5]:='0';
    if cheSmooth.Checked  then st[ 6]:='1' else st[ 6]:='0';
    if cheFlash.Checked   then st[ 7]:='1' else st[ 7]:='0';
    if cheHint.Checked    then st[ 8]:='1' else st[ 8]:='0';
    if cheTag.Checked     then st[ 9]:='1' else st[ 9]:='0';
    if chePlane.Checked   then st[10]:='1' else st[10]:='0';
    if cheMark.Checked    then st[11]:='1' else st[11]:='0';
    if cheAngle.Checked   then st[12]:='1' else st[12]:='0';
    if bNail              then st[13]:='1' else st[13]:='0';
    Obj[1].info[0]:=st;
    end;
  end; //with
  edtTemp.SetFocus;
  if(MarkObj<11)then AxisList;
  if(t<23)then reRelate(MarkObj,ObjCount,false,false,false);
  SetProjection(false,false,13);
end;
//==================== 设置运动按钮 =====================
procedure TfrmMain.setSportMenu(bSport,bPause :boolean); //设置运动菜单项
begin
  menSport.ImageIndex:=IIFi(bSport or bPause,10,8);
  menStart.ImageIndex:=IIFi(bSport and bPause,9,7);
  case iLanguage of
    0:begin
      menSport.Caption:=IIFs(bSport or bPause,'停止&','运动&');
      menStart.Caption:=IIfs(bSport and bPause,'暂停&','逐点描绘&');
      end;
    1:begin
      menSport.Caption:=IIFs(bSport or bPause,'停止&','運動&');
      menStart.Caption:=IIfs(bSport and bPause,'暫停&','逐點描繪&');
      end;
    2:begin
      menSport.Caption:=IIFs(bSport or bPause,'Finish','Sport');
      menStart.Caption:=IIfs(bSport and bPause,'Pause','Gradually');
      end;
    end;
  timAuto.Enabled:= bPause;
end;

procedure TfrmMain.setTimer(t:integer; Draw:boolean);
  var i, first,last :integer;
  procedure setMenuPosition;
    var i:integer;
  begin
    for i:=0 to tlbShort.ControlCount-1 do tlbShort.Controls[i].Show;
    if not menMenuOnBottom.Checked then begin //置于顶部
      with tlbMenu do begin //主菜单
        Top:=0; Left:=0;
        tlbMenu.Anchors:=[akLeft, akTop]; EdgeBorders:=[ebRight, ebBottom];
        end;
      with tlbMain do begin //主工具栏
        Top:=0; Left:=410;
        Anchors:=tlbMenu.Anchors;       EdgeBorders:=[ebLeft, ebBottom];
        end;
      with tlbTools do begin //作图工具栏
        Top:=24; Left:=0; Width:=26; Height:=158; Anchors:=tlbMenu.Anchors;
        end;
      with tlbShort do begin //动态工具栏
        Top:=tlbTools.Top+tlbTools.Height;  Left:=0; Width:=26; Height:=frmMain.Height;
        Anchors:=[akLeft, akTop, akBottom]; EdgeBorders:=[ebRight, ebTop,ebBottom];
        end;
      end
    else begin //置于底部
      with tlbMenu do begin //主菜单
        Top:=IIFi(stbBar.Visible or tabPage.Visible, stbBar.Top-24, frmMain.ClientHeight-24);
        AnChors:=[akLeft, akBottom];   EdgeBorders:=[ebRight, ebTop,ebBottom];
        end;
      with tlbMain do begin //主工具栏
        Top:=tlbMenu.Top; Left:=410;
        Anchors:=[akLeft, akRight, akBottom]; EdgeBorders:=[ebLeft, ebTop,ebBottom];
        end;
      with tlbTools do begin //作图工具栏
        Top:=tlbMenu.Top-25; Width:=164; Height:=25; Anchors:=tlbMenu.Anchors;
        end;
      with tlbShort do begin //动态工具栏
        Top:=tlbTools.Top; Left:=164; Width:=stbBar.Width; Height:=25;
        Anchors:=[akLeft, akRight, akBottom]; EdgeBorders:=[ebLeft, ebTop,ebBottom];
        end;
      end;
    for i:=0 to tlbShort.ControlCount-1 do tlbShort.Controls[i].Hide;
  end;
begin
  if(MarkObj>10)then Obj[MarkObj].hot:=false;
  case t of
  88:begin rX:=270; rY:=270; rZ:=0; Obj[1].p3.z:=rX; Obj[1].p3.w:=rY; Obj[1].p3.r:=rZ; end; //YZ平面
  89:begin rX:=180; rY:=270; rZ:=0; Obj[1].p3.z:=rX; Obj[1].p3.w:=rY; Obj[1].p3.r:=rZ; end; //XZ平面
  90:begin rX:=0;   rY:=0;   rZ:=0; Obj[1].p3.z:=rX; Obj[1].p3.w:=rY; Obj[1].p3.r:=rZ;
    is2D:=butLock.Down;
    if is2D and cheAxisZ.Checked then begin cheAxisZ.Checked:=false; AxisList; end;
    end; //XY平面
  91:begin //状态栏
    menStatus.Checked:=not menStatus.Checked;
    tabPage.Left:=IIFi( menStatus.Checked,400,0);
    tabPage.Width:=stbBar.Width - IIFi( menStatus.Checked,400,0);
    stbBar.Visible:= menPages.Checked or menStatus.Checked;
    if menMenuOnBottom.Checked then setMenuPosition;
    end;
  92:begin //工具栏
    menTools.Checked:=not menTools.Checked;
    tlbTools.Visible:=menTools.Checked; //常用工具栏
    tlbShort.Visible:=menTools.Checked; //动态工具栏
    end;
  93:begin //页面栏
    menPages.Checked:=not menPages.Checked;
    tabPage.Visible:=menPages.Checked;
    stbBar.Visible:= menPages.Checked or menStatus.Checked;
    if menMenuOnBottom.Checked then setMenuPosition;
    end;
  94:begin //菜单位置
    menMenuOnBottom.Checked:=not menMenuOnBottom.Checked;
    setMenuPosition;
    end;
  95:begin //对象列表
    butList.Down:=not butList.Down;
    menList.Checked:=butList.Down;
    pnlList.Visible:=butList.Down;
    end;
  96:begin //恢复原始场景
    initDefault;
    Start( false); //初始化画板 (参数False将显示空画板)
    end;
  100:begin //逐点绘制轨迹线
    if not bSport then begin
      i:=10; first:=0; last:=ObjCount;
      repeat inc(i);  //搜索轨迹线
        with Obj[i] do if(kind=5)and(mode=1)then begin
          if(ObjShow[Layer])then first:=Link[1];
          end;
        until (i>ObjCount)or(first>0);
      if first>0 then last:=Obj[i].Link[0];
      for i:= first to last do
        with Obj[i] do
          if(Kind=1)and(Mode=2)and(H>0)then L:=p2.x; //移动速度大于零的约束点
      for i:=11 to ObjCount do Obj[i].way:=false;
      SportTime:=0; bSport:=true; bPause:=true;
      end
    else
      bPause:=not bPause;
    end;
  101:begin //[M]键
    bPause:=not bPause; ClearSelRec(0); //清除选择队列
    if bSport then begin
      bPause:=false; bSport:=false;
      reRelate(MarkObj,ObjCount,false,false,false);
      end;
    end;
  102:begin
    bSport:=false; bPause:=false;
    if Draw then reRelate(MarkObj,ObjCount,false,false,false);
    if(ObjCount>10)and Draw then ObjListUpdate(0,false);
    end;
  end;
  if(t=100)or(t=101)then setSportMenu(bSport,bPause);
  if not bPause then updateTitle;
//  if t<250 then timFlash.Enabled:= false;
  if(t<>100)and Draw then begin SetProjection(false,false,14); end;
end;

procedure TfrmMain.setWindowStyle; //全屏切换
  var i :integer;  Saved :LongInt;
begin
    If(BorderStyle=bsNone)or isUseToControler then Exit;
    Saved:=GetWindowLong(Handle,gwl_Style); //
    if IsZoomed(frmMain.Handle)and(not tlbMain.Visible)then begin //全屏状态
      tlbMain.Visible:=true;    tlbMenu.Visible:=true;
      tlbTools.Visible:=true;   tlbShort.Visible:=true;
      butZoom.Visible:=false;
      stbBar.Visible:=menPages.Checked or menStatus.Checked;
      PostMessage(Handle, WM_SYSCOMMAND, SC_RESTORE,0);//恢复
      If (Saved and ws_Caption)<>ws_Caption then Begin //显示标题栏
        Case BorderStyle of
          bsSingle,bsSizeable :
            SetWindowLong(Handle,gwl_Style,Saved or ws_Caption or ws_border);
          bsDialog :
            SetWindowLong(Handle,gwl_Style,Saved or ws_Caption or ds_modalframe or ws_dlgframe);
          End;
        Height:=Height+getSystemMetrics(sm_cyCaption);
        End;
      end
    else begin //非全屏状态
      if IsZoomed(frmMain.Handle)then //已经最大化 但未全屏
        PostMessage(Handle, WM_SYSCOMMAND, SC_RESTORE,0); //先回复常态
      PostMessage(Handle, WM_SYSCOMMAND, SC_MAXIMIZE,0);//全屏
      If (Saved and ws_Caption)=ws_Caption then Begin //隐藏标题栏
        Case BorderStyle of
          bsSingle,bsSizeable :
            SetWindowLong(Handle,gwl_Style,Saved and(Not(ws_Caption)) or ws_border);
          bsDialog :
            SetWindowLong(Handle,gwl_Style,Saved and(Not(ws_Caption)) or ds_modalframe or ws_dlgframe);
          End;
        Height:=Height-getSystemMetrics(sm_cyCaption);
        End;
      Height:=Height+TitleHeight-10;
      tlbMain.Visible:=false;   tlbMenu.Visible:=false;
      tlbTools.Visible:=false;  tlbShort.Visible:=false;
      pnlShow.Visible:=false;   butZoom.Visible:=true;
      stbBar.Visible:=(tabPage.Tabs.Count>1)and menPages.Checked;
      end;
    for i:=11 to ObjCount do with Obj[i] do begin
      if(Kind=14)then
        butID.Top:=trunc(p0.y)-butID.height-TitleHeight;
      if(Kind=11)and(Mode=2)and Trace then //+TagP.y
        butID.Top:=trunc(p0.y) -butID.height-TitleHeight+12;
      end;
    Refresh;
//    SetProjection(false,false,14);
end;
//======================= KeyDown =======================
procedure TfrmMain.FormKeyDown(Sender: TObject; var Key: Word; Shift: TShiftState);
  const FontSizes:array[0..17]of Integer=(8,9,10,11,12,14,16,18,20,22,24,26,28,36,48,56,64,72);
  var i,j,k, w0,h0,w1,h1,x,y,tmpObj :integer; var0,var1 :single;
      BMP:TBitmap;  JPG:TJPEGImage;  tmpFile,sForm :string;   ch:char;
      isShow, noSelect :boolean;
      hDrop : UInt;
      FileName : array [0..MAX_PATH] of AnsiChar;
  procedure SelSameObj(ctrlA,shiftA :boolean);//全选指定类型的对象 由Shift+A激活
    var i, nK,nM, dady :integer;  bSel :boolean;
  begin //
    nK:=0; nM:=0; //if(n<1)then exit;
    if(MarkObj>0)then begin //最后选中的对象
      nK:=Obj[MarkObj].Kind;  nM:=Obj[MarkObj].Mode;  dady:=Obj[MarkObj].parent;
      end;
    for i:=0 to maxObj do SelRec[i]:=0; //清空选择队列
    for i:=11 to ObjCount do Obj[i].Hot:=false; //取消被选状态
    noSelect:= (MarkObj<1);
    for i:=11 to ObjCount do with Obj[i] do begin
      if(DelID>0) or Hide or(not ObjShow[Layer]and not bAll)then continue;
      bSel:=ctrlA and not shiftA and noSelect   //全选
         or ctrlA and not shiftA and(Kind=nK)   //同类型
         or shiftA and not ctrlA and(Kind=nK)and(Mode=nM) //同类型同模式
         or shiftA and ctrlA and(Kind=nK)and(Mode=nM)and(parent=Dady); //同类型同模式同父对象
      if bSel then begin
        Hot:=true;  MarkObj:=i;
        inc(SelRec[0]); inc(SelRec[Kind]); SelRec[SelRec[0]+20]:=i;
        end;
      end;
    end;
  procedure updateText(ID:integer);
  begin
    with Obj[ID]do
      case Kind of
        10:begin texID:= TextToBMP(ID, info[2],true); TextAndImage(ID, false,true,true,false); end; //[文字]
        11:TextAndImage(ID, false,true,true,false);
        14:begin setFont(ID,true,false);  butID.Font:=tagFont; end;// //控制按纽 setFont(ID,true,true);//
        else GetTextList( ID);//标签
        end; //case Kind
    end;
begin  //itos(TextToShortCut('Alt+Up')); //32808
  if pnlControl.Visible then // posEdit.Visible or pnlCalc.Visible or pnlText.Visible
    exit;
  if bS and(Key=27)then begin //Shift+Esc 全屏切换
    setWindowStyle;
    exit;
    end;
  keyDown:=true;
  case Key of
    16:begin bS:=true; edtTemp.SetFocus; end; //[Shift]
    17:begin bC:=true; edtTemp.SetFocus; end; //[Ctrl]
    18:begin bA:=true; edtTemp.SetFocus; end; //[Alt]
    88..90:if not bC then begin //[X] [Y] [Z]
      if not timSpin.Enabled then begin
        tmpObj:=MarkObj; MarkObj:=Key-83; menXYZClick(menViewer); MarkObj:=tmpObj;
        end
      else begin
        keyX:= Key=88; if keyX then dy:=0;
        keyY:= Key=89; if keyY then dx:=0;
        end;
      end;
    13:if not bAdd then begin //Shift+Enter 自动排列二维定位对象 文本、参数、计算、度量、按钮...
      if bS or bC then begin
        k:=0;  w0:=0; h0:=0; isShow:=false;
        for i:=11 to ObjCount do with Obj[i]do
          if(DelID=0)and(Kind in[10,11,14])and Hot then begin
          inc(k);
          if(k=1)then begin w0:=trunc(p0.x); end; //左边界
          if(k=2)then begin h0:=abs(trunc(p0.y)-y-TagSize.Y);
            end; //间距
          if(k>1)then begin
            if trunc(p0.x)<>w0 then isShow:=true;//左边界不等
            if(abs(trunc(p0.y)-TagSize.Y-y)<>h0)then isShow:=true; //间距不等
            end;
          y:=trunc(p0.y); //if(Kind=14)then y:=y-TagSize.y;
          end;
        if(k<2)then exit;
        k:=0;
        for i:=11 to ObjCount do with Obj[i]do
          if(DelID=0)and(Kind in[10,11,14])and Hot then begin
          inc(k);
          if(k=1)then x:=trunc(p0.x);
          if isShow then begin //重排列
            if(k>1)then begin
              p0.x:=x;  p0.y:=y+TagSize.Y;
              end;
            y:=trunc(p0.y);
            end
          else  //增减间距
            p0.y:=p0.y+IIFi(bC,-k+1,k-1); //按Ctrl则缩小间距
          if(Kind=14)then begin
            butID.Left:=x;
            butID.Top:=trunc(p0.y)-TitleHeight-TagSize.y+3;
            end;
          TextAndImage(i,false,false,(Mode=2)and bS, false);
          end;
        end
      else begin
        end;
      SetProjection(false,false,8);
      end;
    27:begin // ESCAPE
      bC:=false; bS:=false; bA:=false;
      if(PaintNum>0)then begin //正在手绘
        setPaintList(true);
        exit;
        end;
      if bAdd and not bDotJoin then with Obj[ObjCount]do begin
        if(Kind=4)and(Mode=6)and(not Rand)and(selNum>2)then begin //任意多边形
          k:=trunc(W);
          for i:=1 to k do with Obj[ObjCount+i] do begin //边框属性
            W:=2;  D:=false;  F:=false; color:=Obj[ObjCount].Color; //ObjShow[]:=true;
            for j:=0 to LayerTime do begin ObjShow[j]:=true; TagShow[j]:=false; end;
            end;
          save(1,ObjCount,1,true,false);
          ObjCount:=ObjCount+k;
          ReRelate(MarkObj, ObjCount, false,false,false );
          ObjListUpdate(0,false);
          end
        else begin
          dec( ObjCount, CancelNum);
          for i:=1 to CancelNum do Obj[ObjCount+i].Tag:='';
          end;
        Cursor:= crDefault;
        bAdd:=false; nK:=0; nM:=0; hit:=-1;
        end;
      if not bAdd then MarkObj:=0;
      if bDotJoin then with Obj[MarkObj] do begin //自由点寻找约束构件状态
        Mode:=1; Link[0]:=0; Link[1]:=0; Link[2]:=0; bDotJoin:=false;
        end;
      tlbMain.Enabled:=true;  labHint.Top:=-20;
      butAll.Down:=false;    // butLock.Down:=false;
      bAll:=false;   bSelLink:=false;
      for i:=11 to ObjCount do Obj[i].Way:=false;
      if(PaintListNum>0)then begin //取消手绘选择
        for i:=1 to PaintListNum do PaintData[i].Hot:=false;
        end;
      if(HotTool.Tag+HotMenu.Tag=0)then begin
        ClearSelRec(0); //清除选择队列
        pnlShow.Visible:=false;
        end;  
      HotTool.Down:=false; butProp.Down:=false; HotTool:=butArrow; //HotMenu:=menBar57;
      butPaintRect.Visible:=false;
      butPaintCircle.Visible:=false;
      butPaintDel.Visible:=false;
      butArrow.Down:=true; //释放工具按钮
      HideAllPanel;
      if bPause then setTimer(101,false);
      if bSport then setTimer(102,true);
      for i:=0 to ObjCount do with Obj[i] do if(Kind=14)then begin
        if F then butIDMouseDown(butID, mbLeft,[ssLeft],0,0);
        butID.Visible:=ObjShow[Layer];
        end;
      for i:=11 to maxObj do with Obj[i] do if Assigned(timID)then timID.Enabled:=false;
//      timAnimate.Enabled:=false;
      timAuto.Enabled:=false;
      timSpin.Enabled:=false;
      butSpin.Down:=false;
  //    cmbTag.ItemIndex:=0;      //Obj[1].Mask:=false;
      for i:=11 to ObjCount do with Obj[i] do
        if(Trace)and(nTrace>0)then begin //删除构件的跟踪痕迹
          glDeleteLists( tracList, nTrace-1);
          glDeleteLists( tracList+ nTrace+1, maxTrace-nTrace);
          nTrace:=0;
          end;
      SetProjection(false,false,2);
      exit;
      end; //begin
    32:if hotMenu<>menBar57 then //空格键
        AppObjProc( hotMenu);
        //AppendObj( (hotMenu as TMenuItem).Tag, hotToolK);
    33,34:begin //PgUp/PgDn 翻页
      OldPage:=tabPage.TabIndex;
      if(Key=33)and(OldPage>0) or (Key=34)and(OldPage<tabPage.Tabs.Count-1)then begin
        if(Key=33)and(OldPage>0)then //PgUp 向左翻页
          NewPage:=tabPage.TabIndex-1;
        if(Key=34)and(OldPage<tabPage.Tabs.Count-1)then //PgDn 向右翻页
          NewPage:=tabPage.TabIndex+1;
        ChangePage(NewPage, OldPage);
        tabPage.TabIndex:=NewPage;  OldPage:=NewPage;
        end;
      end;
    37,39,100,102:begin//左右方向键
      with Obj[MarkObj]do
      if bS then begin
        if(Kind=1)and(Mode=1)then begin //自由点x坐标
          p0.x:=p0.x + IIFf(Key in[37,100],-0.01,0.01);
          posX.Caption:=ftos( p0.x, 4);
          end;
        if(Kind=1)and(Mode=2)then begin //约束点
          L:= L + IIFf(Key in[37,100],-0.01,0.01);
          varL.Caption:=ftos(L,4);
          end;
        if(Kind in[10,11,14])then begin //屏幕横坐标
          p0.x:=p0.x + IIFf(Key in[37,100],-1,1);
          posX.Caption:=ftos( p0.x, 0);
          if(Kind=14)then butID.Left:=trunc(p0.x);
          end;
        reRelate(MarkObj,ObjCount,false,false,false);
        SetProjection(false,false,9);
        end
      else if(timSpin.Enabled)then
        dx:=dx+IIFi(Key in[37,100],-1,1)  //自动旋转时改变转速
      else begin  //改变层
        k:=barPage.Position;
        if(key in[37,100])then dec(k) else inc(k); if(k<0)then k:=0;
        barPage.Position:=k;
        end;
      end;
    38,40,98,104:if not bA then with Obj[MarkObj]do begin  //上下方向键
      if(timSpin.Enabled)then
        dy:=dy+IIFi(Key in[38,98],-1,1) //自动旋转时改变转速
      else if bC and not bS then begin //遍历构件
   //     k:=cmbTag.ItemIndex;
   //     if(Key=38)or(Key=98)then dec(k) else inc(k);   if(k<1)then k:=1;
   //     cmbTag.ItemIndex:=k;  cmbTagSelect(cmbTag);
        end
      else if bS and not bC and(Kind=1)and(Mode=1)then begin //自由点y坐标
        p0.y:=p0.y + IIFf(Key=38,0.01,-0.01); posY.Caption:=ftos(p0.Y,4);
        reRelate(MarkObj,ObjCount,false,false,false);
        SetProjection(false,false,9);
        end
      else if bS and bC and(Kind=1)and(Mode=1)then begin //自由点z坐标
        p0.z:=p0.z + IIFf(Key=38,0.01,-0.01); posZ.Caption:=ftos(p0.Z,4);
        reRelate(MarkObj,ObjCount,false,false,false);
        SetProjection(false,false,9);
        end
      else if bS and(Kind in[10,11,14])then begin //屏幕纵坐标
        p0.y:=p0.y + IIFf(Key in[38,98],-1,1);
        posY.Caption:=ftos( p0.y, 0);
        if(Kind=14)then butID.Top:=trunc(p0.y)-TitleHeight-butID.Height+1;
        reRelate(MarkObj,ObjCount,false,false,false);
        SetProjection(false,false,9);
        end;
      end;
{Del}46:if((MarkObj>10)or(PaintListNum>0))and(not bAdd)then begin
      if cheCutter.Visible and(cheCutter.ItemIndex>=0)then begin //删除截面
        for i:=cheCutter.ItemIndex to cheCutter.Count-1 do
          Obj[MarkObj].Cutter[i]:=Obj[MarkObj].Cutter[i+1];
        cheCutter.DeleteSelected;
        if cheCutter.Count<1 then begin
          cheSec.Checked:=false;  Obj[MarkObj].Q:=false;  cheCutter.Hide;
          end;
        with Obj[MarkObj]do
          if(Kind=6)and(Mode in[3,4])then begin //棱边剪裁
            k:=IIFi(mode=3, SolidEdge[S], S*3);
            for i:=1 to k do begin
              Obj[MarkObj+i].Q:= Q;
              Obj[MarkObj+i].Cutter:= Cutter;
              end;
            end;
        end
      else
        DeleteObj(MarkObj,true);//DELETE 删除构件
      end;
    48..58:if not(bc or bs)then barPage.Position:=IIFi(Key=48, 9, Key-49); //叶面跳转1-10
    81:menXYZClick(menViewer);    //Ctrl+Q 面对指定平面
    112:Shellexecute(0,nil,'inRm3D Help.chm',nil,nil, SW_SHOWDEFAULT);//[F1]
{F2}113:if(menMark8.Enabled)then menMarkClick(menMark8); //[F2]定义变换
{F3}114:menTransClick(men128); //[F3]执行变换
    115:set2Dstyle; //[F4] 2D/3D状态 相当于按Z+L并隐藏z轴
    107,109,187,189:if not(bA or bC)then with Obj[MarkObj]do begin //+-号
      if(Mode=2)and(Kind in[1,11])then begin
        if(Kind=11)then begin //改变参数
          if(Key<>iT)then save(0, Markobj, 1, false,true); //保存Undo
          if Rand then begin  // Mask 随机
            var0:=p2.x;  if(Link[3]>0)then var0:=Obj[Link[3]].L; //起点
            var1:=p2.z;  if(Link[4]>0)then var1:=Obj[Link[4]].L; //终点
            L:=random(trunc((var1-var0)*1000))/1000+var0;
            end
          else begin
            if(Key in[107,187])then L:=L+H; //H 增量
            if(Key in[109,189])then L:=L-H;
            end;
          info[2]:=IIFs(F,'',Tag+' =')+FtoS(L,S);
          varL.Caption:=ftos(L,4);
          if(Key<>iT)then save(0, Markobj, 1, true,true);  //保存Redo
          iT:=Key;
          if Trace then setBarTrack(MarkObj); //参数轴
          end;
        if(Kind=1)then begin
          if(Obj[Link[1]].Kind=13)then begin //迭代终像上的点
            if(Key in[107,187])then L:=L+IIFi(L<High(LocaVct[Link[1]]),1,0);
            if(Key in[109,189])then L:=L+IIFi(L>=1,-1,0);
            end
          else if(abs(H)>0)then begin //约束点
            if(Key in[107,187])then L:=L+H;
            if(Key in[109,189])then L:=L-H;
            end;
          end;
        varL.Caption:=ftos(L,4);
        reRelate(MarkObj,ObjCount,false,false,false);
        SetProjection(false,false,9);
        key:=0;
        end;
      if(Kind=13)and(Link[0]=0)then begin //迭代深度
        if(Key in[107,187])then inc(S);
        if(Key in[109,189])and(S>0)then dec(S);
        reRelate(MarkObj,ObjCount,false,false,false);
        SetProjection(false,false,9);
        key:=0;
        end;
      end;
    end;
  if(bS or(bC and bS))and(Key in[48..57])then with Obj[MarkObj] do begin
    if(bC and bS)and(Key in[48..57]) //11..16
      then i:=Key-39
      else i:=IIFi(Key=48, 9, Key-49);
    ObjShow[i]:=not ObjShow[i];
    setBevel(not ObjShow[i], aObjShow[i],nil);
    end;
  if bA then // Alt
    case Key of
    38:if(MarkObj>1)then begin //上下键 选择父对象
        for i:=0 to 20 do SelRec[i]:=0; //清空选择队列
        for j:=1 to ObjCount do with Obj[j]do
          if(DelID=0)and Hot then begin
            Hot:=false;
            for i:=0 to LinkTime do if(Link[i]>0)then begin
              MarkObj:=Link[i];   Obj[MarkObj].Hot:=true;
              inc(SelRec[0]);     inc(SelRec[Obj[MarkObj].Kind]);
              SelRec[20+SelRec[0]]:=MarkObj;
              end;
            end;
        if(SelRec[0]>0)then CountObjNum(false,false);
        SetProjection(false,false,9);
      end;
    40:begin //上下键 选择子对象
        for i:=0 to 20 do SelRec[i]:=0; //清空选择队列
        for k:=1 to ObjCount-1 do
          if(Obj[k].DelID=0)and Obj[k].Hot then begin
            Obj[k].Hot:=false;
            for j:=k+1 to ObjCount do with Obj[j]do
              for i:=0 to LinkTime do if(Link[i]=k)and(not Hot)then begin
                MarkObj:=j;   Obj[j].Hot:=true;
                inc(SelRec[0]);     inc(SelRec[Obj[j].Kind]);
                SelRec[20+SelRec[0]]:=j;
                end;
          end;
        if(SelRec[0]>0)then CountObjNum(false,false);
        SetProjection(true,false,9);
      end;
    187: but10Click(men111);  //Alt + = 计算
    188,190:begin //Alt + <>键 改变标签字号
      for i:=11 to ObjCount do with Obj[i]do
        if(Hot)and((Kind in[10,11,14])or TagShow[Layer])then begin
          k:=-1; repeat inc(k); isShow:=(FontSizes[k]>=TagS); until isShow or(k>17);
          if isShow then begin
            if(Key=188)and(k>0 )then TagS:=FontSizes[k-1];
            if(Key=190)and(k<17)then TagS:=FontSizes[k+1];
            Obj[1].TagP.z:=TagS;
            updateText(i);
            end;
          end;
      if pnlFont.Visible then cmbFontS.Text:= itos(trunc(Obj[1].TagP.z));
      SetProjection(false,false,9);
      end;
    191:if(SelRec[0]>0)then ShowControlBox( MarkObj, 30, tabLabel);   // Alt+/ 设置标签
    end;//if bA ...case Key
  if bS and not bC and(Key=65)then selSameObj(false, true); //Shift+A
  if bC or (Shift=[ssCtrl]) then case Key of
    48..57:barPage.Position:=IIFi(Key=48,Key-29, Key-39); //叶面跳转至11-20
    65:if(ObjCount>10)then begin //Ctrl+A
        if bS then selSameObj(true,true)   //选择同类型对象
              else selSameObj(true,false); //Ctrl+A全选
        CountObjNum(false,false);
        end;
    66:for i:=11 to ObjCount do with Obj[i]do //Ctrl+B黑体字
        if(Hot)then begin
        if(TagT[1]='0')then TagT[1]:='1' else TagT[1]:='0';
        Obj[1].TagT:=TagT;
        updateText(i);
        end;
    67:if not isUseToControler then menCopyObjClick(menCopyObj);   //Ctrl+C复制构件
    72:begin ch:='H'; FormKeyPress(nil, ch); end; //Ctrl+H 显示/隐藏对象
    73:for i:=11 to ObjCount do with Obj[i]do
       if(Hot)then begin //Ctrl+I斜体字
        if(TagT[2]='0')then TagT[2]:='1' else TagT[2]:='0';
        Obj[1].TagT:=TagT;
        updateText(i);
        end;
    75:begin ch:='K'; FormKeyPress(nil, ch); end; //Ctrl+K 显示/隐藏标签
    77:if menStart.Enabled then setTimer(100,false); //Ctrl+M
    78:Start( false);   //Ctrl+N 建立新文件
    79:if bS then begin //Ctrl+Shift+O 原点归零
         Origin:=cgOrigin; Obj[1].p3.x:=0; Obj[1].p3.y:=0;  SetProjection(true,false,0);
         end
        else begin butOpenClick(nil); bC:=false; end;//Ctrl+O 打开文件
    80:if bS then but10Click(men112);  //Ctrl+Shift+P 新建参数
    81:menXYZClick(menXYZ);    //Ctrl+Q 面对指定平面
    82:Undo( false);        //Ctrl+R 撤消操作
    83:if not isReadOnly then SaveFile( sgfFile);  //Ctrl+S 保存文件
    84:if bS then           //Ctrl+Shift+T 字体
        menWidth9Click(menFont)
      else with Obj[MarkObj]do begin //Ctrl+T 跟踪
        Trace:=not Trace; cheTrace.Checked:=Trace;
        if Trace and(maxTrace=0)then maxTrace:=10;
        end;
    85:for i:=11 to ObjCount do with Obj[i]do  //Ctrl+U 下划线字体
       if(Hot)then begin
        if(TagT[3]='0')then TagT[3]:='1' else TagT[3]:='0';
        updateText(i);
        end;
    86:begin //Ctrl+V 粘贴
      if Clipboard.HasFormat(CF_BITMAP)then begin //Ctrl+V 粘贴图片
        tmpFile := exePath+'tmp.JPG'; //临时文件
        BMP:=TBitmap.Create;
        BMP.Assign(Clipboard);
          jpg:= TJpegImage.create;
          jpg.Assign( bmp);
          jpg.CompressionQuality:=90;  //图象质量
          jpg.SaveToFile( tmpFile); //临时保存jpg图象文件
          jpg.free;
        BMP.Free;
        if(MarkObj<11)or not(Obj[MarkObj].Kind in[3,4,6,7,9])then begin
          inc(ObjCount);  //添加图像构件
          with Obj[ObjCount] do begin
            Kind:=10;   Mode:=2;  Tag:=getTag(MarkObj);
            Hot:=true;  L:=1;  R:=0;
            Name:=getObjName(1);//inc(backObj.maxName); Name:=backObj.maxName;
            p0.x:=50;  p0.y:=Height-40;  Color:=cgColorF(1,1,1,1);
            for i:=0 to 24 do begin Link[i]:=0; LinkName[i]:=0; end;
            for i:= 0 to 24 do ObjShow[i]:=true;
            if(Obj[MarkObj].Kind=1)then //粘贴到点上
              begin Link[9]:=MarkObj; LinkName[9]:=Obj[MarkObj].Name; end;
            end;
          MarkObj:=ObjCount;
          Save( 1,MarkObj,1,true,false);
          end;
        with Obj[MarkObj] do begin
          sImage.sFormat:='.JPG';
          sImage.sData:= ImgToTxt(MarkObj, tmpFile, sImage.sFormat);
          texID:= myLoadTexture(MarkObj,texID, tmpFile, nil, w0,h0,kW,kH, true );//最后的true表示透明
          TagSize.x:=w0; TagSize.y:=h0;
          p0.z:=w0; p0.w:=h0;  D:=(Kind<>10);
          if(Kind=9)then info[3]:='' else info[0]:='';  //取消与文件的关联
          if(Kind=4)then begin Link[10]:=0; LinkName[10]:=0; end;
          end;//with  Color:=cgColorF(1,1,1,1);  ColorB:=Color;
        DeleteFile(tmpFile); //删除临时文件
        ObjListUpdate(MarkObj,true);
        reRelate(MarkObj,MarkObj,false,true,false);
        SetProjection(true,false,8);
        end
      else if high(CopyObj)>0 then begin
        menPasteObjClick(menPasteObj); //Ctrl+V 粘贴构件
        end;
      end;
    88:Close;
    90:Undo( true);  //Ctrl+Z 恢复操作
    end;//case Key
end;
procedure TfrmMain.FormKeyUp(Sender: TObject; var Key: Word; Shift: TShiftState);
  var i,NowPage :integer;
begin //Tag键只能在FormKeyUp事件中才能被捕获
  if(ssCtrl in Shift)and(Key=9)and(tabPage.Tabs.Count>0)then begin //Tab
    with tabPage do begin
      NowPage:=TabIndex;
      if TabIndex=(Tabs.Count-1)then OldPage:=0 else OldPage:=TabIndex+1;
      TabIndex:=OldPage;
      end;
    PaintNum:=0; PaintMax:=0; PaintListNum:=0;
    SaveThisPage(NowPage,ObjCount, false,true);
    ReadThisPage(OldPage);
    updateTexture(false);
    ObjListUpdate(0,true);
    ReRelate(11, ObjCount, false,false,false );
    SetProjection(false,false,0);
    for i:=11 to ObjCount do
      if(Obj[i].Kind in[10,11,14])then TextAndImage(i, false,true,true, false);
    exit;
    end;
  if Key=16 then bS:=false; // [Shift] key up.;
  if Key=17 then bC:=false; // [Ctrl] key up. ;
  if Key=18 then bA:=false; // [Alt] key up
  if(Key in[16,17])and(Obj[MarkObj].Kind=2)and(Obj[MarkObj].Mode=2)then bL:=false;
  keyDown:=false;  keyX:=false; keyY:=false;
end;
//======================= KeyPress =======================
procedure TfrmMain.FormKeyPress(Sender: TObject; var Key: Char);
  var i,j,p:integer; ch:char;  st:string;  isShow:boolean;
begin
  if bAdd or posEdit.Visible then exit; //
  ch:= upcase(Key);
  case ch of
  'A':if not(bC or bS)then begin bAll:=not bAll; butAll.Down:=bAll; //显示全部隐藏的对象
      menAll.Checked:=bAll;
      for i:= 11 to ObjCount do with Obj[i] do if(delID=0) then
        if(Kind=14)or(Kind=11)and(Mode=2)then butID.Visible:= ObjShow[Layer]or bAll;
      end;   //显示全部构件
  'G':begin cheFog.Checked:= not cheFog.Checked;
        setEnable( cheFog.Checked, GL_FOG);
        end;
  'I':begin //对象列表
      butList.Down:=not butList.Down;
      menList.Checked:= butList.Down;
      pnlList.Visible:= butList.Down;
      end;
  'L':if(MarkObj<11)then with Obj[1]do begin //锁定场景
      Mask:=not Mask;   butLock.Down:=Mask;
      if Mask then info[0][18]:='1' else info[0][18]:='0';
      is2D:=butLock.Down and(rX=0)and(rY=0)and(rZ=0);
      if is2D and cheAxisZ.Checked then begin
        cheAxisZ.Checked:=false;  AxisList;
        end;
      end;
  'M':if bSport then bSport:=false
      else
        if menSport.Enabled then setTimer(101,false);  //自动移动
  'O':cheOrigin.Checked:=not cheOrigin.Checked; //显示/隐藏原点
  'P':begin
      butProp.Down:=not butProp.Down;
      but10Click(butProp);
      end;
  'R':begin //自动旋转
      edtTemp.SetFocus;
      timSpin.Enabled:=not timSpin.Enabled;   butSpin.Down:=timSpin.Enabled;
      if(dx=0)and(dy=0)then dx:=-10;
      end;
  'S':begin cheSmooth.Checked:= not cheSmooth.Checked; //反锯齿
      setEnable( cheSmooth.Checked, GL_LINE_SMOOTH );
      setEnable( cheSmooth.Checked, GL_POINT_SMOOTH );
//      glShadeModel( IIFc( cheSmooth.Checked, GL_SMOOTH, GL_FLAT));
      end;
  end;
  if ch in['A','S','G','O']then begin
    SetProjection(true,false,15);
    st:=Obj[1].info[0];
    if cheOrigin.Checked    then st[4]:='1' else st[4]:='0';
    if cheFog.Checked       then st[5]:='1' else st[5]:='0';
    if cheSmooth.Checked    then st[6]:='1' else st[6]:='0';
    Obj[1].info[0]:=st;
    end;

  if MarkObj<1 then exit;
  with Obj[MarkObj] do
  case ch of
  'F':if(Kind>2)then begin //填充状态
      F:= not F;  cheSolid.Checked:= F;
      cheMask.Caption:=SwitchS(iLanguage,IIFs(Mode<3,'贴图', '棱边'),IIFs(Mode<3,'貼圖', '棱邊'),IIFs(Mode<3,'Texture', 'Edge'),'');
      if(Kind=6)then begin
        if F then Mask:=false;  cheBlock.Checked:=Mask; //遮挡
        if not F and(Mode<>9)then
          if(Obj[parent].Mode in[3,4,5])or(Obj[parent].Mode>2)then D:=true;
        cheMask.Checked:=D;//贴图 棱边
        if(Obj[parent].Mode=4)and(S>100)then begin
          cheMask.Enabled:= F;
          end;
        end;
      reRelate(MarkObj,MarkObj,false,false,false);
      end;
  'H':begin  //显示/隐藏当前构件
      p:= barPage.Position;  isShow:=false; i:=10;
      repeat inc(i) until(Obj[i].Hot)or(i>ObjCount);//搜索第一个被选择的点
      if(i<=ObjCount)then begin
        for j:=11 to ObjCount do with Obj[j] do //显示状态有否不同
          if Hot and(Obj[i].ObjShow[p]<>ObjShow[p])
            then isShow:=true;
        end;
      for i:=11 to ObjCount do with Obj[i] do
        if hot then begin
          if isShow then ObjShow[p]:=true else ObjShow[p]:= not ObjShow[p];
          setBevel(not ObjShow[p], aObjShow[p],nil);
          if(Kind=14)or(Kind=11)and(Mode=2)then butID.Visible:=ObjShow[p];
          if not ObjShow[p] then Hot:=false;
          end;
      cheShow.Checked:=ObjShow[p];
      ObjListUpdate(MarkObj, false);
      end;
  'K':begin isShow:=false; i:=10;
      p:= barPage.Position;
      repeat inc(i) until(Obj[i].Hot)or(i>ObjCount);//搜索第一个被选择的点
      if(i<=ObjCount)then begin
        for j:=11 to ObjCount do with Obj[j] do //标签显示状态有否不同
          if Hot and(Obj[i].TagShow[p]<>TagShow[p])
            then isShow:=true;
        end;
      for i:=11 to ObjCount do with Obj[i] do
        if Hot then
        for j:= Layer to LayerTime do begin //显示构件标签
          if isShow then TagShow[j]:=true else TagShow[j]:= not TagShow[j];
          setBevel(not TagShow[j], aTagShow[j],nil);
          end;//j
      end;
  'L':begin
      if(Kind<>5)then begin Lock:=not Lock; cheLock.Checked:=Lock; end;
      if(Kind=18)and(Mode=2)then GetTextList(MarkObj); //角度标注
      end;
  end;
  SetProjection(false,false,16);
end;
//======================= 显示队列控制 =========================
procedure TfrmMain.barPageChange(Sender: TObject);
  var i:integer;
begin 
  if bOpenFile then exit;
  Layer:= barPage.Position;
  bAll:=false; butAll.Down:=bAll; menAll.Checked:=bAll;
  for i:= 0 to LayerTime do aObjShow[i].Font.Color:= clBlack;
  aObjShow[Layer].Font.Color:=clRed;
  for i:= 11 to ObjCount do with Obj[i] do if(delID=0)then
    if(Kind=14)or(Kind=11)and(Mode=2)then
      if assigned(butID)then butID.Visible:= ObjShow[Layer];
  if cheAxis.Checked and cheGrid.Checked then GridList;

  SetProjection(false,false,17);
end;
//===================== 添加/删除页面 ===========================
procedure TfrmMain.UpDwPageClick(Sender: TObject; Button: TUDBtnType);
  var i,j, layerMax,NewMax :integer;
begin
  layerMax:=barPage.Max;  NewMax:=UpDwPage.Position;  // pagePos:=barPage.Position;
  if layerMax<NewMax then begin //添加队列
    for j:= 11 to ObjCount do with Obj[j] do
      for i:= NewMax downto Layer+1 do
        begin ObjShow[i]:= ObjShow[i-1];  TagShow[i]:= TagShow[i-1];  end; //for
    end;
  if layerMax>NewMax then begin //删除队列
    if Layer>NewMax then barPage.Position:=NewMax //原位置
    else
    for j:= 11 to ObjCount do with Obj[j] do
      for i:= Layer to layerMax do
        begin ObjShow[i]:= ObjShow[i+1];  TagShow[i]:= TagShow[i+1];  end; //for
    end;
  layerMax:= NewMax;
  barPage.Max:=  layerMax;
  barPage.Width:=layerMax*15+19;
  pnlShow.Width:=(layerMax+1)*15;
  if pnlShow.Visible then
  for i:=0 to layerMax do with Obj[MarkObj]do begin
    setBevel( not ObjShow[i], aObjShow[i], nil );  //对象显示状态
    setBevel( not TagShow[i], aTagShow[i], nil );  //标签显示状态
    end; // for i
  SetProjection(true,false,10);
end;
//===================== 轴线颜色 =======================
function TfrmMain.getScrColor( c:TcgColorF):TcgColorF;
begin
  with c do begin
    if(R+G+B>1.6)then result:=cgColorF(0,0,0,1)
                 else result:=cgColorF(1,1,1,1);
  end;
end;
//====================== 背景色 ===========================
procedure TfrmMain.setBackColor(color:TColor; t,k:integer);
  var i :integer;
begin
  case k of
  21..23:Obj[1].LinkName[k-19]:=color;  //坐标轴颜色   cgTColorToCGColorF(Color,1)
  25:begin varObjColor.Color:=color; //默认构件颜色
      Obj[1].Link[cmbObjKind.ItemIndex+1]:=color;
      Obj[1].ColorB:=cgTColorToCGColorF( Obj[1].Link[9], 1);
      reRelate(11,ObjCount,false,false,false);
      exit;
      end;
  26:begin //标签颜色
      Obj[MarkObj].TagC:=color;  varColor.Color:=color;
      GetTextList(MarkObj);
      end
  else begin //背景色
    frmMain.Color:=Color;
    Obj[1].LinkName[0]:=Color;
    BackColor:=cgTColorToCGColorF( Color, 1.0);
    glClearColor( BackColor.R, BackColor.G, BackColor.B, 1.0);
    AxisColor:= getScrColor( BackColor);
    for i:= 11 to ObjCount do with Obj[i] do
      if not(Kind in[10,11]) then GetTextList( i); //标签
    end;
  end; //case k
  if k<26 then AxisList;  //重建轴线的显示列表
//  SetProjection(true,false,17);
end;
//===================== 箭头设置 ======================
procedure TfrmMain.imgSingleMouseDown(Sender: TObject;Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
  var i,t :integer;
begin
  with Obj[MarkObj] do
    i:=trunc( IIFf(Kind=2, H, L));   // 原箭头值
  t:= TComponent(Sender).Tag;   // 1-左箭头 2-右箭头
  case t of
    1:i:= IIFi( i<2, 1-i, 5-i);
    2:i:= IIFi((i=2)or(i=0), 2-i, 4-i);
    3:i:= IIFi( i<>1, 1,0);
    4:i:= IIFi( i<>2, 2,0);
  end;
  if t<3 then begin // 直线两端的箭头
    setBevel( (i=1)or(i=3), pnlLeft, imgLeft);
    setBevel( (i=2)or(i=3), pnlRight, imgRight);
    Obj[MarkObj].H:= i;
    end
  else  //平面的菱形方式
    Obj[MarkObj].L:= i;
  reRelate(MarkObj,ObjCount,false,false,false);
  SetProjection(false,false,19);
//  Save(0,MarkObj,1,true);
end;
//===================== 截面设置 ======================
procedure TfrmMain.imgForeMouseDown(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
  var i :integer;
begin
  i:= trunc(Obj[MarkObj].H); //原值
  case TComponent(Sender).Tag of
    1:i:= IIFi( i<>1, 1,0);
    2:i:= IIFi( i<>2, 2,0);
  end;
  if i>0 then begin Obj[MarkObj].Q:=false; cheSec.Checked:=false; end;
  Obj[MarkObj].H:= i;
  SetProjection(true,false,20);
//  Save( 0,MarkObj,1,true);
end;
//===================== 炫彩设置 ======================
procedure TfrmMain.imgColorHMouseDown(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
  var i :integer;
begin
  i:= trunc(Obj[MarkObj].W); //原值
  case TComponent(Sender).Tag of
    1:i:= IIFi( i<>1, 1,0);
    2:i:= IIFi( i<>2, 2,0);
  end;
  setBevel( i=1, pnlColorH, imgColorH);
  setBevel( i=2, pnlColorV, imgColorV);
  Obj[MarkObj].W:= i;
  if i>0 then begin Obj[MarkObj].U:=false; cheColor.Checked:=false; end;
  reRelate(MarkObj,MarkObj,false,false,false);
  SetProjection(false,false,20);
//  Save( 0,MarkObj,1,true);
end;
//================ 构件闪烁显示 =================
procedure TfrmMain.timFlashTimer(Sender: TObject);
begin
  bFlash:=true;
  MainDraw( GL_RENDER, true, 'd');
//  SetProjection(true,true,23);
end;
//====================== 定时器 =======================
procedure TfrmMain.timAutoTimer(Sender: TObject);
  var i,first,last :integer;
begin
  if not bPause then exit;
  i:=10; first:=0; last:=ObjCount;
  if bSport then begin //逐点绘制轨迹线
    repeat inc(i);  //搜索轨迹线
      with Obj[i] do if(kind=5)and(mode=1)then first:=Link[1];
      until (i>=ObjCount)or(first>0);
    if first>10 then last:=Obj[i].Link[0];
    end
  else begin
    repeat inc(i);  //搜索第一个动点
      with Obj[i] do
        if(kind=1)and(mode=2)and((H<>0)or(Link[0]>0))then first:=i;
      until (i>=ObjCount)or(first>0);
    end;
  if first=0 then begin //如果没有可动点
    menSport.ImageIndex:=8; bPause:=false;
    timAuto.Enabled:=false; exit;
    end;
  for i:= first to last do
    with Obj[i] do begin  //
    if not((Kind=1)and(Mode=2)and(H<>0))or
      not(Obj[Link[1]].Kind in[2,3,4,5,9,15,16,17,19])
      then continue; //H:步长
    edited:=true;
    MovePoint(i,false,false); //############ 移动约束点 ############
    if i=MarkObj then begin
      varL.Caption:=FtoS(   L,4); posX.Caption:=FtoS(p0.x,4);
      posY.Caption:=FtoS(p0.y,4); posZ.Caption:=FtoS(p0.z,4);
      end;
    if L>9999 then L:=9999; if L<-999 then L:=-999;
    end; //if..else..end
  if bAnimat then frmDrag.CopyImg(true,true);
  if bSport then inc(SportTime); //用于逐点绘制轨迹线
  if first>10 then Rerelate(first,ObjCount,false,false,false);
  SetProjection(false,false,21);
end;
//=================== 函数曲线  函数曲面 ============================
//====================== 函数式编辑框 =============================
procedure TfrmMain.pnlFuncShow;
  var i:integer;  bBreak,bb:boolean;
  function fts( a:single; wid,len:integer):string;
    begin STR( a:wid:len, result); result:=trim(result); end;
begin
  with Obj[MarkObj]do begin
  if(Mode in[7..12,14])then exit; //复制曲面不能编辑
  if(Kind=9)then tabFunc.Caption:=SwitchS(iLanguage,' 函数曲面...',' 函數曲面...',' Expression Surface...','')
            else tabFunc.Caption:=SwitchS(iLanguage,' 函数曲线...',' 函數曲线...',' Expression Curve...', '');
  cheRound.Visible:=Kind=16;  cheRound.Checked:=D;
  with selAxis do begin
    Clear;  AddItem(SwitchS(iLanguage,'直角坐标系','直角座標系','Rectangular',''),nil);
            AddItem(SwitchS(iLanguage,'球面坐标系','球面座標系','Spherical',''),nil);
    if Kind=9 then AddItem(SwitchS(iLanguage,'圆柱坐标系','圓柱座標系','Cylindrical',''),nil);
    end;//with selAxis
  if(Mode<7)then selAxis.ItemIndex:= (Mode-1)div 2;
  if(Mode=13)then selAxis.ItemIndex:= S; //隐函数曲面
  if(Kind=16)and(Mode=5)then selAxis.ItemIndex:=0; //曲线
  if(Kind=16)and(Mode=6)then selAxis.ItemIndex:=1;
  selAxisChange(nil);
  if(Kind=16)and(Mode in[5,6])or(Kind=9)and(Mode=13)
    then selFunc[2].Checked:=true //隐函数
    else selFunc[((Mode+1)mod 2)].Checked:=true; //显函数
  for i:= 0 to 2 do if trim(info[i])=''then info[i]:='0';
  for i:= 0 to 2 do FuncCtrl[i].Text:= info[i];
  edtParA.Text:=IIFs(Link[0]>0, IDtoS(Link[0]), FtS(p3.x,6,3));
  edtParB.Text:=IIFs(Link[1]>0, IDtoS(Link[1]), FtS(p3.y,6,3));
  edtParC.Text:=IIFs(Link[2]>0, IDtoS(Link[2]), FtS(p3.z,6,3));
  edtParD.Text:=IIFs(Link[3]>0, IDtoS(Link[3]), FtS(p4.x,6,3));
  edtParE.Text:=IIFs(Link[4]>0, IDtoS(Link[4]), FtS(p4.y,6,3));
  edtParF.Text:=IIFs(Link[5]>0, IDtoS(Link[5]), FtS(p4.z,6,3));

  edtXmin.Text:=IIFs(Link[7]>0, IDtoS(Link[7]), FtS(p1.x,6,4));
  edtXmax.Text:=IIFs(Link[8]>0, IDtoS(Link[8]), FtS(p1.y,6,4));
  edtXinc.Text:= FtS(p1.z,4,0);
  bb:=(Kind=9) or(Kind=16)and(Mode>4); //曲面 隐函数曲线(直角坐标系)
  edtYmin.Visible:=bb; edtYmax.Visible:=bb; edtYinc.Visible:=bb;
  edtYmin.Text:=IIFs(Link[ 9]>0, IDtoS(Link[9]), FtS(p2.x,6,4));
  edtYmax.Text:=IIFs(Link[10]>0, IDtoS(Link[10]), FtS(p2.y,6,4));
  edtYinc.Text:= FtS(p2.z,4,0);
  bb:=(Kind=9)and(Mode=13); //隐函数曲面
  edtZmin.Visible:=bb; edtZmax.Visible:=bb; edtZinc.Visible:=bb;
  edtZmin.Text:=IIFs(Link[11]>0, IDtoS(Link[11]), FtS(p5.x,6,4));
  edtZmax.Text:=IIFs(Link[12]>0, IDtoS(Link[12]), FtS(p5.y,6,4));
  edtZinc.Text:= FtS(p5.z,4,0);
  end;//with Obj[MarkObj]

  if bAdd then selAxisChange(nil);
  addItem( 0,0, true,true,false); //“无链接”
  for i:=11 to ObjCount-1 do with Obj[i] do
    if(Kind=1)and(Mode=2)
      then addItem( i,0, false,false,false);
  bBreak:=true;
  for i:=11 to ObjCount-1 do with Obj[i] do
    if(Kind=2)and(Mode in[1..4])
      then begin addItem( i,0, false,false,bBreak); bBreak:=false; end;
  bBreak:=true;
  for i:=11 to ObjCount-1 do with Obj[i] do
    if(Kind=11)or(Kind=18)and(Mode=2)
      then begin addItem( i,0, false,false,bBreak); bBreak:=false; end;

  if edtZ.Enabled then edtZ.SetFocus else if edtY.Enabled then edtY.SetFocus;
end;

procedure TfrmMain.selAxisChange(Sender: TObject);//选择坐标系
  const funcText1:Array[0..2,0..2]of string= //曲面
         (('z=F(x,y)', 'x,y,z=F(u,v)', 'F(x,y,z)=0'),  //直角坐标
          ('r=F(m,n)', 'r,m,n=F(u,v)', 'F(r,m,n)=0'),  //球坐标
          ('z=F(r,m)', 'r,m,z=F(u,v)', 'F(r,m,z)=0')); //圆柱坐标
        funcText2:Array[0..2,0..2]of string= //曲线
         (('y=F(x)', 'x,y,z=F(t)', 'F(x,y)=0'), //直角坐标
          ('r=F(t)', 'r,m,n=F(t)', 'F(r,t)=0'), //球坐标
          ('r=F(t)', 'r,m,z=F(t)', 'F(r,t)=0'));//圆柱坐标
        funcLabl:Array[0..2,0..2]of string=
         (('x=','y=','z='),('m=','n=','r='),('m=','r=','z='));
  var i:integer;
begin
  if Obj[MarkObj].Kind=9
    then for i:= 0 to 2 do selFunc[i].Caption:=FuncText1[selAxis.ItemIndex,i]  //曲面
    else for i:= 0 to 2 do selFunc[i].Caption:=FuncText2[selAxis.ItemIndex,i]; //曲线
//  selFunc[2].Enabled:=(selAxis.ItemIndex=0)or(Obj[MarkObj].Kind=16);// false;//
  for i:= 0 to 2 do FuncCtrl[i].EditLabel.Caption:=funcLabl[selAxis.ItemIndex,i];
  selFunc0.Checked:=true;
  selFuncChange(nil);
end;

procedure TfrmMain.selFuncChange(Sender: TObject);//选择函数式
  var a0,a1,a2, f0,f1,f2:boolean;  st:string;  x,y,z:single;
begin
  a0:=selAxis.ItemIndex=0;   f0:=selFunc0.Checked;
  a1:=selAxis.ItemIndex=1;   f1:=selFunc1.Checked;
  a2:=selAxis.ItemIndex=2;   f2:=selFunc2.Checked;
  edtX.Enabled:= f1;
  x:=Obj[2].L;  y:=Obj[3].L;  z:=Obj[4].L;//坐标轴长度
  if Obj[MarkObj].Kind=9 then begin //曲面
    if(f2)then Obj[MarkObj].S:=selAxis.ItemIndex;
    if(f2)then st:='0=' else if(not a1)then st:='z='else st:='r=';
    edtZ.EditLabel.Caption:=st;
    edtY.Enabled:= f1;
    edtZ.Enabled:= true;
    edtXmin.EditLabel.Caption:=IIFs(f1,'u=',edtX.EditLabel.Caption);
    edtYmin.EditLabel.Caption:=IIFs(f1,'v=',edtY.EditLabel.Caption);
    edtZmin.EditLabel.Caption:=IIFs(f2 and(a1),'r=','z=');

    edtXmin.Text:=IIFs(Obj[2].F and not f1,'-'+ftos(x/2,4),'0');
    edtXmax.Text:=IIFs(f1 or(a1 or a2)and(f0 or f2),'6.2832', IIFs(Obj[2].F,ftos(x/2,4), ftos(x,4)));
    edtXinc.Text:='40';

    edtYmin.Text:=IIFs(Obj[3].F and not f1, '-'+ftos(y/2,4), IIFs(a1,'-1.5708','0'));
    edtYmax.Text:=IIFs(f1 or a1 and(f0 or f2), IIFs(a1,'1.5708','3.1416'), IIFs(Obj[3].F,ftos(y/2,4), ftos(y,4)));
    edtYinc.Text:=IIFs(f2,'20','40');

    edtZmin.Text:=IIFs(Obj[4].F,'-'+ftos(z/2,4),'0');
    edtZmax.Text:=IIFs(Obj[4].F, ftos(z/2,4), ftos(z,4));
    edtZinc.Text:=IIFs(f2,'10','40');
    edtZmin.Visible:=f2;  edtZmax.Visible:=f2;  edtZinc.Visible:=f2;
    end;
  if Obj[MarkObj].Kind=16 then begin //曲线
    if(f2)then st:='0=' else if(a0 or a2)then st:='z=' else st:='r=';
    edtZ.EditLabel.Caption:=st;
    edtY.Enabled:=(not a1 or f1)and(not f2);
    edtZ.Enabled:= f1 or a1 or f2;
    if(selFunc0.Checked)then st:=IIFs(a0,'x=','t=');
    if(selFunc1.Checked)then st:='t=';
    if(selFunc2.Checked)then st:=IIFs(a0,'x=','r=');
    edtXmin.EditLabel.Caption:=st;
    edtYmin.EditLabel.Caption:=IIFs(a0, 'y=','t=');
    edtXmin.Text:=IIFs(Obj[2].F and not f1, '-'+ftos(x/2,4), '0');
    edtXmax.Text:=IIFs(f1,'3.1416', IIFs(Obj[2].F, ftos(x/2,4), ftos(x,4)));

    f2:=f2 and a1 or f2 and a0;
    edtYmin.Visible:=f2;  edtYmax.Visible:=f2;  edtYinc.Visible:=f2;
    edtYmin.Text:=IIFs(Obj[3].F and not f1, '-'+ftos(y/2,4), '0');
    edtYmax.Text:=IIFs(f1, '3.1416', IIFs(Obj[3].F,ftos(y/2,4), ftos(y,4)));
    end;
end;

//########################## 描绘方程式 ############################
procedure TfrmMain.butDrawClick(Sender: TObject); //################
  var i :integer;  k :single;
  function EtoF( edt:TlabeledEdit):single;
    begin result:= StrToFloat( edt.Text ); end;
begin
  if trim(edtX.text)=''then edtX.text:='1';
  if trim(edtY.text)=''then edtY.text:='1';
  if trim(edtZ.text)=''then edtZ.text:='1';
  if trim(edtXmin.text)=''then edtXmin.text:='0';
  if trim(edtXmax.text)=''then edtXmax.text:='0';
  if trim(edtXinc.text)=''then edtXinc.text:='4';
  if trim(edtYmin.text)=''then edtYmin.text:='0';
  if trim(edtYmax.text)=''then edtYmax.text:='0';
  if trim(edtYinc.text)=''then edtYinc.text:='4';
  with Obj[MarkObj] do begin
  if(selFunc0.Checked)then Mode:=selAxis.ItemIndex*2+1;
  if(selFunc1.Checked)then Mode:=selAxis.ItemIndex*2+2;
  if(selFunc2.Checked)and(Kind=16)then Mode:=selAxis.ItemIndex+5; //隐函数曲线
  if(selFunc2.Checked)and(Kind= 9)then Mode:=13; //隐函数曲面
  if(Mode=13)then S:=selAxis.ItemIndex;//直角坐标 球面坐标 柱面坐标
  i:=Link[ 0]; if(i>0)then p3.x:=Obj[i].L else p3.x:=EtoF(edtParA);
  i:=Link[ 1]; if(i>0)then p3.y:=Obj[i].L else p3.y:=EtoF(edtParB);
  i:=Link[ 2]; if(i>0)then p3.z:=Obj[i].L else p3.z:=EtoF(edtParC);
  i:=Link[ 3]; if(i>0)then p4.x:=Obj[i].L else p4.x:=EtoF(edtParD);
  i:=Link[ 4]; if(i>0)then p4.y:=Obj[i].L else p4.y:=EtoF(edtParE);
  i:=Link[ 5]; if(i>0)then p4.z:=Obj[i].L else p4.z:=EtoF(edtParF);

  i:=Link[ 7]; if(i>0)then p1.x:=Obj[i].L else p1.x:=EtoF(edtXmin);
  i:=Link[ 8]; if(i>0)then p1.y:=Obj[i].L else p1.y:=EtoF(edtXmax);
  i:=Link[ 9]; if(i>0)then p2.x:=Obj[i].L else p2.x:=EtoF(edtYmin);
  i:=Link[10]; if(i>0)then p2.y:=Obj[i].L else p2.y:=EtoF(edtYmax);
  i:=Link[11]; if(i>0)then p5.x:=Obj[i].L else p5.x:=EtoF(edtZmin);
  i:=Link[12]; if(i>0)then p5.y:=Obj[i].L else p5.y:=EtoF(edtZmax);
  if(p1.y-p1.x)<0.1 then p1.y:=p1.x+0.1;
  if(p2.y-p2.x)<0.1 then p2.y:=p2.x+0.1;
  if(p5.y-p5.x)<0.1 then p5.y:=p5.x+0.1;
  k:=EtoF(edtXinc);   Limit(k, 1,1, 99999,99999);  p1.z:=k;
    if k<1 then edtXinc.Text:='1';  if k>99999 then edtXinc.Text:='99999';
  k:=EtoF(edtYinc);   Limit(k, 1,1, 9999,9999);  p2.z:=k;
    if k<1 then edtYinc.Text:='1';  if k>9999 then edtYinc.Text:='9999';
  k:=EtoF(edtZinc);   Limit(k, 1,1, 9999,9999);  p5.z:=k;
    if k<1 then edtZinc.Text:='1';  if k>9999 then edtZinc.Text:='9999';

  for i:=0 to 2 do info[i]:= FuncCtrl[i].Text;
  if checkFunc(MarkObj) then begin //测试表达式
    save(IIFi(bAdd, 1,0), MarkObj, 1, true,true); //Undo
    ObjListUpdate(0,false);
    ReRelate( MarkObj,ObjCount, false,false,false);
    SetProjection(false, false,99);
    if cheHide.Checked then pnlControl.Hide;
    end;
  end; //with
  if(HotTool<>nil)then HotTool.Down:=false;
  tlbMain.Enabled:=true;  bAdd:=false;
  frmMain.KeyPreview:=true;
end;

procedure TfrmMain.edtZEnter(Sender: TObject);
  var i,j :integer;
begin
  KeyPreview:= false;
  hotEdit:= Sender as TLabeledEdit;
  edtTemp.Text:=trim(hotEdit.Text);
  for i:=1 to ObjCount do Obj[i].Edited:=i=MarkObj;
  bSelLink:=true;
end;
procedure TfrmMain.edtZExit(Sender: TObject);
  var i,t,Len :integer;   st:string;   isCode:boolean;
      fVal:single;  tmpEdit:TLabeledEdit;
begin
  tmpEdit:=(Sender as TLabeledEdit);
  t:=tmpEdit.Tag;
  st:=trim(tmpEdit.Text);
  with Obj[MarkObj]do begin
  if(st='-')or(st='')then begin
    if(t>12)then
      tmpEdit.Text:='2'
    else begin
      if(Link[t]=0)then
        tmpEdit.Text:='0'
      else begin
        case t of
          0:fVal:=p3.x;   1:fVal:=p3.y;   2:fVal:=p3.z;
          3:fVal:=p4.x;   4:fVal:=p4.y;   5:fVal:=p4.z;
          7:fVal:=p1.x;   8:fVal:=p1.y;   9:fVal:=p2.x;
         10:fVal:=p2.y;  11:fVal:=p5.x;  12:fVal:=p5.y;
         end;
        tmpEdit.Text:=ftos(fVal,4);
        Link[t]:=0; LinkName[t]:=0;
        end;
      end;
    end
  else begin
    i:=0;  Len:=length(st);
    repeat inc(i); isCode:=not(st[i] in[#48..#57, '-','.']);
      until(isCode)or(i>=Len);
    if(not isCode)then begin Link[t]:=0; LinkName[t]:=0; end;
    end;
  bSelLink:=false;
  end;//with...
end;

//规范数字输入
procedure TfrmMain.edtParAKeyPress(Sender: TObject; var Key: Char);
  var e:TLabeledEdit;  s:string;  i,p:integer; b:boolean;
begin
  e:=(Sender as TLabeledEdit);
  s:=e.Text;  p:=e.SelStart;
  if s>''then
    if s[1]='{#}' then begin key:=#0;  exit; end;  //{#} 就是字符#
  case Key of
  '-':begin // '-'
    b:=s[1]='-';
    if b then e.Text:=copy(s,2,length(s)) else e.Text:='-'+s;
    if b then dec(p) else inc(p);
    e.SelStart:=p;
    key:=#0;
    end;
  '.':begin
    i:=pos( '.',s);
    if(i>0)then begin
      if(i>p)then s:=copy(s,1,p)
             else s:=copy(s,1,i-1)+ copy(s,i+1,p-i);
      e.Text:=s;
      e.SelStart:=p;
      end;
    end;
  else
    if not(key in [#48..#57, #8])or(p=0)and(s[1]='-')then key:=#0;
  end;
end;

procedure TfrmMain.edtXKeyDown(Sender: TObject; var Key: Word; Shift: TShiftState);
  var s:string;
begin
  if key=13 then begin
    edtZExit(Sender);
    butDrawClick(butOK);
    end
  else begin
    s:=(Sender as TLabeledEdit).Text;
    if s>''then
      if(s[1]='{#}')and(not(key in[37..40]))then key:=0; //{#} 就是字符#
    end;
end;

procedure TfrmMain.butCancClick(Sender: TObject);
begin
  if bAdd then begin
    dec( ObjCount);  bAdd:=false;
    frmMain.KeyPreview:=true; //but25.Down:=false;  pnlFunc.Hide;
    tlbMain.Enabled:=true;    labHint.Top:=-20;
    end;
end;

//================ 添加向量 =================
procedure TfrmMain.menVectorClick(Sender: TObject);
begin
  HotMenu:=(Sender as TMenuItem);
  AppObjProc:=menVectorClick; //按空格键将自动激活菜单
  AppendObj( 22, TComponent(Sender).Tag);
end;
procedure TfrmMain.butVector1Click(Sender: TObject);
begin
  AddingObj( 22, TComponent(Sender).Tag);
end;
//============== 添加正多面体 =================
procedure TfrmMain.menSolidClick(Sender: TObject);
begin
  HotMenu:=(Sender as TMenuItem);
  AppObjProc:=menSolidClick; //按空格键将自动激活菜单
  AppendObj( 63, TComponent(Sender).Tag);
  pnlProp.Hide;
end;
procedure TfrmMain.butSolidClick(Sender: TObject);
begin
  AddingObj( 63, TComponent(Sender).Tag);
  pnlProp.Hide;
end;
//================ 添加台体 =================
procedure TfrmMain.menTableClick(Sender: TObject);
begin
  HotMenu:=(Sender as TMenuItem);
  AppObjProc:=menTableClick; //按空格键将自动激活菜单
  AppendObj( 64, TComponent(Sender).Tag);
end;
procedure TfrmMain.butTableClick(Sender: TObject);
begin
  AddingObj( 64, TComponent(Sender).Tag);
end;
//================ 添加多边形 =================
procedure TfrmMain.menPolygonClick(Sender: TObject);
begin
  HotMenu:=(Sender as TMenuItem);
  AppObjProc:=menPolygonClick; //按空格键将自动激活菜单
  AppendObj( 46, TComponent(Sender).Tag);
end;
procedure TfrmMain.butPolygonClick(Sender: TObject);
begin
  AddingObj( 46, TComponent(Sender).Tag);
end;
//================ 添加度量 =================
procedure TfrmMain.menSizeClick(Sender: TObject);
begin
  AppObjProc:=menSizeClick;
  AppendObj( 113, TComponent(Sender).Tag); //1长度 2半径 3周长 4面积 5体积 6距离 7角度  19方程
end;
procedure TfrmMain.butSizeClick(Sender: TObject);
begin
  AddingObj( 113, TComponent(Sender).Tag); //1长度 2半径 3周长 4面积 5体积 6距离 7角度
end;
//################## 以下代码有关[计算]构件 ##################//
procedure TfrmMain.pnlCalcShow(ID:integer);
  var i,M:integer; st:string;  isEdge,bBreak :boolean;
begin
  popObj.Items.Clear;
  if ObjCount<11 then exit;
  bAdded:=true;
  with Obj[MarkObj]do begin
  butOK.Enabled:=false;
  pnlResult.Caption:= FtoS(L,S);
  labResult.Caption:= info[1];
  if bAdd then memExpr.Text:=''
          else memExpr.Text:= ReplaceCode(MarkObj, info[1]);
  memExpr.SelStart:=length(memExpr.Text); // memExpr.SetFocus;

  M:=MarkObj; if bAdd then dec(M);
  for i:=11 to M do with Obj[i] do
    if(Kind=1)and(Mode=2)then begin //约束点
      str( i:3, st);  addItem(i,0,false,false,false);
      end;
  bBreak:=true;   isEdge:=false;
  for i:=11 to M do with Obj[i] do
    if(Kind=2)and(Mode<13)or(Mode=13)and(not isEdge)then begin //直线
      str( i:3, st);  addItem(i,0,false,false,bBreak);
      isEdge:=(Mode=13);  bBreak:=false;
      end;
  bBreak:=true;
  for i:=11 to M do with Obj[i] do
    if(Kind=3)then begin //圆
      str( i:3, st);  addItem(i,0,false,false,bBreak);
      bBreak:=false;
      end;
  bBreak:=true;
  for i:=11 to M do with Obj[i] do 
    if(Kind=11)or(Kind=18)and(Mode=2)then begin //计算 度量
      str( i:3, st);  addItem(i,0,false,false,bBreak);
      bBreak:=false;
      end;
  end;//with
end;

procedure TfrmMain.edtLabelKeyDown(Sender: TObject; var Key: Word; Shift: TShiftState);
begin
  if(Key=13)then butOKClick(butOK);
end;

procedure TfrmMain.pnlCalcMouseDown(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
  ReleaseCapture;
  case TComponent(Sender).Tag of
    0:SendMessage((Sender as TPanel).Handle, WM_SYSCOMMAND, $f012,0);
    1:SendMessage((Sender as TPanel).Parent.Handle, WM_SYSCOMMAND, $f012,0);
    9..11,17:begin x0:=x; y0:=y; end;  //用于改变“计算”窗口宽度
    end;
end;

procedure TfrmMain.appendExpr(ID:integer);  //创建[计算器]控件
  var i:integer;  he,wi:single; pp:TcgVector;
begin
  pp:=cgVector(40,100,70);
  for i:= 11 to ID-1 do with Obj[i] do //搜索最下面的控件
    if(delID=0)and(Kind in[11,14])and(p0.y>=pp.y)then begin
      pp:=p0;   pp.y:=p0.y+Obj[ID].TagSize.y+10;
      end;
  with Obj[ID] do begin
    pp.w:=p0.w;   //p0.w是字符高度
    p0:=pp;     F:=false;   TagN:='Arial';
    if(Kind=11)then begin   //计算式
      Color:= cgTColorToCGColorF(clRed,1);
      info[2]:=IIFs(F,'',Tag+' =')+FtoS(L,S);
      if(Mode=13)and(Obj[Link[1]].Kind=2)then
        begin p2.x:=0; p2.z:=1; end;
      ObjListUpdate(ID,true);
      end;
    if(Kind=14)then begin
      W:=TagSize.x; H:=TagSize.y;
      createCtrl(ObjCount,true); //创建控制按纽
      end;
    end;
end;

procedure TfrmMain.setListPosision;
  var l,t,r,b :integer;
begin
  l:=0; t:=tlbMenu.Height-1; r:=pnlList.Width; b:=0;
  if menStatus.Checked or menPages.Checked then b:=b+stbBar.Height-4; //状态栏高度
  if menTools.Checked then begin
    if menMenuOnBottom.Checked then b:=b+tlbTools.Height else l:=tlbTools.Width-2;
    end;
  if menMenuOnBottom.Checked then begin t:=-1;  b:=b+tlbMenu.Height; end; //菜单栏高度

  with pnlList do begin
  if butListAnchor.NumGlyphs=1 then begin
    Left:=frmMain.ClientWidth-pnlList.Width; Top:=t; Height:=frmMain.ClientHeight-t-b;
    pnlList.Anchors:=[akTop,akRight,akBottom];
    end;
  if butListAnchor.NumGlyphs=2 then begin
    Left:=l; Top:=t; Height:=frmMain.ClientHeight-t-b;
    pnlList.Anchors:=[akTop,akLeft,akBottom];
    end;
  if(Left<0)then Left:=0;
  if(Left>frmMain.Width-Width)then Left:=frmMain.Width-Width;
  if(Height>(frmMain.ClientHeight-Top))then Height:= frmMain.ClientHeight-Top;
  end;//with
end;

procedure TfrmMain.butOKClick(Sender: TObject);
  var i,j,k,n,wi,he,Len,new :integer;  st:AnsiString;  tmpColor:TColor;
  function its( v:integer):string;
    begin str( v:3, result); end;
  procedure setLink(cmb:TComboBox; Lin:integer);
    var i,n :integer;
    begin n:=10;
      with Obj[MarkObj]do begin
      Link[Lin]:=0;  LinkName[Lin]:=0;  i:=0;
      if(cmb.ItemIndex>0)then begin
        repeat inc(i); until(ObjListID[i].Text=cmb.Items[cmb.ItemIndex])or(i>=ObjListID[0].ID);
        n:=ObjListID[i].ID;
        if(n>10)then begin Link[Lin]:=n; LinkName[Lin]:=Obj[n].Name; end;
        end;
      end;
    end;
begin
  case TComponent(Sender).Tag of
  0:begin //关闭
    if tabAffine.Visible then begin //恢复仿射变换规则  源数据在ShorControlBox中备份
      for i:=0 to 11 do Obj[ MarkObj].Value[i]:= Obj[1000].Value[i];
      for i:=0 to 28 do Obj[ MarkObj].Link[i]:= Obj[1000].Link[i];
      for i:=0 to 28 do Obj[ MarkObj].LinkName[i]:= Obj[1000].LinkName[i];
      end;
    if bAdd then begin
      with Obj[ObjCount]do if pnlControl.Visible and tabPath.TabVisible and Assigned(butID) then begin
        butID.Visible:=false;  DelID:=ObjCount;
        end;
      dec(ObjCount); MarkObj:=ObjCount;
      end;
    HideAllPanel;  bSelLink:=false;
    end; //cancel
  1:begin // 关闭对象列表
    pnlList.Hide;  menList.Checked:=false; butList.Down:=false;
    end;
  2:begin //对象列表停靠左边
    butListAnchor.NumGlyphs:=3-butListAnchor.NumGlyphs;
    setListPosision;
    end;
  9,16:begin //函数曲线 函数曲面
    butDrawClick(butOK);
    end;
  10:with Obj[ MarkObj] do begin  //[文字]
    st:=memText.Text;  len:=Length(st);   info[2]:=st;
    info[1]:='0'; for i:=1 to Len do info[1]:=info[1]+ its(ord(st[i]));
    texID:= TextToBMP(MarkObj,info[2],true); //GetTextList( MarkObj, info[2], Color);
    TextAndImage(MarkObj,false,true,true,true);
    pnlControl.Hide;
    frmMain.KeyPreview:=true;
    if bAdd then ObjListUpdate(MarkObj,true);
    Save(IIFi(bAdd,1,0), ObjCount, 1, true,false);

    if(butTxt.Down)and bAdd then begin
      bAdd:=false;
      butTxt.Down:=false; butArrow.Down:=true;
      end;
    end;
  11:with Obj[ MarkObj] do begin   // OK [计算]
    if(Mode=2)then begin grdParaOK(MarkObj); exit; end; //参数轴
    CleanLink(MarkObj,0);
    for i:=1 to 18 do if parID[i]>0 then begin
      Link[i-1]:=parID[i];  LinkName[i-1]:=Obj[parID[i]].Name;
      end;
    info[0]:= memExpr.Text;
    info[1]:= labResult.Caption;
    L:=res;   st:=Tag+' =';   Hot:=true;
    info[2]:= st+FtoS(res,S);
    if F then info[2]:= st+ '∞';
    if U then info[2]:= st+ SwitchS( iLanguage,'未定义','未定義','undifined','');
    p0.z:=Canvas.TextWidth(info[2]);  p0.w:=Canvas.TextHeight(info[2]);
    if bAdd then appendExpr(MarkObj);
    Save(IIFi(bAdd, 1,0), MarkObj,1,true,true); //保存Undo数据
    reRelate(MarkObj,ObjCount,false,false,false);
    if cheHide.Checked then pnlControl.Hide else SetProjection(false,false,24);
    end;
  13:with Obj[ MarkObj] do begin //迭代
    He:=trunc(H); Wi:=trunc(W);
    for i:= 0 to He do for j:=0 to Wi do
      if objArray[i,j]<11 then begin
        MyMessage(SwitchS(iLanguage,'错误的迭代规则 ！！','错误的迭代规则 ！！','錯誤的疊代規則 ！！',''));
        hotText.Color:=clBtnFace;
        hotText:=txtArray[i,j]; hotText.Color:=clInfoBk;
        exit;
        end;
    if (He+1)*(Wi+1)>LinkTime then begin
      MyMessage(SwitchS(iLanguage,'源像数和映像数之和不能超过48。','源像数和映像数之和不能超过48。', 'The sum of source and destination can not over 48.',''));
      exit;
      end;
    L:=trunc(StrToFloat(edtLayer.Text))-1; ObjShow[trunc(L)]:=true; //层数
    k:=0;
    for i:= 0 to He do for j:=0 to Wi do begin
      inc(k);  Link[k]:=objArray[i,j];  LinkName[k]:=Obj[Link[k]].Name;
      end;
    if cheHide.Checked then pnlControl.Hide;
    Iterate( MarkObj,true,true);//============= 执行迭代 =================
    SetProjection(true,false,24);
    if bAdd then begin ObjListUpdate(MarkObj,true); end;
    Save( IIFi(bAdd, 1,0), MarkObj,1,true,true); //保存Undo数据
    end;
  131:with Obj[MarkObj]do
    if(Kind=13)then begin //随机种子
      Randomize;      R:=RandSeed;
      Iterate( MarkObj,true,true);
      SetProjection(true,false,24);
      end;
  17,141..145:begin //路径 控制
    bSelLink:=false;
    pnlControl.Hide;
    end;
  146:with Obj[MarkObj] do begin //控制 链接
    if(Mode=6)then begin //链接
      U:=radLink.Checked;  S:=0;  maxTrace:=0;
      if U then info[0]:= edtLink.Text  //超链接
      else begin
        S:= Objs[cmbPage.ItemIndex,8].parent;//页面名
        Tag:=tabPage.Tabs[cmbPage.ItemIndex];
        butID.Caption:=Tag;
        if cmbButton.ItemIndex>0 then maxTrace:=LinkName[cmbButton.ItemIndex]; //按钮名
        for i:=0 to LinkTime do LinkName[i]:=0;
        end;
      end;
    if cheHide.Checked then pnlControl.Hide;
    ObjListUpdate(MarkObj,true);
    Obj[MarkObj].hot:=true;
    Save( IIFi(bAdd, 1,0), MarkObj,1,true,true); //保存Undo数据
    end;
  18:begin //参数颜色
    if(Obj[ MarkObj].Kind=13)then begin

      end;
    setLink( cmbColor1, 6); setLink( cmbColor2, 7); setLink( cmbColor3, 8);
    Obj[ MarkObj].ColorV0:=StrToFloat(edtColorV0.Text);
    Obj[ MarkObj].ColorV1:=StrToFloat(edtColorV1.Text);
    if radColor.Checked then j:=0;
    if radGray.Checked then j:=1;
    if radLight.Checked then j:=2;

    if radNoWay.Checked then k:=0;
    if radOneWay.Checked then k:=1;
    if radTwoWay.Checked then k:=2;
    Obj[ MarkObj].ColorMode:= j*3+k;
    if cheHide.Checked then pnlControl.Hide;
    rerelate(MarkObj,ObjCount,false,false,false);
    SetProjection(false,false,8);
    end;
  20:begin //移动构件次序 不可Undo
    st:=cmbMove.Text;
    i:=0; repeat inc(i); until st=ObjListID[i].Text;
    new:=ObjListID[i].ID;
    with Obj[new] do if(Kind=1)and(Mode=4)and(D)then dec(MarkObj);
    MoveObjID(MarkObj, new); //移动次序
    MarkObj:=new;
    upDateLink(ObjCount,true);
    if cheHide.Checked then pnlControl.Hide;
    for i:= 11 to ObjCount do with Obj[i]do begin
      if Assigned(butID)then butID.Tag:=i;
      if Assigned(runID)then runID.Tag:=i;
      if Assigned(imgID)then imgID.Tag:=i;
      if Assigned(timID)then timID.Tag:=i;
      edited:=true; //重建显示列表
      end;
    ObjListUpdate(MarkObj,true);
    rerelate(11,ObjCount,false,false,false);
    SetProjection(true,false,8);
    tlbMain.Enabled:=true;
    end;
  30:begin // 批量修改标签
    for i:=1 to selRec[0] do with Obj[selRec[20+i]] do begin
      Tag:=stArray[i-1];
      if cheHide.Checked then TagShow[Layer]:=true;
      if(Kind=11)then TextAndImage(selRec[20+i], false,true,true, false);  //参数 计算 度量
      GetTextList( selRec[20+i]);
      end;
    ObjListUpdate(0,false); //Obj[hit].Hot:=true;
    if cheHide.Checked then pnlControl.Hide else SetProjection(false,false,8);;
    end;
  40:begin //仿射变换
     with Obj[MarkObj]do for i:=0 to 11 do
        if(Link[i+16]=0)then Value[i]:= StrToFloat(txtArray[8,i].Text);
    if cheHide.Checked then pnlControl.Hide;
    rerelate(MarkObj,ObjCount,false,false,false);
    SetProjection(false,false,8);
    end;
  end;//case
  bAdd:=false;  tlbMenu.Enabled:=true;  tlbMain.Enabled:=true;
  if not pnlControl.Visible then bSelLink:=false;
  KeyPreview:=true;
end;

procedure TfrmMain.memExprChange(Sender: TObject);
begin
  if(TComponent(Sender).Tag=11)then begin //计算器
    if(trim(memExpr.Text)='')then exit;
    butOK.Enabled:= calcFunc(MarkObj, res, true,true);
    end
  else //文本编辑
    butOK.Enabled:= trim(memText.Text)>'';
end;

procedure TfrmMain.memExprKeyDown(Sender: TObject; var Key: Word; Shift: TShiftState);
begin
  frmMain.KeyPreview:=false;
  if butOK.Enabled and(Key=13)and((butOK.Tag=10)and(ssCtrl in Shift)or(butOK.Tag<>10))
    then butOKClick(butOK);
end;

procedure TfrmMain.cmbStyleChange(Sender: TObject);
  var i,iID:integer;
begin
  iID:=MarkObj;
  with Obj[MarkObj]do begin
  case Kind of
    1:begin S:=cmbStyle.ItemIndex; Obj[1].p1.r:=S;  end;  //点型
    2:if(Mode=2)then begin //向量 R=0角向量 1向量 2和 3差 4叉积
      i:=trunc(R);
      if i<2 then R:=1 - cmbStyle.ItemIndex
             else R:=cmbStyle.ItemIndex + 2;
      if i<2 then
        ShowObjProp(MarkObj, 0,0, bL,bR);  //显示构件属性框
      end;
    4: L:=cmbStyle.ItemIndex; //平面形状 三角形/棱形/平行四边形/矩形
    11:if(Mode in[15,16,17])then R:=cmbStyle.ItemIndex;//坐标 向量 向量运算
    17:if(Mode=2)then L:=cmbStyle.ItemIndex; //三视图投影面
    19:begin Angle:=cmbStyle.ItemIndex; cheWay.Enabled:=Angle<>1; end; //圆锥曲线 抛物线/椭圆/双曲线
    end;
  if(Obj[Parent].Kind=6)and(Kind=1)and(Mode=13)then begin //顶点
    iID:=Link[0]; Obj[iID].edited:=true; i:=iID+1;
    repeat if(Obj[i].Kind=1)then Obj[i].S:=S; inc(i); until(Obj[i].Link[0]<>iID);
    end;
  end;//with
  if(MarkObj<11)then AxisList;
  ReRelate(iID,ObjCount,false,false,false);
  SetProjection(false,false,0);
end;
//=============== 用图片作为组合框的选项 ==============
procedure TfrmMain.cmbFillDrawItem(Control: TWinControl; Index: Integer; Rect: TRect; State: TOwnerDrawState);
  var myDest,mySour :Trect;
begin //注意: 将TComboBox的Style属性设为csOwnerDrawFixed
  with mySour do begin
    Left:=0; Top:=Index*15;
    if(Obj[MarkObj].Kind=4)and(Index>3)then Top:=(Index+4)*15;
    Right:=42; Bottom:=Top+14;
    end;
  with myDest do begin
    Left:=rect.Left+2; Top:=Rect.Top+1; Right:=Rect.Left+44; Bottom:=Rect.Bottom-1;
    end;  
  with (Control as TComboBox) do begin
    Canvas.FillRect(Rect);
    Canvas.CopyRect(myDest,imgFillMode.Canvas, mySour);
    end;//with
end;
//=============== 字体工具条的颜色框 ==============
procedure TfrmMain.cmbFontCDrawItem(Control: TWinControl; Index: Integer; Rect: TRect; State: TOwnerDrawState);
  var myDest,mySour :Trect;
begin //注意: 将TComboBox的Style属性设为csOwnerDrawFixed
  with myDest do begin Left:=Rect.Left+2; Top:=Rect.Top+1; Right:=Rect.Left+44; Bottom:=Rect.Bottom-1; end;
  with mySour do begin Left:=1; Top:=1; Right:=84; Bottom:=4; end;
  with (Control as TComboBox) do begin
    Canvas.Brush.Color:=objColor[index];
    if(index<17)then
      Canvas.Rectangle(myDest.Left, myDest.Top, myDest.Right, myDest.Bottom) //色块
    else
      Canvas.CopyRect( myDest, imgColor.Canvas, mySour); //复制图像
    end;//with
end;
//================ 直线、平面的模式 =================
procedure TfrmMain.cmbFillClick(Sender: TObject);
  var i,iID :integer;
begin
  iID:=MarkObj;  i:=cmbFill.ItemIndex;
  with Obj[MarkObj] do begin
    if(Kind=1)and(Mode=5)then
      H:=i   //中点（四心）
    else begin
      if(Kind=4)and(i>3)then i:=(i+4);  //平面没有管状线
      if(i>7)then S:=(i-7)*10+(S Mod 10) else S:=i;
      defaultProp[3]:=S;
      end;
    cheWay.Enabled:=S>7;  //varA.Enabled:=S>7;
    if(Kind in[3,4])then begin
      if(S<8)and(Thick=0)then F:=true;
      cheSolid.Enabled:=(S>7)or(S<8)and(Thick<>0);
      if(S<8)then cheSolid.Checked:=true; //F 边框
      varC.Width:=IIFi((S>7)and(MarkObj>10), 26,56);
      end;
    if(Kind=3)and(S>7)and(Mode in[3,4])and cheWay.Checked then S:=S+100; //S>99: 填充扇形
    if(Obj[Parent].Kind=6)and(Kind=2)and(Mode=13)then begin //棱边
      iID:=Link[0]; Obj[iID].edited:=true; i:=iID+1;
      repeat if(Obj[i].Kind=2)then Obj[i].S:=S; inc(i); until(Obj[i].Link[0]<>iID);
      end;
    end; //with
  if(MarkObj in[5..7])then AxisList;
  reRelate(iID,ObjCount,false,false,false);
  SetProjection(false,false,0);
end;
//=================================================//
//===================== 14 控制按钮 ===================
procedure TfrmMain.createCtrl(ID:integer; New:boolean); //#############创建控制按纽############333
  var butFont:TFont;
begin
  with Obj[ID] do begin
  Lock:=false;
  if not Assigned(butID) then begin //新建按钮
    butID:=TPanel.Create(self);
    with butID do begin
      Parent:=frmMain;   Tag:= ID;  Cursor:=crHandPoint;
      OnMouseDown:=butIDMouseDown;  OnMouseUp:=butIDMouseUp;
      BorderStyle:=bsSingle; Ctl3D:=false;
      end;
    if not New then begin TagN:='Arial'; TagS:=9; end;
    runID:=TSpeedButton.Create(self);
    with runID do begin
      Parent:=butID; Tag:= ID;
      left:=3; top:=3; height:=18; width:=18;
      OnClick:=runIDClick;
      Glyph:=imgRun.Picture.Bitmap;
      NumGlyphs:=1; Visible:=false;  Layout:=blGlyphRight; Margin:=2;
      visible:=false;
      end;
    imgID:=TImage.Create(self);
    with imgID do begin
      left:=butID.Width-16;     top:=butID.Height-16;
      Parent:=butID; Tag:= ID;  height:=12; width:=12;
      Anchors:=[akRight,akBottom];  Cursor:=crSizeAll;
      OnMouseUp:=imgIDMouseUp;      OnDblClick:=imgIDDblClick;
      OnMouseDown:=imgIDMouseDown;  OnMouseMove:=imgIDMouseMove;
      Picture.Bitmap:=imgSize.Picture.Bitmap;
      Transparent:=true;            Visible:=true;
      end;
    end;
  with butID do begin
    setPanelBeval(butID, (Mode=1)and F);//动画 F按下
    width:=trunc( W);     height:=trunc( H);
    left:= trunc( p0.x);  top:= trunc(p0.y)-height-TitleHeight;//
    butFont:=TFont.Create;
    with butFont do begin
      Name:=TagN; Size:=TagS; Color:=TagC;
      Style:=[];
      if TagT[1]='1'then Style:=Style+[fsBold];
      if TagT[2]='1'then Style:=Style+[fsItalic];
      if TagT[3]='1'then Style:=Style+[fsUnderline];
      if TagT[4]='1'then Style:=Style+[fsStrikeOut];
      end;
    caption:=Obj[ID].Tag; font:=butFont;
    butFont.Free;
    visible:=ObjShow[Layer];
    end; //with butID
  end; //with Obj[ID]
end;

procedure TfrmMain.imgIDMouseDown(Sender: TObject; Button: TMouseButton;Shift: TShiftState; X, Y: Integer);
  var i,t:integer;
begin
  x0:=X; y0:=Y;
  bL:=ssLeft in Shift; bR:=ssRight in Shift;
  t:=(Sender as TImage).Tag;
  if bR then begin
    ClearSelRec(0);{清空选择队列} butProp.Down:=true;   MarkObj:=t;
    end;
  MarkObj:=t;
  hotBut:=Obj[MarkObj].butID;
  lastHot:=Obj[MarkObj].hot;   Obj[MarkObj].hot:=true;  bMove:=false;
  hotBut.BringToFront;
  pnlShow.Visible:=tlbMain.Visible;
  ShowObjProp(MarkObj,10,10, bL, bR);
  if cheHint.Checked then begin
    labHint.Caption:=SwitchS(iLanguage,' 双击以编辑控制规则...',' 雙擊以編輯控制規則...','DoubleClick to edit Iterative role...','');
    labHint.top:=25;
    end;
  if pnlFont.Visible then setFont(MarkObj, true, false); //设置字体工具
end;
procedure TfrmMain.imgIDMouseMove(Sender: TObject; Shift: TShiftState; X,Y: Integer);
  var i,He,Wi, L0,T0,W0,H0 :integer;
begin
  if not(bL or bR)or(Obj[MarkObj].Lock)then exit;

  if bL and not(ssShift in Shift)and((x<>x0)or(y<>y0))then begin  //拖动按钮位置
    for i:=11 to ObjCount do if(i<>MarkObj)then Obj[i].Hot:=false;
    L0:=hotBut.Left;  T0:=hotBut.Top;
    if((hotBut.Left+ X-x0)>30)and((hotBut.Left+hotBut.Width+ X-x0)<Width)
      then hotBut.Left:=hotBut.Left+ X-x0;
    if((hotBut.Top + Y-y0)>24)and((hotBut.Top+hotBut.Height+TitleHeight + Y-y0)<ClientHeight)
      then hotBut.Top :=hotBut.Top + Y-y0;

    if(L0<>hotBut.Left)or(T0<>hotBut.Top)then bMove:=true;
    end;
  if bL and(ssShift in Shift)then begin //拖动按钮大小
    W0:=hotBut.Width;   H0:=hotBut.Height;
    Wi:=hotBut.Width;   Wi:=Wi+X-x0; if Wi>=60 then hotBut.Width:=Wi;
    He:=hotBut.Height;  He:=He+Y-y0; if He>=24 then hotBut.Height:=He;
    if(W0<>hotBut.Width)or(H0<>hotBut.Height)then bMove:=true;
    end;
  with Obj[MarkObj] do begin
    W:=hotBut.Width;    varW.Caption:=FtoS(W,0);
    H:=hotBut.Height;   varH.Caption:=FtoS(H,0);
    p0.x:=hotBut.Left;  posX.Caption:=FtoS(p0.x,0);
    p0.y:=hotBut.Top+H+TitleHeight-1; posY.Caption:=FtoS(p0.y,0); //
    end;
  TextAndImage(MarkObj,false,true,true, false);
end;
procedure TfrmMain.imgIDMouseUp(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
  var i:integer;
begin
  bL:=false; bR:=false;  labHint.Top:=-20;
  if not bMove and lastHot then Obj[MarkObj].hot:=false;

  for i:=0 to 63 do SelRec[i]:=0;
  for i:=1 to ObjCount do with Obj[i]do
    if(delID=0)and hot then begin
      inc(SelRec[0]); inc(SelRec[Kind]); SelRec[20+SelRec[0]]:=i;
      end;
  imgListUpdate(MarkObj, Obj[MarkObj].ShowID, true, true,false);
end;
procedure TfrmMain.imgIDDblClick(Sender: TObject);
begin
  with Obj[MarkObj]do
  if(Mode=6)then ShowControlBox( MarkObj,146,      tabLink) //链接
            else ShowControlBox( MarkObj,140+Mode, tabPath);
end;
procedure TfrmMain.runIDClick(Sender: TObject); //暂停钮
begin
  MarkObj:=TComponent(Sender).Tag;
  with Obj[MarkObj]do begin
    runID.NumGlyphs:=3-runID.NumGlyphs;
    if Assigned(timID)then timID.Enabled:=not timID.Enabled;//
    end;
end;
procedure TfrmMain.createTimer( ID :integer; New :boolean);  //创建时钟
begin
  with Obj[ID]do begin
  timID:=TTimer.Create(self);
  with timID do begin
    if(Mode=1)then OnTimer:=timAnimateTimer;  //动画
    if(Mode=2)then OnTimer:=timMoveTimer;     //移动
    if(Mode=4)then OnTimer:=timSeriesTimer;   //系列
    Tag:=MarkObj;  Enabled:=false;
    end; //with timID
  end; //with Obj[ID]
end;

procedure TfrmMain.butIDMouseDown(Sender: TObject; Button: TMouseButton;Shift: TShiftState; X, Y: Integer);
  var a,b,k,i,j,n,ID :integer;  sT:string;  bb:boolean;  tmpBut:TPanel;
begin
  hotBut:=(Sender as TPanel);         hotBut.BringToFront;
  ID:=hotBut.Tag;                     MarkObj:=ID;
  pnlProp.Hide; butProp.Down:=false;
  with Obj[ID] do begin
    if(Mode in[1,2,4])and not Assigned(timID)then //动画、移动、系列
      createTimer(MarkObj, false); //创建时钟

    if(Mode=1)then begin //动画===============
      F:=not F;  Randomize;
      if(S<1)or(Mode=4)then timID.Interval:=10 else timID.Interval:=1000 div S;
      i:=0; while(Link[i]>0)do inc(i);  nTrace:=i-1; //动点总数
      if F then begin //按下按纽 L:=IIFf(Q,p2.z,p2.x);
        for i:=0 to nTrace do with Obj[Link[i]] do
          begin R:=L; kW:=IIFf(F,1,0); kH:=IIFf(F,1,0); end; //保存约束值 约束值归0 Q约束点反向移动
        for i:=0 to LayerTime do bEnd[i]:=true;
        parent:=0;//当前动点
        end
      else begin //抬起按纽  L:=R;
        runID.NumGlyphs:=1;
        for i:=0 to nTrace do with Obj[Link[i]] do Edited:=true;
        reRelate(11,ObjCount,false,false,false); SetProjection(true,false,0);
        end;
      timID.Enabled:=F;
      end;
    if(Mode=2)and(Link[1]>0)then begin //移动===============
      F:=not F;
      if F then
        for i:=0 to 22 do begin
          j:=i*2;   a:=Link[j];   b:=Link[j+1];
          if(a>0)and(b>0)then begin
            if(a=1)then SwapI(a,b);
            Para[j]:=Obj[b].p0;  Para[j].w:=0; //终点
            if(Obj[a].Kind=1)and(Obj[a].Mode=2)then //移动约束点 U:顺序 and not U
              Para[j].r:=ValueOfDot(MarkObj, b, Obj[a].Link[1], false);//终点的点值
            if(Obj[a].Kind=11)and(Obj[a].Mode=2)then
              Para[j].r:=Obj[b].L;
            timID.Interval:=1000 div S;
            end;
          end;
      parent:=0;  //当前移动对象
      timID.Enabled:=F;
      end;
    if(Mode=3)then begin //隐藏/显示===============
      F:=true;  if bAll then butAll.Down:=false;  bAll:=false; 
      ClearSelRec(0); //清除选择队列
      MarkObj:=ObjSelected(0, bS,bC,false,true);
      n:=0;
      for i:=0 to LinkTime do begin
        a:=Link[i]; if(a<11)then break;
        if Mask and((i<nTrace)or(i>(nTrace))) then continue; //手动控制
        if Mask and(Link[i+1]<11)then nTrace:=-1; //鼠标抬起时会归零
        Obj[a].Hot:=false;
        bb:=Obj[a].ObjShow[Layer];
        if not(U or Q)then bb:=not bb else bb:= Q;
        Obj[a].ObjShow[Layer]:= bb;
        if(Obj[a].Kind=14)or(Obj[a].Kind=11)and(Obj[a].Mode=2)then
          Obj[a].butID.Visible:= bb;
          if bb and Trace then begin //显示后选择
             Obj[a].Hot:=true; //Trace 选择被显示的对象
             inc(n);  inc(SelRec[0]); inc(SelRec[Obj[a].Kind]); SelRec[20+n]:=a;
             end;
        end;
      sT:=Tag; //or
      if not(U or Q or Mask)or(Mask)and(nTrace=-1)then begin
        if bb then sT:=StringReplace(sT,'显示','隐藏',[rfIgnoreCase])// AFromText, AToText, [rfReplaceAll, rfIgnoreCase]);
              else sT:=StringReplace(sT,'隐藏','显示',[rfIgnoreCase]);
        if bb then sT:=StringReplace(sT,'Show','Hide',[rfIgnoreCase])// AFromText, AToText, [rfReplaceAll, rfIgnoreCase]);
              else sT:=StringReplace(sT,'Hide','Show',[rfIgnoreCase]);
        Tag:=sT;
        butID.caption:=sT;
        end;
      if bb and Trace then CountObjNum(false, false); 
      ObjListUpdate(MarkObj, false);
      SetProjection(false,false,8);
      end;
    if(Mode=4)then begin //系列控制===============
      F:=not F;  nTrace:=0; tmpBut:=hotBut;
      if F then begin //按下
        for i:=0 to LinkTime do
          if(Link[i]>10)and(Link[i]<=ObjCount)and(Obj[Link[i]].Mode<3)
            then Obj[Link[i]].F:=false;
        if U then with Obj[Link[0]]do begin //顺序按下
          butIDMouseDown(butID, mbLeft, [], 0,0);
          if(Mode=3)then begin
            F:=false; setPanelBeval(butID, false); //隐藏/显示 立即抬起
            end;
          end
        else      //同时按下
          for i:=0 to LinkTime do
            if(Link[i]>10)and(Link[i]<=ObjCount)then
              with Obj[Link[i]]do
              if(delID=0)and(Kind=14)then begin
                butIDMouseDown(butID, mbLeft, [], 0,0);
                if(Mode=3)then begin
                  F:=false; setPanelBeval(butID, false); //隐藏/显示 立即抬起
                  end;
                end;
        end
      else begin  //抬起
        for i:=0 to LinkTime do
          if(Link[i]>10)and(Link[i]<=ObjCount)then
          with Obj[Link[i]]do
            if(delID=0)and(Kind=14)and(Mode<5)then begin
              F:=(Mode=4);
              setPanelBeval(butID, false);
              if Assigned(timID)then timID.Enabled:=false;
              runID.Visible:=false; imgID.Visible:=true;
              if(Mode=4)then butIDMouseDown(butID, mbLeft, [], 0,0);
              end;
        timID.Enabled:=false;
        end;
      hotBut:=tmpBut;
      timID.Enabled:=F;
      end;
    if(Mode=6)then begin //链接===============
      F:=true; //鼠标抬起时再执行链接
      end;
    runID.Visible:=(Mode<3)and F;
    imgID.Visible:=(Mode=3)or not F or(Mode in[3,6]);
    setPanelBeval(hotBut, F);
    end; //with
end;

procedure TfrmMain.butIDMouseUp(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
  var i,ID, NowPage, tmpButt :integer; st:PAnsiChar; stL:string;  bb:boolean;
begin
  ID:=(Sender as TComponent).Tag;
  with Obj[ID] do begin
  if not((Kind=14)and(Mode in[3,6]))then exit; //隐藏 链接
  F:=false; setPanelBeval(hotBut, false);
  if(Mode=3)and Mask then inc(nTrace);
  if(Mode=6)then begin //链接
    if U then begin //超链接
      st:=PAnsiChar(trim(edtLink.Text));  stL:=copy(st,1,4);
      if(stL='http')or(stL='www.')or FileExists(st)then
        ShellExecute(handle,nil, st, nil,nil,sw_ShowNormal);
      end
    else begin //换页
      for i:=11 to ObjCount do with Obj[i]do if(Kind=14)then begin
        F:=false;
        setPanelBeval(hotBut, false);  imgID.Visible:=true; runID.Visible:=false;
        if Assigned(timID)then timID.Enabled:=false;
        end;
      NowPage:=tabPage.TabIndex;  //当前页
      i:=-1; bb:=false;
      repeat inc(i); if(i<(tabPage.Tabs.Count))then bb:=(Objs[i,8].parent=S);
       until bb or(i>(tabPage.Tabs.Count-1));
      if bb then begin
        OldPage:=i; {目标页} tmpButt:=maxTrace; {目标按钮}
        if(NowPage<>OldPage)then begin //改变页面
          PaintNum:=0; PaintMax:=0; PaintListNum:=0;
          SaveThisPage(NowPage,ObjCount, false,true);
          ReadThisPage(OldPage); //获得ObjCount
          updateTexture(false);
          ObjListUpdate(0,true);
          if(tmpButt>0)then begin //链接按钮
            i:=10; repeat inc(i); bb:=(Obj[i].DelID=0)and(Obj[i].Name=tmpButt); until bb or(i=ObjCount);
            if bb and(i>10)and(i<maxObj)and(Obj[i].Kind=14)then begin
              butIDMouseDown(Obj[i].butID, mbLeft,[],0,0);//激活按钮
              if(Obj[i].Mode=3)then
                butIDMouseUp(Obj[i].butID, mbLeft,[],0,0);//
              end;
            end;
          ReRelate(11, ObjCount, false,false,false );
          SetProjection(false,false,0);
          for i:=11 to ObjCount do
            if(Obj[i].Kind in[10,11,14])then TextAndImage(i, false,true,true, false);
          tabPage.TabIndex:=OldPage;
          end;
        end;
      end;
    end;
  end;//with Obj[ID] do if...
end;
//================== 动画控制 =====================
procedure TfrmMain.timAnimateTimer(Sender: TObject);
  var i,k,t :integer;  isEnd:boolean;
begin //caption :='';
  k:=maxObj;
  t:=(Sender as TComponent).Tag;
  with Obj[t] do begin
    if U then begin //多点顺序移动
      if(bEnd[parent])then begin //parent 当前动点
        bEnd[parent]:=MovePoint(Link[parent],Q,false);//移动约束点 Q 单次移动
        if not bEnd[parent] then begin
          inc(parent);
          if(parent>nTrace)then begin
            if Q then F:=false //Q 单次移动到终点结束 nTrace动点总数
            else begin
              for i:=0 to nTrace do bEnd[i]:=true;
              parent:=0;
              end;
            end;
          end;
        end;
      end
    else begin //多点同时移动
      for i:= 0 to nTrace do
        if(bEnd[i])then bEnd[i]:=MovePoint(Link[i],Q,false) or not Q;  //Q 单次移动
      i:=-1; repeat inc(i); until bEnd[i]or(i=nTrace); //如果有一个没到终点就不停止
      if not bEnd[i]then F:=false;
      end;
    for i:=0 to nTrace do Obj[Link[i]].edited:=true;
    for i:=0 to nTrace do if(Link[i]<k)then k:=Link[i];
    if not F then begin
      timID.Enabled:=false;
      runID.Visible:=false; imgID.Visible:=true;  //runID暂停按钮
      setPanelBeval(butID, false);
      end;
    end;
  ReRelate(k,ObjCount,false,false,false);
  SetProjection(false,false,21);
end;
//================== 移动控制 =====================
procedure TfrmMain.timMoveTimer(Sender: TObject);
  var a,b,c, i,k,ID,iID, Lin,N :integer;  dL,lA,lB, Len :single;
    pA,pB,pC, pV,pP :TcgVector;     isEnd :boolean;
begin
  ID:=(Sender as TComponent).Tag;
  with Obj[ID] do begin
    isEnd:=true;      //  Len:=0;
    a:=Link[parent];    pA:=Obj[a].p0;  lA:=Obj[a].L;
    b:=Link[parent+1];  pB:=Obj[b].p0;  lB:=Obj[b].L;
    if(Obj[a].Mode=1)and(not cgVecComp(pA,pB))then begin //移动自由点
      if Q then isEnd:=false  //Q 动态跟随
           else pB:=Para[parent];      //移到目标点然后停止 Vec:初始目标点
      if EP(R)then    //步长为0
        Obj[a].p0:=pB //直接移动
      else begin
        if(cgDistance(pA,pB)<=R)then //两点间距小于移动步长
          Obj[a].p0:=pB
        else begin
          pV:=cgNormalVec(pB,pA);   //动点到终点的向量
          Obj[a].p0:=cgVecAddMult(pA,pV,R);//R移动步长
          end;
        end;
      end;
    if(Obj[a].Kind=1)and(Obj[a].Mode=2)then begin //移动约束点
      Lin:=Obj[a].Link[1]; //约束件
      if Q then lB:=ValueOfDot(b, b, Lin, false)  //Q 跟随
           else lB:=Para[parent].r; //终点值
      if EP(R)then lA:=lB  //步长为0则直接移动
           else lA:=ValueOfDot(a, a, Lin, false);
      if not EP(R)then Len:=abs(lB-lA);//点值差
      if not EP(Len)then isEnd:=false;
      if not isEnd and(Len<=R)then begin lA:=lB; isEnd:=true; end;
      if not isEnd then lA:=lA + IIFf(lA>lB,-1,1)*R;
      if(Obj[Lin].Kind=2)then with Obj[a]do begin //直线上的约束点 D定距
        L:=lA;   if D then Obj[a].L:=lA * Obj[Lin].L;
        with Obj[a]do if U then begin if(L<p2.x)then L:=p2.x; if(L>p2.z)then L:=p2.z; end;
        end
      else if(Obj[Lin].Kind=3)and(Obj[Obj[Lin].parent].Mode<3)then begin//圆上的点
        Obj[a].L:=lA * IIFf(Obj[a].Deg, 360, towPi);
        with Obj[a]do if U then begin if(L<p2.x)then L:=p2.x; if(L>p2.z)then L:=p2.z; end;
        end
      else if(Obj[Lin].Kind=3)and(Obj[Lin].Mode in[3,4])and Obj[a].D then begin //圆弧上的点
        k:=high(LocaVct[Lin]);
        Obj[a].L:=lA * LocaVct[Lin,k].w;
        with Obj[a]do if U then begin if(L<p2.x)then L:=p2.x; if(L>p2.z)then L:=p2.z; end;
        end
      else if(Obj[Lin].Kind=4)and not EP(R)then begin //平面上的点
        pC:= Footer(pB, Lin, false); //目标点在平面上的投影
        N:=trunc(Obj[Lin].W); if(N=99)then N:=4; if(N>100)then N:=N-100;//W>100 正n边形
        if Obj[a].U and not cgDotInPolygon(pC, LocaVct[Lin], N) then begin //被移动点限制在平面内
          N:=N-1;
          pV:=LocaVct[Lin,0];   pV.w:=cgDistance( pV, pC);
          for i:= 0 to N do begin
            pP:=cgDotNearestLine( pC, LocaVct[Lin,i], LocaVct[Lin,i+1] );
            if(pP.w<pV.w)then pV:=pP;
            end;
          pC:=pV;
          end;
        setLine( 9, LocaVct[Lin,1], cgNormalVec(LocaVct[Lin,1],LocaVct[Lin,2]));
        pV:=footer(pC, 9, true);//直线上的垂点
        lA:=cgDistance(pV, LocaVct[Lin,1]);
        if(cgDistance(pV, LocaVct[Lin,2])>Obj[Lin].p4.w)then lA:=-lA;
        lB:=pV.w;
        if(cgDistance(pV, LocaVct[Lin,0])<cgDistance(pC, LocaVct[Lin,0]))then lB:=-lB;

        dL:=R/cgDistance(pA,pC);
        if(dL>=1)then begin
          Obj[a].L:=lA;  Obj[a].R:=lB;
          end
        else begin
          Obj[a].L:=Obj[a].L+( lA-Obj[a].L)*dL;
          Obj[a].R:=Obj[a].R+( lB-Obj[a].R)*dL;
          end;
        end
      else
        Obj[a].L:=lA;
      end;
    if(Obj[a].Kind=11)and(Obj[a].Mode=2)then begin //移动参数值
      if Q then isEnd:=false  //Q 动态跟随
           else lB:=Para[parent].r;    //移到目标值然后停止
      if EP(R)then Obj[a].L:=lB //步长为0则直接移动
      else begin
        if(abs(Obj[a].L-lB)<=R)
          then Obj[a].L:=lB
          else begin
            lA:=R; if(Obj[a].L>lB)then lA:=-R;
            Obj[a].L:=Obj[a].L+lA;//R移动步长
            end;
        end;
      isEnd:=EP(Obj[a].L-lB);
      end;
    if isEnd then begin
      if(Obj[a].Kind=1)then begin
        Pointe(a, false,false,false);
        Len:=cgDistance(Obj[a].p0, pB);
        end;
      if(Len<0.0001)then begin
//若某个点移动到终点,则
//1 标记该点已到达终点
//1 U=false(同时移动)若所有点都已到终点,则结束移动(F:=false)
//2 U=true (顺序移动)启动下一个点,若是最后一个点则结束移动(F:=false)
        Para[parent].w:=1;
        if not U then begin //同时移动
          i:=-2; isEnd:=true;
          repeat
            inc(i,2); c:=Link[i]; b:=Link[i+1];
            if(c>0)and(b>0)and(Para[i].w<>1)then isEnd:=false; //若某个点未达终点
           until(not isEnd)or(c<1)or(b<1);
          if isEnd then F:=false;   //若所有点均已达终点
          end
        else begin //顺序移动
          inc(parent,2);
          if U and((Link[parent]<1)or(Link[parent+1]<1))then F:=false;
          end;
        end;
      end;
    reRelate( a, ObjCount, false, false,false);
    SetProjection(false,false,20);
//移动过程中
//U=false(同时移动)启动下一个点
    if not U then begin //同时移动
      inc(parent,2);
      if(Link[parent]<1)or(Link[parent+1]<1)then parent:=0;
      end;
    if not F then begin
      timID.Enabled:=false;   runID.Visible:=false; imgID.Visible:=true;
      setPanelBeval(butID, false);
      end;
  end;// with Obj[ID]
end;
//================== 系列控制 =====================
procedure TfrmMain.timSeriesTimer( Sender: Tobject); //系列按钮控制
  var a,i,ID,n :integer;   bb:boolean;
begin //
  ID:=(Sender as TComponent).Tag;
  n:=0; bb:=false;  //按钮数
  with Obj[ID] do begin
    for i:=0 to LinkTime do if(Link[i]>10)and(Link[i]<ObjCount)then inc(n);
    if U then begin //顺序执行
      a:=Link[nTrace];  bb:=true;
      if(not Obj[a].F)then begin
        if(nTrace<(n-1))then begin
          inc(nTrace);
          with Obj[Link[nTrace]]do begin
            butIDMouseDown(butID, mbLeft, [], 0,0);
            if(Mode=3)then begin //隐藏/显示 立即抬起
              F:=false; setPanelBeval(butID, false);
              end;
            end;
          end
        else
          bb:=false;
        end;
      end
    else begin
      for i:=0 to n-1 do if(Obj[Link[i]].F)then bb:=true;
      end;
    if not bb then begin
      F:=false;
      timID.Enabled:=false;   runID.Visible:=false; imgID.Visible:=true;
      setPanelBeval(butID, false);
      end;
  end;//with Obj[t]
end;

procedure TfrmMain.pnlCtrlShow(ID:integer);
  var a,i,j,n :integer;  st:string;
begin
  tlbMain.Enabled:=false;
  with pnlControl do begin
    Left:=Obj[ID].butID.Left+Obj[ID].butID.Width;
    Top:=Obj[ID].butID.Top; Visible:=true;
    end;
  with Obj[ID] do begin
  if(Mode<6)then begin
    lstPath.Clear;  j:=0;
    for i:=0 to LinkTime do begin
      if(Link[i]=0)then break;
      if(Link[i]<11)then Link[i]:=0
        else begin
        if(i<>j)then SwapI(Link[j],Link[i]);
        lstPath.AddItem(IDtoItem(Link[j]),nil);
        inc(j);
        end; //动点
      end;
    for i:=0 to j do LinkName[i]:=Obj[Link[i]].Name;
    end;
  if(Mode=6)then begin //链接
    radLink.Checked:=U or(tabPage.Tabs.Count=1);
    radPage.Enabled:=tabPage.Tabs.Count>1;
    cmbPage.Enabled:=radPage.Checked and(tabPage.Tabs.Count>1);
    cmbButton.Enabled:=cmbPage.Enabled;
    if(trim(info[0])>'')then edtLink.Text:=info[0];
    if(tabPage.Tabs.Count>1)then begin
      cmbPage.Clear;  j:=0;
      for i:=1 to tabPage.Tabs.Count do begin
        if(i=tabPage.TabIndex+1)
          then st:=SwitchS(iLanguage,'(当前页)','(當前頁)','(Current Page)','')
          else st:=tabPage.Tabs[i-1];
        cmbPage.AddItem( itos(i)+' '+st, nil);
        if(Objs[i-1,8].parent=S)then j:=i-1; //链接的页名
        end;
      if(j<=0)then begin
        if(tabPage.TabIndex=0)then j:=1 else j:=0;
        S:=Objs[j,8].parent;
        end;
      cmbPage.ItemIndex:=j;
      cmbPageChange(cmbPage);
      end;
    end;
  if bAdd and(Mode<6)then radMoveClick(nil);
  end;// with Obj[ID]
  if(Obj[ID].Mode<6)then begin lstPath.SetFocus;  lstPath.ItemIndex:=0; end;
  pnlShow.Hide;
end;

procedure TfrmMain.radMoveClick(Sender: TObject);
begin
  with Obj[MarkObj]do begin
  if(Mode=6)then begin //链接
    cmbPage.Enabled:=radPage.checked;   //链接页面
    cmbButton.Enabled:=cmbPage.Enabled; //链接按钮
    edtLink.Enabled:=radLink.checked;   //外部链接
    end;
  end; //with
end;

procedure TfrmMain.lstCtrlMouseDown(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
  var i :integer;  Lst:TListBox;
begin
  Lst:=(Sender as TListBox);
  if not Lst.Focused then Lst.SetFocus;
  posEdit.Tag:=0;
  popObj.Items.Clear;
  addItem(MarkObj,14, true, (Lst.ItemIndex>=0),false); //(Obj[MarkObj].Kind=17)or
  case Lst.tag of
  140:case Obj[MarkObj].Mode of
    1:for i:=11 to MarkObj-1 do with Obj[i] do if(delID=0)then //动画
        if(Kind=1)and(Mode=2)and(Obj[Link[1]].Kind in[2,3,5,11,15,16,17,19])
          then addItem(i,0,false,false,false);
    2:for i:=11 to MarkObj-1 do with Obj[i] do if(delID=0)then //移动
        if(Kind=11)and(Mode<3)then addItem(i,0,false,false,false);
    3:for i:=11 to MarkObj-1 do with Obj[i] do if(delID=0)then //隐藏
        if(Mode<>13)then addItem(i,0,false,false,false);
    4:for i:=11 to MarkObj-1 do with Obj[i] do if(delID=0)then //系列
        if(Kind=14)and(Mode<4)then addItem(i,0,false,false,false);
    end;
  171:begin
    for i:=11 to MarkObj-1 do with Obj[i] do //路径
        if(delID=0)and(Kind in[1,2,3,4,5,15,16,17,19])then addItem(i,0,false,false,false);
    butPathU.Enabled:=Lst.ItemIndex>0;
    butPathD.Enabled:=(Lst.ItemIndex>=0)and(Lst.ItemIndex<Lst.Count-1);
    butPathDel.Enabled:=(Lst.Count>1);//and(Lst.ItemIndex>=0);
    end;
  end; //case
  bSelLink:=true;
end;
//================ 以上代码有关 控制 ===================
//===================== 13 迭代 ================//
procedure TfrmMain.DieDaiResize;
  var k:integer;
begin
  with Obj[MarkObj] do begin
  pnlIterate.Height:=trunc(H+1)*22+18;
  pnlIterate.Width:= trunc(W+1)*36+18;
  k:=pnlIterate.Height+80;
  pnlControl.Height:=IIfi( k<120, 120, k);
  pnlControl.Width:= pnlIterate.Width +100;
  end;//with
end;

procedure TfrmMain.pnlIterateShow(Add:boolean);
  var a,i,j,k,n, Wi,He :integer;
begin
  with Obj[MarkObj] do begin
  Wi:=trunc(W); He:=trunc(H);  a:=Link[0]; //a迭代次数
  txtDepth.Text:=IIFs( a>0, IDtoS(a), ItoS(S));
  edtLayer.Text:=ItoS(trunc(L)+1);
  butDieDaiAdd.Enabled:=(a=0)and(S<9);
  butDieDaiSub.Enabled:=false;
  cheLast.Checked:=D; cheDot.Checked:=F; //终像 含点
  cheRand.Checked:=Rand; butRand.Enabled:=not bAdd and Rand; //随机
  n:=0;
  for i:= 0 to He do for j:=0 to Wi do begin
    if Add then begin
      objArray[i,j]:=0;  txtArray[i,j].Text:='?';
      end
    else begin
      inc(n);  k:=Link[n];
      objArray[i,j]:=k;  txtArray[i,j].Text:=IDtoS(k);
      end;
    txtArray[i,j].Color:=clBtnFace; //  clRed;//
    end;
  end;//with
  DieDaiResize;  bSelLink:=true;
  hotText:=txtArray[0,0];   //hotText.Ctl3D:=false;
  txtArray[0,0].SetFocus;   //hotText.Color:=clWhite;//clInfoBk;
end;

procedure TfrmMain.txtDepthEnter(Sender: TObject);
begin  //用Tab键进入控件时相当于鼠标单击
  txtDepth0MouseDown(Sender, mbLeft, [], 0,0);
end;

procedure TfrmMain.txtDepth0MouseDown(Sender: TObject; Button: TMouseButton;Shift: TShiftState; X, Y: Integer);
  var i,j,t:integer;
  procedure Item(j,k:integer);
    var i:integer;
  begin
    for i:=11 to MarkObj-1 do with Obj[i] do
      if(Kind=1)and(IIFb(j=0,true,Mode<3))or(Kind=11)then
        AddItem( i,0,false,false,false);
  end;
begin
  posEdit.Tag:=0;
  if(Obj[MarkObj].Kind=13)then HotText.Color:=clBtnFace;
  HotText:=(Sender as TEdit);
  if(Obj[MarkObj].Mode=16)then begin //仿射变换规则
    popObj.Items.Clear;  AddItem( 0,0, true, Obj[MarkObj].Link[HotText.Tag]>10, false);
    for i:=11 to MarkObj-1 do with Obj[i] do
      if(Kind=1)and(Mode=2)or(Kind=11)then AddItem( i,0,false,false,false);
    end;
  if(Obj[MarkObj].Kind=13)then begin //迭代规则
    HotText.Color:=clInfoBk; //White;   //HotText.Ctl3D:=true;
    t:=HotText.Tag;
    popObj.Items.Clear; AddItem( 0,0,true,t=101,false);
    with Obj[MarkObj] do begin
    if t=101 then begin //迭代次数
      butDieDaiAdd.Enabled:=(Link[0]=0)and(S<32);
      butDieDaiSub.Enabled:=(Link[0]=0)and(S>0);
      butDieDaiAdd.Hint:='增加|增加迭代深度';
      butDieDaiSub.Hint:='减少|减少迭代深度';
      Item(2,0);
      end
    else begin
      if(t mod 21)=0 then begin //原像
        butDieDaiAdd.Enabled:=H<7;  butDieDaiSub.Enabled:=H>0;
        butDieDaiAdd.Hint:='增加|增加原像';
        butDieDaiSub.Hint:='减少|减少原像';
        Item(1,0);
        end
      else begin //映像
        butDieDaiAdd.Enabled:=W<20; butDieDaiSub.Enabled:=W>1;
        butDieDaiAdd.Hint:='增加|增加映象';
        butDieDaiSub.Hint:='减少|减少映象';
        Item(0,t div 10);
        end;
      end;
    end;//with Obj[MarkObj]
    end;//if
  bSelLink:=true;
end;

function isNumber(var k:single; myEdit:TEdit):boolean;
  var i,Len:integer; st:string;  isNumb :boolean;
begin
  result:=true;  isNumb:=false;
  st:=trim(myEdit.Text);  if st='' then begin st:='0'; myEdit.Text:='0'; exit; end;
  Len:=length(st);
  for i:=1 to Len do begin
    if not(st[i] in [#48..#57,'.','-'])then result:=false; //遇见字母则置否
    if st[i]in[#48..#57]then isNumb:=true; //遇见数字则置真
    end;
  if result then begin //
    if not isNumb then begin st:='0';  myEdit.Text:='0'; end; //仅有负号或小数点
    k:=StrToFloat(st);   //and result
    end;
end;

procedure TfrmMain.txtDepthExit(Sender: TObject);
  var k :single; st:string;
begin k:=0;
  if isNumber(k,(Sender as TEdit)) then
    with Obj[MarkObj] do begin
    if(Kind=13)then begin //迭代
      Link[0]:=0;   LinkName[0]:=0;  S:=trunc(k);//k迭代深度
      bSelLink:=false;
      end;
    if(Mode=16)then begin //仿射变换
      Link[hotText.Tag+16]:=0;    LinkName[hotText.Tag+16]:=0;
      end;
    end; //if...with...
end;

procedure TfrmMain.txtDepthKeyPress(Sender: TObject; var Key: Char);
begin //只接受数字键
    if not(key in [#48..#57, #8])then key:=#0;
end;

procedure TfrmMain.butDieDaiAddClick(Sender: TObject);
  var i,j,t:integer;
begin
  t:= TComponent(Sender).Tag;
  with Obj[MarkObj] do begin
  hotText.Color:=clBtnFace;
  if HotText.Tag=101 then begin //迭代次数
    S:=S+ IIFi(t=0, 1,-1);
    txtDepth.Text:=IntToStr(S);
    butDieDaiSub.Enabled:=S>0;   //butDieDaiAdd.Enabled:=S<16;
    if not bAdd then Iterate( MarkObj,true,true); //
    if not bAdd then reRelate(MarkObj,ObjCount,false,true,false);
    SetProjection(false,false,25);
    end
  else begin
    i:=hotText.Tag div 20;  j:=hotText.Tag mod 21;
    if(j=0)then begin //原象数
      H:=H+ IIFi(t=0, 1,-1);
      butDieDaiAdd.Enabled:=H<7;   butDieDaiSub.Enabled:=H>0;
      if(i>H)then i:=trunc(H);
      end
    else begin        //初象数
      W:=W+ IIFi(t=0, 1,-1);
      butDieDaiAdd.Enabled:=W<20;  butDieDaiSub.Enabled:=W>1;
      if(j>W)then j:=trunc(W);
      end;
    DieDaiResize;
    hotText:=txtArray[i,j];  hotText.SetFocus; hotText.Color:=clWhite;
    bSelLink:=true;
    end;
  end;//with Obj[MarkObj]
end;
//================ 以下代码有关“移位”===================
function TfrmMain.ObjIsParent(ID,Son :integer):boolean;//ID是否Son的父构件
  var i,j:integer;
begin
  result:=false;
  if(ID<11)or(Son<11)or(ID>Son)then exit;
  for i:=ID to Son do Obj[i].Edited:=(i=ID);
  with Obj[ID]do if(Kind=11)and(Mode=2)then begin
    for i:=10 to LinkTime do if(Link[i]>0)then Obj[Link[i]].Edited:=true;
    end;
  for i:=ID+1 to Son do
    with Obj[i] do if not Edited then begin
      j:=-1;
      repeat inc(j); if(Link[j]>10)and(Obj[Link[j]].Edited)then Edited:=true;
       until(j=LinkTime)or(Edited);
    end;
  result:=Obj[Son].Edited;
end;

procedure TfrmMain.MoveObjID(old,new :integer);
  var i,n, Num :integer; gol:TmyObject;
      pp:array of TmyObject;
  procedure getObjEdges(ID:integer; var n:integer);
  begin
    with Obj[ID]do begin
    if(Kind=4)and(Mode=6)then   //多边形
      n:=trunc(W)*IIFi( D,2,1); //D正多边形加上顶点
    if(Kind=6)then //实体
      case Mode of
        3:n:=SolidEdge[S]+SolidVct[S]; //多面体
        4:if(S=0)then n:=trunc(Obj[Link[0]].W)*4 else n:=S*5; //S=0凸棱台 S>0正棱台
        5:n:=(trunc(W)-2)*3; //凸壳
        end;
    end;
  end;
begin
  n:=0;
  with Obj[old] do
    if(Kind=1)and(Mode=4)and((Obj[Link[0]].Kind in[3,5,15,16,17,19])or(Obj[Link[1]].Kind in[3,5,6,7,9,15,16,17]))
      then n:=1;
  getObjEdges(old, n);
  if n=0 then begin //单个对象
    gol:=Obj[old];
    if new>old then begin //往后移
      Num:=0; getObjEdges(new, Num);
      if Num>0 then inc(new,Num);
      for i:=old to new-1 do Obj[i]:=Obj[i+1];
      end;
    if new<old then
      for i:=old downto new+1 do Obj[i]:=Obj[i-1]; //往前移
    Obj[new]:=gol;
    end
  else begin //成组对象，如多边形或棱台或多面体
    setLength(pp, n+1);
    for i:=0 to n do pp[i]:=Obj[old+i];
    if new>old then begin //往后移
      Num:=0; getObjEdges(new, Num);
      if Num>0 then inc(new,Num);
      Num:=new-old-n;
      for i:=0 to Num do Obj[old+i]:=Obj[old+n+i+1];
      for i:=0 to n do Obj[old+Num+i]:=pp[i];
      end;
    if new<old then begin //往前移
      Num:=old-new;
      for i:=0 to Num do Obj[old+n-i]:=Obj[old-i-1];
      for i:=0 to n do Obj[new+i]:=pp[i];
      end;
    setLength(pp, 0);
    end;
end;
{
procedure TfrmMain.butMoveClick(Sender: TObject);
  var i,new :integer;
begin
  new:=StrToInt(cmbMove.Text);  
  i:=10; repeat inc(i); until Obj[i].ShowID=new;
  new:=i;
  with Obj[new] do if(Kind=1)and(Mode=4)and(D)then dec(MarkObj);
  MoveObjID(MarkObj, new);
  MarkObj:=new;
  upDateLink(ObjCount,true);
  pnlControl.Hide;
  ObjListUpdate(MarkObj,true);
  for i:= 11 to ObjCount do Obj[i].edited:=true; //重建显示列表
  rerelate(11,ObjCount,true,false,false);
  SetProjection(true,false,8);
  tlbMain.Enabled:=true;
end; }

procedure TfrmMain.cmbMoveSelect(Sender: TObject);
begin
  butOK.Enabled:=true;
end;
//=================== 以上代码有关“移位” ===================
procedure TfrmMain.butSaveDefaultClick(Sender: TObject);
  var i:integer;
begin
  if TComponent(Sender).Tag=0 then begin //保存场景
    With Obj[1]do begin
      p5.x:=Obj[5].Color.A;  pTR.x:=Obj[5].S;
      p5.y:=Obj[6].Color.A;  pTR.y:=Obj[6].S;
      p5.z:=Obj[7].Color.A;  pTR.z:=Obj[7].S;
      for i:=0 to 2 do if Obj[5+i].F then info[0][13+i]:='1' else info[0][13+i]:='0';
      Vec.x:=Obj[2].L;  Vec.y:=Obj[3].L;  Vec.z:=Obj[4].L;//坐标轴长
      Vec.w:=Obj[2].R;  Vec.r:=Obj[3].R;  p4.r:=Obj[4].R; //坐标轴尾长

      if IsZoomed(frmMain.Handle)then info[0][17]:='1' else info[0][17]:='0'; //IsZoomed()窗口是否最大化
      if butList.Down then info[0][20]:='1' else info[0][20]:='0'; //是否显示对象列表
      if butListAnchor.NumGlyphs=1 then info[0][21]:='0' else info[0][21]:='1'; //对象列表位置状态
      setWindowFrame(false);
      end;
    Obj[8]:=Obj[1]; Obj[8].Name:=8;
    end
  else begin  //恢复场景
    Obj[1]:=Obj[8]; Obj[1].Name:=1;
    setDefault(false);
    if(Obj[1].info[0][17]='1')and not IsZoomed(frmMain.Handle)then
      frmMain.WindowState := wsMaximized;//窗体最大化     wsNormal
    if(Obj[1].info[0][20]='1')then begin
      butList.Down:=true;  menList.Checked:=true; pnlList.Visible:=true;
      end;
    SetProjection(false,false,8);
    end;
end;
//============== 默认构件参数 ====================
procedure TfrmMain.cmbObjKindChange(Sender: TObject);
  var i:integer; v:single; st:string;
begin
  i:=cmbObjKind.ItemIndex+1;
  case i of
    1:st:=SwitchS(iLanguage,'点径','點經','Size','');
    2,3,5,6,7,9:st:=SwitchS(iLanguage,'线径','線經','Line Width','');
    4:st:=SwitchS(iLanguage,'边径','边經','Frame','');
    8:st:=SwitchS(iLanguage,'精度','精度','Accuracy','');
   10:st:=SwitchS(iLanguage,'字体','字體','Font','');
    end;
  labObjSize.Caption:=st;
  with Obj[1] do begin
  case i of 1:v:=p1.x; 2:v:=p1.y; 3:v:=p1.z; 4:v:=p1.w;
            5:v:=p2.x; 6:v:=p2.y; 7:v:=p2.z; 8:v:=p2.w;
            9:v:=p5.w; 10:v:=TagP.z; end;
  str( v:5:2, st);
  varObjSize.Caption:=st;  varObjColor.Color :=Link[i];
  end;
end;
//================= 选择操作符 ==================
procedure TfrmMain.N27Click(Sender: TObject);
  var Len:integer;  st:WideString;
begin
  st:=(Sender as TMenuItem).Caption;
  if not memText.Focused and(st<>'pi')and(st<>'ei')then st:=st +'()';////
  if memExpr.Focused then begin //计算框
    memExpr.Text:=insExpr( st, memExpr.Text, memExpr.SelStart, Len );
    memExpr.SelStart:=Len-1;
    end;
  if hotEdit.Focused then begin
    hotEdit.Text:=insExpr( st, hotEdit.Text, hotEdit.SelStart, Len );
    hotEdit.SelStart:=Len-1;
    end;
  if memText.Visible then begin //文本框
    memText.Text:=insExpr( st, memText.Text, memText.SelStart, Len );
    memText.SelStart:=Len-1;
    end;
end;
//================== 场景自动旋转 =======================
procedure TfrmMain.timSpinTimer(Sender: TObject);
  var xx,yy,zz :single;
begin
  if butSpin.Down then begin //场景自动旋转
    rX:=rX+dx/20; Limit(rX, 0,rX+360, 360,rX-360);
    rY:=rY+dy/20; Limit(rY, 0,rY+360, 360,rY-360);
    end
  else begin //面对指定平面
    inc(FlashSize);
    xx:=(rX1-rX0)/50;      yy:=(rY1-rY0)/50;      zz:=(rZ1-rZ0)/50;
    rX:=rX0+xx*FlashSize;  rY:=rY0+yy*FlashSize;  rZ:=rZ0+zz*FlashSize;
    if(FlashSize>=50)then timSpin.Enabled:=false;
    end;
  SetProjection(false,false,8);
end;
//====================== 控制按钮 路径 三视图 =========================
procedure TfrmMain.pnlPathShow(ID:integer; Add:boolean);
  var i:integer; st:string;
  function ItS(i:integer):string; begin str(i:3,result);end;
begin
  if(ID<11)then exit;
  lstPath.Clear;    st:='';
  with Obj[ID] do begin
  if(Kind=14)or(Kind=17)and(Mode=1)then begin
    for i:=0 to LinkTime do if Link[i]>0 then lstPath.AddItem(IDtoItem(Link[i]),nil);
    for i:=0 to LinkTime do if Link[i]>0 then st:=st+ItS(Link[i]);
    info[0]:=st;
    end;
  if(Kind=17)and(Mode=2)then begin //
    for i:=1 to LinkTime do if Link[i]>0 then lstPath.AddItem(IDtoItem(Link[i]),nil);
    end;
  butOK.Enabled:=false;
  lstPath.ItemIndex:= lstPath.Count-1; //指向最下一项
  butPathU.Visible:=(Kind=14)or(Kind=17)and(Mode=1);  butPathU.Enabled:=lstPath.ItemIndex>0;
  butPathD.Visible:=(Kind=14)or(Kind=17)and(Mode=1);  butPathD.Enabled:=false;
  butPathDel.Enabled:=lstPath.Count>1;
  butPathResume.Visible:=(Kind=14)or(Kind=17)and(Mode=1);  butPathResume.Enabled:=false;
  bSelLink:=true;
  end; //with
end;
//====================== 计算显示精度 =====================
procedure TfrmMain.cmbAccuracyChange(Sender: TObject);
begin res:=0;
  with Obj[MarkObj]do begin
  S:=cmbAccuracy.ItemIndex;
  if(Kind=11)then begin
    TextAndImage(MarkObj,false,false,true, false);
    MainDraw( GL_RENDER, false,'b');
    end;
  if(Kind=18)then GetTextList ( MarkObj); //更新标签
  end; //with
end;

procedure TfrmMain.menOpenClick(Sender: TObject);
  var i:integer;
begin // 打开文件
  for i:=11 to maxObj do if Assigned(Obj[i].timID)then Obj[i].timID.Enabled:=false;
  timAuto.Enabled:=false;
  if MarkObj>0 then Obj[MarkObj].hot:=false;
  if not checkSaved then exit; //是否保存已经编辑的模型
  OpenBox.InitialDir :=sgfPath;
  OpenBox.FileName:= sgfName;
  OpenBox.Filter:='Solid geometry files (*.sgf)|*.sgf';
  If OpenBox.Execute then begin
    SgfFile:= OpenBox.FileName;
    sgfName:=ExtractFileName(sgfFile);
    sgfPath:=ExtractFilePath(sgfFile);
    end
  else Exit;
  setPopMenu( true, SgfFile);
  Start(true);
end;

procedure TfrmMain.menSize8Click(Sender: TObject);
begin //度量菜单 //1长度 2半径 3周长 4面积 5体积 6距离 7角度 15坐标
  AppendObj( menSize.Tag, TComponent(Sender).Tag);
end;

procedure TfrmMain.menMoveIDClick(Sender: TObject);
  var i,j, min,max :integer;
begin
  if MarkObj<11 then begin
    case iLanguage of
      0:MyMessage('请先选择欲移动次序的构件。');
      1:MyMessage('請先選擇慾移動次序的構件。');
      2:MyMessage('Please select a component to change order.');
      end;
    exit;
    end;
  case iLanguage of
    0:labMove.Caption:='将#'+ itos(Obj[MarkObj].ShowID)+'对象“'+Obj[MarkObj].Tag+'”的次序移到:' ;
    1:labMove.Caption:='将#'+ itos(Obj[MarkObj].ShowID)+'對象“'+Obj[MarkObj].Tag+'”的次序移到:' ;
    2:labMove.Caption:='Change the order of #'+ itos(Obj[MarkObj].ShowID)+' Object "'+Obj[MarkObj].Tag+'" to:' ;
    end;

  min:=10; max:=ObjCount+1;
  for j:= 11 to MarkObj-1 do with Obj[MarkObj] do //前移位置
    if(DelID=0)and(Mode<13)then
      for i:= 0 to LinkTime do
        if(Link[i]=j)and(Link[i]>min)then min:=j;
  if(MarkObj+1)<=ObjCount then
  for j:= MarkObj+1 to ObjCount do with Obj[j] do
    if(DelID=0)and(Mode<13)then
      for i:= 0 to LinkTime do
        if(Link[i]=MarkObj)and(j<max)then max:=j;
  with Obj[MarkObj] do
  if((min+1)>=max)or(Mode=13)//or(Kind=1)and(Mode=4)
    then begin
    case iLanguage of
      0:MyMessage( '#'+itos(ShowID)+' 对象的次序不能改变。 ');
      1:MyMessage( '#'+itos(ShowID)+' 對象的次序不能改變。 ');
      2:MyMessage( '#'+itos(ShowID)+' object'+'"'+'s order can not changes. ');
      end;
    exit;
    end;
  cmbMove.Clear;
  i:=min;
  repeat
    inc(i);
    with Obj[i] do //
    if(DelID>0)or(i=MarkObj)or(Mode=13) //Mode=13 棱边
        or(Kind=1)and(Mode=4)and //与圆或轨迹线有关的交点有两个
          ((Obj[Link[0]].Kind in[3,5,15,16,17,19])or(Obj[Link[1]].Kind in[3,5,6,7,9,15,16,17,19]))
          then continue;
//      cmbMove.AddItem(itos(Obj[i].ShowID),nil);
    cmbMove.AddItem( ObjListID[ Obj[i].ShowID ].Text,nil);
  until(i=max-1) ;
  if(cmbMove.Items.Count=0)then with Obj[MarkObj] do begin
    case iLanguage of
      0:MyMessage( '#'+itos(ShowID)+' 对象的次序不能改变。 ');
      1:MyMessage( '#'+itos(ShowID)+' 對象的次序不能改變。 ');
      2:MyMessage( 'The order of the object '+Tag+' cannot be changed.');
      end;
    exit;
    end;
  butOK.Enabled:=false; tlbMain.Enabled:=false;
  ShowControlBox( MarkObj,20,tabMove);
end;

procedure TfrmMain.vi(Sender: TObject); //来自菜单menSport.OnClick
  var i:integer;
begin
  for i:=11 to ObjCount do with Obj[i]do
    if(Kind=14)and F then butIDMouseDown(butID, mbLeft,[ssLeft],0,0);
  setTimer( TComponent(Sender).Tag, false);
end;

procedure TfrmMain.menObjHideClick(Sender: TObject);
  var ch :Char;
begin
  case(Sender as TComponent).Tag of
    1:ch:='H';  //显示/隐藏对象
    2:ch:='K';  //显示/隐藏标签
    end;
  FormKeyPress(nil,ch);
end;
//================== 场景旋转按钮 =========================
procedure TfrmMain.menSpinClick(Sender: TObject);
  var i,t :integer;  ch:char;
begin
  t:=(TComponent(Sender).Tag);
  case t of
    8:begin //全显
      bAll:=not bAll; butAll.Down:=bAll;  menAll.Checked:=bAll;
      butLock.Down:=Obj[1].Mask;
      for i:= 11 to ObjCount do with Obj[i] do if(DelID=0)then begin //
        if(Kind=14)or(Kind=11)and(Mode=2)then butID.Visible:= ObjShow[Layer]or bAll;
        end;
      SetProjection(false,false,9);
      end;
  204:begin //对象列表
      if(Sender is TMenuItem)then butList.Down:=menList.Checked
                             else menList.Checked:=butList.Down;
      pnlList.Visible:= butList.Down;
      if pnlList.Visible then with pnlList do begin
        if(Top <0)or(Top>frmMain.height-20)then Top:=0;
        if(Left<0)or(Left>frmMain.Width-40)then Left:=0;
        end;
      if butList.Down then ch:='1'else ch:='0'; Obj[1].info[0][20]:=ch;
      end;
  205:with Obj[1]do begin //场景锁定
      ch:='L';  FormKeyPress(nil, ch);
      end;
  210:setWindowStyle; //全屏
  212:begin //场景旋转
      edtTemp.SetFocus;
      if(dx=0)and(dy=0)then dx:=-10;
      timSpin.Enabled:=not timSpin.Enabled;
      butSpin.Down:=timSpin.Enabled;
      end;
    end;
end;

procedure TfrmMain.but12Click(Sender: TObject);
begin
  if bAdd then begin
    hotTool.Down:=false;   butArrow.Down:=true;
    dec(ObjCount);         labHint.Top:=-20;
    end;
  AddingObj( (Sender as TComponent).Tag, 0 );
end;
//=================== 变换标记 ============================
procedure TfrmMain.menMarkClick(Sender: TObject);
  var i,t:integer;
begin //t=3标记中心/轴/平面 4标记向量 5标记距离 6标记角度 7标记比 8自定义
  //若未选择对象，则取消标记
  t:= (TComponent(Sender).Tag) mod 10;
  if(Sender as TMenuItem).Checked and(SelRec[0]=0)then begin
    for i:=0 to 2 do MarkTrans[t,i]:=0;
    (Sender as TMenuItem).Checked:=false; //
    CountObjNum(false,false);
    exit;
    end
  else begin
    for i:=0 to 2 do MarkTrans[t,i]:=SelRec[21+i];
    (Sender as TMenuItem).Checked:=true; //
    end;
  FlashSize:=5;   Obj[0].Way:=false;  Obj[0].Seled:=false;
  MarkObj:=SelRec[21]; bFlash:=true;  timFlash.Enabled:=true;
  if t=8 then begin  //自定义
    if(MarkTrans[8,0]>MarkTrans[8,1])then SwapI(MarkTrans[8,0],MarkTrans[8,1]);
    men128.Caption:=SwitchS(iLanguage,'变换 ','變换 ','Transform ','')
      +Obj[MarkTrans[8,0]].Tag+'→'+Obj[MarkTrans[8,1]].Tag+'& ';
    men128.Visible:=true;
    end;
end;
//=================== 变换 ============================
procedure TfrmMain.menTransClick(Sender: TObject);
  var i,j,k,t, LastCount :integer;  isNoSel :boolean;
begin //t=1投影 2对称 3旋转 4缩放 5平移 6向量 8自定义 9反演  为兼容而不能改变定义次序
  HotMenu:=(Sender as TMenuItem);
  AppObjProc:=menTransClick; //按空格键将自动激活菜单
  isNoSel:=true; i:=0;
  if(bAdd)then BreckAdding; //中断添加过程
  if(SelRec[0]>0)then
    repeat
      j:=Obj[SelRec[21+i]].Kind; t:=Obj[SelRec[21+i]].Mode;
      isNoSel:=( j in[8,10,11,13,18]) or(j=17)and(t=2); //三视图不能再变换
      inc(i);
      until(i>=SelRec[0])or not isNoSel;
  t:=TComponent(Sender).Tag;
  if isNoSel or(t=131) then begin  //若未选择对象。t=131迭代
    but10Click(Sender); //选择对象
    exit;
    end;
  if(t=130)then t:=10 else t:= t mod 10;
  LastCount:=ObjCount;
  for i:=0 to SelRec[0]-1 do begin
    if(Obj[SelRec[21+i]].Kind in[8,10,11,13,18])then continue;
    if(t<4)and(SelRec[21+i]=MarkTrans[3,0])then continue; //忽略标记对象
    inc(ObjCount);  inc(backObj.maxName);
    Obj[ObjCount]:=Obj[SelRec[21+i]];
    Obj[SelRec[21+i]].Hot:=false;
    with Obj[ObjCount]do begin
      Name:=getObjName(1);//Name:=backObj.maxName;
      texTag:=0;    Tag:=Obj[SelRec[21+i]].Tag+'''';
      Mode:=t+6;    Hot:=true;  Edited:=true;  Q:=false;   if(Kind=6)then W:=1;
      CleanLink(ObjCount,0);// for j:=0 to LinkTime do begin Link[j]:=0; LinkName[j]:=0; end;
      for j:=0 to LayerTime do ObjShow[j]:=true;
      for j:=0 to 6 do begin Cutter[j,0]:=0; Cutter[j,1]:=0; Cutter[j,2]:=0; end;
      Link[0]:=SelRec[21+i];
      mainList:=0;  maskList:=0;  wireList:=0;
      seleList:=0;  tracList:=0;  stipList:=0;
      case t of
        1:begin //1投影
          Link[1]:=7; if(MarkTrans[3,0]>0)then Link[1]:=MarkTrans[3,0];
          R:=0; U:=false;  D:=false;
          if(MarkTrans[7,0]>0)then for j:=0 to 2 do Link[3+j]:=MarkTrans[7,j];//标记比值
          end;
        2:begin //2对称
          Link[1]:=1; if(MarkTrans[3,0]>0)then Link[1]:= MarkTrans[3,0];
          if(Kind in[3,4])then Thick:=-Obj[Link[0]].Thick; //圆或平面的厚度
          end;
        3:begin //5旋转
          Link[1]:=4; R:=DefaultProp[5];  Deg:=true;  U:=false; //Deg 角度
          if(MarkTrans[3,0]>0)and(Obj[MarkTrans[3,0]].Kind<5)
            then Link[1]:=MarkTrans[3,0]; //标记中心/轴
          if(MarkTrans[6,0]>0)then for j:=0 to 2 do Link[3+j]:=MarkTrans[6,j];//标记角度
          end;
        4:begin //4缩放
          Link[1]:=1; R:=DefaultProp[6]; //默认缩放值
          if(MarkTrans[3,0]>0)and(Obj[MarkTrans[3,0]].Kind=1 )
            then Link[1]:=MarkTrans[3,0];
          if(MarkTrans[7,0]>0)then for j:=0 to 2 do Link[3+j]:=MarkTrans[7,j];//标记比值
          end;
      5,8:begin //5平移 8自定义
          for j:=0 to 2 do Link[j+1]:=MarkTrans[t,j];
          if(t=5)then pTR:=defaultVec;
          end;
        6:begin //6向量
          if(MarkTrans[4,0]>0)then for j:=0 to 2 do Link[1+j]:=MarkTrans[4,j];
          Deg:=false; //定比
          R:=1;       //比例/距离
          end;
        9:begin //9反演
          Link[1]:=1; //默认原点为反演中心
          if(MarkTrans[3,0]>0)and(Obj[MarkTrans[3,0]].Kind=1 )
            then Link[1]:=MarkTrans[3,0];
          R:=3; //默认反演值
          if(Obj[Link[0]].Kind=2)then begin Kind:=3; Mode:=15; end;//直线反演为圆
          if(Obj[Link[0]].Kind=4)then
            begin Kind:=6; Mode:=15; S:=32; Color.A:=1; end;//平面反演为球
          end;
       10:begin //10仿射
          for k:=0 to 2 do for j:=0 to 3 do
            Value[k*4+j]:=IIFi((k=j)or(j=3), 1, 0);
          ShowControlBox(ObjCount,40,tabAffine);//
          end;
        end; //case t
      for j:=0 to 5 do LinkName[j]:=Obj[Link[j]].Name;
      if(t=8)then begin //自定义变换
        if(Obj[Link[0]].Kind in[2,3])then begin Kind:=5; F:=true; end; //直线的自定义变换转化为轨迹线
        if(Obj[Link[0]].Kind=4)then Kind:=7; //平面的自定义变换转化为曲面
        R:=3; H:=5; //R 采样精度
        end;
      end; //with ...
    save(1,ObjCount,1,true,false);
    SelRec[21+i]:=ObjCount;
    end; //for i...
  MarkObj:=ObjCount;
  ReRelate(LastCount+1, MarkObj, false,false,false );
  ObjListUpdate(MarkObj,true); //if(HotTool<>nil)then HotTool.Down:=false;
  SetProjection(false,false,0);
  if pnlProp.Visible then ShowObjProp(MarkObj, 0,0, true,true);  //显示构件属性框
end;
//=================== 页面控制 =========================
procedure TfrmMain.ShowTabEdit;
  var i,j,N,w :integer;
begin
    w:=9; //左边距
    N:=tabPage.TabIndex;
    j:=tabPage.FirstIndex;
    if N>0 then for i:=j to N-1 do w:=w+tabPage.ItemWidth(i)+9;
    edtPage.Width:=tabPage.ItemWidth(N);
    edtPage.Text:=tabPage.Tabs[N];
    edtPage.Left:=tabPage.Left+w;
    edtPage.Visible:=true;
    edtPage.SetFocus;   edtPage.SelectAll;
    Keypreview:=false;
end;

procedure TfrmMain.SaveThisPage(Page,Num:integer; isSave,isDelList:boolean);
  var i :integer;
begin
  for i:=11 to Num do with Obj[i]do begin
    if Assigned(butID)then butID.Visible:=false ; //隐藏按钮
    if Assigned(timID) then timID.Enabled:=false;  //停止动画 and butID.Visible
    end;
  if(not isSave)and isDelList then
    for i:=11 to ObjCount do with Obj[i]do begin
      glDeleteLists( mainList, 1);  mainList:=0;
      glDeleteLists( maskList, 1);  maskList:=0;
      glDeleteLists( wireList, 1);  wireList:=0;
      glDeleteLists( seleList, 1);  seleList:=0;
      glDeleteTextures(1,@texID);   texID:=0;   //释放纹理内存
      glDeleteTextures(1,@texTag);  texTag:=0;  //释放纹理内存
      end;
  Obj[0].Kind:=barPage.Max;
  Obj[0].Mode:=barPage.Position;
  setLength(Objs[Page],Num+1);
  for i:=0 to Num do Objs[Page,i]:=Obj[i]; //保存当前模型
  bEdit:= bEdit or(BackObj.undoMax>0);
  BackObjs[Page]:=BackObj; //Undo数据
  if bAdd then BreackAdd;
end;
procedure TfrmMain.ReadThisPage(Page:integer);
  var i :integer;
begin
  ObjCount:=high(Objs[Page]);   ;
  for i:=1 to maxObj do ObjNameStack[i]:=false;//清空ID表
  for i:=0 to ObjCount do begin
    Obj[i]:=Objs[Page,i]; //载入页面
    ObjNameStack[ Obj[i].Name ]:=true;
    end;
  for i:=ObjCount+1 to maxObj-1 do Obj[i]:=Obj[maxObj];
  for i:=1 to ObjCount do Obj[i].Edited:=true;
  with Obj[1]do begin
    for i:=0 to 2 do Obj[5+i].F:=(info[0][13+i]='1') or (Obj[5+i].S=0); //坐标平面边框
    pTR.x:=Obj[5].S;   pBL.x:=Obj[5].H;
    pTR.y:=Obj[6].S;   pBL.y:=Obj[6].H;
    pTR.z:=Obj[7].S;   pBL.z:=Obj[7].H;
    Origin.x:=p3.x; Origin.y:=p3.y; //坐标原点的屏幕位置
    Deep:=p4.x;  //景深
    Pers:=p4.y;  //透视度
    Mask:=info[0][18]='1';  butLock.Down:=Mask;
    end;
  BackObj:=BackObjs[Page]; //Undo数据

  barPage.Max:=Obj[0].Kind;
  barPage.Width:= barPage.Max*15+19;
  pnlShow.Width:=(barPage.Max+1)*15;   pnlShow.Visible:=false;
  Layer:=Obj[0].Mode;
  aObjShow[Layer].Font.Color:=clRed;
  barPage.Position:=Layer;
  UpDwPage.Position:=Obj[0].Kind;
  bAll:=false;  butAll.Down:=bAll;   menAll.Checked:=bAll;
  ClearSelRec(0); //清空选择队列
  
  PaintNum:=0; PaintMax:=0; PaintListNum:=0;
end;
//=================== 页控制 =================
procedure TfrmMain.popPageClick(Sender: TObject);
  var i,M,Now,t,Answer :integer;  tmpName:string;
begin
  PaintNum:=0; PaintMax:=0; PaintListNum:=0; //手绘
  if bAdd then BreackAdd;
  t:=(Sender as TComponent).Tag;
  Now:=tabPage.TabIndex; //当前页面
  bEdit:= true;
  case t of
    1:ShowTabEdit; //重命名
    2:begin //增加空白页面
      tabPage.Tabs.Add('Page'+ItoS(tabPage.Tabs.Count+1));
      tabPage.TabIndex:=tabPage.Tabs.Count-1;
      SaveThisPage(Now,ObjCount, false,true); //缓存当前页面数据
      for i:=11 to maxObj do Obj[i].Tag:='';
      Obj[0].iL:=0; Obj[0].iR:=0;  //清除自定义变换规则
      inc(maxPage); Obj[8].parent:=maxPage;
      ObjCount:=10;   backObj.MaxName:=10;
      updateTexture(false);
      backObj.UndoMax:=0; backObj.UndoID:=0;
      barPage.Max:=0;    barPage.Width:=19;
      SetProjection(false,false,16);
      ObjListUpdate(0,false); //Start(false,true);
      end;
    3:begin //复制当前页面
      tabPage.Tabs.Add('Page'+ItoS(tabPage.Tabs.Count+1));
      tabPage.TabIndex:=tabPage.Tabs.Count-1;
      SaveThisPage(Now,ObjCount, false,false); //缓存当前页面数据
      backObj.UndoMax:=0; backObj.UndoID:=0;
      inc(maxPage); Obj[8].parent:=maxPage;
      end;
    4:if OpenBox.Execute then begin //追加文件
        SaveThisPage(Now,ObjCount, false,true); //缓存当前页面数据
        OpenBox.Filter:='Solid geometry files (*.sgf)|*.sgf';
        tmpName:=OpenBox.FileName;
        M:=OpenFile(tmpName,false,true);
        if(M>10)then ObjCount:=M;
        end
      else
        exit;
    9:begin //删除当前页
      Answer:= MessageDlg(SwitchS(iLanguage,'删除的页面将不可恢复，是否删除?','刪除的頁面將不可恢復，是否刪除?',
              'Will not restore deleted pages, do you deleted?',''),
              mtCustom, [mbYes, mbNo], 0);
      if Answer=mrNo then exit;
      for i:=11 to ObjCount do with Obj[i]do begin
        if assigned(butID)then butID.Visible:=false;
        if assigned(timID)then timID.Enabled:=false;
        end;
      if(Now=tabPage.Tabs.Count-1)//若删除最后页面
        then dec(Now)
        else for i:=Now to tabPage.Tabs.Count-2 do begin
              Objs[i]:=Objs[i+1];   BackObjs[i]:=BackObjs[i+1];
              end;
      ReadThisPage(Now);
      updateTexture(false);
      tabPage.Tabs.Delete(tabPage.TabIndex);
      end;
    end;//case t
  if(t=4)and(M>10)or(t=9)then begin
    setDefault(false);
    if(ObjCount>10)then ReRelate(11, ObjCount, false,false,false );
    ObjListUpdate(11,true);
    SetProjection(false,false,0);
    end;
  menPageDelete.Enabled:= tabPage.Tabs.Count>1;
  popPageDelete.Enabled:= menPageDelete.Enabled;

  menPageNew.Enabled:=  tabPage.Tabs.Count<PageTime;
  menPageClone.Enabled:=  menPageNew.Enabled;
  menPageOpen.Enabled:=   menPageNew.Enabled;
  popPageNew.Enabled:=    menPageNew.Enabled;
  popPageClone.Enabled:=  menPageNew.Enabled;
  popPageOpen.Enabled:=   menPageNew.Enabled;
  pnlShow.Visible:=false;
end;
//============== 切换页面 ==============
procedure TfrmMain.ChangePage(OldPage,NowPage:integer);
  var i:integer;
begin
  PaintNum:=0; PaintMax:=0; PaintListNum:=0;
  SaveThisPage(NowPage,ObjCount, false,true); //保存当前页
  ReadThisPage(OldPage);                      //读入新页
  updateTexture(false);                       //刷新纹理
  ObjListUpdate(0,true);                       //刷新对象列表
  ReRelate(11, ObjCount, false,false,false ); //重新构造
  SetProjection(true,false,0);
  for i:=11 to ObjCount do
    if(Obj[i].Kind in[10,11,14])then TextAndImage(i, false,true,true,false);//刷新标签
end;
procedure TfrmMain.tabPageMouseDown(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
  var i,w, NowPage :integer;
begin
  timAuto.Enabled:=false;
  edtPage.Visible:=false;
  if(tabPage.Tabs.Count>1)then begin
    w:=5; //左边距
    NowPage:=tabPage.TabIndex;
    i:=tabPage.FirstIndex;
    repeat
      w:=w+9+tabPage.ItemWidth(i);
      inc(i);
     until(w>X)or(i>=tabPage.Tabs.Count);
    OldPage:=i-1;
    if(NowPage<>OldPage)then begin //改变页面
      ChangePage(OldPage, NowPage);
      end;
    tabPage.TabIndex:=OldPage;
    end;
  if(ssDouble in Shift)and(ssLeft in Shift)then //双击
    ShowTabEdit;
end;

procedure TfrmMain.tabPageMouseMove(Sender: TObject; Shift: TShiftState; X,Y: Integer);
  var i,w,M :integer;   st:string;
begin
  if not(ssLeft in Shift)or not(ssShift in Shift)or(tabPage.Tabs.Count=0)then exit;
  w:=9; //左边距
  i:=tabPage.FirstIndex;
    repeat
      w:=w+tabPage.ItemWidth(i)+10;
      inc(i);
     until(w>X)or(i>=tabPage.Tabs.Count);
  NewPage:=i-1;
  if(NewPage<>OldPage)then begin //改变页面顺序
    st:=tabPage.Tabs[NewPage];
    tabPage.Tabs[NewPage]:=tabPage.Tabs[OldPage];
    tabPage.Tabs[OldPage]:=st;

    M:=high(Objs[NewPage]);
    setLength(Objs[OldPage], M+1);
    for i:=0 to M do Objs[OldPage,i]:=Objs[NewPage,i];
    setLength(Objs[NewPage], ObjCount+1);
    for i:=0 to ObjCount do Objs[NewPage,i]:=Obj[i];

    tabPage.TabIndex:=NewPage;
    OldPage:=NewPage;
    end;
end;

procedure TfrmMain.edtPageChange(Sender: TObject);
  var i:integer;
begin
  i:=tabPage.TabIndex;
  tabPage.Tabs[ i]:=edtPage.Text;
  edtPage.Width:=tabPage.ItemWidth( i)+2;
  i:=edtPage.SelStart;
  edtPage.SelStart:=0;
  edtPage.SelStart:=i;
end;

procedure TfrmMain.edtPageExit(Sender: TObject);
begin
  edtPage.Visible:=false;
  Keypreview:=true;
end;

procedure TfrmMain.edtPageKeyDown(Sender: TObject; var Key: Word;  Shift: TShiftState);
begin
  if(Key in[9,13,27])then edtPage.Visible:=false;
end;
//====================== 构件复制 =======================
procedure TfrmMain.menCopyObjClick(Sender: TObject);
  var i,j,k :integer;
begin
  if MarkObj<=0 then exit;
  Clipboard.Clear;
  for i:=1 to ObjCount do with Obj[i] do Edited:=hot; //标记已选择的构件
  for i:=ObjCount DownTo 2 do //标记父构件
    with Obj[i] do if Edited then begin
      if(Kind=1)and(Mode=4)then begin //交点
        if(Link[2]>10)then Obj[Link[2]].Edited:=true; //共轭交点
        if(Link[2]= 0)then begin
          for j:=i+1 to ObjCount do with Obj[j] do
            if(Kind=1)and(Mode=4)and(Link[2]=i)then Edited:=true;
          end;
        end;
      if(Mode=13)then Obj[Link[0]].Edited:=true;//棱边
      if(Kind=6)and(Mode in[3,4,5])or(Kind=4)and(Mode=6)then begin
        for j:=i+1 to ObjCount do with Obj[j]do
          if(Kind<3)and(Mode=13)and(Link[0]=i)then Edited:=true;
        end;
      if(i>1)then for j:=0 to LinkTime do
        if not(Link[j]in[2..7])then Obj[Link[j]].Edited:=true;

      end;
  j:=0; for i:=11 to ObjCount do if Obj[i].Edited then inc(j);//统计标记构件
  setLength(CopyObj,j);
  j:=0;
  for i:=11 to ObjCount do if(Obj[i].Edited)then begin
    case i of
    1:with CopyObj[j]do begin
      for k:=0 to LinkTime do begin Link[k]:=0; LinkName[k]:=0; end;
      for k:=0 to LayerTime do begin ObjShow[k]:=i>=Layer; TagShow[k]:=cheTag.Checked and(Kind=1); end;
      Kind:=1; Mode:=1; Name:=1;
      TagP.x:=-0.6; TagP.y:=0.1; TagP.z:=0;  TagS:=7; //Tag 位置
      p0:=cgVector(1,1,0);  S:=1; W:=Obj[1].p1.x;
      U:=false; D:=false; bDown:=true;
      hide:=false; Lock:=false;
      color:=cgTColorToCGColorF( Obj[1].Link[1],1); ColorB:=Color;
      end;
    5..7:with CopyObj[j]do begin
      for k:=0 to LayerTime do begin ObjShow[k]:=i>=Layer; TagShow[k]:=cheTag.Checked and(Kind=1); end;
      Kind:=4; Mode:=3; Link[0]:=1; LinkName[0]:=1; Link[1]:=i; LinkName[1]:=i;
      S:=4; H:=0; W:=3; R:=3; L:=5;
      F:=true; D:=false; U:=false; //F边框
      TagP.z:=1; TagP.w:=1; info[0]:='';  //标签位置
      color:=cgTColorToCGColorF(Obj[1].Link[4],1); color.A:=0.4; ColorB:=Color;
      end;
    else
      CopyObj[j]:=Obj[i];
    end; //case i
    inc(j);
    end;
  menPasteObj.Enabled:=true;
end;
//===================== 粘贴对象 ========================
procedure TfrmMain.menPasteObjClick(Sender: TObject);
  var i,j,k,M,N,pos, minN,maxN :integer;  Key:word;  Shift: TShiftState;
begin
  if Clipboard.HasFormat(CF_BITMAP) then begin //复制剪贴板图片
    bC:=true;   Key:=86;
    FormKeyDown(nil, Key, Shift);
    bC:=false;  Exit;
    end;
  M:=high(CopyObj); if(M<0)then exit;
  pos:=getObjName(M+1);
  for i:=0 to M do begin
    N:=CopyObj[i].Name;
    CopyObj[i].Name:=pos+i; // backObj.maxName+i+1;
    if(M>0)then for j:=i+1 to M do
      for k:=0 to LinkTime do
        if(CopyObj[j].LinkName[k]=N)then CopyObj[j].LinkName[k]:=CopyObj[i].Name;
    end;
  ClearSelRec(0);

  for i:=0 to M do begin //添加复制的对象
    k:=ObjCount+i+1;
    if(CopyObj[i].Kind=1)and(CopyObj[i].Mode=1)then begin //将添加的自由点略作偏移
      CopyObj[i].p0.x:=CopyObj[i].p0.x+1; CopyObj[i].p0.y:=CopyObj[i].p0.y+1;
      end;
    Obj[k]:=CopyObj[i];
    with Obj[k] do begin
      mainList:=0;  maskList:=0;  wireList:=0;  seleList:=0;  tracList:=0;
      texTag:=0;    texID:=0;     hot:=true;    bMultiSel:=true;
      Tag:=getTag(k);
      end; 
    end;
  inc(ObjCount, M+1);
  upDateLink(ObjCount, true); //刷新链接

  reRelate(ObjCount-M, ObjCount, false,false,true);
  SetProjection(true,false,16);
  ObjListUpdate(0,false); //Start(false,true);
  for i:=11 to ObjCount do with Obj[i]do if(Kind in[10,11])then begin
    if(Kind=10)then texID:= TextToBMP(i,info[2],true); //GetTextList( MarkObj, info[2], Color);
    if(Kind=11)then TextAndImage(i,false,true,true, false);
    end;
  for i:=ObjCount-M to ObjCount do with Obj[i]do //Undo
    if(Kind=1)and(Mode=1)then
      if(Link[0]=0)and(Link[1]=0)and(Link[2]=0)then save(1,i,1,true,false);

  MarkObj:=ObjCount;
  menObjDel.Enabled:=true; 
end;
//================ 直接拖入图片、文件 =================
procedure TfrmMain.WMDropFiles(var Msg: TWMDropFiles);//拦截WM_DROPFILES消息
  var fName :TDropFile;
      sForm, fromFile, tmpFile :string;
      tmpData :AnsiString;
      i,M, tmpMarkObj :integer;
      Point :TPoint;
      BMP:TBitmap;  JPG:TJPEGImage;
      tmpTex :Cardinal;
      isEdit :boolean;
begin
  DragQueryFile(Msg.DROP, 0, fName, SizeOf(fName)); //拖入外部文件
  fromFile:=string(fName);  //sgfFile:=string(fName);
//  sgfName:=ExtractFileName(sgfFile);
  sForm:=ExtractFileExt(fromFile);    sForm:=UpperCase(sForm);//文件格式
  if(sForm='.SGF')then begin //拖进模型文件
    SaveThisPage(tabPage.TabIndex, ObjCount, false,true); //缓存当前页面数据
    if(ObjCount<11)and(tabPage.Tabs.Count=1)
      then M:=OpenFile(fromFile,true, false)  //OpenFile()中包含了 setDefault(false);
      else M:=OpenFile(fromFile,false, true);
    if(M>10)then begin
      ObjCount:=M;
      ReRelate(11, ObjCount, false,false,false );
      ObjListUpdate(0,false);
      SetProjection(false,false,0);
      for i:=11 to ObjCount do
        if(Obj[i].Kind in[10,11,14])then TextAndImage(i, false,true,true, false);
      end;
    exit;
    end;
  if not((sForm='.BMP')or(sForm='.JPG')or(sForm='.GIF')or(sForm='.PNG'))then exit;

  DragQueryPoint(Msg.DROP, Point);  //查询鼠标位置
  DragFinish(Msg.DROP); //结束拖拽
  with Obj[MarkObj]do
    isEdit:=(MarkObj>10)and((Kind in[4,6,7,9])or(Kind=3)and(Obj[parent].Mode<3)); //若选择了平面或曲面则贴图
  if isEdit
    then tmpMarkObj:=MarkObj
    else begin inc(ObjCount); if(ObjCount<11)then ObjCount:=11; tmpMarkObj:=ObjCount; end;

  Save( ord(not isEdit), MarkObj,1,false,true);
  if sForm='.BMP'then begin //转换为jpg格式
    tmpFile := exePath+'tmp.JPG'; //临时文件
    BMP:=TBitmap.Create;
    BMP.LoadFromFile(fromFile);
      JPG:= TJpegImage.create;
      jpg.Assign( BMP);
      jpg.CompressionQuality:=90;  //图象质量
      jpg.SaveToFile( tmpFile); //临时保存jpg图象文件
      jpg.free;
    BMP.Free;
    sForm:='.JPG';
    tmpData:= ImgToTxt(tmpMarkObj, tmpFile, sForm);
    with Obj[tmpMarkObj]do
    tmpTex:=myLoadTexture(tmpMarkObj,texID, tmpFile, nil, TagSize.x,TagSize.y, kW,kH, true );
    DeleteFile(tmpFile); //删除临时文件
    end
  else begin
    with Obj[tmpMarkObj]do
      tmpTex:=myLoadTexture(tmpMarkObj,texID, fromFile, nil, TagSize.x,TagSize.y, kW,kH, true );//D背景透明
    tmpData:= ImgToTxt(tmpMarkObj, fromFile, sForm);
    end;
  if(tmpMarkObj<>MarkObj)then begin //
    with Obj[ObjCount]do begin
      Kind:=10;       Mode:=2;  L:=1;   Hot:=true;    Tag:=getTag(MarkObj);
      Name:=getObjName(1);
      p0.x:=Point.X;  p0.y:=Point.Y+TitleHeight;
      TagScr.x:=0;    TagScr.y:=-10;    Color:=cgColorF(1,1,1,1);
      for i:= 0 to 24 do ObjShow[i]:=true;
      if(MarkObj>10)and(Obj[MarkObj].Kind=1)then begin //粘贴到点上
        p2.y:=0; w:=0; Link[9]:=MarkObj; LinkName[9]:=Obj[MarkObj].Name;
        end;
      end;
    MarkObj:=ObjCount;
    end;
  with Obj[MarkObj] do begin
    sImage.sData:=tmpData;    sImage.sFormat:=sForm;
    texID:=tmpTex;            D:=(Kind<>10);  cheMask.Checked:=D;
    Link[10]:=0;  LinkName[10]:=0; //Link[10]=0清除数值对象纹理
    if(Kind=9)then info[3]:=''else info[0]:='';  //取消与文件的关联
    end;//with  //  Color:=cgColorF(1,1,1,1); ColorB:=Color;
  Save( ord(not isEdit), MarkObj,1,true,true);
  ObjListUpdate(MarkObj,true);
  reRelate(MarkObj,MarkObj,false,true,false);
  SetProjection(true,false,8);
end;

procedure TfrmMain.menEditClick(Sender: TObject); //菜单：编辑
  var i,j,k :integer;  bb:boolean;
begin
  menPaintDel.Enabled:=(PaintMax>0);
  menUndo.Enabled:=(backObj.UndoID>0)or(PaintListNum>0);
  menRedo.Enabled:=(backObj.UndoID<backObj.UndoMax);
  menMove.Enabled:=(SelRec[0]>1)and(SelRec[1]+SelRec[11]=SelRec[0]); //移动
  menAll.Enabled:=(ObjCount>11);
  bb:=(SelRec[0]>0);
  menHide.Enabled:=bb; //隐藏/显示按钮
  j:=0; if bb then
    repeat inc(j); with Obj[SelRec[20+j]]do bb:=(Kind in[1,11])and(Mode=2);
     until(not bb)or(j>=SelRec[0]);
  menAnimation.Enabled:=bb; //动画按钮
  menSeries.Enabled:=(SelRec[14]>1); //系列按钮

  bb:=false;
  if(SelRec[0]>0)then begin j:=0; //是否有父对象
    repeat inc(j); i:=-1;
      if(Obj[j].DelID=0)and(Obj[j].Hot)then
        repeat inc(i); bb:=(Obj[j].Link[i]>0);  until(bb)or(i>=LinkTime);
     until(bb)or(j=ObjCount);
    end;
  menSelDad.Enabled:=bb; //显示父对象
  bb:=false;
  if(SelRec[0]>0)then begin j:=0; //是否有子对象
    repeat inc(j); i:=-1;
      if(Obj[j].DelID=0)and(Obj[j].Hot)then begin k:=j;
        repeat inc(k); i:=-1;
          repeat inc(i); bb:=(Obj[k].Link[i]=j);  until(bb)or(i>=LinkTime);
         until bb or(k>=ObjCount);
        end;
     until(bb)or(j>=ObjCount);
    end;
  menSelSon.Enabled:=bb; //显示子对象
  if Clipboard.HasFormat(CF_BITMAP) then menPasteObj.Enabled:=true;//粘贴图片
  if(Obj[MarkObj].Kind=14)then menObjDel.Enabled:=true;
end;

procedure TfrmMain.menViewClick(Sender: TObject); //菜单：显示
  var i:integer; 
begin
  i:=10;
  if(ObjCount>10)then
    repeat inc(i); until(not Obj[i].ObjShow[Layer])or(i=ObjCount);
  menAll.Enabled:= not Obj[i].ObjShow[Layer]and(ObjCount>10);//全选
  menObjHide.Enabled:= SelRec[0]>0;   //隐藏对象
  menTagHide.Enabled:= SelRec[0]>0; //隐藏标签
  menX.Checked:= (rX=270)and(rY=270)and(rZ=0);
  menY.Checked:= (rX=180)and(rY=270)and(rZ=0);
  menZ.Checked:= (rX=  0)and(rY=  0)and(rZ=0);
  menLock.Checked:= butLock.Down;
  men2D.Checked:= (butLock.Down)and(menZ.Checked); //是否2D状态
  i:=10;
  repeat inc(i); until(i>ObjCount)or(Obj[i].Kind in[1..5,7,17,19])and Obj[i].Trace ;
  menTraceDel.Enabled:=(i<=ObjCount); //踪迹
end;
//================== 绘制颜色菜单 ====================
procedure TfrmMain.butPaintColorEDrawItem(Sender: TObject; ACanvas: TCanvas; ARect: TRect; Selected: Boolean);
  var i,t :integer;  c0,c1 :TColor;
begin
  t:=(Sender as TComponent).Tag;
  if Selected then ACanvas.Brush.Color:= clHighlight
              else ACanvas.Brush.Color:= clMenu;
  ACanvas.FillRect(ARect);
  InflateRect(ARect, -1,-1); ARect.Left:=16;
  ACanvas.Brush.Color:=objColor[t];
  ACanvas.Rectangle(ARect.Left, ARect.Top, ARect.Right, ARect.Bottom); //色块
  c1:=-1;
  for i:=11 to ObjCount do if Obj[i].Hot then begin //判断已选对象是否相同颜色
    c0:=cgColorFToTColor(Obj[i].Color);//已选对象的颜色
    if(c1<0)then c1:=c0                //首个已选对象颜色
            else if(c1<>c0)then c1:=-1;//异色
    if(c1<0)then break;
    end;
  for i:=0 to 16 do if(c1=objColor[i])then break; //匹配菜单项颜色
  if(i<=16)then begin
    PaintColorIndex:=i;
    ACanvas.Brush.Color:=clBlack;
    if(PaintColorIndex<17)and(PaintColorIndex=t)then
      ACanvas.Rectangle(4, 12*t+3, 10, 12*t+9); // draw the mark
    end;
end;

procedure TfrmMain.butPaintColorEMeasureItem(Sender: TObject; ACanvas: TCanvas; var Width, Height: Integer);
begin
  Width:=30;  Height:=12;
end;
//================== 点击颜色菜单 ===============
procedure TfrmMain.butPaintColorFClick(Sender: TObject);
  var i,j,t :integer; cc :TcgColorF;
begin
  t:=(Sender as TComponent).Tag;
  case t of
    17:begin //非标色
      if(PaintColorIndex<17)then
        colorBox.Color:=objColor[PaintColorIndex];
      if colorBox.Execute then
        cc:=cgTColorToCGColorF(colorBox.Color, 1);
      end;
    18:begin
      ShowControlBox( MarkObj, 18, tabColor); //参数色
      exit;
      end;
    else
      cc:=cgTColorToCGColorF(objColor[t], 1); //标准色
    end;
  if(butPen.Down)then begin //手绘颜色
    PaintColorIndex:=t;  PaintColor:=cc;
    end
  else begin //构件颜色
    for i:=1 to SelRec[0] do with Obj[SelRec[20+i]] do begin
      if(Kind in[10,11,14])then begin
        TagC:=objColor[t];
             if(Kind=10)then texID:=TextToBMP(i,info[2],false)      //文本
        else if(Kind=11)then texID:=TagToBMP(i, false)        //参数
        else if(Kind=14)then butID.Font.Color:=objColor[t];//控制按纽
        end
      else begin
        Color:=cc;  ColorB:=cc; Edited:=true;
        for j:=6 to 8 do begin Link[j]:=0; LinkName[j]:=0; end;
        end;
      if(SelRec[20+i]<8)then AxisList
      end;
    reRelate(11,ObjCount,false,false,false);
    SetProjection(true,false,8);
    end;
end;
//================== 手绘形状 ===============
procedure TfrmMain.butPaintCircleClick(Sender: TObject);
  var t :integer;
begin
  t:=(Sender as TComponent).Tag;
  butPaintDel.Down:=false;
  if(t<>0)then butPaintRect.Down:=false;   //方框
  if(t<>1)then butPaintCircle.Down:=false; //椭圆
  if(t<2)and(PaintNum>0)then setPaintList(true);
  if(t=2)then begin //来自菜单“清除手绘线”
    glDeleteLists(60001,PaintListNum);
    PaintListNum:=0;    PaintMax:=0;
    menPaintDel.Enabled:=false;
    menObjDel.Enabled:= false;
    SetProjection(true,false,8);
    end;
end;
//=============== 线样式 ===================
procedure TfrmMain.menWidth9Click(Sender: TObject);
  var i,t :integer;  tmpColor:TColor;   bb:boolean;
begin
  t:=(Sender as TComponent).Tag;
  case t of
    1..5:begin //线宽
      if butPen.Down then //涂鸦
        PaintWidth:=t
      else begin
        for i:=11 to ObjCount do with Obj[i]do
          if(Hot)and(Kind in[2,3,5,15,16,17,19])then begin
            W:=t;    Edited:=true;
            end;
        end;
      end;
    7..9:begin //线型
      if butPen.Down then //涂鸦
        PaintStyle:=t-7
      else begin
        for i:=11 to ObjCount do with Obj[i]do
          if(Hot)and(Kind in[2,3,5,15,16,17,19])then begin
            S:=t-7;  Edited:=true;
            end;
        end;
      end;
    10:with pnlFont do begin //字体
      menFont.Checked:=not menFont.Checked;
      Visible:=menFont.Checked;
      pnlFont.Tag:=selRec[21];
      if Visible then setFont(pnlFont.Tag, pnlFont.Tag>0, false);
      end;
    end;
  if(t<>10)then (Sender as TMenuItem).Checked:=true;
  if not butPen.Down then begin
    reRelate(11,ObjCount,false,false,false);
    SetProjection(true,false,8);
    end;
end;
//=============== 点样式 ===================
procedure TfrmMain.menDotSize9Click(Sender: TObject);
  var i,j,t, iID :integer;
begin
  t:=(Sender as TComponent).Tag;
  for i:=11 to ObjCount do with Obj[i] do //是否交点或顶点
    if(Hot)and(Kind=1)and(Mode in[4,13])then begin
      iID:=Link[0];
      for j:=11 to ObjCount do with Obj[j]do
        if(Link[0]=iID)and(Kind=1)and(Mode in[4,13])then
          Hot:=true;
    end;
  for i:=11 to ObjCount do with Obj[i]do
    if(Hot)and(Kind=1)then begin
      if(t<6)then W:=t*2 else S:=t-6;
      Edited:=true;
    end;
  reRelate(11,ObjCount,false,false,false);
  SetProjection(true,false,8);
end;

procedure TfrmMain.butPaintDelClick(Sender: TObject);
begin
  if(PaintNum>0)then setPaintList(false);
  labHint.Visible:=not butPaintDel.Down;
end;

procedure TfrmMain.butNailClick(Sender: TObject);
begin
  bNail:=not bNail;
  butNail.NumGlyphs:=2-ord(bNail);
  if bNail then Obj[1].info[0,16]:='1' else Obj[1].info[0,16]:='0';
  Obj[8].info[0]:=Obj[1].info[0];
end;
//==================== 控制框 ======================
procedure TfrmMain.ShowControlBox( ID,butTag:integer; tabSheet :TTabSheet);
  var i,j,k,n :integer; st:string;    v0,v1 :single;
  function ItS(i:integer):string; begin str(i:3,result);end;
  procedure setConstraints(W,H, minW,minH :integer);
    begin with pnlControl do begin
      Width:=W;  Height:=H;  Constraints.MinWidth:=minW;   Constraints.MinHeight:=minH;
      end;
    end;
begin
  bC:=false; bS:=false; bA:=false;
  tabPath.TabVisible:=false;  tabText.TabVisible:=false;  tabIterate.TabVisible:=false;
  tabCalc.TabVisible:=false;  tabLabel.TabVisible:=false;
  tabFunc.TabVisible:=false;  tabPara.TabVisible:=false;  tabMove.TabVisible:=false;
  tabColor.TabVisible:=false; tabLink.TabVisible:=false;  tabAffine.TabVisible:=false;
//  setConstraints(120,140, 120,140);
  butOK.Tag:=butTag;
  if butTag=30
    then cheHide.Caption:=SwitchS(iLanguage,'显示标签','顯示標籤','Show Labels','')
    else cheHide.Caption:=SwitchS(iLanguage,'计算后关闭','計算后關閉','Close After OK','');
  KeyPreview:=false;
  Save( 0, ID,1,false,true); //保存Undo数据
  with pnlControl do
  case butTag of
    9,16:begin Left:=26; Top:=24;  //函数曲线、函数曲面
      setConstraints(550, IIFi(butCalcPad.NumGlyphs=1,166,140), 550,140);
      end;
    10:begin //文本
      memText.Font.Name:=Obj[MarkObj].TagN;
      memText.Font.Size:=Obj[MarkObj].TagS;
      memText.Font.Color:=Obj[MarkObj].TagC;
      setConstraints(380,140, 200,80);
      end;
    11:if(Obj[ID].Mode=1)
      then setConstraints(420,IIFi(butCalcPad.NumGlyphs=1,140,124), 420,120) //计算
      else setConstraints(460,120, 460,100);  //参数滑块
    13:begin //迭代规则
      setConstraints(210,120, 210,125);
      butRand.Caption:=SwitchS(iLanguage,'随 机','隨 機','Random','');
      end;
    17,141..144:setConstraints(260,150, 120,150); //路径 按钮
    146:setConstraints(440,140, 440,140);   //按钮-链接
    18:setConstraints(300,340, 300,340);    //参数颜色
    20:setConstraints(300,140, 340,140);    //次序
    30:setConstraints(300,140, 300,140);    //自动生成标签序列
    40:setConstraints(320,140, 320,140);    //仿射变换规则
    end;
  butRand.Visible:=(butTag=13);//随机(迭代)

  butCalcPad.Visible:=(butTag in[9,16])or(Obj[ID].Kind=11)and(Obj[ID].Mode=1); //小键盘切换钮
  pnlCalcPad.Visible:=butCalcPad.Visible and(butCalcPad.NumGlyphs=1);
  pagControl.Height:=pnlControl.Height- IIFi(pnlCalcPad.Visible, 53,29);

  tabSheet.TabVisible:=true;
  if(Obj[ID].Kind in[14,17])then tabPath.Caption:=stMode[Obj[ID].Kind,Obj[ID].Mode];

  cheHide.Visible:= butTag in[9,11,13,16,30,40];
  tlbCalc.Visible:=(butTag in[9,16])or(butTag=11)and(Obj[ID].Mode=1);
  pnlControl.Show;  butOK.Enabled:=true;
  with Obj[ID]do if(Kind=14)then begin
    pnlControl.Left:=butID.Left + butID.Width;
    pnlControl.Top :=butID.Top;
    end;
  case butTag of
    9,16: pnlFuncShow;//函数曲线、函数曲面
    10:begin   //文本
      memText.text:=Obj[MarkObj].info[2];    memText.SetFocus;
      butOK.Enabled:=(memText.Text>'');
      end;
    11:if(Obj[ID].Mode=1)then begin   //计算
        pnlCalcShow(ID);
        memExpr.SetFocus;
        butOK.Enabled:=(memExpr.Text>'');
        if(trim(memExpr.Text)='')then pnlResult.Caption:='?';
        bSelLink:=true;
        end
      else begin //参数轴
        cmbPara.Clear;  grdPara.RowCount:=0;
        for i:=11 to ObjCount do with Obj[i]do
          if(DelID=0)and(i<>ID)then begin
          if(Kind=1)and(Mode=2)or(Kind=3)or(Kind=6)or(Kind=17)and(Mode=2)
            or(Kind=11)and(Mode=2)or(Mode in[7,9,10,12,15])
            then cmbPara.AddItem(itos(ShowID)+'.'+stMode[kind,Mode]+' '+Tag ,nil);
        end;
        with Obj[ID]do begin //读取已有控制数据
          i:=11;
          while(i<LinkTime)and(Link[i]>10)do begin
            grdPara.RowCount:=(i-10); // 添加
            grdPara.Cells[1,i-11]:=ftos( Para[i].x,2);
            grdPara.Cells[2,i-11]:=ftos( Para[i].y,2);
            with Obj[Link[i]]do
              grdPara.Cells[3,i-11]:=itos(ShowID)+'.'+stMode[kind,Mode]+' '+Tag;
            grdPara.Cells[4,i-11]:=ftos( Para[i].z,2);
            grdPara.Cells[5,i-11]:=ftos( Para[i].w,2);
            inc(i);
            end;
          if(grdPara.Cells[1,0]='')then grdPara.Cells[1,0]:=ftos( p2.x,2);
          if(grdPara.Cells[2,0]='')then grdPara.Cells[2,0]:=ftos( p2.z,2);
          pnlControl.Height:=(i-11)*18+80;
          end;
        edtValu.Hide; cmbPara.Hide;
        end;
    13: pnlIterateShow(bAdd); //迭代
    141..145, 17: pnlPathShow(ID, bAdd); //14控制 17路径
    146:pnlCtrlShow(ID);//控制链接
    18:begin //参数颜色
      cmbColor1.Clear;
      cmbColor1.AddItem('-', nil);
      for i:=11 to ObjCount do with Obj[i] do begin
        if(DelID>0)or Hide or(Mode=13)then continue;
        if(Kind=1)and(Mode=2)or(Kind in[2,3,6,11])then
          cmbColor1.AddItem( ObjListID[ShowID].Text,nil);
        end;
      cmbColor1.ItemIndex:=0;
      cmbColor2.Items:=cmbColor1.Items; cmbColor2.ItemIndex:=0;
      cmbColor3.Items:=cmbColor1.Items; cmbColor3.ItemIndex:=0;
      if(SelRec[11]>0)then begin
        n:=0;
        for i:=1 to SelRec[0]do with Obj[SelRec[20+i]] do
          if(Kind=11)then begin
            inc(n);
            if(n=1)then cmbColor1.ItemIndex:=cmbColor1.Items.IndexOf( ObjListID[ShowID].Text );
            if(n=2)then cmbColor2.ItemIndex:=cmbColor2.Items.IndexOf( ObjListID[ShowID].Text );
            if(n=3)then cmbColor3.ItemIndex:=cmbColor3.Items.IndexOf( ObjListID[ShowID].Text );
            end;
        cmbColor2.Enabled:=n=3;  cmbColor3.Enabled:=n=3;
        radColor.Checked:=true;  //激活 radGrayClick();
        end
      else with Obj[MarkObj]do begin
        if(Kind=13)then begin //迭代
          Link[6]:=trunc(Vec.x);  Link[7]:=trunc(Vec.y);  Link[8]:=trunc(Vec.z);
          end;
        if(Link[6]>10)then cmbColor1.ItemIndex:=cmbColor1.Items.IndexOf( ObjListID[Obj[Link[6]].ShowID].Text );
        if(Link[7]>10)then cmbColor2.ItemIndex:=cmbColor2.Items.IndexOf( ObjListID[Obj[Link[7]].ShowID].Text );
        if(Link[8]>10)then cmbColor3.ItemIndex:=cmbColor3.Items.IndexOf( ObjListID[Obj[Link[8]].ShowID].Text );
        cmbColor2.Enabled:=cmbColor1.ItemIndex>0;
        cmbColor3.Enabled:=cmbColor2.ItemIndex>0;
        end;
      with Obj[MarkObj] do begin
        edtColorV0.Text:=IIFs(ColorV0<>0, FtoS(ColorV0,2), '0.0');
        edtColorV1.Text:=IIFs(ColorV1<>0, FtoS(ColorV1,2), '1.0');
        j:=ColorMode div 3; k:=ColorMode Mod 3;
        radColor.Checked:=(j=0);  radGray.Checked:=(j=1);   radLight.Checked:=(j=2);
        radNoWay.Checked:=(k=0);  radOneWay.Checked:=(k=1); radTwoWay.Checked:=(k=2);
        end;
      end;
    20:begin //次序
      end;
    30:begin  //自动生成标签序列
      edtLabel.Text:=Obj[SelRec[21]].Tag;
      edtLabelChange(nil);
      pnlControl.Refresh;
      edtLabel.SetFocus;
      end;
    40:begin //仿射变换规则
      for i:=0 to 11 do Obj[1000].Value[i]:=Obj[ID].Value[i];
      for i:=0 to 28 do Obj[1000].Link[i]:=Obj[ID].Link[i];
      for i:=0 to 28 do Obj[1000].LinkName[i]:=Obj[ID].LinkName[i]; //临时备份
      for k:=0 to 2 do for j:=0 to 3 do with Obj[ID]do begin
        i:=k*4+j;
        if(Link[i+16]>10)then txtArray[8,i].Text:=Obj[Link[i+16]].Tag
                         else txtArray[8,i].Text:=fTrim(Value[i]);
        end;
      HotText:=txtArray[8,0];  HotText.SetFocus;
      bSelLink:=true;
      end;
    end;
  pnlControl.BringToFront;
end;

procedure TfrmMain.pnlControlMouseDown(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
  ReleaseCapture;
  SendMessage(pnlControl.Handle, WM_SYSCOMMAND, $f012,0);
  x0:=x; y0:=y;
end;

procedure TfrmMain.pnlControlMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
begin
  if not(ssLeft in Shift)then exit;
  if ssShift in Shift then
    pnlControl.width:=pnlControl.width+ x-x0; //
  x0:=x; y0:=y;
end;

procedure TfrmMain.imgDragMouseDown(Sender: TObject; Button: TMouseButton;Shift: TShiftState; X, Y: Integer);
begin
//  if((Sender as TComponent).Tag=2)and not(ssShift in Shift)then begin //对象列表
//    ReleaseCapture;
//    SendMessage(pnlObjList.Handle, WM_SYSCOMMAND, $f012,0);
//    end;
  x0:=x; y0:=y;
end;

procedure TfrmMain.imgDragMouseMove(Sender: TObject; Shift: TShiftState; X,Y: Integer);
begin
  if not(ssLeft in Shift)then exit;
  if(Sender as TComponent).Tag=1 then //对象列表
    with pnlControl do begin
      Width:=Width+x-x0;
      Height:= Height+y-y0;
      if tabLabel.Visible  then edtLabelChange(nil); //批量修改标签
      Refresh;
      end;
end;
//===================== 参数滑竿 ====================
procedure TfrmMain.DrawParaBar( ID, p:integer; isDrag,isLocus:boolean);
  var a,i,j, cID,iID :integer;  kL:single;
      pos:TcgVector;
      inArea :array[0..LinkTime]of boolean;
  const Vct:array[0..2]of TPoint=((x:0; y:0),(x:0; y:8),(x:9; y:4));
begin
 if not isLocus then with Obj[ID].imgID do begin //
    Canvas.Pen.Color:= varScreen.Color;  //边框色 clRed;// 
    Canvas.Brush.Color:= varScreen.Color;//填充色 clBlue;//
    Canvas.Rectangle(0,0,Width,Height); //填充背景色

    Canvas.Pen.Color:=cgColorFToTColor(Obj[ID].Color);//
    if Canvas.Pen.Color=frmMain.Color then Canvas.Pen.Color:=frmMain.Color xor $FFFF;

    Canvas.Brush.Color:=Canvas.Pen.Color;
    Canvas.RoundRect(varBlockPos, 2, Width, 7, 2,2); //滑竿

    Canvas.Pen.Color:=cgColorFToTColor(Obj[ID].ColorB);//clRed;
    if Canvas.Pen.Color=frmMain.Color then Canvas.Pen.Color:=frmMain.Color xor $FFFF;
    Canvas.Brush.Color:=Canvas.Pen.Color;
    with Obj[ID]do
      p:= trunc((L-p2.x)/(p2.z-p2.x) *maxTrace)+ varBlockPos;
    if(p<varBlockPos)then p:=varBlockPos;  if(p>(Width-8))then p:=Width-8;
    Canvas.RoundRect(p,0,p+8, 9, 2,2); //滑块
    if Obj[ID].Q then begin
      if Obj[ID].U //动画
        then begin Canvas.Rectangle(1,0, 4,9);  Canvas.Rectangle(6,0, 9,9); end //暂停
        else Canvas.Polygon(Vct); //启动
      end;
    end; //with Obj[ID].imgID
  iID:=ID;
  if isDrag then with Obj[ID]do begin
    for i:=0 to LinkTime do inArea[i]:=true;
    i:=11;  cID:=0;
    while(Link[i]>10)and(i<LinkTime)do begin
      a:=Link[i];  pos:=Para[i];  if(a<iID)then iID:=a;
      if(L>=pos.X)and(L<=pos.Y)then begin //cID:=a;   //当前值涉及的对象
        for j:=11 to LinkTime do if(Link[j]=a)then inArea[j]:=false;
        kL:= pos.Z + (pos.W-pos.Z)*(L-pos.X)/(pos.Y-pos.X);
        if(Obj[a].Mode in[7,9,10,12])or(Obj[a].Kind=17)and(Obj[a].Mode=2)
          then Obj[a].R:=kL
          else Obj[a].L:=kL;
        Obj[a].Edited:=true;  Obj[iID].Edited:=true;
        end;
      inc(i);
      end;
    i:=11;
    while(Link[i]>10)and(i<LinkTime)do begin //
      if(inArea[i])then begin
        a:=Link[i];  pos:=Para[i];  if(a<iID)then iID:=a;
        if(L<pos.X)then kL:=pos.Z;
        if(L>pos.Y)then kL:=pos.W;
        if(Obj[a].Mode in[7,9,10,12])or(Obj[a].Kind=17)and(Obj[a].Mode=2)
          then Obj[a].R:=kL
          else Obj[a].L:=kL;
        Obj[a].Edited:=true;  Obj[iID].Edited:=true;
        end;
      inc(i);
      end;   
    if not isLocus then begin
      reRelate( iID, ObjCount,false,false,false );
      SetProjection( true, false,8);
      end;
    end;//with Obj[ID]
end;

procedure TfrmMain.setBarTrack(ID:integer);
begin
  with Obj[ID]do begin
    butID.Left:=trunc(p0.x +TagP.X -varBlockPos); //
    butID.Top :=trunc(p0.y +TagP.y) -(Height-ClientHeight); //    butID.Top:=trunc(p0.y)-26;
    butID.Width:=maxTrace +8 +varBlockPos; //
    imgID.Width:=butID.Width;
    DrawParaBar(ID, 0,true,false);
    end;
end;
//================ 参数滑竿 ==================
procedure TfrmMain.createParaBar( ID:integer; New:boolean);//创建参数轴
begin //
  with Obj[ID]do begin
  parent:=ID;
  if not Assigned(butID) then butID:=TPanel.Create(self); //新建参数轴
  with butID do begin
    Left:=trunc(p0.x +TagP.X -varBlockPos); //  -26;//
    Top :=trunc(p0.y +TagP.Y) -(frmMain.Height - frmMain.ClientHeight);
    Width:=maxTrace +8 +varBlockPos ;    Height:=9;
    Parent:=frmMain;      Tag:= ID;  //Cursor:=crHandPoint;
    BorderStyle:=bsNone;  BevelOuter:=bvNone;
    Color:=varScreen.Color;
    Visible:=true;
    end;
  if not Assigned(imgID)and Assigned(butID) then  //新建图片
    imgID:=TImage.Create(self);
  with imgID do begin
    Parent:=butID;   Tag:= ID;    //Angle动画频率  Align:=alClient;//
    Left:=0;  Width:=620; Top:=0;   Height:=butID.Height;
      Canvas.Rectangle(0,0,Width,Height); //填充背景色
    Width:=butID.Width;
    Visible:=true;
    OnMouseDown:=imgParaMouseDown;
    OnMouseMove:=imgParaMouseMove;
    OnMouseUp:=imgParaMouseUp;
    OnDblClick:=imgParaDblClick;
    Cursor:=crDefault;
    end;
  butID.Visible:=(Trace and ObjShow[Layer] );
  end; //with Obj[ID]
end;

procedure TfrmMain.timVarTimer( Sender: TObject);    //參數動畫
  var iID :integer;
begin
  iID:= (Sender as TComponent).Tag;
  if EP( Obj[iID].H) then exit;
  MovePoint( iID, false,false);
  DrawParaBar( iID, 0,true,false);
end;


procedure TfrmMain.imgParaMouseDown(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
  var ID :integer;
  procedure hintShow(st:string);
    begin labHint.Caption:=st; labHint.top:=25;  end;
begin
  ID:=(Sender as TComponent).Tag;
  if(bSelLink)and(MarkObj>10)then begin //选择关联构件
    setObjLink(MarkObj,ID, Obj[ID].Tag);
    if(MarkObj<ID)then ChangeObjID(MarkObj,ID);
    bSelLink:=true;
    exit;
    end;
  x0:=X;  y0:=Y; moveX:=0;
  bL:= ssLeft in Shift; //if bL and not Obj[ID].Q then exit;
  bR:=ssRight in Shift;
  if bMove and(bL)then bDown:=true;
  MarkObj:=ID;
  if(bL)and( (X<=varBlockPos)and Obj[ID].Q or (X=-1)) //x=-1系由勾选'动画'属性时设置
    then with Obj[MarkObj] do begin //Q 滑竿左边显示动画钮
    U:=not U;  cheColor.Checked:=U;  //動畫  Obj[ID].Q and
    DrawParaBar(MarkObj, 0,false,false);
    if U then begin
      if not Assigned(timID) then timID:=TTimer.Create(self);
      with timID do begin
        if EP(Angle)then Interval:=0 else Interval:=trunc(1000/Angle);
        Tag:=MarkObj;
        OnTimer:=timVarTimer;  //參數动画
        Enabled:=true;
        end;
      end
    else
      if Assigned(timID) then timID.Enabled:=false;
    bDown:=false;
    exit;
    end;
  if not Obj[MarkObj].Hot then
    ObjSelected(MarkObj, false,false,true,false);
  butProp.Down:=bNail or bR;
  ShowObjProp(MarkObj, 0,0, false,bR);  //显示构件属性框
  if(ssLeft in Shift)and cheHint.Checked and not bMove then begin
    labHint.Caption:=SwitchS(iLanguage,' 双击以编辑控制规则... ',' 雙擊以編輯控制規則... ','Double click to edit control rules ',' ');
    labHint.top:=25;
    end;
end;

procedure TfrmMain.imgParaMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
  var a,i,j,ID,cID,iID,p :integer;   k :single;  isHit:boolean;
begin
  if EP(X-moveX)then exit; //无位移则退出
  moveX:=X;
  ID:= (Sender as TComponent).Tag;
  if bSelLink then begin Obj[ID].butID.Cursor:=9; exit; end;
  with Obj[ID]do begin
  if(Kind<>11)or(Mode<>2)then exit;
  isHit :=false;
  if(bS)then
    butID.Cursor:=crSizeWE
  else begin
    if(X<= varBlockPos)then begin //动画
      if Q then butID.Cursor:=crHandPoint;
      end
    else begin
      p:=trunc((L-p2.x)/(p2.z-p2.x)*maxTrace + 4+ varBlockPos);  //p2.x起值 p2.z终值
      isHit:=(X>(p-6))and(X<(p+6)); //鼠标是否在滑块内
      if(isHit)then butID.Cursor:=crHandPoint else butID.Cursor:=9;
      end;
    end;
  bMove:=isHit;

  if not(bL or bR)then exit;//

  if(bDown)and bL and not(bS or bR)then begin //拖动滑块
    L:= p2.x + (p2.z-p2.x) * (X-4-varBlockPos)/(maxTrace); //p2.x起值 p2.z终值
    if(L<p2.x)then L:=p2.x;   if(L>p2.z)then L:=p2.z;
    k:=IntPower(10, S); L:=trunc(L*k)/k;//S 值精度
    if bC and(H<>0)then begin //黏附到步长整数倍
      k:=abs(H); p:=trunc((L-p2.x+k/2)/k);   L:=p2.x+ p*k;
      end;
    if pnlProp.Visible then begin varL.Caption:=ftos(L,4); varL.Refresh; end;
    Obj[ID].Edited:=true;  iID:=ID;
    DrawParaBar(ID, 0,true,false);
    end;
  if bL and not(Lock or bC or bS or bDown)and(X>varBlockPos)then begin //移动滑杆
    p0.x:=p0.x+X-x0;   butID.Left:=trunc(p0.x +TagP.X- varBlockPos); //
    p0.y:=p0.y+Y-y0;   butID.Top :=trunc(p0.y +TagP.Y)-(Height-ClientHeight); // 26;//
    TextAndImage(ID,false,true,false, false);
    end;
  if bS and bL and not bR then begin //拉伸滑杆
    maxTrace:=maxTrace +X-x0; //参数轴长度
    if maxTrace<50 then maxTrace:=50;  if maxTrace>600 then maxTrace:=600;
    butID.Width:=maxTrace+8+ varBlockPos;  //
    imgID.Width:=maxTrace+8+ varBlockPos;
    DrawParaBar(ID, 0, false,false);
    varTrace.Caption:=itos(maxTrace);
    x0:=X;
    end;
  butID.Refresh;
  end;//with
end;

procedure TfrmMain.imgParaMouseUp(Sender :TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
  if bSelLink then begin bSelLink:=false; exit; end;
  labHint.Top:=-20;
  bL:=false; bR:=false;
  bDown:=false; bMove:=false;
//    setBarTrack(MarkObj);
end;

procedure TfrmMain.imgParaDblClick(Sender :TObject);
begin
  ShowControlBox( MarkObj, 11, tabPara);
end;

procedure TfrmMain.cmbParaSelect(Sender: TObject);
begin
  grdPara.Cells[3,grdPara.Row]:=cmbPara.items[cmbPara.ItemIndex];
  cmbPara.Hide;
end;

procedure TfrmMain.butParaAddClick(Sender: TObject);
  var i:integer;  n,v,v0,v1 :single;
begin
  v:=Obj[MarkObj].p2.z;//参数终值
  case(Sender as TComponent).Tag of
    1:with grdPara do begin // 添加
      RowCount:=RowCount+1;
      if(Cells[2,RowCount-2]>'')and(StrToFloat(Cells[2,RowCount-2])<v)
        then Cells[1,RowCount-1]:=Cells[2,RowCount-2]
        else Cells[1,RowCount-1]:=Cells[1,RowCount-2];
      Cells[2,RowCount-1]:=ftos(v,2);
      Cells[4,RowCount-1]:=Cells[4,RowCount-2];
      Cells[5,RowCount-1]:=Cells[5,RowCount-2];
      pnlControl.Height:=RowCount*18+80;
      end;
    2:begin // 删除
      if(grdPara.RowCount>1)then
        grdPara.RowCount:=grdPara.RowCount-1 
      else
        for i:=1 to 5 do grdPara.Cells[i,0]:='';
      end;
    end;
end;

procedure TfrmMain.grdParaSelectCell(Sender: TObject; ACol, ARow: Integer; var CanSelect: Boolean);
  var i,h :integer;   s:string;
begin
  cmbPara.Visible:=(aCol=3);
  edtValu.Visible:=(aCol<>3);
  if(aCol=3)then begin
    i:=-1;
    repeat inc(i);
      until(grdPara.Cells[3,aRow]=cmbPara.items[i])or(i>=cmbPara.Items.Count);
    cmbPara.ItemIndex:=i;
    cmbPara.Top:=grdPara.Top + 18*(aRow-grdPara.TopRow) + 1;
    end
  else begin
    edtValu.Top:=grdPara.Top + 18*(aRow-grdPara.TopRow) +3;
    i:=(aCol-1)*43+12; if(aCol>3)then i:=i+115;
    edtValu.Left:=grdPara.Left+ i;
    edtValu.Text:= grdPara.Cells[aCol, aRow];
    edtValu.SetFocus;
    end;
end;

procedure TfrmMain.edtValuExit(Sender: TObject);
begin
  grdPara.Cells[grdPara.Col, grdPara.Row]:= edtValu.Text;
  edtValu.Text:='';
  edtValu.Hide;
end;

procedure TfrmMain.grdParaOK( ID:integer);
  var i,j,p,n :integer;  s :string;
  function StoF(s :string):Single;
    begin if(s='')then result:=0 else result:=StrToFloat(s);  end;
begin
  CleanLink(ID,11); // for i:=11 to LinkTime do begin Obj[ID].Link[i]:=0; Obj[ID].LinkName[i]:=0; end;
  for i:=0 to grdPara.RowCount-1 do begin
    if(grdPara.Cells[3,i]='')then Break;
    p:=pos('.',grdPara.Cells[3,i]);
    j:= StrToInt( copy( grdPara.Cells[3,i], 1, p-1));
    n:=10; repeat inc(n); until(Obj[n].DelID=0)and(Obj[n].ShowID=j)or(n>ObjCount);
    with Obj[ID]do begin
      Link[11+i]:=n; LinkName[11+i]:=Obj[n].Name;
      Para[11+i].x:= StoF(grdPara.Cells[1,i]);
      Para[11+i].y:= StoF(grdPara.Cells[2,i]);
      Para[11+i].z:= StoF(grdPara.Cells[4,i]);
      Para[11+i].w:= StoF(grdPara.Cells[5,i]);
      end;
    end;
  if cheHide.Checked then pnlControl.Hide;
end;

procedure TfrmMain.menLabelClick(Sender: TObject);
begin
  ShowControlBox( MarkObj, 30, tabLabel);
end;
//===================== 批量设置标签 ======================
procedure TfrmMain.edtLabelChange(Sender: TObject);
  var i,j,k,n, Len,xPos,yPos, nPos, Count :integer;    noCode,bb:boolean;
      st, aStr :AnsiString;
  function NextSt(st:string):string;
    var i,Len,Num :integer; ch:char;
  begin //
    Len:=Length(st); //字串长
    ch:=st[Len];     //最后一个字符
    if(ch in['0'..'9'])then begin //尾字符为数字
      i:=Len; repeat dec(i); until(i=0)or not(st[i]in['0'..'9']);
      Num:=StrToInt(copy(st,i+1,Len-i));
      st:=copy(st,1,i);
      inc(Num);
      result:=st+IntToStr(Num);
      end
    else begin
      if not(ch in['a'..'y','A'..'Y'])then result:=st+'1'
      else begin
        inc(ch);
        if(Len>1)then result:=copy(st,1,Len-1)+ch
                 else result:=ch;
        end;
      end;
  end;
begin //
  st:=trim(edtLabel.Text);
  butOK.Enabled:=(st>'')and(st<>'\');
  if not butOK.Enabled then exit;
  Count:=selRec[0]-1;   if(Count<5)then Count:=5;
  setLength(stArray, Count+1);

  Len:=Length(st);
  stArray[0]:=st;
  nPos:=Pos('\',st);  xPos:=0;  //批量标志符 不显示
  if(nPos>0)then
    stArray[0]:=copy( st,1,nPos-1)
  else begin
    if(st[Len]in[']','}'])then xPos:=Len;
    if(xPos>0)then stArray[0]:=copy( st,1,xPos-1);
    end;
  for i:=1 to Count do stArray[i]:=NextSt(stArray[i-1]);//替换末尾字符
  if(nPos>0)then
    for i:=0 to Count do stArray[i]:=stArray[i]+ copy(st,nPos+1,Len-nPos) //合并'\'字符前后字串
  else if(xPos>0)then
    for i:=0 to Count do stArray[i]:=stArray[i]+ copy(st,xPos,1);//合并尾字串

  imgLabel.Canvas.Font.Size:=12;
  imgLabel.Canvas.Font.Name:='Arial';
  imgLabel.Canvas.Rectangle(2,2, imgLabel.Width, imgLabel.Height);
  xPos:=10;
  for k:=0 to 4 do begin
    Len:=Length(stArray[k]);
    j:=1;  yPos:=8;  imgLabel.Canvas.Font.Size:=12;
    repeat
      if(stArray[k,j]in['[','{','_','^'])then begin
        if(stArray[k,j] in['{','^'])then yPos:=4;  // 上标
        if(stArray[k,j] in['[','_'])then yPos:=14; // 下标
        inc(j);   imgLabel.Canvas.Font.Size:=9;
        end;
      if(stArray[k,j]in[']','}'])then begin
        inc(j);   imgLabel.Canvas.Font.Size:=12;  yPos:=8;
        end;
      i:=j; n:=0;
      repeat
        bb:=(stArray[k,i]in['_','[','{', '^',']','}'])or(i>Len);
        inc(i);  if not bb then inc(n);
        until bb or(i>Len);

      aStr:= copy( stArray[k],j,n);
      if(j<=Len)then begin
        imgLabel.Canvas.TextOut(xPos, yPos, aStr);
        xPos:=xPos +imgLabel.Canvas.TextWidth( aStr);
        end;
      j:=j+n;
      until(j>Len);
    xPos:=xPos+20;
    end;
end;
//=============== 参数颜色 ===================
procedure TfrmMain.radGrayClick(Sender: TObject);
  var W,H, H0,H1 :integer;  color0,color1 :TColor;
begin
  W:=imgColor.Width;  H:=18;
  H0:=IIFi(radGray.Checked, 5, 1);
  H1:=IIFi(radGray.Checked, 7, 3);
  if radGray.Checked then color0:=$000000 else color0:=$4444FF;
  if radGray.Checked then color1:=$FFFFFF else color1:=$0000FF;
      imgColorR.Canvas.Brush.Color:=color0;
      imgColorR.Canvas.Rectangle( 0,0, 252, 18);
      imgColorG.Canvas.Rectangle( 0,0, 252, 18);
      imgColorB.Canvas.Rectangle( 0,0, 252, 18);
      imgColorR.Canvas.CopyRect( Rect(W-1,1, 2*W+1,H-1),
                imgColor.Canvas, Rect( 0,H0, W, H1 )); //复制图像
      imgColorR.Canvas.Brush.Color:=color1;
      imgColorR.Canvas.Rectangle(2*W-1, 0, 3*W, H);

      imgColorG.Canvas.CopyRect( Rect( 0, 1, W, H-1 ),
                imgColor.Canvas, Rect( 0,H0, W, H1 )); //复制图像
      imgColorG.Canvas.CopyRect( Rect(W-1,1, 2*W+1,H-1),
                imgColor.Canvas, Rect( 0,H0, W, H1 )); //复制图像
      imgColorG.Canvas.CopyRect( Rect(2*W,1,3*W,H-1 ),
                imgColor.Canvas, Rect( 0,H0, W, H1 )); //复制图像

      imgColorB.Canvas.CopyRect( Rect(W-1, 1,-1, H-1 ),
                imgColor.Canvas, Rect( 0,H0, W, H1 )); //复制图像
      imgColorB.Canvas.CopyRect( Rect(W-1,1, 2*W+1,H-1),
                imgColor.Canvas, Rect( 0,H0, W, H1 )); //复制图像
      imgColorB.Canvas.CopyRect( Rect(3*W-1,1,2*W-1,H-1),
                imgColor.Canvas, Rect( 0,H0, W, H1 )); //复制图像
end;

procedure TfrmMain.cmbColor3Change(Sender: TObject);
begin
  if(cmbColor1.ItemIndex=0)then cmbColor2.ItemIndex:=0;
  if(cmbColor2.ItemIndex=0)then cmbColor3.ItemIndex:=0;
  cmbColor2.Enabled:= cmbColor1.ItemIndex>0;
  cmbColor3.Enabled:= cmbColor2.ItemIndex>0;
  radLight.Enabled:=  cmbColor3.ItemIndex>0;
  if radLight.Checked and(cmbColor3.ItemIndex=0)then radColor.Checked:=true;
end;
//============== 面向指定平面 ===============
//Ctrl+Q 设定视角
//Q 恢复视角
procedure TfrmMain.menXYZClick(Sender: TObject);
  var t:integer;  tmpVec:TcgVector;
begin
  t:=(Sender as TComponent).Tag; //t=87设定视角 86恢复视角
  timSpin.Enabled:=false; butSpin.Down:=false;
  rX0:=rX;    rY0:=rY;    rZ0:=rZ;
  rX1:=rX2;   rY1:=rY2;   rZ1:=rZ2;
  if(t=87)then begin //t=87设定视角
    rX2:=rX;   rY2:=rY;   rZ2:=rZ;
    exit;
    end; 
  with Obj[MarkObj]do if(Kind in[1,2,3,4,6,19])then begin
    tmpVec:=Vec; if(Kind=1)then begin tmpVec:=p0; cgNormalize(tmpVec); end;
    if menViewer.Checked then cgInvertVec(tmpVec);
    if EP(tmpVec.x)and EP(tmpVec.y)
      then begin rX1:=0; rY1:=0; end
    else if EP(tmpVec.x)and not EP(tmpVec.y)
      then rX1:=IIFi(tmpVec.y>0,180,0)
    else if EP(tmpVec.y)and not EP(tmpVec.x)
      then rX1:=IIFi(tmpVec.x>0,270,90)
    else rX1:=IIFi(tmpVec.x>0,270,90)-arcTan(tmpVec.y/tmpVec.x)*180/Pi;
    rY1:=-arcCos(tmpVec.z)*180/Pi;
    rZ1:=0;
    menViewer.Checked:=not menViewer.Checked;
    end;
  FlashSize:=0;
  timSpin.Enabled:=true;
end;
//============= 计算器键盘 ==============
procedure TfrmMain.butCalc7Click(Sender: TObject);
  var i,t,Len,Pos :integer;   txt:string;  bb:boolean;
  HotLable:TBoundLabel;
  const st='0123456789.+-*/^(),';
begin
  t:=(Sender as TComponent).Tag;
  if memExpr.Focused then Pos:=memExpr.SelStart;
  if hotEdit.Focused then Pos:=hotEdit.SelStart;
  if(t=99)then begin //BackSpace
    if memExpr.Focused then txt:=memExpr.Text;
    if hotEdit.Focused then txt:=hotEdit.Text;
    Len:=length(txt);
    if memExpr.Focused then begin
      memExpr.Text:=copy(txt,1,Pos-1) + copy(txt,Pos+1,Len-Pos);
      memExpr.SelStart:=Pos-1;
      end;
    if hotEdit.Focused then begin
      hotEdit.Text:=copy(txt,1,Pos-1) + copy(txt,Pos+1,Len-Pos);
      hotEdit.SelStart:=Pos-1;
      end;
    end
  else if(t=100)then begin //打开/关闭小键盘
    butCalcPad.NumGlyphs:=3-butCalcPad.NumGlyphs;
    bb:=butCalcPad.NumGlyphs=1;
    pnlControl.Height:=pnlControl.Height+ IIFi(bb,23,-23);
    pagControl.Height:=pagControl.Height+ IIFi(bb,-23,23);
    pnlCalcPad.Visible:=bb;
    tlbCalc.Left:=butOK.Left + IIFi(bb,0,-60);
    tlbCalc.Top:=butOK.Top - IIFi(bb, 25,2);
    end
  else begin  //小键盘
    if memExpr.Focused then begin //计算框
      memExpr.Text:=insExpr( st[t+1], memExpr.Text, Pos, Len );
      memExpr.SelStart:=Len-1;
      end;
    if hotEdit.Focused and(hotEdit.Tag<3)then begin //函数框
      if(t in[21..29])then begin
        HotLable:=(Sender as TBoundLabel);
        txt:=copy(HotLable.Caption,1,1);
        end
      else
        txt:=st[t+1];
      hotEdit.Text:=insExpr( txt, hotEdit.Text, Pos, Len );
      hotEdit.SelStart:=Len-1;
      end;
    end;
end;

procedure TfrmMain.butPathResumeClick(Sender: TObject);
  var i,n, Num,Len,t,Pos :integer; st:string;
begin  //按钮、路径、三视图
  t:=(Sender as TComponent).Tag;
  with Obj[ MarkObj] do begin
  Num:=lstPath.Count-1;   Pos:=lstPath.ItemIndex;
  case t of
    1:begin //恢复原路径
      for i:=0 to LinkTime do Link[i]:=0;
      Len:=Length(info[0]);
      Num:=(Len div 3)-1;
      for i:=0 to Num do Link[i]:=StrToInt(copy(info[0], i*3+1, 3));
      for i:=0 to Num do LinkName[i]:=Obj[Link[i]].Name;
      pnlPathShow(MarkObj, false);
      Pos:=lstPath.Count-1;
      end;
    2:begin //移出  
      lstPath.DeleteSelected;
      n:=0; if(Kind=17)and(Mode=2)then n:=1; //n=1三视图
      if Pos<=Num then begin
        for i:=Pos to Num do begin
          Link[i+n]:=Link[i+n+1];   LinkName[i+n]:=LinkName[i+n+1];
          end;
        end;
      Link[Num+n]:=0;  LinkName[Num+n]:=0;
      Pos:=lstPath.Count-1;
      end;
    3:begin //前移路径点
      SwapI(Link[Pos],Link[Pos-1]);
      SwapI(LinkName[Pos],LinkName[Pos-1]);
      st:=lstPath.Items[Pos];
      lstPath.Items[Pos]:=lstPath.Items[Pos-1];
      Dec(Pos);
      lstPath.Items[Pos]:=st;
      end;
    4:begin //后移路径点
      SwapI(Link[Pos],Link[Pos+1]);
      SwapI(LinkName[Pos],LinkName[Pos+1]);
      st:=lstPath.Items[Pos];
      lstPath.Items[Pos]:=lstPath.Items[Pos+1];
      Inc(Pos);
      lstPath.Items[Pos]:=st;
      end;
    end;
  end;
  lstPath.ItemIndex:=Pos;
  butPathU.Enabled:=(Pos>0);
  butPathD.Enabled:=(Pos<lstPath.Count-1);
  butPathDel.Enabled:=(lstPath.Count>1);
  butPathResume.Enabled:=(t>1);
  butOK.Enabled:=true;
  reRelate(MarkObj,ObjCount,false,false,false);
  SetProjection(true,false,8);
end;

procedure TfrmMain.lstPathExit(Sender: TObject);
begin
  bSelLink:=false;
end;

procedure TfrmMain.cmbPageChange(Sender: TObject);
  var i,j,p,n,k :integer;
begin
  p:=cmbPage.ItemIndex;
  cmbButton.Clear;
  cmbButton.AddItem( SwitchS(iLanguage,'(无)','(無)','(None)',''), nil);
  cmbButton.ItemIndex:=0;
  if(p<0)then exit;
  if(p=tabPage.TabIndex)then begin
    for i:=0 to cmbPage.Items.Count-1 do
      if(Objs[i,8].parent=Obj[MarkObj].S)then cmbPage.ItemIndex:=i; //parent页名
    end
  else begin
    n:=high(Objs[p]); j:=0; k:=0;
    for i:=11 to n do
      if(Objs[p,i].Kind=14)and(Objs[p,i].Mode<6)then begin
        cmbButton.AddItem( Objs[p,i].Tag, nil);
        inc(j); Obj[MarkObj].LinkName[j]:=Objs[p,i].Name;
        if(Obj[MarkObj].maxTrace=Objs[p,i].Name)then k:=j; //当前按钮
        end;
    cmbButton.ItemIndex:=k;
    end;

end;

procedure TfrmMain.butLinkFileClick(Sender: TObject);
begin
  OpenBox.InitialDir :=sgfPath;
  OpenBox.Filter:='All (*.*)';
  if OpenBox.Execute then //打开文件框
    edtLink.Text:=OpenBox.FileName;
end;

procedure TfrmMain.menTraceClick(Sender: TObject); //菜单 踪迹/清除
  var i :integer; Key :Word;
begin
  case (Sender as TComponent).Tag of
  0:if(SelRec[0]>0)and(ObjCount>10)then //设置踪迹
    for i:=11 to ObjCount do with Obj[i]do
      if(Kind in[1..5,7,17,19])and Hot then Trace:=not Trace;
  1:begin Key:=27; FormKeyDown(nil, Key, []); end; //清除踪迹
  end;
end;
//================== 截面菜单 ===================
procedure TfrmMain.cheCutterClickCheck(Sender: TObject);
  var i,j :integer;
begin
  with Obj[MarkObj]do begin
  i:=cheCutter.ItemIndex;
  if cheCutter.State[i]=cbUnChecked then Cutter[i,2]:=0;
  if cheCutter.State[i]=cbChecked  then Cutter[i,2]:=1;
  if cheCutter.State[i]=cbGrayed  then Cutter[i,2]:=2;
  if(Kind=6)and(Mode>2)then begin
    getEdges( MarkObj, i,j); //j棱边数 k顶点数
    for j:=1 to i do Obj[MarkObj+j].Cutter:=Cutter;//为棱边设置截面
    end;
  if Q then SetProjection(false,false,8);
  end; //with
end;

procedure TfrmMain.cheCutterMouseDown(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
  var i:integer; itm:TMenuItem;
begin //往截面菜单里添加平面
  if Button<>mbRight then exit; //按下右键
  posEdit.Tag:=0;
  AddItem( MarkObj,4,true,cheCutter.ItemIndex>=0,false);
  for i:=5 to ObjCount do with Obj[i] do
    if(Obj[i].DelID=0)and(not Hide)and not(i in[8..10])and(Kind=4)and(i<>MarkObj)then
      AddItem( i,4,false,false,false);
end;
{======================= 设置字体 =======================}
function getColorIndex( col:TColor):integer;
  var i:integer;
begin
  result:=0;
  for i:= 0 to 16 do if(objColor[i]=col)then break;
  result:=i;
end;

procedure TfrmMain.SetFont(ID:integer; bEnable, FontToObj:boolean);
  var i,j,k,t,iID :integer;  tmpFont :TFont;
  procedure setObjFont(ID:integer);
    begin
    if(ID>0)then with Obj[ID] do begin  //设置对象字体
      TagN:=tagFont.Name;   if trim(TagN)='' then TagN:='Arial';
      TagS:=tagFont.Size;   if TagS<8 then TagS:=8;
      TagC:=tagFont.Color;
      TagT:='0000';
      if(     fsBold in tagFont.Style)then TagT[1]:='1';
      if(   fsItalic in tagFont.Style)then TagT[2]:='1';
      if(fsUnderline in tagFont.Style)then TagT[3]:='1';
      if(Obj[ID].Kind=10)and(memText.Visible)then memText.Font:=tagFont;
      end;
    with Obj[1] do begin //设置默认标签字体
      info[1] :=tagFont.Name;
      TagP.z  :=tagFont.Size;
      Link[10]:=tagFont.Color;
      TagT:='0000';
      if(     fsBold in tagFont.Style)then TagT[1]:='1';
      if(   fsItalic in tagFont.Style)then TagT[2]:='1';
      if(fsUnderline in tagFont.Style)then TagT[3]:='1';
      varColor.Color:=tagFont.Color;
      end
    end;
begin
  cmbFontN.Enabled:=bEnable;  cmbFontS.Enabled:=bEnable;  cmbFontC.Enabled:=bEnable;
  butFontB.Enabled:=bEnable;  butFontI.Enabled:=bEnable;  butFontU.Enabled:=bEnable;
  if not(bEnable)then exit;
  if FontToObj then begin //设置对象字体
    if(ID<0)then begin //设置默认标签字体
      setObjFont( ID);
      end
    else begin //设置对象字体
      varColor.Color:= tagFont.Color;// objColor[ cmbFontC.ItemIndex];// butFontC.Color;
      for j:=1 to SelRec[0] do with Obj[SelRec[20+j]] do begin
        ID:=SelRec[20+j];
        if ID in[2..4] then ID:=1; //坐标轴字体与原点相同
        setObjFont(ID); //设置对象字体
        case Kind of
          10:begin texID:= TextToBMP( ID, info[2],false); TextAndImage( ID, false,true,true, false); end; //[文字]
          11:TextAndImage( ID, false,true,true, false);
          14:butID.Font:=tagFont;// //控制按纽
          else GetTextList( ID);//标签
          end; //case Kind
        if(Mode=13)then begin //棱边或顶点的标签
          iID:=Link[0];  t:=Kind;
          GetTextList( iID);//标签
          for i:=iID+1 to ObjCount do with Obj[i]do
            if(Link[0]=iID)and(Kind=t)and(Mode=13)then begin
              setObjFont( i);
              GetTextList( i);//标签
              end;
          end;
        if(j in[1..4])then  //坐标原点标签
          for i:=2 to 4 do with Obj[i]do begin
            TagN:=Obj[1].TagN; TagS:=Obj[1].TagS;  TagT:=Obj[1].TagT;
            GetTextList( i);
            end;
        end;
      SetProjection(true,false,8);
      end;
    end
  else begin //设置控件字体
    if(pnlFont.Tag=-3)then with Obj[1] do begin // 默认标签字体
      tagFont.Name:=info[1];
      tagFont.Size:=trunc(TagP.z);
      tagFont.Color:=Link[10];      ;
      tagFont.Style:=[];
      if TagT[1]='1' then tagFont.Style:=tagFont.Style+[fsBold];
      if TagT[2]='1' then tagFont.Style:=tagFont.Style+[fsItalic];
      if TagT[3]='1' then tagFont.Style:=tagFont.Style+[fsUnderline];
      end
    else with Obj[ID] do begin //对象字体
      if TagN='' then TagN:='Arial';  tagFont.Name:= TagN;
      if TagS<6  then TagS:=9;        tagFont.Size:= TagS;
      tagFont.Color:= TagC;
      tagFont.Style:=[];
      if TagT[1]='1' then tagFont.Style:=tagFont.Style+[fsBold];
      if TagT[2]='1' then tagFont.Style:=tagFont.Style+[fsItalic];
      if TagT[3]='1' then tagFont.Style:=tagFont.Style+[fsUnderline];
      if(Kind=10)then memText.Font:=tagFont;
      end;
    cmbFontN.Text:=tagFont.Name;
    cmbFontS.Text:=itos(tagFont.Size);                
    cmbFontC.ItemIndex:=getColorIndex(tagFont.Color);
    butFontB.Down:=fsBold in tagFont.Style;
    butFontI.Down:=fsItalic in tagFont.Style;         
    butFontU.Down:=fsUnderline in tagFont.Style;

    end; //with Obj[ID]
end;
//====================== 调色板 ===========================
procedure TfrmMain.pnlColorClick(Sender: TObject);
  var i,j,t,k,ID,iID :integer;  cc:single; tmpColor:TColor;  tmpFont:TFont;
begin
  t:=TComponent(Sender).Tag;  k:=edtTemp.Tag;  j:=0;
  pnlColorPad.Hide;
  if(t=17)and ColorBox.Execute then tmpColor:= colorBox.Color //扩展色
    else tmpColor:= pnlColor[t].Color;
  hotLabel.Color:= tmpColor;
  if(k in[15,25])then begin  //背景颜色、对象默认颜色
    setBackColor(tmpColor, t,k);
    for i:=11 to ObjCount do with Obj[i] do begin
      if(Kind=10)and(Mode=1)then texID:= TextToBMP(i,info[2],false);
      if(Kind=11)then TextAndImage( i,false,true,true,false);
      if(Kind=11)and(Mode=2)and Trace then setBarTrack(i);
      end;
    AxisList;
    MainDraw( GL_RENDER, false, 'd');
    exit;
    end
  else begin
    if(t=18)then begin
      ShowControlBox( MarkObj, 18, tabColor); //参数色
      exit;
      end;
    if(MarkObj>0)then begin
      with Obj[MarkObj]do
      if not((Kind in[9,16])or(Obj[parent].Kind=17)
        or(Obj[parent].Kind=6)and(Obj[parent].Mode=5)
        or(Obj[parent].Kind=4)and(Obj[parent].Mode=6)and not Rand )then
        for i:=6 to 8 do begin Link[i]:=0; LinkName[i]:=0; end; //清除颜色参数
      varC.Caption:='';   varC1.Caption:='';
      end;
    end;
  if(MarkObj>0)then with Obj[ MarkObj] do begin
    ID:=MarkObj;
 //   varC.Color:=tmpColor;
    if(ID<8)then Obj[1].LinkName[ID]:=varC.Color;
    if(ID in[2..4])then Obj[ID].TagC:=varC.Color;
    p4.w:=varC.Color;
    if(Link[12]>0)then cc:=Obj[Link[12]].L  //透明度
                  else cc:=StrToFloat( varA.Caption);
    if(hotLabel=varC) then Color := cgTColorToCGColorF( varC.Color, cc);
    if(hotLabel=varC1)then ColorB:= cgTColorToCGColorF(varC1.Color, cc);
    if(Obj[ID].Kind<8)then Obj[1].Link[Obj[ID].Kind]:=tmpColor; //设置默认色值

    if(Obj[parent].Kind=6)and(Obj[parent].Mode=5)then ColorB:=Color;//凸壳内外同色
    if(Mode=13)and(Kind in[1,2,4,6])then begin
      ID:=Link[0];  getEdges(ID,i,k);//i棱边数 k顶点数
      if(Kind=2)then //棱边
        for j:=1 to i do begin Obj[ID+j].Color:=Color;  Obj[ID+j].ColorB:=Color; end;
      if(Kind=1)then //顶点
        for j:=1 to k do begin Obj[ID+i+j].Color:=Color;  Obj[ID+i+j].ColorB:=Color; end;
      end;
    if(Kind=6)and(Mode=3)and(S in[1,2,6])then begin
      Rand:=false; cheTrace.Checked:=false;
      end;
    if(Kind in[2,4,5,7,9])then //取消端点色、轨迹色
        begin U:=false; cheColor.Checked:=false; end;
    end; //with
  if(MarkObj>0)and(MarkObj<8)then AxisList;
  if(MarkObj>10)then ReRelate(ID,ObjCount,false,false,false);
  SetProjection(false,false,18);
//  if(MarkObj>10)then Save(0,MarkObj,1,true,true);
end;
//================== 字体工具条 ===================
procedure TfrmMain.butFontDClick(Sender: TObject);
begin
  with tagFont do begin
    Style:=[];
    if butFontB.Down then Style:=Style+[fsBold];
    if butFontI.Down then Style:=Style+[fsItalic];
    if butFontU.Down then Style:=Style+[fsUnderline];
    Name:=cmbFontN.Text; //字名
    Size:=StrToInt(cmbFontS.Text); //字号
    if(TComponent(Sender).Tag=7)and(cmbFontC.ItemIndex=17)and ColorBox.Execute
      then Color:= ColorBox.Color //颜色框
      else Color:= objColor[cmbFontC.ItemIndex];
    setFont(pnlFont.Tag, true, true);
    end;
end;

procedure TfrmMain.pnlFontMouseDown(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
  x0:=x; y0:=y;
end;

procedure TfrmMain.pnlFontMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
begin
  if not(ssLeft in Shift)then exit;
  pnlFont.Left:=pnlFont.Left+ x-x0; //
  pnlFont.Top :=pnlFont.Top + y-y0;
end;

procedure TfrmMain.imgFontClick(Sender: TObject);
begin
  pnlFont.Hide; menFont.Checked:=false;
end;

procedure TfrmMain.menCuttingClick(Sender: TObject); // 切割
  var a,b, i :integer; //
begin
  if(Obj[SelRec[21]].Kind=4)then SwapI( SelRec[21], SelRec[22]);
  a:=SelRec[21];  b:=SelRec[22];
  with Obj[a]do begin //被切割的对象
    Q:=true;  Cutter[0,0]:=Obj[b].Name; Cutter[0,1]:=b; Cutter[0,2]:=2;
    end;
  Obj[a].Hot:=false;  Obj[b].Hot:=false;
  for i:= 0 to 1 do begin
    inc(ObjCount);  Obj[ObjCount]:=Obj[SelRec[21+i]]; //新建对象
    CleanLink( ObjCount,1);
    with Obj[ObjCount]do begin
      Name:= getObjName(1);
      Mode:=11;  Tag:=Obj[SelRec[21+i]].Tag+'''';  texTag:=0;
      mainList:=0;  maskList:=0; wireList:=0; seleList:=0; tracList:=0;
      Link[0]:=SelRec[21+i]; LinkName[0]:=Obj[Link[0]].Name;
      end;
    end; //for j
  MarkObj:=ObjCount-1;
  with Obj[ObjCount]do begin //设置新建的平面
    Link[1]:=MarkObj;   LinkName[1]:=Obj[Link[1]].Name;
    Link[2]:=Link[1];   LinkName[2]:=LinkName[1];
    Link[3]:=Link[1];   LinkName[3]:=LinkName[1];
    for i:=0 to LayerTime do ObjShow[i]:=false;
    end;
  with Obj[MarkObj]do begin //设置新建的被切割对象
    Q:=true;   pTR:=Obj[b].Vec; pTR.w:=0; Hot:=true; //pTR 平移量
    Cutter[0,0]:=Obj[ObjCount].Name; Cutter[0,1]:=ObjCount; Cutter[0,2]:=1;
    end;
  save( 1, ObjCount, 2, true,false);
  ReRelate( MarkObj, ObjCount, false,false,false);
  SetProjection( false,false,18);
  ObjListUpdate( MarkObj, true); //更新对象列表
  if pnlProp.Visible then ShowObjProp(MarkObj, 0,0, true,true);  //显示属性框
end;

end.
{显示列表索引值的分配：
0   : 环境变量
1   : 坐标原点字符 'o',
2..4: 坐标轴
5..7: 坐标平面字符 'x','y','z'
8   : 直线的箭头
11..999: 构件

Obj[1] p0原点 其它值为系统当前环境变量 注意:执行Obj[1]:=Obj[8]后，必须使Obj[1].Name:=1;
Obj[2..4] 坐标轴
Obj[5..7] 坐标平面
Obj[8] 默认初始环境变量 注意:执行Obj[8]:=Obj[1]后，必须Obj[8].Name:=8;

操作符
+ - * / ^
标准函数
abs()     绝对值。例 abs(-1.23)=1.23
int()     整数。例 int(12.3)=12
fr()      小数。
sqr()     平方。
sqrt()    平方根。
exp()     e的乘幂。例 exp(1.0)=e
ln()      e为底的自然对数。例 ln(e)=1
sgn(n)    n<0为-1，n=0为0，n>0为1
round(n)  四舍五入
random(n) 随机数
heav(n)   n<0为0，n>=0为1

max(a,b)  较大值
min(a,b)  较小值
rad(a,b)  斜边长   =sqrt(sqr(a)+sqr(b))
equal(a,b)相等     a=b  为1，a<>b 为0
note(a,b) 不相等   a<>b 为1，a=b  为0
less(a,b) 小于     a<b  为1，a>=b 为0
lesse(a,b)小于等于 a<=b 为1，a>b  为0
三角函数
sin()     正弦
cos()     余弦
tan()     正切
sinh()    双曲正弦
cosh()    双曲余弦
tanh()    双曲正切
arcsin()  反正弦
arccos()  反余弦
arctan()  反正切
常数
pi
ei
//##############################################################################
Maching Cubes 等值面算法
牛顿迭代法 牛顿下山法
弦截法 单点弦法和双点弦法及平行弦法
直线方程式
平面方程式
圆方程式

直线交角标注规则
1 在公垂线起点作平行线
2 以两线之交角作任意半径的圆弧
3

参数字串可以包含八个字符：crfmstpb。字符之间无需空格，字符个数、字符顺序任意，大小写均可。各字符含义：
c 用于控件，禁止全屏
r 禁止保存文件
f 隐藏标题栏，无边框
m 隐藏菜单栏
s 隐藏状态栏
t 隐藏工具栏
p 隐藏页面栏
b 菜单置于底部

{Mode: 画笔与背景的颜色混合模式; Delphi 定义了模式枚举 TPenMode, 包含以下模式:}
pmBlack       {总是黑色}
pmWhite       {总是白色}
pmNop         {画笔无效}
pmNot         {背景色取反}
pmCopy        {画笔设置的颜色}
pmNotCopy     {画笔颜色取反}
pmMergePenNot {画笔颜色与背景颜色的反色的组合}
pmMaskPenNot  {画笔颜色与背景公共色的反色的组合}
pmMergeNotPen {画笔颜色取反后与背景颜色的组合}
pmMaskNotPen  {画笔的反色与背景的公共色的组合}
pmMerge       {画笔颜色与背景颜色的组合}
pmNotMerge    {pmMerge 的反色}
pmMask        {画笔与背景公共颜色的组合}
pmNotMask     {pmMask 的反色}
pmXor         {画笔颜色与背景颜色的 Xor 组合}
pmNotXor      {pmXor 的反色}
